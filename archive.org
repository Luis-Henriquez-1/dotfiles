#+title: archive.org
#+author: Luis Henriquez-Perez

I try to avoid deleting headlines. There's no reason to delete them if they
might prove useful later. This file will contain the headlines that for
some reason I'm not using.

You may wonder that if I'm using version control why have this file. Why not get
the headlines back searching my vcs history. Well, version control does not
"know" about org headlines. And I don't know of a way to search through it
painlessly.

* with-map!
:PROPERTIES:
:ID:       02bc8acb-5be4-4772-96bc-79cd3392818f
:END:

#+begin_src emacs-lisp
(defmacro with-map! (map &rest body)
  "Let-bind dotted symbols to their values in BODY.
This is similar to `let-alist' but map can be any key value structure."
  (declare (indent 1))
  (loopy (with (dot-regexp (rx bos "." (group (1+ (not white))) eos)))
	 (for sym (-select #'symbolp (-flatten body)))
	 (expr sym-name (symbol-name sym))
	 (expr (_ group1) (s-match dot-regexp sym-name))
	 (unless group1 (skip))
	 (expr name (intern group1))
	 (unioning bindings (list sym name))
	 (finally-return `(map-let ,bindings ,map ,@body))))
#+end_src

* wrapping forms
:PROPERTIES:
:ID:       48e48c0f-7bb3-45c9-b4af-2da0ce84b64e
:END:

When writing macros in lisp it is not uncommon to need to write a macro that can
nest a form within some number of other forms (for an example, see [[id][after!]]). This
macro makes this problem much easier.

The original idea for this macro came from [[https://gitlab.common-lisp.net/iterate/iterate/-/blob/master/iterate.lisp][iter's source code]].

#+begin_src emacs-lisp
(defun xl-wrap-form (wrappers form)
  "Wrap FORM with each wrapper in WRAPPERS.
WRAPPERS are a list of forms to wrap around FORM."
  (declare (pure t) (side-effect-free t))
  (setq wrappers (reverse wrappers))
  (if (consp wrappers)
      (xl-wrap-form (cdr wrappers)
                    (append (car wrappers)
                            (list form)))
    form))
#+end_src

* anaphora :anaphora:
:PROPERTIES:
:ID:       9938b1e1-6c6e-4a45-a85e-1a7f2d0bf6df
:END:

Anaphora refers to the ability to refer to. I have decided it is best to use
=<>= to denote the symbol referred to by anaphoric macros because it is easy to
type (assuming parentheses completion), because such a symbol uncommon in lisp.
A key advantage to this is that there is a consistent "syntax" for anaphoric
variables as opposed to using =it=. A consequence of this is that you have more
flexibility to name variables. Additionally, I like that it looks like a slot or
placeholder.

https://en.wikipedia.org/wiki/Anaphoric_macro

** anaphoric symbol regexp :anaphora:core:library:emacs:config:
:PROPERTIES:
:ID:       40c97bd5-dab1-44df-86f7-90274d5a8ea0
:END:

#+begin_src emacs-lisp
(defconst XL-ANAPHORIC-SYMBOL-REGEXP
  (eval-when-compile (rx "<" (group (zero-or-more (not (any white ">" "<")))) ">"))
  "Regular expression that matches an anaphoric symbol.")
#+end_src

** anaphoric symbol :anaphora:core:library:
:PROPERTIES:
:ID:       db8169ba-1630-42fe-9ab7-e29c110a18c3
:END:

#+begin_src emacs-lisp
(defun xl-anaphoric-symbol-p (obj)
  "Return non-nil if OBJ is an anaphoric symbol."
  (and (symbolp obj)
       (string-match-p XL-ANAPHORIC-SYMBOL-REGEXP (symbol-name obj))))
#+end_src

** true anaphora name :anaphora:
:PROPERTIES:
:ID:       2833cd75-9c85-4c0e-9523-4489d387150a
:END:

#+begin_src emacs-lisp
(defun xl-anaphoric-true-symbol (symbol)
  "Return the symbol that corresponds to the anaphoric symbol."
  (save-match-data
    (string-match XL-ANAPHORIC-SYMBOL-REGEXP (symbol-name symbol))
    (intern (match-string 1 (symbol-name symbol)))))
#+end_src

** take symbol and return anaphoric symbol :anaphora:
:PROPERTIES:
:ID:       4b89588e-f3c3-49d3-8851-fdd214cee563
:END:

#+begin_src emacs-lisp
(defun xl-anaphoric-symbol (symbol)
  "Return anaphoric form of symbol."
  (xl-symbol-intern '< symbol '>))
#+end_src

** body symbols :anaphora:
:PROPERTIES:
:ID:       2bae458e-404a-48e7-b57e-ce7f543f6e6d
:END:

#+begin_src emacs-lisp
(defun xl-anaphoric-symbols (body)
  "Return all the anaphoric symbols in body."
  (->> (-flatten body)
       (-filter #'xl-anaphoric-symbol-p)
       (-uniq)))
#+end_src

** all anaphoric symbols in obj :anaphora:
:PROPERTIES:
:ID:       e0c0eb8c-52b3-4411-ab0b-06255490dacf
:END:

#+begin_src emacs-lisp
(defun xl-anaphoric-symbols-in-obj (obj)
  "Return a list of anaphoric symbols in OBJ."
  (s-match-strings-all XL-ANAPHORIC-SYMBOL-REGEXP (xl-to-string obj)))
#+end_src

