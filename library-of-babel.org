#+title: library of babel
#+author: Luis Henriquez-Perez

This is a library of code blocks that I use.

* org extensions
:PROPERTIES:
:ID:       8f6c8447-8ec1-413e-8e35-f2f7feffafa5
:END:

** allow pretty printing source blocks
:PROPERTIES:
:ID:       935fe5b8-ae2c-47b9-938b-3512fa5506b2
:END:

** allow wrapping elisp source blocks with code
:PROPERTIES:
:ID:       e54b3c9d-9ab8-41fc-86e8-fd76084dc75b
:END:

** load subtree from file
:PROPERTIES:
:ID:       3dd7e72a-d3d3-4ce5-b85f-e25c22d25f0e
:END:

* straight :straight:
:PROPERTIES:
:ID:       2e251cc7-04de-43f8-a31f-1574a54ad576
:END:

[[straight][straight.el]] is a package manager that installs packages by cloning their git
repositories from online and building them from source. A consequence of this is
that you have the history of every installed emacs package locally. Another
consequence is that you can completely reproduce the state of your emacs on
another machine by installing the same packages with the same versions.

** variables :straight:pacman:core:
:PROPERTIES:
:ID:       9dff9894-667c-4e74-9624-8aee533f8f70
:END:

We don't need to clone everything from the git repos. Setting the depth to one
conserves some disk space.

#+begin_src emacs-lisp
(setq straight-use-package-version 'straight)
(setq straight-use-package-by-default nil)
(setq straight-check-for-modifications nil)
(setq straight-recipes-emacsmirror-use-mirror t)
(setq straight-vc-git-default-clone-depth 1)
#+end_src

** handle autoloads for me
:PROPERTIES:
:ID:       d3b052e4-fc7e-4b64-bd53-a6aa4b8abd16
:END:

To save startup time, we don't want to load packages unnecessarily. Many
packages have what I like to call (I just made this up :smirk-cat:) "entry-points", or
commands that are used to trigger the loading of the package. =straight=
optionally handles this for us.

#+begin_src emacs-lisp
(setq straight-disable-autoloads nil)
(setq straight-cache-autoloads t)
#+end_src

** package integration
:PROPERTIES:
:ID:       db1f9042-5b6c-41a9-a69c-d05d0493fdb0
:END:

By "integration" this variable means that it disables =package.el='s
initialization. We don't need =straight= to do this for us because it is handled in
[[id][early-init]].

#+begin_src emacs-lisp
(setq straight-enable-package-integration nil)
#+end_src

** load bootstrap file
:PROPERTIES:
:ID:       544f1bbe-3981-4d1b-8b24-3395b27890b2
:END:

#+begin_src emacs-lisp
(defun xl-load-straight-bootstrap-file (target-dir)
  "Load the boostrap file from TARGET-DIR."
  (defvar bootstrap-version)
  (let ((bootstrap-version 5)
	(bootstrap-file (expand-file-name "straight/repos/straight.el/bootstrap.el" target-dir)))
    (load bootstrap-file nil 'nomessage)))
#+end_src

** install straight.el
:PROPERTIES:
:ID:       ab38beca-2f26-4718-ab73-e4e4409f1563
:END:

I got the inspiration of cloning straight's repo (as opposed to just using the
[[https://github.com/raxod502/straight.el#bootstrapping-straightel][bootstrap code]]) from [[https://github.com/kinnala/diy-emacs][diy-emacs]].

#+begin_src emacs-lisp
(defun xl-install-straight (recipe target-dir)
  "Install straight to TARGET-DIR."
  (let* ((repo (plist-get (cdr recipe) :repo))
	 (repo-dir (expand-file-name "straight/repos/" target-dir))
	 (github-link (format "https://github.com/%s.git" repo))
	 (commit (plist-get recipe :commit)))
    (unless (xl-straight-installed-p)
      (make-directory repo-dir t)
      (shell-command (format "git -C %s clone %s" repo-dir github-link)))
    (shell-command (format "git -C %s checkout %s" repo-dir commit))))
#+end_src

** whether installed
:PROPERTIES:
:ID:       9216f0b9-93d5-43fe-aa96-3796674ab520
:END:

#+begin_src emacs-lisp
(defun xl-straight-installed-p (target-dir)
  "Return non-nil if straight is installed."
  (and (file-exists-p (expand-file-name "straight/" target-dir))
       (file-exists-p (expand-file-name "straight/repos/straight.el/bootstrap.el" target-dir))))
#+end_src

** read recipes
:PROPERTIES:
:ID:       f7a3baa6-d876-40d3-84f5-74b1d9b4f432
:END:

One of the goals is to be able to completely reproduce my Emacs configuration.
To do this I store the recipes of all the package I install in [[helpvar:XL-RECIPE-FILE][XL-RECIPES-FILE]].
Upon startup I read this file and register all the recipes in it with =straight=.

#+begin_src emacs-lisp
(defun xl-read-recipes (recipe-file)
  "Read and return recipes from RECIPE-FILE."
  (with-temp-buffer
    (insert-file-contents-literally recipe-file)
    (goto-char (point-min))
    (let (sexp sexps)
      (ignore-errors
	(while (setq sexp (read (current-buffer)))
	  (push sexp sexps)))
      (nreverse sexps))))
#+end_src

** versions alist
:PROPERTIES:
:ID:       3db31fa0-86e3-49e3-a13c-c3966bd7d6f7
:END:

#+begin_src emacs-lisp
(defun straight%versions-alist ()
  "Return an alist of (package . version)."
  (let ((versions-alist nil))
    (straight--map-repos
     (lambda (recipe)
       (straight--with-plist recipe
	   (package local-repo type)
	 (when (and local-repo (not (assoc local-repo versions-alist)))
	   (when-let ((commit (straight-vc-get-commit type local-repo)))
	     (push (cons local-repo commit) versions-alist))))))
    versions-alist))
#+end_src

** ensure commit
:PROPERTIES:
:ID:       2b6d7825-24b7-429d-b5ad-7df9603dfd93
:END:

We have to make sure that we're at the correct commit. Otherwise, we need to
rebuild with the correct commit.

#+begin_src emacs-lisp
(defun xl-straight-ensure-target-commit (recipe)
  "Make sure the recipe is at the TARGET-COMMIT"
  (if-let* ((package (car recipe))
	    (recipe (cdr recipe))
	    (type (plist-get recipe :type))
	    (local-repo (plist-get recipe :local-repo))
	    (current-commit (straight-vc-get-commit type local-repo))
	    (target-commit (plist-get recipe :commit)))
      (progn
	(message "%s %s %s" current-commit (if (string= current-commit target-commit) "=" "/=") target-commit)
	(unless (string= current-commit target-commit)
	  (straight-vc-check-out-commit recipe target-commit)
	  (straight-rebuild-package package))
	(message "new commit: %s" (straight-vc-get-commit type local-repo)))
    (message "%s doesn't have required shit (%s %s %s %s)." package type local-repo current-commit target-commit)))
#+end_src

** install packages to directory
:PROPERTIES:
:ID:       498862a1-8491-4ec1-95ad-f0bafd818ddc
:END:

Perhaps, in the future I could figure out preciesly how straight generates its
load paths and generate them without actually needing to call straight. The
advantage of doing it this way is that it is fool-proof.

Note that the packages need to all be "registered" before actually.

#+begin_src emacs-lisp
(defun xl-install-packages (recipe-file target-dir)
  "Install packages as specified by RECIPE-FILE to TARGET-DIR."
  (let* ((recipes (xl-read-recipes recipe-file)))
    (xl-install-straight (assoc 'straight recipes) target-dir)
    (setq straight-base-dir target-dir)
    (xl-load-straight-bootstrap-file target-dir)
    (mapc #'straight-register-package recipes)
    (dolist (recipe recipes)
      (straight-use-package recipe)
      ;; (xl-straight-ensure-target-commit recipe)
      )))
#+end_src

* noweb references
:PROPERTIES:
:ID:       e18a7b93-6b1d-4462-908e-6922ab778eff
:END:

** generate autoloads
:PROPERTIES:
:ID:       bf289d48-c7ea-49af-bd01-c4555159b229
:END:

#+name: declare-autoloads
#+begin_src emacs-lisp
(loopy (list key (hash-table-keys straight--autoloads-cache))
       (expr forms (cdr (hash-get key straight--autoloads-cache)))
       (expr form `(ignore-errors ,@forms))
       (collect autoload-forms form)
       (finally-return `(progn ,@autoload-forms)))
#+end_src

