#+title: init.org
#+author: Luis-Henriquez-Perez

* ensure lexical binding
:PROPERTIES:
:ID:       2b8148c3-1418-4896-ba53-1673d2d82659
:END:

Emacs by default uses dynamic binding. Lexical binding is a [[https://nullprogram.com/blog/2016/12/22/][known way to boost
startup speed]]. To enable it you add the following [[info:elisp#Using Lexical Binding][buffer-local variable]] on the
top of your elisp file.

#+begin_src emacs-lisp
;; -*- lexical-binding: t -*-
#+end_src

* core
:PROPERTIES:
:ID:       d82e84fc-0e6d-460d-a5bf-33dd56564795
:END:

This headline sets up package management and defines the fundamental functions
and macros I use for the rest of my configuration.

** config files and directores
:PROPERTIES:
:ID:       be8993d3-c8f7-451b-8cb4-04a9138e5c4e
:END:

It's useful to store directories which I reference frequently in variables and
functions. This way I can reference the full path. Certain directories are
important; and I end up referencing them alot.

#+begin_src emacs-lisp
(defvaralias 'XL-INIT-FILE 'user-init-file)

(defvaralias 'XL-EMACS-DIR 'user-emacs-directory)

(defconst XL-README-FILE (expand-file-name "README.org" "~/")
  "README file from which all other files are tangled.")

(defconst XL-LOCAL-DIR (concat XL-EMACS-DIR ".local/")
  "Directory where I store files that need to exist, but I don't want to see.")

(defconst XL-CACHE-DIR (concat XL-LOCAL-DIR "cache/")
  "Directory where I store files used for caching information.")

(defconst XL-RECIPE-FILE (concat XL-EMACS-DIR "recipes.el")
  "File that stores the recipes for all the packages I install.")

(defconst XL-PACKAGES-DIR (concat XL-LOCAL-DIR "packages/")
  "Directory where packages are stored.")
#+end_src

** package management
:PROPERTIES:
:ID:       00eaa1a5-b5fe-437d-9888-1846ea9a232b
:END:

The goal I have with package management is to deal with it all in this headline.
All package installation should happen here so that later we can use focus on
configuring packages, pretending like all the packages I'm are built-in to Emacs.

**** straight
:PROPERTIES:
:ID:       2e251cc7-04de-43f8-a31f-1574a54ad576
:END:

[[straight][straight.el]] is a package manager that installs packages by cloning their git
repositories from online and building them from source. A consequence of this is
that you have the history of every installed emacs package locally. Another
consequence is that you can completely reproduce the state of your emacs on
another machine by installing the same packages with the same versions.

***** settings
:PROPERTIES:
:ID:       86037015-ca61-48f9-96bf-df8fc625a35d
:END:

****** variables
:PROPERTIES:
:ID:       9dff9894-667c-4e74-9624-8aee533f8f70
:END:

We don't need to clone everything from the git repos. Setting the depth to one
conserves some disk space.

#+begin_src emacs-lisp
(setq straight-base-dir XL-PACKAGES-DIR)
(setq straight-use-package-version 'straight)
(setq straight-use-package-by-default nil)
(setq straight-check-for-modifications nil)
(setq straight-recipes-emacsmirror-use-mirror t)
(setq straight-vc-git-default-clone-depth 1)
#+end_src

****** handle autoloads for me
:PROPERTIES:
:ID:       d3b052e4-fc7e-4b64-bd53-a6aa4b8abd16
:END:

To save startup time, we don't want to load packages unnecessarily. Many
packages have what I like to call (I just made this up :smirk-cat:) "entry-points", or
commands that are used to trigger the loading of the package. =straight=
optionally handles this for us.

#+begin_src emacs-lisp
(setq straight-disable-autoloads nil)
(setq straight-cache-autoloads t)
#+end_src

****** package integration
:PROPERTIES:
:ID:       db1f9042-5b6c-41a9-a69c-d05d0493fdb0
:END:

By "integration" this variable means that it disables =package.el='s
initialization. We don't need =straight= to do this for us because it is handled in
[[id][early-init]].

#+begin_src emacs-lisp
(setq straight-enable-package-integration nil)
#+end_src

***** load bootstrap file
:PROPERTIES:
:ID:       544f1bbe-3981-4d1b-8b24-3395b27890b2
:END:

#+begin_src emacs-lisp
(defun xl-load-straight-boostrap-file ()
  "Load straight bootstrap file."
  (defvar bootstrap-version)
  (let ((bootstrap-version 5)
	(bootstrap-file (concat XL-PACKAGES-DIR "straight/repos/straight.el/bootstrap.el")))
    (load bootstrap-file nil 'nomessage)))
#+end_src

***** whether installed
:PROPERTIES:
:ID:       9216f0b9-93d5-43fe-aa96-3796674ab520
:END:

#+begin_src emacs-lisp
(defun xl-straight-installed-p ()
  "Return non-nil if straight is installed."
  (let ((straight-dir (concat XL-PACKAGES-DIR "straight/")))
    (and (file-exists-p straight-dir)
	 (file-exists-p (concat XL-PACKAGES-DIR "straight/repos/straight.el/bootstrap.el")))))
#+end_src

***** install
:PROPERTIES:
:ID:       ab38beca-2f26-4718-ab73-e4e4409f1563
:END:

I got the inspiration of cloning straight's repo (as opposed to just using the
[[https://github.com/raxod502/straight.el#bootstrapping-straightel][bootstrap code]]) from [[https://github.com/kinnala/diy-emacs][diy-emacs]].

#+begin_src emacs-lisp
(defun xl-install-straight (recipe commit base-dir)
  "Install straight to BASE-DIR."
  (let* ((repo (plist-get (cdr recipe) :repo))
	 (repo-dir (concat base-dir "straight/repos/"))
	 (github-link (format "https://github.com/%s.git" repo)))
    (make-directory repo-dir t)
    (shell-command (format "git -C %s clone %s" repo-dir github-link))
    (shell-command (format "git -C %s checkout %s" repo-dir commit))))
#+end_src

**** read recipes
:PROPERTIES:
:ID:       f7a3baa6-d876-40d3-84f5-74b1d9b4f432
:END:

One of the goals is to be able to completely reproduce my Emacs configuration.
To do this I store the recipes of all the package I install in [[helpvar:XL-RECIPE-FILE][XL-RECIPES-FILE]].
Upon startup I read this file and register all the recipes in it with =straight=.

#+begin_src emacs-lisp
(defun xl-read-recipes ()
  "Read and return recipes from `XL-RECIPE-FILE'."
  (with-temp-buffer
    (insert-file-contents-literally XL-RECIPE-FILE)
    (let (forms form)
      (setq form (ignore-errors (read (current-buffer))))
      (while form
	(push form forms)
	(setq form (ignore-errors (read (current-buffer)))))
      (nreverse forms))))
#+end_src

**** generate load-path
:PROPERTIES:
:ID:       498862a1-8491-4ec1-95ad-f0bafd818ddc
:END:

Perhaps, in the future I could figure out preciesly how straight generates its
load paths and generate them without actually needing to call straight. The
advantage of doing it this way is that it is fool-proof.

#+begin_src emacs-lisp
(defun xl-generate-package-paths ()
  "Return list of package load-paths for RECIPES.
Calls `straight-use-package' on each recipe as a side-effect."
  (pcase-let* ((load-path load-path)
	       (old-load-path load-path)
	       (recipes (xl-read-recipes))
	       (`(,_ ,commit ,recipe) (assoc "straight" recipes)))
    (unless (xl-straight-installed-p)
      (xl-install-straight recipe commit XL-PACKAGES-DIR))
    (xl-load-straight-boostrap-file)
    (pcase-dolist (`(,_ ,_ ,recipe) recipes)
      (straight-use-package recipe))
    (cl-set-difference load-path old-load-path :test #'string=)))
#+end_src

**** set the load-path
:PROPERTIES:
:ID:       ea592f75-e8dd-4ee7-a44e-c2da9d76191b
:END:

I could just use the side-effect of [[helpfn:straight-use-package][straight-use-package]] to fill up the
[[helpvar:load-path][load-path]]. However, I eventually want to compile this step away in the style of
[[https://github.com/nilcons/emacs-use-package-fast][emacs-use-package-fast]].

#+begin_src emacs-lisp
(require 'cl-lib)
(cl-callf2 append (xl-generate-package-paths) load-path)
#+end_src

**** updating the recipe file
:PROPERTIES:
:ID:       cc40b9ac-d061-44f2-84b6-2f5e782e2ed8
:END:

I need a way to update the recipe file based on packages I have installed. Right
now I the file will be updated with the packages I choose to install with
straight. In the future I want more fine grained control, perhaps showing me the
difference between the packages I installed in my current Emacs session compared
with the last and allowing me to choose which ones to add.

***** versions alist
:PROPERTIES:
:ID:       3db31fa0-86e3-49e3-a13c-c3966bd7d6f7
:END:

#+begin_src emacs-lisp
(defun straight%versions-alist ()
  "Return an alist of (package . version)."
  (let ((versions-alist nil))
    (straight--map-repos
     (lambda (recipe)
       (straight--with-plist recipe
	   (package local-repo type)
	 (when (and local-repo (not (assoc local-repo versions-alist)))
	   (when-let ((commit (straight-vc-get-commit type local-repo)))
	     (push (cons local-repo commit) versions-alist))))))
    versions-alist))
#+end_src

***** update recipe file
:PROPERTIES:
:ID:       63b9a6eb-bc36-4555-b0d6-0100841277ca
:END:

#+begin_src emacs-lisp
(defun xl/update-recipes ()
  "Update the recipe file with new recipes."
  (interactive)
  (with-temp-file XL-RECIPE-FILE
    (iter (with (gc-cons-threshold XL-GC-CONS-THRESHOLD-MAX)
		(versions-alist (straight%versions-alist))
		(packages (cl-sort (hash-table-keys straight--recipe-cache) #'string-lessp))
		(recipe-cache straight--recipe-cache)
		(print-length nil)
		(print-level nil)
		(print-quoted t))
	  (for package packages)
	  (expr recipe (hash-get package recipe-cache))
	  (expr local-repo (plist-get recipe :local-repo))
	  (when (and local-repo (assoc local-repo versions-alist))
	    (expr revision (alist-get local-repo versions-alist))
	    (expr package (substring-no-properties package))
	    (expr recipe (cons (intern package) recipe))
	    (prin1 (list package revision recipe) (current-buffer))
	    (insert ?\n)))))
#+end_src

** library
:PROPERTIES:
:ID:       70af1291-6b16-4261-ba83-19bb16d0023e
:END:

This headline contains all the the helper functions and macros I defined for
customizing Emacs. The main thing that's done in an Emacs configuration is
configuring packages, both built-in packages and external packages. And in this
process, there are often packages that augment and aid in the configuration of
other packages. Additionally, if you care about startup time it's important to
make sure packages are only loaded when they need to be. The major purpose of
this library is to provide me the tools to configure these packages in a way
that is concise and efficient.

*** custom helpers
:PROPERTIES:
:ID:       cfa16796-a4fe-4e2a-a021-fb9891950556
:END:

These are tools that are specifically designed to help me write macros.

**** symbols
:PROPERTIES:
:ID:       fa9a5fb6-381a-441f-8ecc-d3b4a5cab11d
:END:

Conversion between symbols, keywords, and strings are prevalent in
macro-writing.

***** symbol intern
:PROPERTIES:
:ID:       06bfc6f7-4c51-44e7-b32e-1434a602b55b
:END:

This is a convenience function for quickly banging out a custom symbol. It's
advantage over just plain [[helpfn:intern][intern]] is that it will coerce its arguments to a
symbol. This is useful when writing macros where it is a common occurance to
have a mix of different objects (usually strings and symbols) that you want to
put together into one symbol. This function is meant to just do what I mean.

#+begin_src emacs-lisp
(defun xl-symbol-intern (&rest args)
  "Return ARGS as a symbol."
  (declare (pure t) (side-effect-free t))
  (intern (apply #'xl-to-string args)))
#+end_src

***** intern format
:PROPERTIES:
:ID:       b371718f-2067-450c-8117-fb22f44be208
:END:

#+begin_src emacs-lisp
(defun xl-intern-format (format-string &rest args)
  "Return format string as a symbol."
  (intern (apply #'format format-string args)))
#+end_src

***** keyword intern
:PROPERTIES:
:ID:       0618b8d7-e0a4-4e3e-8d89-b7d0ebe43917
:END:

Sometimes I want to create a keyword by interning a string or a symbol. This
commands saves me having to add the colon at the beginning before interning.

#+begin_src emacs-lisp
(defun xl-keyword-intern (&rest args)
  "Return ARGS as a keyword."
  (declare (pure t) (side-effect-free t))
  (apply #'xl-symbol-intern ":" args))
#+end_src

***** keyword name
:PROPERTIES:
:ID:       e853603a-851d-429f-9201-f2e93734dfaf
:END:

Calling [[helpfn:symbol-name][symbol-name]] on a keyword returns the keyword as a string. However,
sometimes we don't want the prepended colon on they keyword. This function is
for that occasion.

#+begin_src emacs-lisp
(defun xl-keyword-name (keyword)
  "Return the name of the KEYWORD without the prepended `:'."
  (declare (pure t) (side-effect-free t))
  (substring-no-properties (xl-to-string keyword) 1))
#+end_src

***** convert to string
:PROPERTIES:
:ID:       60f22f98-8204-45ae-9943-f19cdfe60459
:END:

This function is for converting something to a string, no questions
asked. Similar to [[id:06bfc6f7-4c51-44e7-b32e-1434a602b55b][xl-symbol-intern]], I use it when I don't want to be bothered
with details and just want a string.

#+begin_src emacs-lisp
(defun xl-to-string (&rest args)
  "Return ARGS as a string."
  (declare (pure t) (side-effect-free t))
  (with-output-to-string
    (-each args #'princ)))
#+end_src

***** detect emacs symbols
:PROPERTIES:
:ID:       207ed522-51f3-45e7-91ba-8afb828d950b
:END:

These headline contains functions to detect particular Emacs symbols. Certain
Emacs symbols follow a convention. For example, most hooks end with the suffics
=-hook=. It may be useful--particularly in macros--to know what kind of symbol
we're dealing with. And, it may also be useful to be able to convert a normal
symbol (by which I mean one that doesn't follow the conventions) to one of these
particular kinds.

****** hook symbol
:PROPERTIES:
:ID:       7ae3dac1-058b-4b1b-a010-aeb5b121d3f6
:END:

As I mentioned, the convention for hook symbols is that they are suffixed with
=-hook=. This function checks for such variables.

#+begin_src emacs-lisp
(defun xl-emacs-hook-symbol-p (symbol)
  "Return true if symbol is a hook symbol."
  (declare (pure t) (side-effect-free t))
  (s-matches-p ".+-hook\\'" (symbol-name symbol)))
#+end_src

****** hookify symbol
:PROPERTIES:
:ID:       b308a172-6e99-491c-a382-7ee28e9fc1ae
:END:

#+begin_src emacs-lisp
(defun xl-emacs-hookify (symbol)
  "Return SYMBOL converted to hook.
If SYMBOL is already a hook symbol, return it unchanged."
  (declare (pure t) (side-effect-free t))
  (if (xl-emacs-hook-symbol-p symbol)
      symbol
    (xl-symbol-intern symbol '-hook)))
#+end_src

****** mode symbol
:PROPERTIES:
:ID:       ec25e275-c36f-4cee-be04-1fdf8c974857
:END:

#+begin_src emacs-lisp
(defun xl-emacs-mode-symbol-p (symbol)
  "Return non-nil if symbol is a mode symbol."
  (declare (pure t) (side-effect-free t))
  (s-matches-p ".+-mode\\'" (symbol-name symbol)))
#+end_src

****** modeify symbol
:PROPERTIES:
:ID:       61fa29a7-9697-4171-8b6f-f4c0b487c02c
:END:

#+begin_src emacs-lisp
(defun xl-emacs-modeify (symbol)
  "Return SYMBOL converted to hook.
If SYMBOL is already a hook symbol, return it unchanged."
  (declare (pure t) (side-effect-free t))
  (if (xl-emacs-mode-symbol-p symbol)
      symbol
    (xl-symbol-intern symbol '-mode)))
#+end_src

****** map symbol
:PROPERTIES:
:ID:       b7ab2b84-ebea-46fe-8494-89a2aed2f6e8
:END:

#+begin_src emacs-lisp
(defun xl-emacs-map-symbol-p (obj)
  "Return non-nil if OBJ is an emacs map symbol."
  (and (symbolp obj)
       (s-suffix-p "-map" (symbol-name obj))))
#+end_src

***** internal XL symbol
:PROPERTIES:
:ID:       72aa71bd-186b-47b3-b30e-1bf5da6b41b1
:END:

To avoid.

#+begin_src emacs-lisp
(defun xl-internal-symbol-p (symbol)
  "Return non-nil if symbol is an internal XL symbol."
  (declare (pure t) (side-effect-free t))
  (s-matches-p "\\`xl-.+" (symbol-name symbol)))
#+end_src

**** quoting
:PROPERTIES:
:ID:       95a2271b-a21b-4fed-a6b8-1e76ca821ed4
:END:

This headline deals with utility functions for dealing it quotes. A quote is a
special form in lisp that is ued to indicate that a symbol or an expression
should not be evaluted. The quotes are so prevalent in lisp that they each have
a character that's used to abbreviate them as I will explain.

The purpose of this headline is to provide functions that are useful for macro
writing. What we deal with when writing macro is syntax itself.

***** single-quoted
:PROPERTIES:
:ID:       533945fc-c700-42ce-8b93-d6bd9e16d9c7
:END:

A single quote prevents the evaluation of a symbol so that lisp reads the symbol
as syntax instead of evaluating it for its value. I should not that the ='= is
just how emacs displays a quote for brevity. In reality something like ~'cat~ is
~(quote cat)~.

#+begin_src emacs-lisp
(defun xl-single-quoted-p (obj)
  "Return non-nil if OBJ is sharp-quoted."
  (declare (pure t) (side-effect-free t))
  (pcase obj
    (`(quote ,obj) t)
    (_ nil)))
#+end_src

***** sharp-quoted
:PROPERTIES:
:ID:       6ba0980e-4391-47ef-a555-4c1dc3132f3b
:END:

A sharp quote is visually represented as =#'=. The real lisp representation of
this is =(function)=. So a ~#'foo~ would be ~(function foo)~. =function= is the
same as =quote= except the former tells the compiler you're referring to the
function symbol.

#+begin_src emacs-lisp
(defun xl-sharp-quoted-p (obj)
  "Return non-nil if OBJ is sharp-quoted."
  (declare (pure t) (side-effect-free t))
  (pcase obj
    (`(function ,obj) t)
    (_ nil)))
#+end_src

***** backquoted
:PROPERTIES:
:ID:       2c7af958-3aa0-48d6-a852-fd5feae452a9
:END:

#+begin_src emacs-lisp
(defun xl-backquoted-p (obj)
  "Return non-nil if OBJ is backquoted."
  (declare (pure t) (side-effect-free t))
  (pcase obj
    (`(backquote ,obj) t)
    (_ nil)))
#+end_src

***** quoted
:PROPERTIES:
:ID:       d1b6c539-c8ca-4dc4-b76d-e2f9406b1c04
:END:

#+begin_src emacs-lisp
(defun xl-quoted-p (symbol)
  "Return non-nil if symbol is quoted."
  (declare (pure t) (side-effect-free t))
  (or (xl-single-quoted-p symbol)
      (xl-sharp-quoted-p symbol)
      (xl-backquoted-p symbol)))
#+end_src

***** unquote
:PROPERTIES:
:ID:       dbf97264-95e9-478b-aa44-edcbd3f39665
:END:

#+begin_src emacs-lisp
(defun xl-unquote (obj)
  "Return OBJ unquoted.
If object is already unquoted, return OBJ."
  (declare (pure t) (side-effect-free t))
  (pcase obj
    (`(,(or backquote quote function) ,obj) obj)
    (_ obj)))
#+end_src

**** macro keyword arguments
:PROPERTIES:
:ID:       dc7a63e6-041b-4855-b206-6d72ef732de1
:END:

Following past examples (such as that of), I initially opted for allowing
keyword arguments in the "function args" part of defun-like macros. This is fine
when there's only one keyword argument, but any more and it starts to get
crowded. It doesn't help that emacs functions tend towards longer names due to a
lack of namespaces. Therefore, I support keyword args in the function body.

#+begin_src emacs-lisp
(defun xl-keyword-macro-args (body)
  "Return list of (docstring KEYWORD-ARGS BODY)."
  (loopy (with (docstring (when (stringp (car body)) (pop body))))
	 (while (keywordp (car body)))
	 (append plist (list (pop body) (pop body)))
	 (finally-return (list docstring plist body))))
#+end_src

**** true-list-p
:PROPERTIES:
:ID:       43089182-316b-4191-a3f1-6f2d1b1b971e
:END:

Sometimes I want to know whether something is a list and not a cons
cell. Usually, this happens when I want to know whether I can loop over
something--you can loop over a list but not a cons cell.

#+begin_src emacs-lisp
(defun xl-true-list-p (obj)
  "Return non-nil if OBJ is a list and not a cons cell."
  (declare (pure t) (side-effect-free t))
  (and (listp obj) (not (-cons-pair-p obj))))
#+end_src

**** wrapping forms
:PROPERTIES:
:ID:       48e48c0f-7bb3-45c9-b4af-2da0ce84b64e
:END:

When writing macros in lisp it is not uncommon to need to write a macro that can
nest a form within some number of other forms (for an example, see [[id][after!]]). This
macro makes this problem much easier.

The original idea for this macro came from [[https://gitlab.common-lisp.net/iterate/iterate/-/blob/master/iterate.lisp][iter's source code]].

#+begin_src emacs-lisp
(defun xl-wrap-form (wrappers form)
  "Wrap FORM with each wrapper in WRAPPERS.
WRAPPERS are a list of forms to wrap around FORM."
  (declare (pure t) (side-effect-free t))
  (setq wrappers (reverse wrappers))
  (if (consp wrappers)
      (xl-wrap-form (cdr wrappers)
                    (append (car wrappers)
                            (list form)))
    form))
#+end_src

**** anaphora
:PROPERTIES:
:ID:       9938b1e1-6c6e-4a45-a85e-1a7f2d0bf6df
:END:

Anaphora refers to the ability to refer to. I have decided it is best to use
=<>= to denote the symbol referred to by anaphoric macros because it is easy to
type (assuming parentheses completion), because such a symbol uncommon in lisp.
A key advantage to this is that there is a consistent "syntax" for anaphoric
variables as opposed to using =it=. A consequence of this is that you have more
flexibility to name variables. Additionally, I like that it looks like a slot or
placeholder.

https://en.wikipedia.org/wiki/Anaphoric_macro

***** anaphoric symbol regexp
:PROPERTIES:
:ID:       40c97bd5-dab1-44df-86f7-90274d5a8ea0
:END:

#+begin_src emacs-lisp
(defconst XL-ANAPHORIC-SYMBOL-REGEXP
  (eval-when-compile (rx "<" (group (zero-or-more (not (any white ">" "<")))) ">"))
  "Regular expression that matches an anaphoric symbol.")
#+end_src

***** anaphoric symbol
:PROPERTIES:
:ID:       db8169ba-1630-42fe-9ab7-e29c110a18c3
:END:

#+begin_src emacs-lisp
(defun xl-anaphoric-symbol-p (obj)
  "Return non-nil if OBJ is an anaphoric symbol."
  (and (symbolp obj)
       (string-match-p XL-ANAPHORIC-SYMBOL-REGEXP (symbol-name obj))))
#+end_src

***** true anaphora name
:PROPERTIES:
:ID:       2833cd75-9c85-4c0e-9523-4489d387150a
:END:

#+begin_src emacs-lisp
(defun xl-anaphoric-true-symbol (symbol)
  "Return the symbol that corresponds to the anaphoric symbol."
  (save-match-data
    (string-match XL-ANAPHORIC-SYMBOL-REGEXP (symbol-name symbol))
    (intern (match-string 1 (symbol-name symbol)))))
#+end_src

***** take symbol and return anaphoric symbol
:PROPERTIES:
:ID:       4b89588e-f3c3-49d3-8851-fdd214cee563
:END:

#+begin_src emacs-lisp
(defun xl-anaphoric-symbol (symbol)
  "Return anaphoric form of symbol."
  (xl-symbol-intern '< symbol '>))
#+end_src

***** body symbols
:PROPERTIES:
:ID:       2bae458e-404a-48e7-b57e-ce7f543f6e6d
:END:

#+begin_src emacs-lisp
(defun xl-anaphoric-symbols (body)
  "Return all the anaphoric symbols in body."
  (->> (-flatten body)
       (-filter #'xl-anaphoric-symbol-p)
       (-uniq)))
#+end_src

***** all anaphoric symbols in obj
:PROPERTIES:
:ID:       e0c0eb8c-52b3-4411-ab0b-06255490dacf
:END:

#+begin_src emacs-lisp
(defun xl-anaphoric-symbols-in-obj (obj)
  "Return a list of anaphoric symbols in OBJ."
  (s-match-strings-all XL-ANAPHORIC-SYMBOL-REGEXP (xl-to-string obj)))
#+end_src

**** xl-true
:PROPERTIES:
:ID:       25dcd81e-11a1-42b1-87a3-1df8c5a56cf1
:END:

This is the opposite of [[helpfn:ignore][ignore]]. Like =ignore= it takes any number of
arguments. Unlike it, it always returns =t= instead of always returning =nil=.

#+begin_src emacs-lisp
(defun xl-true (&rest _)
  "Return t."
  t)
#+end_src

**** xl-false
:PROPERTIES:
:ID:       0d1349cc-8bd5-4830-9c3b-9b4f9ebe25d0
:END:

#+begin_src emacs-lisp
(defalias 'xl-false 'ignore)
#+end_src

**** eval a form in a string
:PROPERTIES:
:ID:       79cfc39a-0924-468b-9fbc-83388323a39b
:END:

Sometimes it is useful to evaluate a lisp form that's in a string. One example,
is when [[https://orgmode.org/manual/Evaluating-Code-Blocks.html#Evaluating-Code-Blocks][evaluating code in source blocks]]. In general, this comes up
whenever you have to evaluate code you've gotten from a buffer.

You may be wondering why I first wrapped the form in the string with a [[helpfn:progn][progn]]
form. The reason is that [[helpfn:read-from-string][read-from-string]] only takes reads one from from a
string at a time.

This function came from [[https://emacs.stackexchange.com/questions/19877/how-to-evaluate-elisp-code-contained-in-a-string][this stackexchange question]].

#+begin_src emacs-lisp
(defun xl-eval-from-string (string)
  "Eval from from string."
  (eval (car (read-from-string (format "(progn %s)" string)))))
#+end_src

**** dwim single
:PROPERTIES:
:ID:       13c4df8f-86f6-46e8-8507-60c08b96fb14
:END:

#+begin_src emacs-lisp
(defun xl-dwim-single (obj)
  "If OBJ is a list of one element return CAR of OBJ.
Otherwise, return OBJ."
  (declare (pure t) (side-effect-free t))
  (if (= (safe-length obj) 1) (car obj) obj))
#+end_src

*** custom macros
:PROPERTIES:
:ID:       cfe0d468-92ee-4a4f-9908-4ea0b1964ac4
:END:

**** after!
:PROPERTIES:
:ID:       e209d256-86e0-4e30-a7d5-78a583729b42
:END:

=after!= is yet another wrapper around == that can accept multiple features or
even a specification of features using =and= or =or=.

The reason that we check for the feature is to prevent [[hvar:eval-after-load][eval-after-load]] from
polluting the [[hvar:after-load-list][after-load-list]]. =eval-after-load= adds an entry to
=after-load-list= whether or not it has been loaded.

We intentionally avoid with-eval-after-load to prevent eager macro expansion
from pulling (or failing to pull) in autoloaded macros/features.

#+begin_src emacs-lisp
(defmacro after! (features &rest body)
  "Wrapper around `with-eval-after-load'."
  (declare (indent defun) (debug t))
  (cond ((eq 'or (car-safe features))
	 (loopy (list feature (cdr features))
		(collect form `(after! ,feature ,@body))
		(finally-return (macroexp-progn forms))))
        ((eq 'and (car-safe features))
	 (loopy (with ((first . rest) (cdr features))
		      (forms `(after! ,first ,@body)))
		(list feature (reverse rest))
		(expr forms `(after! ,feature ,@(list forms)))
		(finally-return forms)))
        ((listp features)
         `(after! (and ,@features) ,@body))
        ((symbolp features)
         `(if (featurep ',features)
              ,(macroexp-progn body)
            (eval-after-load! ,features ,@body)))
        (t (error "Invalid argument."))))
#+end_src

**** with-os!
:PROPERTIES:
:ID:       a3ea434a-3f70-4137-a525-5be4bc63c3a2
:END:

Emacs is for the most part operating system agnostic. Packages written in elisp
should work across operating systems. Nevertheless, there are a handful of
settings that should favors particular operating systems over others.

#+begin_src emacs-lisp
(defmacro with-os! (os &rest body)
  "If OS is current system's operating system, execute body.
OS can be either `mac', `linux' or `windows' (unquoted)."
  (declare (indent defun))
  (when (funcall (cond ((eq :not (car-safe os)) (-not #'member))
                       (t #'member))
                 (pcase system-type
                   (`darwin 'mac)
                   (`gnu/linux 'linux)
                   (`(cygwin windows-nt ms-dos) 'windows)
                   (_ nil))
                 (-list os))
    `(progn ,@body)))
#+end_src

**** eval-after-load!
:PROPERTIES:
:ID:       8d831084-539b-4072-a86a-b55afb09bf02
:END:

=eval-after-load= is a macro that evaluates a lisp form after a file or feature
has been loaded. It's syntax is a bit terse because you need to quote the
feature as well as the form to be evaluated.

Also, if an =eval-after-load= block contains an error and it is triggered by a
feature, the error will happening. I think it might be that because the form was
not successfully evaluated =eval-after-load= does not realize it should stop
loading it. To remedy this I wrap the block with [[helpfn:condition-case][condition-case]].

#+begin_src emacs-lisp
(defmacro eval-after-load! (feature &rest body)
  "A wrapper around `eval-after-load!' with error catching."
  (declare (indent defun))
  `(eval-after-load ',feature
     '(condition-case error
          (progn ,@body)
        (error
         (message "Error in `eval-after-load': %S" error)))))
#+end_src

**** set!

One "gotcha" in Emacs is the existence of custom variables. Unlike typical
variables custom variables sometimes rely on certain code being executed when
they're initialized or when their values are changed. If you just set the
variable normally with [[helpfn:setq][setq]] you'd change it's value but you wouldn't be running
it's corresponding code so the change you think would happen, might not happen
at all.

Rather than keeping track of which variables have custom setters and which do
not, I opt to just use this macro.

For this reason I use =set!= as a replacement for =setq=.

[[https://opensource.com/article/20/3/variables-emacs][This article]] provides a brilliant synopsis of emacs variables.

Note that I may depreciate this in favor of setf.

#+begin_src emacs-lisp
(defmacro set! (&rest args)
  "Set"
  (pcase (length args)
    ((pred (= 1))
     (alet (car (xl-anaphoric-symbols args))
       `(set! ,(xl-anaphoric-true-symbol it)
	      ,(--tree-map (if (xl-anaphoric-symbol-p it) (xl-anaphoric-true-symbol it) it)
			   (car args)))))
    ((and (pred cl-evenp) (pred > 0))
     `(progn
	,@(loopy (cons (sym val . _) args #'cddr)
		 (expr setter `(or (get ',sym 'custom-set) 'set))
		 (collect `(funcall ,setter ',sym ,val)))))
    (_
     (error "Invalid arguments."))))
#+end_src

**** set-default!
:PROPERTIES:
:ID:       bc6b7560-fb71-4fc7-a53b-98f92c657d92
:END:

=set-default= is used for.

#+begin_src emacs-lisp
(defmacro set-default! (sym val)
  `(funcall (or (get ',sym 'custom-set-default) 'set-default) ',sym ,val))
#+end_src

**** fn!
:PROPERTIES:
:ID:       0ebd39d6-0f09-4a66-a6fc-5c259cab150d
:END:

This is a macro for writing anaphoric lambdas. It is based on [[https://github.com/troyp/fn.el][fn]], the main
difference being that in a few special cases you can specify a named anaphoric
variable. Also, I don't support the alternate =fn:= syntax.

#+begin_src emacs-lisp
(defmacro fn! (&rest body)
  "Expand into an anaphoric macro with body BODY."
  (let* ((argsym (make-symbol "ARGS"))
	 (symbolic-placeholders (-uniq (xl-anaphoric-symbols body)))
	 (number-fn (lambda (it) (s-matches-p "<[[:digit:]]>" (symbol-name it))))
	 (numbers-p (-all-p number-fn symbolic-placeholders)))
    (alet (if numbers-p
	      (-sort (lambda (it other) (string-lessp (symbol-name it) (symbol-name other)))
		     symbolic-placeholders)
	    symbolic-placeholders)
      `(lambda (&rest ,argsym)
	 (-let [,it ,argsym] ,@body)))))
#+end_src

*** use-package
:PROPERTIES:
:ID:       4882e62d-4602-40a6-9fbb-5efb0b5f4bc2
:END:

**** init use-package
:PROPERTIES:
:ID:       8879bd2b-5c7b-43d2-b922-7bb7cd6fea48
:END:

Finally, we get to use =use-package= to configure itself! :smile: By default,
=use-package= provides its own messages and error handling. This can make the
macro expansion of a =use-package= form crowded and much more difficult to
read. Setting [[helpvar:use-package-expand-minimally][use-package-expand-minimally]] tells =use-package=.

By default =use-package= loads a package immediately. Setting
[[helpvar:use-package-always-defer][use-package-always-defer]] tells =use-package= not to load it unless I explicitly
request it (for example, with the =:demand= keyword).

#+begin_src emacs-lisp
(require 'use-package)
(require 'dash)
(require 'loopy)
(require 's)

(use-package use-package
  :init
  (setq use-package-expand-minimally t)
  (setq use-package-always-defer t))

(defalias 'use-package! 'use-package)
#+end_src

**** use-package
:PROPERTIES:
:ID:       29e1513a-e12a-4818-870e-8d5fab7fe1a0
:END:

[[https://github.com/jwiegley/use-package][use-package]] provides a uniform syntax for cross-configuring different
packages and features. It is widely used among the emacs community. In this
headline I build upon it and adapt it to my needs.

***** helpers
:PROPERTIES:
:ID:       c8a6f579-c4ff-4b0f-942e-f87dab208deb
:END:

When it comes to helping myself with helper functions I spare no expense.

****** inserting keywords
:PROPERTIES:
:ID:       86f9fa28-6842-4580-994a-24f5d4608ad4
:END:

=use-package= has a built-in way of inserting keywords.

******* functional =use-package= keyword insertion
:PROPERTIES:
:ID:       4968a708-05f2-4a3b-8395-850a3c119fd2
:END:

This is an implementation for inserting something into a list before or after a
particular thing in the list. It is implemented in generally and without
side-effects. That way, it's easily testable.

#+begin_src emacs-lisp
(defun use-package%insert-keyword (where place key list)
  "Insert KEY at PLACE in PLIST.
If WHERE is before, KEY is inserted before place. If WHERE is `after' it is
inserted after PLACE."
  (--splice (eq place it)
	    (funcall (if (eq where 'before) #'identity #'reverse)
		     (list key it))
	    list))
#+end_src

******* dwim insert
:PROPERTIES:
:ID:       54fc11db-534a-4b59-836c-3165cf48b61d
:END:

I insert most =use-package= keywords in the same place. I don't want to have to
specify it all the time. Additionally, I don't want to have to keep repeating
the idiom =(setq use-package-keywords...use-package-keywords)= all the time
either.

#+begin_src emacs-lisp
(defun use-package%dwim-insert (key &optional where place)
  "Convenience wrapper around `use-package%insert-keyword'.
This is the same as `use-package%insert-keyword' except WHERE and PLACE to
`before' and `:hook'."
  (let ((where (or where 'before))
	(place (or place :hook)))
    (setq use-package-keywords
	  (use-package%insert-keyword where place key use-package-keywords))))
#+end_src

****** normalize cons
:PROPERTIES:
:ID:       d5beb18f-b18c-407b-9840-bda400ef52b4
:END:

=use-package= uses this funky-looking cons cell syntax to mean.

#+begin_src emacs-lisp
(defun use-package%normalize-cons (cons-pair)
  "Normalize."
  (-table-flat #'cons
	       (-list (car cons-pair))
	       (-list (cdr cons-pair))))
#+end_src

****** create autoloads
:PROPERTIES:
:ID:       ee0dc9c0-1bb3-4309-a61d-5b1c7f4c6ddf
:END:

Perhaps the most code saved with =use-package= is in it's generation of autoload
forms.

#+begin_src emacs-lisp
(defun use-package%autoload (package fn)
  "Return a form that autoloads FN from PACKAGE."
  `(unless (fboundp ',fn)
     (autoload #',fn ,(symbol-name package) nil t nil)))
#+end_src

****** generate normalizer
:PROPERTIES:
:ID:       f287aa5b-51ed-40da-bbc1-9a40586a1f83
:END:

I only use this function and [[id:495d3d70-f19f-420d-86ef-d75c49a77b66][its counterpart]] once so maybe putting this in
functions is rather overkill. But I like doing things right. And who knows?
Might be useful later. :shrug:

#+begin_src emacs-lisp
(defun use-package%normalize (key)
  "Return an appropriate normalize symbol for key."
  (xl-symbol-intern 'use-package-normalize/ key))
#+end_src

****** generate a handler
:PROPERTIES:
:ID:       495d3d70-f19f-420d-86ef-d75c49a77b66
:END:

#+begin_src emacs-lisp
(defun use-package%handler (key)
  "Return an appropriate handler symbol for key."
  (xl-symbol-intern 'use-package-handler/ key))
#+end_src

****** override keyword
:PROPERTIES:
:ID:       aff6cbbe-7657-4287-9632-31dab7310c63
:END:

I want to override some existing =use-package= keywords. Use package keywords
are defined by three things: the existence of the keyword in
[[helpvar:use-package-keywords][use-package-keywords]], the existence of a [[https://github.com/jwiegley/use-package#third-step-create-a-handler][handler]], and the existence of a
[[https://github.com/jwiegley/use-package#second-step-create-a-normalizer][normalizer]]. To overwrite an existing keyword all you have to do is
override the corresponding normalizer and handler. The purpose of this function
is to provide an easy way to do this.

#+begin_src emacs-lisp
(defun use-package%override (old new)
  "Overrides OLD with NEW.
OLD is an existing use-package keyword. NEW is the keyword to override OLD with."
  (advice-add (use-package%normalize old) :override (use-package%normalize new))
  (advice-add (use-package%handler old) :override (use-package%handler new)))
#+end_src

***** custom keywords
:PROPERTIES:
:ID:       62cec5ac-a2f9-435b-96a7-4db0d9691f25
:END:

One thing to note is that I don't allow arguments to be optionally in a
list. This makes things much more complicated and it makes.

****** silence
:PROPERTIES:
:ID:       c69b021f-c1eb-4f51-8de3-234c4660a0ba
:END:

Many packages print some output to the messages buffer. And, while it may be
useful to receieve messages, often they can be telling you what you already know.

#+begin_src emacs-lisp
(use-package%dwim-insert :silence)

(defun use-package-normalize/:silence (key _ fns)
  "Normalize."
  (iter (for fn fns)
	(cl-assert (symbolp fn) nil "%s hello %s" key fn)
	(collect fn)))

(defun use-package-handler/:silence (name _ fns rest state)
  "Generate forms that silence output of FNS.
FNS is a list of function symbols."
  `(,@(iter (for fn fns)
	    (collect (use-package%autoload fn name))
	    (collect `(xl-gadvice-shut-up #',fn)))
    ,@(use-package-process-keywords name rest state)))
#+end_src

****** gc-pause
:PROPERTIES:
:ID:       70dba953-1a83-4de8-9a63-43e20c50fe5a
:END:

The keyword pauses emacs gargbage collection (e.g increases the
[[helpvar:gc-cons-threshold][gc-cons-threshold]] to [[helpvar:most-positive-fixnum][most-positive-fixnum]]) for the duration of functions that
it's passed in. It should be used on particularly computationally expensive
functions that a package provides.

#+begin_src emacs-lisp
(use-package%dwim-insert :gc-pause)

(defalias 'use-package-normalize/:gc-pause 'use-package-normalize/:silence)

(defun use-package-handler/:gc-pause (name _ fns rest state)
  "Generate forms that inhibit `gc-cons-threshold' for the duration of FNS."
  `(,@(iter (for fn fns)
	    (collect (use-package%autoload name fn))
	    (collect `(xl-gadvice-pause-garbage-collection #',fn)))
    ,@(use-package-process-keywords name rest state)))
#+end_src

****** ignore
:PROPERTIES:
:ID:       eeeaf89c-78e6-453d-bf3b-27091cc11bca
:END:

Sometimes I want to ignore certain functions.

#+begin_src emacs-lisp
(use-package%dwim-insert :ignore)

(defalias 'use-package-normalize/:ignore 'use-package-normalize/:silence)

(defun use-package-handler/:ignore (name _ fns rest state)
  "Generate forms that cause FNS to do nothing and return nil."
  `(,@(iter (for fn fns)
	    (collect (use-package%autoload name fn))
	    (collect `(xl-gadvice-ignore #',fn)))
    ,@(use-package-process-keywords name rest state)))
#+end_src

****** always yes
:PROPERTIES:
:ID:       f2d89960-ed41-4a72-847f-e150db56330b
:END:

There are a number of functions in Emacs that prompt.

#+begin_src emacs-lisp
(use-package%dwim-insert :assume-yes)

(defalias 'use-package-normalize/:assume-yes 'use-package-normalize/:silence)

(defun use-package-handler/:assume-yes (name _ fns rest state)
  "Ensure that FNS always assume yes for confirmation."
  `(,@(iter (for fn fns)
	    (collect (use-package%autoload name fn))
	    (collect `(xl-assume-yes #',fn)))
    ,@(use-package-process-keywords name rest state)))
#+end_src

****** os
:PROPERTIES:
:ID:       9d78d90a-0309-44c6-be96-82bd6608546a
:END:

This keyword provides an concise and declarative way of using [[id:a3ea434a-3f70-4137-a525-5be4bc63c3a2][with-os!]].

#+begin_src emacs-lisp
(use-package%dwim-insert :os)

(defun use-package-normalize/:os (_ _ args)
  (cl-assert (member (car args) '(mac linux windows)))
  (car args))

(defun use-package-handler/:os (name _ os rest state)
  "Wrap body form with `with-os!' macro."
  `((with-os! ,os ,@(use-package-process-keywords name rest state))))
#+end_src

****** hook
:PROPERTIES:
:ID:       02e42811-3b97-44f1-ad0c-d59787173ffb
:END:

Here I override the default hook keyword with my own which uses =xl-hook-add=
instead of =add-hook=.

#+begin_src emacs-lisp
(use-package%dwim-insert :xl-hook)
(use-package%override :hook :xl-hook)

(defun use-package-normalize/:xl-hook (name _ args)
  "Make sure that."
  (loopy (list elt args)
	 (cond ((symbolp elt)
		(collect (cons (xl-emacs-hookify elt) (xl-emacs-modeify name))))
	       ((-cons-pair-p elt)
		(expr (hooks . mode) elt)
		(subloop (list hook (-list hooks))
			 (collect (cons (xl-emacs-hookify hook) mode))))
	       (t
		(do (error "%s requires %s" key elt))))))

(defun use-package-handler/:xl-hook (name _ alist rest state)
  "Use `xl-hook-add' to add HOOK to FN for each (HOOK . FN) in HOOK-ALIST."
  `(,@(loopy (list (hook . fn) alist)
	     (collect `(xl-hook-add ',hook ',fn))
	     (collect (use-package%autoload name fn)))
    ,@(use-package-process-keywords name rest state)))
#+end_src

****** before-call
:PROPERTIES:
:ID:       55e66d22-b75d-4e77-9f99-dca1afbe1094
:END:

Packages don't live in an isolated enviroment. Often one package depends on one
or more packages. Sometimes, I add customizations to a package using certain
libraries and then I need to load them when that package is loaded. The purpose
of this keyword is to load a package when a certain function is called.

#+begin_src emacs-lisp
(use-package%dwim-insert :before-call)

(defun use-package-normalize/:before-call (name key args)
  "Ensure ARGS is a list of symbols or list."
  (iter (for elt args)
	(cond ((symbolp elt) (collect (cons name elt)))
	      ((-cons-pair-p elt) (collect elt))
	      (t (error "%s requires either symbols or cons cells." key elt)))
	(finally-do (-map #'use-package%normalize-cons loopy-result))))

(defun use-package-handler/:before-call (name key alist rest state)
  "Generate forms that load PACKAGE before FN is called."
  `(,@(iter (for (package . fn) alist)
	    (collect (use-package%autoload package fn))
	    (collect `(xl-load-before-call ',package #',fn)))
    ,@(use-package-process-keywords name rest state)))
#+end_src

****** after-call
:PROPERTIES:
:ID:       2c7dd1a8-c0ee-42cd-b76f-8a72c94be848
:END:

The.

#+begin_src emacs-lisp
(use-package%dwim-insert :after-call)

(defalias 'use-package-normalize/:after-call #'use-package-normalize/:before-call)

(defun use-package-handler/:after-call (name _ alist rest state)
  "Generate form that loads package after fn is called."
  `(,@(iter (for (package . fn) alist)
	    (collect (use-package%autoload name fn))
	    (collect `(xl-load-after-call ',package #',fn)))
    ,@(use-package-process-keywords name rest state)))
#+end_src

****** set
:PROPERTIES:
:ID:       9948a4ae-f80a-4b13-b97a-0895481021a6
:END:

I should give credit. I got this idea from the leaf macro.

#+begin_src emacs-lisp
(use-package%dwim-insert :set)

(defun use-package-normalize/:set (_ _ args)
  "Raise an error if."
  (cl-assert (-all-p #'listp args) nil "Should all be lists.")
  args)

(defun use-package-handler/:set (name _ values rest state)
  "Generate forms that set var to value."
  `(,@(loopy (list (var . val) values)
	     (expr setter (if (listp var) 'setf 'set!))
	     (collect `(,setter ,var ,val)))
    ,@(use-package-process-keywords name rest state)))
#+end_src

****** rule
:PROPERTIES:
:ID:       30ee0415-dccf-4742-9c31-bd33b900ab81
:END:

This keyword integrates with [[id:b3351a74-b2d0-42b8-9895-b6baad0adb0b][dbc]] (display buffer control). What it does is.

#+begin_src emacs-lisp
(use-package%dwim-insert :rule)

(defun use-package-normalize/:rule (_ _ args)
  "Ensure ARGS is a list of lists."
  (cl-assert (-all-p #'xl-true-list-p args))
  args)

(defun use-package-handler/:rule (name _ rules rest state)
  "Generate popup rule for each."
  `(,@(loopy (list rule rules)
	     (collect `(dbc-add-rule ,@rule)))
    ,@(use-package-process-keywords name rest state)))
#+end_src

****** idle-require
:PROPERTIES:
:ID:       916f88bd-10e1-4030-a1d9-e42baf095492
:END:

This keyword integrates with [[0d619336-e852-4c6a-89a8-38ccbb71a077][idle-require]]. It can accept a boolean.

#+begin_src emacs-lisp
(use-package%dwim-insert :idle-require)

(defun use-package-normalize/:idle-require (package _ args)
  "Ensure each elements in ARGS is a symbol.
If an element is t, convert it to PACKAGE."
  (loopy (list symbol args)
	 (unless (symbolp symbol) (do (error "This key doesn't have this.")))
	 (collect (if (eq t symbol) package symbol))))

(defun use-package-handler/:idle-require (name _ features rest state)
  "Generate forms that `idle-require' FEATURES."
  `(,@(loopy (list feature features)
	     (collect `(idle-require ',feature nil t)))
    ,@(use-package-process-keywords name rest state)))
#+end_src

****** config
:PROPERTIES:
:ID:       fa0947a2-7f0c-447e-9b16-03edb2648ad6
:END:

This keyword is meant to overwrite the built-in =:config= keyword. It does the
same thing, except it uses =after!= instead of =with-eval-after-load=.

#+begin_src emacs-lisp
(use-package%dwim-insert :xl-config)
(use-package%override :config :xl-config)

(defun use-package-normalize/:xl-config (_ _ args)
  args)

(defun use-package-handler/:xl-config (name _ forms rest state)
  "Wrap FORMS in an `after!' block."
  `((after! ,name ,@forms)
    ,@(use-package-process-keywords name rest state)))
#+end_src

****** alias
:PROPERTIES:
:ID:       9fe0d171-55b4-4022-82ec-abfb5e776cae
:END:

Sometimes I want to alias certain.

#+begin_src emacs-lisp
(use-package%dwim-insert :alias)

(defalias 'use-package-normalize/:alias 'use-package-normalize/:set)

(defun use-package-handler/:alias (name _ aliases rest state)
  "Generate aliases forms for ALIASES."
  `(,@(loopy (list (sym . def) aliases)
	     (collect (use-package%autoload name def))
	     (collect `(defalias ',sym #',def)))
    ,@(use-package-process-keywords name rest state)))
#+end_src

****** advice
:PROPERTIES:
:ID:       c8f56e77-7e95-493e-bf10-0bb8daccbd1e
:END:

#+begin_src emacs-lisp
(use-package%dwim-insert :advice)

(defun use-package-normalize/:advice (_ _ advices)
  "Ensure that ADVICES is a list of advice arguments.
ADVICES should be of the form (WHERE SYMBOL ADVICE PROPS EXPIRE-FN) where PROPS
and EXPIRE-FN are optional."
  (loopy (list it advices)
	 (cond ((-cons-pair-p it)
		(expr fn advice)
		(collect (list :around fn advice)))
	       ((listp it)
		(expr (key . rest) it)
		(subloop (list (fn . advice) rest)
			 (collect (list key fn advice))))
	       (t
		(do (error ""))))))

(defun use-package-handler/:advice (name _ advices rest state)
  "Generate forms that add advice."
  `(,@(loopy (list (where symbol advice props expire-fn) advices)
	     (collect `(xl-advice-add #',symbol ,where #',advice ,props ,expire-fn)))
    ,@(use-package-process-keywords name rest state)))
#+end_src

****** xl-advice
:PROPERTIES:
:ID:       1a0d6ff0-0dcd-4374-b52c-79bf617b3a2b
:END:

A keyword specifically designed for =xl= advices, or advices of the form
=xl-<name>-advice=. For convenience, it is assumed to use =around= advice.

#+begin_src emacs-lisp
(use-package%dwim-insert :xl-advice)

(defun use-package-normalize/:xl-advice (_ _ advices)
  "Ensure that ADVICES is a list of advice arguments.
ADVICES should be of the form (WHERE SYMBOL ADVICE PROPS EXPIRE-FN) where PROPS
and EXPIRE-FN are optional."
  (loopy (list it advices)
	 (unless (keywordp (car it)))
	 (when (-cons-pair-p it)
	   (expr (fn . advice) it)
	   (collect (list :around fn (xl-symbol-intern 'xl-- advice '-advice))))))

(defun use-package-handler/:xl-advice (name _ advices rest state)
  "Generate forms that add advice."
  `(,@(loopy (list (where symbol advice props expire-fn) advices)
	     (expr where (if (keywordp where) where (xl-keyword-intern where)))
	     (collect `(xl-advice-add #',symbol ,where #',advice ,props ,expire-fn)))
    ,@(use-package-process-keywords name rest state)))
#+end_src

****** initial state
:PROPERTIES:
:ID:       e923e94e-9051-4be8-8dda-6566601ba865
:END:

I create this work to allow for easier cross configuration of states between
packages.

#+begin_src emacs-lisp
(use-package%dwim-insert :initial-state)

(defun use-package-normalize/:initial-state (name _ states)
  "Require series of symbols or cons of the form (MODE . STATE)."
  (loopy (list elt states)
	 (cond ((symbolp elt)
		(collect (cons (xl-emacs-modeify name) elt)))
	       ((consp elt)
		(expr (mode . state) elt)
		(collect (cons mode state)))
	       (t
		(do (error "Hello"))))))

(defun use-package-handler/:initial-state (name _ states rest state)
  "Generate forms to set the initial evil state of certain modes."
  `(,@(loopy (list (mode . state) states)
	     (collect forms `(evil-set-initial-state ',mode ',state))
	     (finally-return `((after! (evil ,name) ,@forms))))
    ,@(use-package-process-keywords name rest state)))
#+end_src

*** essential libraries
:PROPERTIES:
:ID:       18602d49-dcc3-47c3-8579-62f7a7b7a83a
:END:

These are packages that I use to make writing lisp code more convenient. Emacs
Lisp is a full-featured, turing-complete language. However, for some data
structures like hash-tables and alists it is missing consistently named
functions for performing operations on these data structures. This is improving
slowly with the introduction of libraries like =seq.el= and =map.el= but still
leaves much to be desired. This sounds like a complaint, but it actually
highlights the advantage of the extensibility of Emacs.

**** shut-up
:PROPERTIES:
:ID:       71681f9f-2760-4cee-95a0-4aeb71191a42
:END:

This package provides a macro named =shut-up= that as its name suggests,
silences output of any forms within it :speak-no-evil:. Emacs itself and many
emacs packages spew messages. While I can see how in certain circumstances there
messages can be useful, most of the time they are superfluous.

#+begin_src emacs-lisp
(use-package shut-up :demand t)
#+end_src

**** mmt
:PROPERTIES:
:ID:       a4377985-fe0e-4980-b839-08c334bde76c
:END:

=mmt= is a library of tools for writing macros. Specifically, it provides the
quintessential =once-only= and =with-gensyms= macros which are used to prevent
variable leaking.

#+begin_src emacs-lisp
(use-package mmt)
#+end_src

**** dash
:PROPERTIES:
:ID:       7885c48d-0ead-4d77-8de1-e9faec58b583
:END:

Dash is rich list manipulation library. Many of the functions it have already
been found in some form or another in emacs in features such as =cl-lib= and
=seq= and =subr=, but dash has some very convenient functions and macros over
emacs (such as =-let)=. Moreover, a lot of work has been put into making it's
functions efficient; some are even more efficient than built-in cl
functions. Additionally, it's already used as a dependency of very many packages
so I'll likely end up loading it anyway.

#+begin_src emacs-lisp
(use-package dash :demand t)
#+end_src

**** subr-x
:PROPERTIES:
:ID:       ee3ad1b5-920a-4337-9874-79e066ed53fe
:END:

#+begin_src emacs-lisp
(use-package subr-x :demand t)
#+end_src

**** ht
:PROPERTIES:
:ID:       56bb0ff4-6ad1-44b7-a9a4-54abf48ed253
:END:

=ht= is a package that tries to provide a consistently named API for dealing with
hash-tables.

#+begin_src emacs-lisp
(use-package ht)
#+end_src

**** dash-functional
:PROPERTIES:
:ID:       704fc35f-0ad0-4eb3-9eb5-d8335465dbd8
:END:

=dash-functional= provides "function combinators". These are functions that take
one or more functions as arguments and return a function. One example of this is
emacs's [[helpfn:apply-partially][apply-partially]]. These functions can help.

#+begin_src emacs-lisp
(use-package dash-functional :demand t)
#+end_src

**** s
:PROPERTIES:
:ID:       b96acb97-3963-4713-a03b-6294c65903fd
:END:

=s= is an api for strings inspired by [[id:704fc35f-0ad0-4eb3-9eb5-d8335465dbd8][dash]]. It has many useful string functions
that are not built-in to Emacs. Notably, it is functional.

#+begin_src emacs-lisp
(use-package s :demand t)
#+end_src

**** f
:PROPERTIES:
:ID:       f44da560-dc3f-4635-926e-eec4fd6d159d
:END:

#+begin_src emacs-lisp
(use-package f :demand t)
#+end_src

**** anaphora
:PROPERTIES:
:ID:       1c47bd8a-15f1-4b1c-9574-23547d27d968
:END:

It's common to want to refer to the thing you're operating on in lisp and in
many other languages. In lisp this often requires assigning the variable a name.
But if you're only.

#+begin_src emacs-lisp
(use-package anaphora :demand t)
#+end_src

**** loopy
:PROPERTIES:
:ID:       1c30099a-86b4-41f9-8390-e9e3c20b0257
:END:

=loopy= is an alternative to =cl-loop= that preserves lisp structure. It is akin
to [[https://common-lisp.net/project/iterate/][Common Lisp's iter]]. dash's functions and macros are good for most
cases. But they are not as good in my opinion when you're dealing with a complex
loop that involves accumulating several variables or atypical control-flow (as
in, break statements or return statements). This is where =loopy= comes into
play.

***** loopy
:PROPERTIES:
:ID:       da17f1ea-7b0d-4d8c-a068-792ed58c6a79
:END:

#+begin_src emacs-lisp
(use-package loopy
  :demand t
  :config
  (callf2 cl-adjoin '-split loopy-default-flags)
  (loopy-defalias 'fret 'finally-return)
  (loopy-defalias 'ret 'return))
#+end_src

***** iter
:PROPERTIES:
:ID:       cf3f024a-8bec-4f5a-bd63-38b09dc23ca5
:END:

I thought I'd be using this macro exclusively and that I'd never use =loopy= at
all. However, =loopy= has the distinct advantage that it has more freedom to
name its clauses without clobbering them with existing Emacs functions. So I'd
say I use =loopy= when the loop doesn't need.

For the same drawback as I've mentioned, =loopy-iter= can't use the =list=
clause because it would get confused with it and the built-in Emacs function
[[helpfn:list][list]]. For that reason we need to use one of lists aliases.

#+begin_src emacs-lisp
(use-package loopy-iter
  :demand t
  :config
  (callf2 cl-adjoin '+lax-names loopy-default-flags)
  (loopy-defalias 'for 'list)
  (loopy-defalias 'each 'list)
  :alias
  (iter . loopy-iter)
  (iterate . loopy-iter))
#+end_src

***** dash destructuring
:PROPERTIES:
:ID:       87615a1d-2790-44c4-ac95-90a36ff9c496
:END:

#+begin_src emacs-lisp
(use-package loopy-dash
  :demand t
  :config
  (callf2 cl-adjoin '+dash loopy-default-flags))
#+end_src

**** noflet
:PROPERTIES:
:ID:       27f06ae0-ed4d-45ca-b451-fa05a47b8fe0
:END:

This package provides an alternative to the built-in =cl-flet= called
=noflet=. The [[][]] is that.

#+begin_src emacs-lisp
(use-package noflet :demand t)
#+end_src

**** dbc
:PROPERTIES:
:ID:       b3351a74-b2d0-42b8-9895-b6baad0adb0b
:END:

=dbc= stands for "display-buffer-control". This package provides an interface
for working with [[helpfn:display-buffer-alist][display-buffer-alist]]. In a nutshell, =display-buffer-alist= is
a Emacs's built in way of allowing the user to customize how windows are opened.

#+begin_src emacs-lisp
(use-package dbc
  :demand t
  :init
  (--each '((display-buffer-in-side-window . ((side . bottom) (window-height . 0.5)))
	    (display-buffer-in-side-window . ((side . top) (window-height . 0.4)))
	    (display-buffer-in-side-window . ((side . left) (window-width 0.4)))
	    (display-buffer-in-side-window . ((side . right) (window-width 0.4))))
    (dbc-add-ruleset (xl-to-string (alist-get 'side (cdr it))) it)))
#+end_src

**** db
:PROPERTIES:
:ID:       9b79f07b-8397-4f95-b79c-5e136a9b2079
:END:

#+begin_src emacs-lisp
(use-package db)
#+end_src

**** log4e
:PROPERTIES:
:ID:       8360e875-61a6-46f8-a401-2a98c9e517fa
:END:

#+begin_src emacs-lisp
(use-package log4e
  :demand t
  :alias (xl/popup-log-buffer . xl--log-open-log)
  :config
  (log4e:deflogger "xl" "%t [%l] %m" "%H:%M:%S")
  (xl--log-enable-logging)
  (defalias 'xl-log 'xl--log-info))
#+end_src

**** ts

#+begin_src emacs-lisp
(use-package ts)
#+end_src

**** a
:PROPERTIES:
:ID:       32110690-9d0a-4e3d-a1d8-7695b42aeb30
:END:

=a= is an association list library.

#+begin_src emacs-lisp
(use-package a :demand t)
#+end_src

**** list-utils
:PROPERTIES:
:ID:       f87d570a-4b06-42ea-acaa-a0bedba0e623
:END:

#+begin_src emacs-lisp
(use-package list-utils)
#+end_src

**** map
:PROPERTIES:
:ID:       129b620e-62ab-40ca-ba8f-a5f7f64d6651
:END:

#+begin_src emacs-lisp
(use-package map :demand t)
#+end_src

*** aliases
:PROPERTIES:
:ID:       bad5a570-2b94-4ada-88f0-de9f32fa9b7e
:END:

**** prefixed-core
:PROPERTIES:
:ID:       14b63dc9-1d95-4bd7-8b29-8b2b33bd1e69
:END:

This package defines numerous aliases to existing commands in an attempt to make
commands more discoverable and naming schemes more consistent. For example, it
aliases the function [[helpfn:set-frame-font][set-frame-font]] to [[helpfn:frame-set-font][frame-set-font]] because if you were
looking for function that involved the frame, the first thing you'd look for is
for functions namespaced =frame=.

#+begin_src emacs-lisp
(use-package prefixed-core :demand t)
#+end_src

**** custom aliases
:PROPERTIES:
:ID:       c32ede6e-05ae-4067-8505-ffe328295536
:END:

#+begin_src emacs-lisp
(defalias 'atomp 'atom)
(defalias 'buffer-next 'next-buffer)
(defalias 'buffer-previous 'previous-buffer)
#+end_src

*** debug-p
:PROPERTIES:
:ID:       39197346-c420-4518-b8f8-8ea247d6decb
:END:

[[helpvar:void-debug-p][xl-debug]] is snatched from [[https://github.com/hlissner/doom-emacs][Doom's]] [[https://github.com/hlissner/doom-emacs/blob/develop/core/core.el][doom-debug-mode]]. The point of this variable is
to serve as an indicator of whether the current Emacs instance is run for
debugging. When Emacs is set up for debugging it prints out many messages about
what its doing via [[hfn:void-log][xl-log]].

#+begin_src emacs-lisp
(defvar xl-debug-p (or (getenv "DEBUG") init-file-debug)
  "When non-nil print debug messages.
The --debug-init flag and setting the DEBUG envar will enable this at startup.")
#+end_src

*** defun macro
:PROPERTIES:
:ID:       cd0699fa-57fd-4a8b-99b6-3e98f94f888a
:END:

This is a macro to address the.

**** parser alist
:PROPERTIES:
:ID:       fa0773f5-d6be-4c9f-966f-7e8c2e68e40e
:END:

#+begin_src emacs-lisp
(defvar defun%parser-alist nil)
#+end_src

**** parse-hook
:PROPERTIES:
:ID:       f7c0897d-79da-4e73-8ba7-ac5bdedacbfb
:END:

#+begin_src emacs-lisp
(callf2 cl-adjoin '(:hook . defun%parse-hook) defun%parser-alist :test #'equal)

(cl-defun defun%parse-hook (init _ hooks &key depth append local)
  (let-alist init
    (iter (with (orig-name (intern (format "xl--%s-hook" .name))))
	  (initially (push `(cl-defun ,orig-name ,.args ,.docstring ,@.body) loopy-result))
	  (each hook hooks)
	  (expr hook-fn (xl-symbol-intern hook '& .name))
	  (collect `(defalias ',hook-fn ',orig-name))
	  (collect `(add-hook ',hook #',hook-fn ,(or append depth) ,local)))))
#+end_src

**** parse advice
:PROPERTIES:
:ID:       fbff4b81-3a11-42df-a61f-42e6c5771734
:END:

#+begin_src emacs-lisp
(iter (for type '(:override :around :before :after))
      (expr parser 'defun%parse-advice)
      (collect (cons type parser))
      (finally-do (callf cl-union defun%parser-alist loopy-result :test #'equal)))

(cl-defun defun%parse-advice (init name advices &key props)
  (let-alist init
    (iter (with (orig-name (xl-symbol-intern 'xl-- .name '-advice)))
	  (initially (push `(cl-defun ,orig-name ,.args ,.docstring ,@.body) loopy-result))
	  (each advice advices)
	  (expr fname (xl-symbol-intern .name '@ advice))
	  (collect `(cl-defun ',fname ',.args ,.docstring ,@.body))
	  (collect `(advice-add ',fname ,name #',fname)))))
#+end_src

**** parse generic advice
:PROPERTIES:
:ID:       73f153c5-b005-41c1-bc35-3aa47b4339f1
:END:

#+begin_src emacs-lisp
(callf2 cl-adjoin '(:generic-advice . defun%parse-generic-advice) defun%parser-alist :test #'equal)

(cl-defun defun%parse-generic-advice (init name advices &key props)
  (let-alist init
    (let ((generic-advice-fn (xl-intern-format "xl-generic-advice-%s" .name))
	  (advice-fn (xl-intern-format "xl-advice-" .name)))
      `((cl-defun ,generic-advice-fn ,.args ,.docstring ,@.body)
	(cl-defun ,advice-fn (fn) (advice-add fn :around ,advice-fn))))))
#+end_src

**** defun!
:PROPERTIES:
:ID:       408d1cdf-5cc6-43e8-813d-15025aa23f13
:END:

#+begin_src emacs-lisp
(defmacro defun! (name args docstring &rest body)
  (declare (indent defun) (doc-string 3))
  (loopy (loop (while (and (listp (car body)) (keywordp (caar body))))
	       (collect clauses (pop body)))
	 (expr init (a-list 'name name 'args args 'docstring docstring 'body body))
	 (loop (each (command-name . rest) clauses)
	       (expr command (alist-get command-name defun%parser-alist))
	       (expr command-args (-take-while (-not #'keywordp) rest))
	       (expr rest (-drop-while (-not #'keywordp) rest))
	       (append forms (apply command init command command-args rest)))
	 (return `(progn ,@forms))))
#+end_src

**** wrappers around
:PROPERTIES:
:ID:       74419a54-dd6e-4c29-81a0-5248ff2a0058
:END:

***** defhook!
:PROPERTIES:
:ID:       57e8e84e-c928-451f-8cfc-1c3b638bc318
:END:

#+begin_src emacs-lisp
(defmacro defhook! (name args docstring &rest body)
  "Wrapper around `defun!'."
  (declare (indent defun) (doc-string 3))
  `(defun! ,name (&rest _) ,docstring (:hook ,@args) ,@body))
#+end_src

***** defadvice!
:PROPERTIES:
:ID:       6742346f-f9f5-4898-a1f1-668271f52b8e
:END:

#+begin_src emacs-lisp
(defmacro defadvice! (name args docstring &rest body)
  "Wrapper around `defun!'."
  (declare (indent defun) (doc-string 3))
  `(defun! ,name (&rest _) ,docstring (,@args) ,@body))
#+end_src

***** generic-advice!
:PROPERTIES:
:ID:       141da0b0-f721-4576-921b-7d800291267a
:END:

#+begin_src emacs-lisp
(defmacro defgadvice! (name args docstring &rest body)
  (declare (indent defun) (doc-string 3))
  `(defun! ,name (&rest _) ,docstring (:generic-advice ) ,@body))
#+end_src

*** hooks
:PROPERTIES:
:ID:       0832d639-564d-4556-a398-ff729a75ac0b
:END:

I have my own naming convention for hooks. I use it to make it obvious when a
function is a hook.

**** hook regexp
:PROPERTIES:
:ID:       5093d6ce-741d-4d11-8ac7-15c02aa45b3b
:END:

#+begin_src emacs-lisp
(defconst XL-HOOK-REGEXP "\\`\\(.+\\)&\\(.+\\)\\'"
  "Regular expression used to match `xl-' defined hooks.")
#+end_src

**** add hook
:PROPERTIES:
:ID:       e8d69a71-bab4-4e75-b8f8-33426200a0df
:END:

#+begin_src emacs-lisp
(cl-defun xl-hook-add (hooks functions &key depth local expire)
  "Alias FUNCTIONS to follow XL naming convention and add them to HOOKS."
  (iter (each hook (-list hooks))
	(iter (each function (-list functions))
	      (expr name (xl-symbol-intern hook '& fn))
	      (defalias name function)
	      (when expire (xl-expire name expire))
	      (add-hook hook name depth local))))
#+end_src

**** remove hook
:PROPERTIES:
:ID:       e8ec61e0-a819-452c-8fb2-bf3023684b53
:END:

#+begin_src emacs-lisp
(defun xl-remove-hook (hooks)
  "Remove HOOKS from their correponding hook variable.
HOOKS is a hook function or a list of hook functions that follow XL naming
conventions."
  (iter (each hook (-list hooks))
	(remove-hook (xl-hook-orig-var hook) hook)))
#+end_src

**** hook function
:PROPERTIES:
:ID:       d5ed128c-32a0-4387-a1e5-b4536ed86c95
:END:

#+begin_src emacs-lisp
(defun xl-hook-fn-p (hook)
  "Return non-nil if HOOK is defined with XL naming conventions."
  (s-match XL-HOOK-REGEXP (symbol-name hook)))
#+end_src

**** original hook variable
:PROPERTIES:
:ID:       8788ec0c-2ab2-4fb3-b383-55d6ee533e8d
:END:

#+begin_src emacs-lisp
(defun xl-hook-orig-var (hook)
  "Return hook variable for HOOK.
HOOK is a hook function defined with XL naming conventions."
  (nth 1 (xl-hook-fn-p hook)))
#+end_src

**** original hook function
:PROPERTIES:
:ID:       640d7e5d-d3a7-43be-94df-0fb9c02201d9
:END:

#+begin_src emacs-lisp
(defun xl-hook-orig-fn (hook)
  "Return the hook function for HOOK.
HOOK is a hook function that follows XL naming conventions."
  (nth 2 (xl-hook-fn-p hook)))
#+end_src

*** advice
:PROPERTIES:
:ID:       19b9021d-f310-485b-9258-4df19423c082
:END:

I want to name advices so that they can be distinguished from other functions. I
also want to be able to deduce the function being advised from the name.

**** advice regexp
:PROPERTIES:
:ID:       22a4ff2c-27b7-4938-802f-5b669caa3f12
:END:

#+begin_src emacs-lisp
(defconst XL-ADVICE-REGEXP "\\([^[:space:]]+\\)@\\([^[:space:]]+\\)"
  "Regular expression that matches.")
#+end_src

**** remove XL advice
:PROPERTIES:
:ID:       3d13ea95-44aa-4261-8480-5ae9701d533d
:END:

Since we can get the advisee from the advise name, or remove advice only needs
one argument--the advice to remove.

#+begin_src emacs-lisp
(defun xl-advice-remove (advices)
  "Remove ADVICES from the functions they advise.
ADVICES is an advice or a list of advices."
  (iter (each advice (-list advices))
	(advice-remove (xl-advice-orig-fn advice) advice)))
#+end_src

**** adding an advice
:PROPERTIES:
:ID:       14e23074-10ea-41cc-88e5-bac600658b20
:END:

#+begin_src emacs-lisp
(cl-defun xl-advice-add (functions where advices &key depth local)
  "Add ADVICES to FUNCTIONS.
WHERE, DEPTH and LOCAL are the same as in `advice-add'."
  (iter (each function (-list functions))
	(iter (each advice (-list advices))
	      (expr name (xl-symbol-intern function '@ advice))
	      (defalias name function)
	      (advice-add function where advice))))
#+end_src

**** original fn
:PROPERTIES:
:ID:       eb5e771f-243b-4645-8be7-59fe2dcf1978
:END:

#+begin_src emacs-lisp
(defun xl-advice-orig-fn (advice)
  "Return the function ADVICE is advised to.
ADVICE is an advice function that follows XL naming conventions."
  (nth 1 (s-match XL-ADVICE-REGEXP (symbol-name advice))))
#+end_src

**** original advice
:PROPERTIES:
:ID:       49f49994-637a-4e26-b680-3535463ee8bf
:END:

#+begin_src emacs-lisp
(defun xl-advice-orig-advice (advice)
  "Return the function that ADVICE aliases.
ADVICE is an advice function that follows XL naming conventions."
  (nth 2 (s-match XL-ADVICE-REGEXP (symbol-name advice))))
#+end_src

**** generic advices
:PROPERTIES:
:ID:       8fb485ec-5387-46da-820e-629dcf004962
:END:

There are some advices that are used so often that they do not lend themselves
to =defadvice!=, which is better suited for a unique advice defined only once.

***** catch errors
:PROPERTIES:
:ID:       3ac98fde-fe86-4221-abc7-d8bdfee4a58b
:END:

One important note here. I first wrote [[helpfn:xl-report-error-advice][xl-report-error-advice]] as an around
advice that should be added to functions. The problem here is that sometimes I
advise compiled functions; and when I do, the variable =orig-fn= is bound to a
compiled function instead of a symbol. This is why this function has to
pre-emptively insert FN. A similar situation occurs with [[][generic expiring
advice]].

#+begin_src emacs-lisp
(defgadvice! catch-error (orig-fn &rest args)
  "Catch and log any error."
  (condition-case error
      (apply orig-fn args)
    (error
     (xl-log "Failed calling %s because of %s" orig-fn (error-message-string error)))))
#+end_src

***** expire
:PROPERTIES:
:ID:       437e07f7-e506-4dcf-aa88-d2c962d186ba
:END:

Sometimes I am confronted with hooks or advices that either should'nt be be
called more than once. A common example is [[][loading a dependency for a
package]]. 

#+begin_src emacs-lisp
(defgadvice! remove-advice (orig-fn args)
  "Remove ORIG-FN from"
  (apply orig-fn args)
  (when (xl-advice-fn-p orig-fn) (xl-advice-remove orig-fn))
  (xl-log "%s has been removed from %s" orig-fn))

(defgadvice! remove-hook (orig-fn args)
  (apply orig-fn args)
  (when (xl-hook-fn-p orig-fn) (xl-hook-remove orig-fn))
  (xl-log "%s has been removed from %s" orig-fn))
#+end_src

***** assume yes in prompts
:PROPERTIES:
:ID:       82960e31-b0c5-4b79-8ac4-508629bd63a4
:END:

Once in a while I come across a function that a [[helpfn:y-or-n-p][y-or-n-p]] prompt for things I
don't want to be prompted for. Or, in other words, for me the cost of the extra
second I spend typing =y= or =n= is not worth the benefit ([[helpfn:ert-delete-all-tests][ert-delete-all-tests]]
is an example).

#+begin_src emacs-lisp
(defgadvice! assume-yes (orig-fn &rest args)
  "An advice that makes `y-or-n-p' return t without prompt."
  (noflet ((y-or-n-p (prompt) t))
    (apply orig-fn args)))
#+end_src

***** silence
:PROPERTIES:
:ID:       7eddba70-8597-4af7-bc93-6ebdcc06ee6c
:END:

Many packages output to the messages buffer. Often, I either find these messages
unecessary or, as an experienced user, I get it already. In these cases I prefer
to silence the said messages.

#+begin_src emacs-lisp
(defgadvice! silence-output (orig-fn &rest args)
  "Silence output of FN."
  (shut-up (apply orig-fn args)))
#+end_src

***** logging certain functions
:PROPERTIES:
:ID:       1ccfaa39-924f-4b1d-82b2-e458511cbb1b
:END:

I make distinctions between different kinds of functions such as advices, hook
functions and interactive functions. Depending on which type of function it is I
want to log it differently.

****** log message
:PROPERTIES:
:ID:       f0f4d5fd-2ce2-408c-8a4d-f55e39744132
:END:

#+begin_src emacs-lisp
(defun xl-log-message (fn)
  "Return the message logged."
  (cond ((xl-hook-fn-p fn)
	 (format "& %s -> %s"
		 (xl-hook-orig-var fn)
		 (xl-hook-action fn)))
	((xl-advice-fn-p fn)
	 (format "@ %s -> %s"
		 (xl-advice-orig-fn fn)
		 (xl-advice-orig-advice fn)))
	(t
	 (format "%s called" fn))))
#+end_src

****** log advice
:PROPERTIES:
:ID:       25ea174f-af84-49e3-ad13-c797ef4ee6b2
:END:

Maybe it's overkill having an advice just to log a function. But it helps
maintain maximum purity and extensibility.

#+begin_src emacs-lisp
(defun xl-log-function (fn &optional after)
  "Log calls to FN.
Add a log to *xl-log* after function is called.
This function should be primarly used for side-effect but does incidentally return the
log function that is added to FN."
  (advice-add fn (if after :after :before) (xl-new-log-advice fn)))

(defun xl-new-log-advice (fn)
  "Return new log advice for FN."
  (alet (xl-symbol-intern "xl-log-" fn)
    (fset it `(lambda (&rest _) (xl-log ,(xl-log-message fn))))
    it))
#+end_src

***** pause garbarge collection
:PROPERTIES:
:ID:       41e763bd-215f-4176-95c1-f41261864671
:END:

Sometimes you come across a function that is computationally expensive. An
example is [[helpfn:helm-system-packages][helm-system-packages]], function that has to make a list of all system
packages which can contain several thousand items.

#+begin_src emacs-lisp
(defgadvice! pause-gc (orig-fn &rest args)
  "An around advice that pauses `gc-cons-threshold'."
  (let ((gc-cons-threshold XL-GC-CONS-THRESHOLD-MAX))
    (apply orig-fn args)))
#+end_src

***** log
:PROPERTIES:
:ID:       843d4ca9-ea52-46ea-9d77-bfd9e7222669
:END:

Sometimes I want to use =xl-log= instead of =message=.

#+begin_src emacs-lisp
(defgadvice! use-xl-log-instead (orig-fn &rest args)
  (noflet ((message (&rest message-args) (apply #'xl-log message-args)))
    (apply orig-fn args)))
#+end_src

***** ignore output
:PROPERTIES:
:ID:       5053afcc-7a44-44d4-80b6-f42c3ea87926
:END:

#+begin_src emacs-lisp
(defgadvice! ignore (orig-fn &rest args)
  (xl-log "Ignoring %s %s." orig-fn args))
#+end_src

***** loading on call
:PROPERTIES:
:ID:       fa6583aa-5e7c-4212-be8a-b90b4c08aa31
:END:

Instead of loading all features on startup, we want to load features only when
we need them--just in time. And by "just in time" I mean at the last possible
moment or in practice just before a function that uses this feature is called.
While I could use =defadvice!= for defining these advices, doing this would
quickly become repetative because it's something that is done so often in
package configuration. The function =before-call= and =after-call= provide a fast
and convenient way to do this.

****** load-on-call
:PROPERTIES:
:ID:       324e707b-2f44-4168-a846-037f5401dedb
:END:

This is the internal function which I use to build the others. It loads a
package before or after (you specify) a particular function is called. To do
this it adds an =XL= advice that loads the feature to the function.

#+begin_src emacs-lisp
(defun xl-load-on-call (package where fn)
  "Load PACKAGE before or after FN is called."
  (alet (xl-symbol-intern 'xl--load- package '-advice)
    (fset it `(lambda (&rest _)
                (xl-log "Loading %s" ',package)
                (require ',package)))
    (xl-advice-add fn where it nil t)))
#+end_src

****** load before call
:PROPERTIES:
:ID:       cc0e92bc-cd6d-4994-82ea-eb065fc3ad89
:END:

For convenience, I provide [[helpfn:xl-load-before-call][xl-load-before-call]] and [[helpfn:xl-load-after-call][xl-load-after-call]]. It's nice
not to have to specify the advice keyword.

#+begin_src emacs-lisp
(defun xl-load-before-call (package fn)
  "Load PACKAGE before FN is called."
  (xl-load-on-call package :before fn))
#+end_src

****** load after call
:PROPERTIES:
:ID:       b0b294d0-15ac-42d9-9e4c-fd9da8a95206
:END:

#+begin_src emacs-lisp
(defun xl-load-after-call (package fn)
  "Load PACKAGE after FN is called."
  (xl-load-on-call package :after fn))
#+end_src


*** idle-require
:PROPERTIES:
:ID:       0d619336-e852-4c6a-89a8-38ccbb71a077
:END:

Idle require is a tool for loading autoload functions, files or features during
idle time. The way to use this is to idle-require many small packages that
individually don't take too much time. This helps ensure that in emacs loading
of big packages like org-mode is snappy.

When emacs goes idle for [[helpvar:idle-require-idle-delay][idle-require-idle-delay]] seconds, the features will
start loading. [[helpvar:idle-require-load-break][idle-require-load-break]] is the break between features idle
require loads.

=idle-require= messages us to tell us when a package is being idle required and
when it has finished idle-requiring packages. I don't want to see the message
unless I'm debugging.

Since we're evaluating a good amount of lisp expressions, we should boost
garbage collection during this time.

#+begin_src emacs-lisp
(use-package idle-require
  :demand t
  ;; :xl-use-xl-log idle-require-mode idle-require-load-next
  :gc-pause idle-require-load-next
  :set
  (idle-require-load-break . 2)
  (idle-require-idle-delay . 10))
#+end_src

** emacs settings
:PROPERTIES:
:ID:       b61797fe-a520-448b-8dfa-055b357ebfa7
:END:

*** custom commands
:PROPERTIES:
:ID:       b03e1f14-3f29-4abd-af47-3692998cf1a1
:END:

This section is for commands that are really useful for me, but not present in
Emacs or (as far as I know at least, in other packages). This headline is
similar in goals to [[https://github.com/bbatsov/crux][crux]] (collection of ridiculously useful extensions for Emacs).

**** font
:PROPERTIES:
:ID:       d600fe06-7a61-43e1-93ea-4e193c69c9f3
:END:

Setting the font correctly and well is crucial for your efficiency while using
emacs. A well choosen font can make things very readable.

Also, sometimes I have font "mania" where I keep toggling different fonts so see
what I feel like using at the moment. Therefore, I need an easy way to toggle.

***** font size
:PROPERTIES:
:ID:       3efd0698-a8d3-4fc0-b22b-7f0589de4661
:END:

It's very suprising to me Emacs doesn't provide a function for interactively
setting the font size.

Make sure to appropriately update [[helpvar:default-frame-alist][default-frame-alist]] when changing font size.
Otherwise, you might find (as I did) that switching themes might reset your font
size to its default value.

#+begin_src emacs-lisp
(defun xl-set-font-size (size)
  "Set the font size for the current frame."
  (let ((fs (font-spec :name (frame-parameter nil 'font))))
    (font-put fs :size size)
    (set-frame-font fs nil t)
    (let ((new-font (frame-parameter nil 'font))
          (current-default (assq 'font default-frame-alist)))
      (setf (alist-get 'font default-frame-alist) new-font))))
#+end_src

***** font max and min size
:PROPERTIES:
:ID:       309c572a-6aaa-4986-a79d-4774110e6ead
:END:

I have had the experience where I've accidentally set Emacs font so large or so
small that I've had to restart Emacs because even though I know how to undo it,
I could not read anything. Here I declare font size bounds I should never go
outside of.

#+begin_src emacs-lisp
(defconst XL-FONT-MAX-SIZE 30
  "Maximum font size.
The font size that `xl/set-font-size' should never go above.")

(defconst XL-FONT-MIN-SIZE 11
  "Minimum font size.
The font size that `xl/set-font-size' should never go below.")
#+end_src

***** setting font size
:PROPERTIES:
:ID:       b138b662-4087-4199-abe5-ecacb22dfb2a
:END:

#+begin_src emacs-lisp
(defun xl/set-font-size ()
  "Set the font size interactively.
Inhibit accidentally setting font size too high or too low."
  (interactive)
  (let* ((old-size (/ (face-attribute 'default :height) 10))
         (prompt "The font size is currently %d. What do you want to change it to? ")
         (new-size (string-to-number (read-string (format prompt old-size)))))
    (cond ((> new-size XL-FONT-MAX-SIZE)
	   ;; (message "That font size is too large. It should be below %d." XL-FONT-MAX-SIZE)
	   (call-interactively #'xl/set-font-size))
	  ((< new-size XL-FONT-MIN-SIZE)
	   ;; (message "That font size is too small. It should be above %d." XL-FONT-MIN-SIZE)
	   (call-interactively #'xl/set-font-size))
	  (t
	   (xl-set-font-size new-size)
	   (message "Font set from %d to %d." old-size new-size)))))
#+end_src

***** font-face
:PROPERTIES:
:ID:       1bf8b603-ba11-422f-80d2-53dd8483fdbb
:END:

There is also no interactive function for setting the font face.

I will note that I use [[helpfn:xl-list-fonts][x-list-fonts]] intentionally, because it gives you options.

#+begin_src emacs-lisp
(defun xl/set-font-face ()
  "Apply an existing xfont to all graphical frames."
  (interactive)
  (alet (completing-read "Choose font: " (x-list-fonts "*"))
    (set-frame-font it nil t)))
#+end_src

**** kill Emacs processes
:PROPERTIES:
:ID:       811f6b55-6f54-4854-9098-8754359b4f85
:END:

#+begin_src emacs-lisp
(defun xl/kill-emacs-processes ()
  "Kill all emacs processes."
  (interactive)
  (loopy (with (count 1) (process "emacs"))
	 (while (ignore-errors (kill-process process)))
	 (expr process (format "emacs<%d>" count))
	 (do (incf count))
	 (finally (message "killed %d processes" count))))
#+end_src

**** important buffers
:PROPERTIES:
:ID:       14021345-8f7d-4219-9f79-ea81c23f8f40
:END:

Some buffers are so important that they merit a convenience function to switch
specifically to them. One such buffer is the buffer for this README.

***** emacs directory
:PROPERTIES:
:ID:       7ea118cb-4eb6-4ffb-9d82-6ae65ff7a961
:END:

#+begin_src emacs-lisp
(defun xl/open-dired-at-emacs-dir ()
  "Switch to a dired buffer at emacs directory."
  (interactive)
  (dired user-emacs-directory))
#+end_src

***** elisp init file
:PROPERTIES:
:ID:       74ad3337-4a36-4524-87c1-6b46b2dc24dd
:END:

#+begin_src emacs-lisp
(defun xl/switch-to-init-file ()
  "Switch to init file."
  (interactive)
  (find-file user-init-file))
#+end_src

***** readme org file
:PROPERTIES:
:ID:       ceb0caee-f950-4ab5-a6e9-aad436334469
:END:

#+begin_src emacs-lisp
(defun xl/switch-to-readme ()
  "Switch to README."
  (interactive)
  (find-file (f-full "~/README.org")))
#+end_src

**** tangling
:PROPERTIES:
:ID:       9e5695e0-82ac-4f49-a237-63ca70b1036f
:END:

***** tangle asynchronously
:PROPERTIES:
:ID:       9fcff539-5c1c-4ec8-8aa7-ac8fb82d3392
:END:

Tangling is extremely slow using [[helpfn:org-babel-tangle][org-babel-tangle]]. With a large org file like mine there's
a significant lag and Emacs is blocked while it is tangling.

#+begin_src emacs-lisp
(defun xl/tangle-config-async ()
  "Tangle the readme file asynchronously."
  (interactive)
  (let ((input (expand-file-name "init.org" "~/.tangld/src/emacs/"))
	(output (expand-file-name "init.el" "~/.config/emacs/")))
    (async-start
     `(lambda ()
	(require 'org)
	(require 'ob-tangle)
	(require 'rx)
	(setq org-confirm-babel-evaluate nil)
	(let ((gc-cons-threshold most-positive-fixnum)
	      (org-confirm-babel-evaluate nil))
	  (mkdir "~/.config/emacs/" t)
	  (org-babel-tangle-file ,input ,output)))
     `(lambda (result)
	(message (if result "Successfully tangled %s" "Failed to tangle %s") ,output)))))
#+end_src

**** open Emacs instance
:PROPERTIES:
:ID:       287537bc-f1a7-4c04-bbb6-c372df540e04
:END:

#+begin_src emacs-lisp
(defun xl/open-emacs-instance ()
  "Open a new emacs instance in debug-mode."
  (interactive)
  (cond ((eq system-type 'darwin)
         (start-process-shell-command
          "emacs"
          nil "open -n /Applications/Emacs.app --args --debug-init"))
        ((eq system-type 'gnu/linux)
         (start-process "emacs" nil "emacs" "--debug-init"))))
#+end_src

**** jump to line
:PROPERTIES:
:ID:       47480f9a-2e82-435a-a098-6a1a9a11c2f0
:END:

A simplified version of [[helpfn:consult-line][consult-line]] that only works in org mode. Thing
is, although consult line looks prettier I find it less useful to see fontified
headlines and would rather view the entire path.

#+begin_src emacs-lisp
(defun xl/goto-org-heading ()
  "Jump to an org heading."
  (interactive)
  (let ((selectrum-should-sort-p nil)
        (org-outline-path-complete-in-steps)
        (org-goto-interface 'outline-path-completion)
	(org-goto-max-level 10))
    (org-goto))
  (when (eq major-mode 'org-mode) (org%show-branch)))
#+end_src

*** variables defined in c source code
:PROPERTIES:
:ID:       5d7f2962-8d10-40a4-b134-c368e2b1b4d5
:END:

This headline contains variables that are defined in c-source code and thefore
do not pertain to any particular package. For this reason I don't wrap these
variables in a [[29e1513a-e12a-4818-870e-8d5fab7fe1a0][use-package]] block.

**** don't create lockfiles
:PROPERTIES:
:ID:       ae464c90-d220-4db2-a3fd-fec36b9181e4
:END:

https://stackoverflow.com/questions/8246483/emacs-how-to-disable-files-creation

#+begin_src emacs-lisp
(set! create-lockfiles nil)
#+end_src

**** delete duplicates in history
:PROPERTIES:
:ID:       1c381491-c4fa-4b5e-99de-ec6bd33df77c
:END:

This variable tells savehist not to record duplicate entries in history. Note
this is not apart of savehist technically; it is a variable defined in C source
code.

#+begin_src emacs-lisp
(set! history-delete-duplicates t)
#+end_src

**** don't echo keystrokes
:PROPERTIES:
:ID:       b8856ebe-6208-4271-ad5a-d352fabec8bb
:END:

After you type a key, emacs echoes it into the echo area. I find this
unnecessary. Additionally, this will interfere with [[https://github.com/justbur/emacs-which-key][which-key]]. The keystroke
echoing in the mode line makes the which-key prompt disappear prematurely.

#+begin_src emacs-lisp
(set-default! echo-keystrokes 0)
#+end_src

**** set the fill-column
:PROPERTIES:
:ID:       84d8e85a-a6a1-49cd-b46e-e5cd3f825438
:END:

Fill column refers to the column where line-wrapping will occur. The standard
value for this is =80= but historically that was because of the [[https://en.wikipedia.org/wiki/Punched_card][IBM punch
card]]. Now this is not the case so I don't think it's as much of a deal.

#+begin_src emacs-lisp
(set-default! fill-column 80)
#+end_src

**** recursive minibuffers
:PROPERTIES:
:ID:       7eb20f6d-75b4-4eec-8878-e7232c1a153d
:END:

This means that you can use the minibuffer while in the minibuffer. One
situation where I use this feature is in the command [[helpfn:eval-expression][eval-expression]]. As I'm
typing an expression, I get completion from the minibuffer.

#+begin_src emacs-lisp
(set-default! enable-recursive-minibuffers t)
#+end_src

**** utf-8 text encoding
:PROPERTIES:
:ID:       26344072-c145-40bd-9ade-8c7f2eef54c8
:END:

#+begin_src emacs-lisp
(setq-default locale-coding-system 'utf-8)
(setq-default buffer-file-coding-system 'utf-8)

(set-language-environment 'utf-8)
(setq-default locale-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
(setq-default default-file-name-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)

(setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))

;; (with-os! (:not windows)
;;   (setq selection-coding-system 'utf-8))

(when (fboundp 'set-charset-priority)
  (set-charset-priority 'unicode))
#+end_src

**** disable bi-directional text
:PROPERTIES:
:ID:       6c12f14c-75c7-4b30-9bb4-ca6e8d3cae47
:END:

Disabling bidirectional text provides a small performance boost. Bidirectional
text is useful for languages that read right to left.

#+begin_src emacs-lisp
(set-default! bidi-display-reordering 'left-to-right)
(set-default! bidi-paragraph-direction 'left-to-right)
#+end_src

**** stop beeping
:PROPERTIES:
:ID:       2a83cb3a-ca2e-4d9c-a296-340d33855614
:END:

#+begin_src emacs-lisp
(set-default! ring-bell-function #'ignore)
#+end_src

**** resize pixelwise
:PROPERTIES:
:ID:       02daff3d-e532-4cfa-a217-81e27627e7a7
:END:

;; https://github.com/baskerville/bspwm/issues/551#issuecomment-574975395

#+begin_src emacs-lisp
(set-default! window-resize-pixelwise t)
(set-default! frame-resize-pixelwise t)
#+end_src

**** use yes or no
:PROPERTIES:
:ID:       82a84315-2018-42e0-bd1a-74af7b722593
:END:

Essentially, I am telling all Emacs functions that prompt the user for a =yes=
or =no= to instead allow me to type =y= or =p=. [[helpfn:yes-or-no-p][yes-or-no-p]] is defined in c
source code.

#+begin_src emacs-lisp
(xl-advice-add #'yes-or-no-p :override #'y-or-n-p)
#+end_src

*** miscellaneous
:PROPERTIES:
:ID:       65edb4e7-0fe1-4e37-ae9b-027c9f15162a
:END:

This headline contains headings for which I have not yet determined a good
hierarchy.

**** log the init time
:PROPERTIES:
:ID:       36e2113f-a28f-4ef2-bb90-141f82291c91
:END:

I find it convenient to be able to view the init time in the =*xl-log*=
buffer. Speed is important to me and I want to know how fast my Emacs is at
initializing. :race-car:

I'm not sure why, but [[helpfn:emacs-init-time][emacs-init-time]] is not completely accurate in some
circumstances. The one I'm referring to now is with general prefix bindings.

#+begin_src emacs-lisp
(defhook! log-init-time (emacs-startup-hook)
  "Log the init time."
  (xl-log "emacs-init-time -> %s" (emacs-init-time)))
#+end_src

**** startup
:PROPERTIES:
:ID:       f9854e53-dd9d-4381-8e9c-8336736d4308
:END:

As it's name suggests, the built-in startup feature in Emacs.

If you just set [[helpvar:inhibit-startup-echo-area-message][inhibit-startup-echo-area-message]] to =t= the word =nil= is
messaged.  So it's best just to override the function entirely.

As per [[https://emacs.stackexchange.com/questions/18677/prevent-auto-save-list-directory-to-be-created][this stackoverflow question]], this prevents the =auto-save-directory= from
being created.

#+begin_src emacs-lisp
(use-package startup
  :ignore display-startup-echo-area-message startup-echo-area-message
  :set
  (auto-save-list-file-prefix  . nil)
  (inhibit-startup-buffer-menu . t)
  (inhibit-startup-message     . t)
  (inhibit-startup-screen      . t)
  (inhibit-default-init        . t)
  (inhibit-spash-screen        . t)
  (initial-scratch-message     . nil)
  (initial-buffer-choice       . #'startup%initial-buffer-choice)
  (initial-major-mode          . 'fundamental-mode)
  :init
  (defun startup%initial-buffer-choice ()
    "Return the initial buffer to be displayed.
This function is meant to be used as the value of `initial-buffer-choice'."
    (alet (if xl-debug-p "*xl-log*" "*scratch*")
      (get-buffer-create it))))
#+end_src

**** cus-edit
:PROPERTIES:
:ID:       a844ddb6-245b-463c-963d-743c931698ae
:END:

Emacs automatically creates a [[helpvar:custom-file][custom-file]] for customizations done via the [[info:emacs#Easy
 Customization][customization interface]]. I am one of those who prefers to set them myself in my
config file as opposed to having this file. Therefore, I set it to [[;][null-device]].

#+begin_src emacs-lisp
(use-package cus-edit
  :set
  (custom-file            . null-device)
  (custom-theme-directory . (concat XL-LOCAL-DIR "themes/")))
#+end_src

**** server
:PROPERTIES:
:ID:       3a1120f5-2809-42d6-938c-3916483033e0
:END:

#+begin_src emacs-lisp
(use-package server
  :set
  (server-auth-dir . (concat XL-CACHE-DIR "server/")))

(defhook! run-server-maybe (emacs-startup-hook)
  "Run emacs as a server if it's not running already."
  (require 'server)
  (unless (server-running-p) (server-start)))
#+end_src

**** linux
:PROPERTIES:
:ID:       6572e618-e5ef-445b-90d6-14dc2c24f1a4
:END:

#+begin_src emacs-lisp
(with-os! linux
  (set! x-underline-at-descent-line t)
  (set! x-gtk-use-system-tooltips nil))
#+end_src

**** scrolling
:PROPERTIES:
:ID:       c91bcd0f-da83-44a3-9d9e-e1f55dcdb642
:END:

#+begin_src emacs-lisp
(set-default! hscroll-margin 2)
(set-default! hscroll-step 1)
(set-default! scroll-conservatively 1001)
(set-default! scroll-margin 0)
(set-default! scroll-preserve-screen-position t)
#+end_src

**** fast scrolling
:PROPERTIES:
:ID:       964a8b3e-37b4-4d6b-9298-3a1be3cfe6aa
:END:

"More performant rapid scrolling over unfontified regions. May cause brief
spells of inaccurate fontification immediately after scrolling."

#+begin_src emacs-lisp
(set! fast-but-imprecise-scrolling t)
#+end_src

**** disable cursor blinking
:PROPERTIES:
:ID:       fe8a259b-12e6-4e58-a324-eab831283a86
:END:

By default the cursor blinks. The point is so that it is easier to find on the
screen. Usually, however, I have no trouble finding it so I disable it.

#+begin_src emacs-lisp
(use-package frame
  :config
  (blink-cursor-mode -1))
#+end_src

**** garbage collection
:PROPERTIES:
:ID:       dda841d2-25f3-4595-ab6a-87cb1bb72dba
:END:

Emacs garbage collects too frequently for most modern machines. This makes emacs
less performant especially when performing a large number of calculations,
because it spends resources garbage collecting when it doesn't have to. Indeed,
increasing the value of [[helpvar:gc-cons-threshold][gc-cons-threshold]], the number of bytes of consing
between garbage collections, is known to make a notable difference in user
startup time. By default it is only 800 KB.

***** gc cons threshold
:PROPERTIES:
:ID:       50e19a55-a04b-4ca0-8024-a88b23b5b41f
:END:

I define three levels on frequency with which emacs should perform garbage
collection.

#+begin_src emacs-lisp
;; (defcustom XL-GC-CONS-THRESHOLD-MULTIPLIER nil
;;   "The number multiplied")

(defconst XL-GC-CONS-THRESHOLD-MAX most-positive-fixnum
  "The upper limit for `gc-cons-threshold'.
When VOID is performing computationally intensive operations,
`gc-cons-threshold' is set to this value.")

(defconst XL-GC-CONS-THRESHOLD (eval-when-compile (* 16 1024 1024))
  "The default value for `gc-cons-threshold'.
This is the value of `gc-cons-threshold' that should be used in typical usages.")

(defconst XL-GC-CONS-THRESHOLD-MIN (eval-when-compile (* 4 1024 1024))
  "The value for `gc-cons-threshold'.")
#+end_src

***** gcmh
:PROPERTIES:
:ID:       86653a5a-f273-4ce4-b89b-f288d5d46d44
:END:

=gcmh= does three things. It reduces garbage collection by setting, it adds a
hook telling Emacs to gargbage collect during idle time, and it tells Emacs
to garbage collect more frequently when it's idle.

Note that I add gcmh mode hook at the end so that all the other hook commands
are done before setting the =gc-cons-threshold= back to a normal value.

#+begin_src emacs-lisp
(use-package gcmh
  :hook emacs-startup-hook
  :set
  (gcmh-idle-delay          . 5)
  (gcmh-verbose             . xl-debug-p)
  (gcmh-high-cons-threshold . XL-GC-CONS-THRESHOLD)
  (gcmh-low-cons-threshold  . XL-GC-CONS-THRESHOLD-MIN))
#+end_src

***** minibuffer
:PROPERTIES:
:ID:       8c02fc83-5e7e-4115-9768-020abcf82541
:END:

[[helpvar:minibuffer-setup-hook][minibuffer-setup-hook]] and [[helpvar:minibuffer-exit-hook][minibuffer-exit-hook]] are the hooks run just before
entering and exiting the minibuffer (respectively). In the minibuffer I'll be
primarily doing searches for variables and functions. There are alot of
variables and functions so this can certainly get computationally expensive. To
keep things snappy I increase boost the [[helpvar:gc-cons-threshold][gc-cons-threshold]] just before I enter
the minibuffer, and restore it to it's original value a few seconds after it's closed.

It would take me forever to guess the name =minibuffer-setup-hook= from the
variable [[helpvar:minibuffer-exit-hook][minibuffer-exit-hook]]. If I knew the name =minibuffer-exit-hook= but did not
know what the hook to enter the minibuffer was, I'd probably
=minibuffer-enter-hook= because [[https://www.wordhippo.com/what-is/the-opposite-of/exit.html]["enter" is one of the main antonyms of "exit"]].
It'd take me forever to guess =startup=. Note that the only tricky thing about
this example.

At first I thought of =entry= but after more thought I realized
hook variables use action verbs in their names not nouns. So the =exit= in
=minibuffer-exit-hook= is actually the verb =exit= not the noun.

#+begin_src emacs-lisp
(defvaralias 'minibuffer-enter-hook 'minibuffer-setup-hook)

(defhook! boost-garbage-collection (minibuffer-enter-hook)
  "Boost garbage collection settings to `XL-GC-CONS-THRESHOLD-MAX'."
  (setq gc-cons-threshold XL-GC-CONS-THRESHOLD-MAX))

(defhook! defer-garbage-collection (minibuffer-exit-hook :append t)
  "Reset garbage collection settings to `xl-gc-cons-threshold' after delay."
  (setq gc-cons-threshold XL-GC-CONS-THRESHOLD))
#+end_src

**** theme
:PROPERTIES:
:ID:       c35c131a-bcc5-49f9-bc24-a5f91cde785d
:END:

***** don't prompt me when loading theme
:PROPERTIES:
:ID:       eaa6531c-1188-41c7-a645-a82d9f482449
:END:

If you don't enable =custom-save-themes=, emacs asks you whether you're sure you
want to load a theme for security reasons. I prefer the convenience of not being
prompted.

Loading a theme qualifies as an intensive operation as all the faces on the
screen need to be redisplayed.

#+begin_src emacs-lisp
(use-package custom
  :gc-pause load-theme
  :set
  (custom-safe-themes . t))
#+end_src

***** loading theme
:PROPERTIES:
:ID:       b4773208-5e96-46d2-90d0-1731f6581f1b
:END:

Sometimes there are things that need tidying up after loading a theme. For
example, if I'm using evil I need to update the cursor color.

#+begin_src emacs-lisp
(defvar xl-after-load-theme-hook nil
  "Hook run after the theme is loaded with `load-theme'.")

(defadvice! run-after-load-theme-hook (:after load-theme)
  "Set up `xl-load-theme-hook' to run after `load-theme' is called."
  (run-hooks 'xl-after-load-theme-hook))
#+end_src

***** disable old themes first
:PROPERTIES:
:ID:       c2110d52-ce27-4f3a-b856-1e31200f597c
:END:

Sometimes we end up with remants of the faces of old themes when we load a new
one. For this reason, I make sure to disable any enabled themes before applying
a new theme.

#+begin_src emacs-lisp
(defadvice! disable-old-themes (:around load-theme)
  "Disable old themes before loading new ones."
  (mapc #'disable-theme custom-enabled-themes)
  (apply orig-fn args))
#+end_src

**** disable terminal initialization
:PROPERTIES:
:ID:       540c1c5a-cd31-45cf-afaf-b8e48a76e68e
:END:

According to Doom Emacs, when running emacs in terminal tty is *tremendously* slow.

#+begin_src emacs-lisp
(unless (display-graphic-p)
  (xl-advice-add #'tty-run-terminal-initialization :override #'ignore)
  (defhook! init-tty (window-setup-hook)
    (advice-remove #'tty-run-terminal-initialization #'ignore)
    (tty-run-terminal-initialization (selected-frame) nil t)))
#+end_src

**** prevent emacs from killing certain buffers
:PROPERTIES:
:ID:       ae935cf5-7322-499c-96d7-20209d9b6641
:END:

I never want the =*scratch*= and =*Messages*= buffer to be killed. I owe this idea
to [[https://github.com/rememberYou/.emacs.d][rememberYou's Emacs]].

#+begin_src emacs-lisp
(defhook! lock-certain-buffers (after-init-hook)
  "Prevent certain buffers from being killed."
  (iter (each buffer (list "*scratch*" "*Messages*"))
	(with-current-buffer buffer (emacs-lock-mode 'kill))))
#+end_src

** keybindings
:PROPERTIES:
:ID:       e4605d42-4d57-40d9-8594-15b06f6196a4
:END:

The goal is to efficiently setup the bindings we need to use Emacs. It's
important to remember that not matter how powerful the commands you have, if you
don't invest the time into binding them to useful keys you'll be very
inefficient, having to press =M-x= between any non built-in command. Its
important to bind them and to do it in an organized way so you can always find
the bindings you need when you need it.

*** bind!
:PROPERTIES:
:ID:       328d3e9f-8885-4c69-94b0-1f9984f33d61
:END:

This headline is concerned with the definition of =bind!=, a general purpose
mapping macro similar to [[https://github.com/hlissner/doom-emacs/blob/develop/core/core-keybinds.el][doom's map macro]], [[https://github.com/justbur/emacs-bind-map][bind-map]], and [[https://github.com/priyadarshan/bind-key][bind]] used in
use-package (of these though it is most similar to doom's macro). The purpose is
to provide a versatile, non-repetative, and extensible syntax that does what I
mean. Overall I want to abstract the act of keybinding and to not concern myself
with the automatable (not a word probably) details of binding keys.

**** evil key to states
:PROPERTIES:
:ID:       672841ed-1c4b-4351-ac68-e7107cc0bea2
:END:

I want to specify evil states via keywords just like Doom Emacs's =map!=
macro. So, for example =:nm= in front of a binding would mean the binding should
be bound in =normal= and =motion= state. The reason for doing this is that (1)
it is more concise than naming the actual states and (2) it allows us to specify
bindings of different states in the same form as opposed to [[helpfn:evil-define-key*][evil-define-key*]].

#+begin_src emacs-lisp
(defun xl-bind%evil-keyword-to-states (evil-keyword)
  "Return list of evil states specified by EVIL-KEYWORD.
EVIL-KEYWORD is a keyword whose letters correspond to the first letters of evil
states (e.g. :i \"i\" would correspond to \"insert\" state).
If any letter in EVIL-KEYWORD does not correspond to an evil state, return nil."
  (loopy (with (evil-states '(normal visual emacs insert operator motion)))
	 (seq char (seq-uniq (xl-keyword-name evil-keyword)))
	 (expr state (--first (->> (symbol-name it)
				   (seq-first)
				   (char-equal char))
			      evil-states))
	 (unless state (return nil))
	 (collect state)))
#+end_src

**** deferring keymaps
:PROPERTIES:
:ID:       76200d2b-839d-4111-863a-08021e18c7e4
:END:

As it stands =define-key= and friends raise an error if the keymap you specified
has not been defined. We want the =bind!= macro to do what we mean: if a key's
keymap is not defined, then bind the key when it is.

***** deferred binding forms
:PROPERTIES:
:ID:       e03e1a47-41d1-4dd8-9f1a-8151de76da2a
:END:

To do this, the first step is creating a variable that will store the binding
forms that need to be evaluated when a keymap is loaded.

#+begin_src emacs-lisp
(defvar xl-bind%deferred-bindings nil
  "Alist of deferred bindings.
Each element is of the form (KEYMAP . BINDING-FORMS).
KEYMAP is a keymap that has not yet been bound. BINDING-FORMS are the forms to
be evaluated when KEYMAP is bound.")
#+end_src

***** updating deferred bindings
:PROPERTIES:
:ID:       fa345a49-e002-4efd-ba68-5f533d42aebb
:END:

This hook will traverse the alist of deferred bindings, checking to see whether
a keymap in the alist is bound. If it is we evaluate its corresponding forms.

#+begin_src emacs-lisp
(defun xl-bind%update-deferred-bindings (deferred-bindings)
  "Evaluate bindings whose keymap now exist.
Return any keymaps whose keymaps still don't exist."
  (iter (each (elt &as keymap . forms) deferred-bindings)
	(cond ((boundp keymap)
	       (xl-log "bind keys from -> %S" keymap)
	       (funcall `(lambda () (progn ,@forms))))
	      (t
	       (collect elt)))))
#+end_src

***** hook for deferred bindings
:PROPERTIES:
:ID:       a95d82f1-9614-4ec5-a2e5-a2f29f514e2b
:END:

We also need to add a hook to [[helpfn:after-load-functions][after-load-functions]]. The hook
=after-load-functions= is abnormal because it does not end in =-hook=. It is run
after any file is loaded. We put use this hook so we can be sure to catch any
new keymaps.

#+begin_src emacs-lisp
(defhook! eval-deferred-bindings (after-load-functions)
  "Evaluate deferred bindings whose keymap is now bound."
  (cl-callf xl-bind%update-deferred-bindings xl-bind%deferred-bindings))
#+end_src

***** with-deferred-keymap!
:PROPERTIES:
:ID:       ddb17e5c-74e8-445e-b659-cf94f4831a46
:END:

The final touch is to create a macro that evaluates its body only if a specified
keymap is already bound. If the keymap is not bound then it simply updates
[[helpvar:xl-bind%deferred-bindings][xl-bind:deferred-bindings]]. I wrap every individual binding with this form.

#+begin_src emacs-lisp
(defmacro with-deferred-map! (map &rest forms)
  "Defer the evaluation of FORMS until MAP is loaded.
If MAP is already loaded, evaluate forms immediately."
  (declare (indent defun))
  (pcase map
    ((or (pred boundp) 'local-map 'global-map)
     `(progn ,@forms))
    (_
     `(cl-callf a-update xl-bind%deferred-bindings ',map #'append ',forms))))
#+end_src

**** reading clauses
:PROPERTIES:
:ID:       9038980a-be61-4ad5-a0b5-cd151b96d0d9
:END:

***** whether is a binding
:PROPERTIES:
:ID:       743e3fdb-fb0c-44ba-a5e9-7282b20cfdcc
:END:

#+begin_src emacs-lisp
(defun xl-bind%binding-p (clause)
  "Return non-nil if CLAUSE contains a keybinding."
  (pcase (-take-last 2 clause)
    (`(,(or (pred stringp) (pred vectorp) (pred symbolp)) ,(pred xl-quoted-p)) t)
    (_ nil)))
#+end_src

***** read a clause
:PROPERTIES:
:ID:       255730df-5715-4808-8a7d-6c37bd1333e5
:END:

#+begin_src emacs-lisp
(defun xl-bind%read-clause (clauses)
  "Return CLAUSES."
  (loopy (with (clauses (--splice (listp (car it)) (xl-bind%read-clause it) clauses)))
	 (list clause clauses)
	 (cond ((or (xl-bind%binding-p clause)
		    (xl-bind%binding-p (-butlast clause)))
		(collect bindings clause))
	       (t
		(append common-args clause)))
	 (finally-return (-map (-partial #'append common-args) bindings))))
#+end_src

**** normalization
:PROPERTIES:
:ID:       56abc5a3-bcf7-4943-a941-939e16d46dea
:END:

The purpose of normalization is to make the clauses homogenous and into a form
that is easily.

***** fix the keybinding
:PROPERTIES:
:ID:       0202c1a2-75a3-45ac-a226-8b6b906d96ac
:END:

This means that the keybinding should always be last.

#+begin_src emacs-lisp
(defun xl-bind%normalize-keybinding (clause)
  "Return clause with proper keybinding."
  (append (-drop-last 2 clause)
	  (-interleave '(:key :def) (-take-last 2 clause))))
#+end_src

***** fix the evil state
:PROPERTIES:
:ID:       1a8f4cf8-1013-4e0c-8fd1-21b69c2e6b8b
:END:

#+begin_src emacs-lisp
(defun xl-bind%normalize-evil-state (clause)
  "Return clause with proper evil-state."
  (pcase (-take-last 5 clause)
    (`(,(and (pred keywordp) ekey) :key ,_ :def ,_) t
     `(,@(-drop-last 5 clause) :states ,(xl-bind%evil-keyword-to-states ekey)
       ,@(-take-last 4 clause)))
    (_ clause)))
#+end_src

***** flatten plist values
:PROPERTIES:
:ID:       6be10885-4bbe-47e2-bd47-0c14f51b9065
:END:

Remember, that the goal of normalization is to end up with a list of plists with.

#+begin_src emacs-lisp
(defun xl-bind%flatten-plist-values (plist)
  "Expand clause."
  (loopy (cons (key val . rest) plist #'cddr)
	 (cond ((or (atom val) (xl-quoted-p val))
		(append new (list key val)))
	       ((= 1 (length val))
		(append new (list key (car val))))
	       (t
		(expr tails (xl-bind%flatten-plist-values `(,key ,(cdr val) ,@rest)))
		(subloop (list tail tails)
			 (collect flattened (append new tail)))
		(append new (list key (car val)))))
	 (finally-return (cons new flattened))))
#+end_src

***** make clause into proper plist
:PROPERTIES:
:ID:       e836329e-c2b9-4978-a3d7-9ba32c160f04
:END:

#+begin_src emacs-lisp
(defun xl-bind%make-proper-plist (list)
  "Ensure every key in LIST has only one value."
  (loopy (with (list `(,@list :done)))
	 (while list)
	 (expr elt (pop list))
	 (expr next (car list))
	 (cond ((keywordp elt)
		(expr key elt))
	       (t
		(collect values elt)))
	 (when (keywordp next)
	   (append plist (list key (xl-dwim-single values)))
	   (expr values nil))
	 (finally-return plist)))
#+end_src

***** merge multiple plist values
:PROPERTIES:
:ID:       d50cb073-54c0-4b96-8df1-2ae195ac4651
:END:

#+begin_src emacs-lisp
(defun xl-bind%merge-duplicate-plist-keys (plist)
  "Merge duplicate keys in PLIST."
  (iter (conses (key val . _) plist #'cddr)
	(cond ((assoc key alist)
	       (expr var (alist-get key alist))
	       (set var (append (symbol-value var) (list val))))
	      (t
	       (expr var (gensym (symbol-name key)))
	       (set var (list val))
	       (collect alist (cons key var))))
	(fret (loopy (list (key . var) alist)
		     (append (list key (xl-dwim-single (symbol-value var))))))))
#+end_src

***** normalize the list
:PROPERTIES:
:ID:       377bcdf9-3798-4dff-83e5-13f3a59e112e
:END:

#+begin_src emacs-lisp
(defun xl-bind%normalize-plist (plist)
  "Return the list normalized."
  (loopy (while plist)
	 (expr key (pop plist))
	 (expr values (loopy (while (and plist (not (keywordp (car plist)))))
			     (collect (pop plist))))
	 (expr alist (a-update alist key #'append (list values)))
	 (finally-return alist)))
#+end_src

***** ensure-keymap
:PROPERTIES:
:ID:       1fb99451-7b0e-4bef-b980-7f4e038dd38d
:END:

#+begin_src emacs-lisp
(defun xl-bind%ensure-keymap (token)
  (if (not (plist-get token :map))
      `(:map global-map ,@token)
    token))
#+end_src

***** apply-prefix
:PROPERTIES:
:ID:       5c1aa062-8660-453b-ba8e-04610bec043a
:END:

#+begin_src emacs-lisp
(defun xl-bind%apply-prefix (token)
  (-let [(&plist :prefix :key) token]
    (if (and prefix key (stringp key))
	`(:key ,(concat prefix "\s" key) ,@token)
      token)))
#+end_src

***** convert lists
:PROPERTIES:
:ID:       74298919-c3f2-4e7e-8377-bd8a87def771
:END:

#+begin_src emacs-lisp
(defun xl-bind%process-prefix (plist)
  (loopy (cons (key val . _) plist #'cddr)
	 (cond ((and (eq key :prefix) (listp val))
		(append (list key (s-join "\s" val))))
	       (t
		(append (list key val))))))
#+end_src

**** converting tokens to forms
:PROPERTIES:
:ID:       aade9ecc-ee16-407d-a451-03da731daeb2
:END:

This section is about actually converting define key clauses that have already
been parsed and processed into lisp forms that actually correspond to
bindings. The design of this step follows a =use-package=.

***** convert logic
:PROPERTIES:
:ID:       9c779428-a8b5-4e2c-b3d3-c369f7f161b0
:END:

What list of converters should be used to edit the token depends on the token
itself. Some converters imply not using others. Some should only be used in
certain circumstances.

#+begin_src emacs-lisp
(defvar xl-bind%converters
  '((evil-which-key which-key)
    which-key
    defer-map
    kbd
    (evil-bind bind)
    bind))
#+end_src

***** decide on which converters to use
:PROPERTIES:
:ID:       09ad63c3-c438-47d2-9e4e-789bc0a4b488
:END:

Code that is split into appropriate parts is easier to read and write.

#+begin_src emacs-lisp
(defun xl-bind%converters (token)
  "Return a list of converters for TOKEN."
  (loopy (with (converters xl-bind%converters))
	 (list (name . exclude) (-map #'-list converters))
	 (expr convert-fn (xl-symbol-intern 'xl-bind%convert- name))
	 (expr pred (xl-symbol-intern 'xl-bind%predicate- name))
	 (when (and (funcall pred token) (not (member name excluded)))
	   (collect fns convert-fn)
	   (append excluded exclude))
	 (finally-return fns)))
#+end_src

***** convert token to forms
:PROPERTIES:
:ID:       10116109-b7a6-4e6e-94b2-6b41d4fc9f1f
:END:

#+begin_src emacs-lisp
(defun xl-bind%convert-token-to-forms (token converters)
  "Convert TOKEN to a list of forms."
  (-let [(converter . rest) converters]
    (funcall (or converter #'ignore) token rest)))
#+end_src

***** binding-forms
:PROPERTIES:
:ID:       31d4d497-afac-4ccf-a426-afa8f159e242
:END:

#+begin_src emacs-lisp
(defun xl-bind%binding-forms (tokens)
  "Convert BIND-TOKENS to binding forms.
Return a list of forms that binds keys specified by BIND-TOKENS."
  (loopy (list token tokens)
	 (expr converters (xl-bind%converters token))
	 (expr forms (xl-bind%convert-token-to-forms token converters))
	 (append forms)))
#+end_src

***** converting to forms
:PROPERTIES:
:ID:       7fd1a756-b8aa-41e4-8dae-7a0dfdd1e17b
:END:

****** which-key
:PROPERTIES:
:ID:       076b2b4d-7c12-4ebd-8f84-1d649487ae72
:END:

#+begin_src emacs-lisp
(defun xl-bind%predicate-which-key (token)
  "Return non-nil if TOKEN has a which-key."
  (--all-p (plist-get token it) '(:key :map :wk :prefix)))

(defun xl-bind%convert-which-key (token converters)
  "Add needed which-key form."
  (-let* (((&plist :key :map :wk :prefix) token))
    `((after! which-key
	(which-key-add-keymap-based-replacements ,map ,prefix ,wk))
      ,@(xl-bind%convert-token-to-forms token converters))))
#+end_src

****** evil which-key
:PROPERTIES:
:ID:       290cceaf-30b1-48d0-a688-b7db49728f01
:END:

The way evil works is that for an existing map (such as =org-mode-map=), it
creates an evil variant for each state. And this is the keymap that actually has
priority over original keymap when the given state is enabled. You can access
this keymap via the function [[helpfn:evil-get-auxiliary-keymap][evil-get-auxiliary-keymap]].

#+begin_src emacs-lisp
(defun xl-bind%predicate-evil-which-key (token)
  (and (xl-bind%predicate-which-key token)
       (xl-bind%predicate-evil-bind token)))

(defun xl-bind%convert-evil-which-key (token converters)
  "Return which key forms for an evil token."
  (loopy (with ((&plist :states :map :prefix :key :wk) token)
	       (rest (xl-bind%convert-token-to-forms token converters)))
	 (list state states)
	 (expr keymap `(evil-get-auxiliary-keymap ,map ',state))
	 (collect forms `(which-key-add-keymap-based-replacements ,keymap ,prefix ,wk))
	 (finally-return `((after! which-key ,@forms) ,@rest))))
#+end_src

****** evil-bind
:PROPERTIES:
:ID:       7d69d323-2eeb-4d90-88c8-cfde7f7768d3
:END:

#+begin_src emacs-lisp
(defun xl-bind%predicate-evil-bind (token)
  "Return non-nil if TOKEN."
  (and (xl-bind%predicate-bind token)
       (plist-get token :states)
       t))

(cl-defun xl-bind%convert-evil-bind (token converters)
  "Return evil binding form for TOKEN."
  (-let [(&plist :states :map :key :def) token]
    `((after! evil (evil-define-key* ',states ,map ,key ,def))
      ,@(xl-bind%convert-token-to-forms token converters))))
#+end_src

****** bind
:PROPERTIES:
:ID:       be633966-63b6-40ef-a5fe-79444218caf2
:END:

#+begin_src emacs-lisp
(defun xl-bind%predicate-bind (token)
  (-all-p (-partial #'plist-get token) '(:map :key :def)))

(defun xl-bind%convert-bind (token converters)
  "Add binding form for token."
  (-let [(&plist :prefix :map :key :def :states) token]
    `((define-key ,map ,key ,def)
      ,@(xl-bind%convert-token-to-forms token converters))))
#+end_src

****** defer binding
:PROPERTIES:
:ID:       f8892022-1921-44de-b157-7182bbcba31c
:END:

#+begin_src emacs-lisp
(defun xl-bind%predicate-defer-map (token)
  (xl-bind%predicate-bind token))

(defun xl-bind%convert-defer-map (token converters)
  `((with-deferred-map! ,(plist-get token :map)
      ,@(xl-bind%convert-token-to-forms token converters))))
#+end_src

****** kbd
:PROPERTIES:
:ID:       cdf12c08-799d-4cbc-be73-88ca77efc16f
:END:

This is the final step. The purpose of the binding tokens is to conveniently
provide the data needed about each binding so that we can write our own custom
function to generate binding forms. Obviously, this is very customizable.

#+begin_src emacs-lisp
(defun xl-bind%predicate-kbd (token)
  (and (plist-get token :kbd) (not (vectorp (plist-get token :key))) t))

(defun xl-bind%convert-kbd (token converters)
  (-let [(&plist :kbd :key) token]
    (-> (if kbd (map-insert token :key `(kbd ,key)) token)
	(xl-bind%convert-token-to-forms converters))))
#+end_src

***** localleader
:PROPERTIES:
:ID:       e83756c1-2472-4b69-8a9e-4a9328af32a7
:END:

This is a wrapper macro around =bind!= that applies. Eventually, I want to
implement this macro as a =:localleader= keyword, so I can use just one macro,
=bind!= for everything. But this was easier to implement quickly.

#+begin_src emacs-lisp
(defmacro bind-localleader! (&rest clause)
  "Apply localleader to bindings."
  `(bind!
     ((:prefix ,XL-EMACS-LOCALLEADER-KEY ,XL-EMACS-LOCALLEADER-SHORT-KEY)
      ,@clause)
     ((:prefix ,XL-EMACS-LOCALLEADER-KEY ,XL-EMACS-LOCALLEADER-SHORT-KEY)
      (:states insert emacs)
      ,@clause)
     ((:prefix ,XL-EVIL-LOCALLEADER-KEY ,XL-EVIL-LOCALLEADER-SHORT-KEY)
      (:states normal visual motion)
      ,@clause)))
#+end_src

**** bind!
:PROPERTIES:
:ID:       0ce28150-7971-466f-b9b7-3cf33c496393
:END:

Finally, our main macro is here.

#+begin_src emacs-lisp
(defmacro bind! (&rest clauses)
  "Define bindings based on CLAUSES."
  (declare (indent defun))
  `(progn
     ,@(->> (xl-bind%read-clause (cons '(:kbd t) clauses))
	    (-map #'xl-bind%normalize-keybinding)
	    (-map #'xl-bind%normalize-evil-state)
	    (-map #'xl-bind%make-proper-plist)
	    (-mapcat #'xl-bind%flatten-plist-values)
	    (-map #'xl-bind%merge-duplicate-plist-keys)
	    (-map #'xl-bind%process-prefix)
	    (-map #'xl-bind%apply-prefix)
	    (-mapcat #'xl-bind%flatten-plist-values)
	    (-map #'xl-bind%ensure-keymap)
	    (xl-bind%binding-forms))))
#+end_src

*** leaders
:PROPERTIES:
:ID:       1e4dac95-9c16-41db-9f99-63a250b447c2
:END:

The way I organize my keys is via leader keys. The leader will be the root of a
keybinding tree. And once you know the leader, you can "discover" the other
bindings as you need to. You can see the concept of the leader used in Emacs
distributions such as [[https://github.com/syl20bnr/spacemacs][Spacemacs]] and [[https://github.com/hlissner/doom-emacs][Doom Emacs]].

**** evil leaders
:PROPERTIES:
:ID:       47c4c3c5-3859-46a4-a4ef-3d27c552eec0
:END:

These leaders are specifically for evil mode states (not including insert and
Emacs). I choose the space (=SPC=) key for evil leaders because it is one of if
not the easiest key to press because of its central placement on the keyboard
and its sheer size--at least on the [[https://en.wikipedia.org/wiki/QWERTY][qwerty]] keyboard that I use. The choice
of =SPC m= for the major mode specific keys is simply for the pnemonic =m= which
stands for "major mode". The short major mode prefix key =,= is for cases when I
want to shorten a key binding. Although obviously not as easy to remember as
=m=, it provides me with one shorter keypress in certain situations.

#+begin_src emacs-lisp
(defconst XL-EVIL-LEADER-KEY "SPC"
  "The evil leader prefix key.")

(defconst XL-EVIL-LOCALLEADER-KEY "SPC m"
  "The localleader prefix key for major-mode specific commands.")

(defconst XL-EVIL-LOCALLEADER-SHORT-KEY ","
  "A shorter alternative `xl-localleader-key'.")
#+end_src

**** emacs leaders
:PROPERTIES:
:ID:       f3299c73-837e-46f9-a29e-9932c4570858
:END:

These leaders are for evil insert and emacs states as well as vanilla
Emacs. Note that evil Emacs state is different from vanilla Emacs. One of the
goals with these bindings is to set up keybindings in the case that I disable
evil mode or in the case that I want to use my bindings in insert or Emacs
state--or even vanilla Emacs. The choice behind the bindings is the same as
[[id:][before]], except I just prepended the =Meta= (a.k.a. the =Alt= key) to everything.

#+begin_src emacs-lisp
(defconst XL-EMACS-LEADER-KEY "M-SPC"
  "The leader prefix key used for Insert and Emacs states.")

(defconst XL-EMACS-LOCALLEADER-KEY "M-SPC m"
  "The localleader prefix key for major-mode specific commands.")

(defconst XL-EMACS-LOCALLEADER-SHORT-KEY "M-,"
  "A short non-normal  `xl-localleader-key'.")
#+end_src

*** prefix commands
:PROPERTIES:
:ID:       2cf36d16-eafc-46d8-8b19-e1eb02d39c0d
:END:

A quote from [[https://github.com/hlissner/doom-emacs/blob/develop/core/core-keybinds.el#L182][Doom Emacs]]:

We use a prefix commands instead of general's :prefix/:non-normal-prefix
properties because general is incredibly slow binding keys en mass with them in
conjunction with :states -- an effective doubling of Doom's startup time!

#+begin_src emacs-lisp
(defvar xl-leader-map (make-sparse-keymap))

(define-prefix-command 'xl/leader 'xl-leader-map)
#+end_src

*** ensuring high keymap precedence
:PROPERTIES:
:ID:       e06bcfa0-63e9-429e-8ff7-4263cbd4f9b1
:END:

In Emacs, there's a [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Searching-Keymaps.html][hierarchy of keymaps]] that consulted when determining which
keymap takes precedence. The steps I take in this headline are also in [[https://github.com/noctuid/evil-guide#preventing-certain-keys-from-being-overridden][noctuid's
evil-guide]].

**** minor mode
:PROPERTIES:
:ID:       9863dc90-fc8c-422c-918f-3d75d52e8a14
:END:

Creating a minor mode to hold the leader map allows us to toggle our leader
bindings on or off.

Enabling =override-mode= needs to be the first thing we do in
=emacs-startup-hook=, or at least it needs to be before modes that set
keybindings like evil. Otherwise, your bindings might not take effect
immediately. This is why I set the advice dept to =-100=.

#+begin_src emacs-lisp
(defvar xl-override-mode-map (make-sparse-keymap))

(define-minor-mode xl-override-mode
  "Global minor mode for higher precedence evil keybindings."
  :keymap xl-override-mode-map
  :global t)

(xl-hook-add 'emacs-startup-hook #'xl-override-mode -100)
#+end_src

**** take precedence over Emacs bindings
:PROPERTIES:
:ID:       9248fb7f-1901-4beb-8b3a-faded48cdddc
:END:

Looking at the [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Searching-Keymaps.html][Emacs keymap hierarchy]], emulation mode maps is pretty up
there. The [[helpvar:emulation-mode-map-alists][emulation-mode-map-alists]] takes an ali.

#+begin_src emacs-lisp
(push '((xl-override-mode . xl-override-mode-map)) emulation-mode-map-alists)
#+end_src

**** make an overriding map
:PROPERTIES:
:ID:       f52fbd32-58a0-4b60-a382-b29112f5d972
:END:

The whole point of the leader bindings is that they be available everywhere and
at all times. Accordingly, we want to ensure our leaders and all their child
bindings take precedence over other Emacs bindings. To do this I create a keymap
that will override all other keymaps, aptly named =XL-OVERRIDE-MAP=.

#+begin_src emacs-lisp
(define-key xl-override-mode-map (kbd XL-EMACS-LEADER-KEY) #'xl/leader)
#+end_src

**** registering override map with evil
:PROPERTIES:
:ID:       23b55b9c-ea38-485a-b986-ac62d60a6f75
:END:

To ensure that =xl-override-mode-map= takes priority over evil states, we need
to make it an intercept map for all evil states. In evil, intercept maps are
maps that take priority (intercept) evil bindings when they have a different
binding for the same key (this is opposed to =overriding-maps=, which completely
override an evil keymap).

#+begin_src emacs-lisp
(defhook! make-intercept-map (evil-mode-hook)
  "Register `xl-override-map' as an intercept map."
  (iter (each state '(normal motion visual insert emacs))
	(evil-make-intercept-map xl-override-mode-map state t)))
#+end_src

**** binding the leader keys to the prefix map
:PROPERTIES:
:ID:       d710cbf7-66c5-4934-a2d4-998fdb6f7731
:END:

These keys need to be bound before =evil-mode-hook=, specifically right after
evil is loaded. Otherwise, the bindings won't take effect immediately in buffers
that have already been created by emacs (such as =*scratch*= and
=*Messages*=). Instead, they will only work after you switch states once.

#+begin_src emacs-lisp
(bind!
 (:map xl-override-mode-map)
 (:ie XL-EMACS-LEADER-KEY 'xl/leader)
 (:mnv XL-EVIL-LEADER-KEY 'xl/leader))
#+end_src

*** which-key
:PROPERTIES:
:ID:       2ad092a3-ff63-49cd-91b9-380c91dbe9f5
:END:

Emacs is full of so many keybindings, that it can be difficult to keep track of
them. Especially when you're starting out, but even when you're an Emacs-pro,
it's easy to forget what a particular functionality is bound to. Typically,
you'll remember the first few key strokes but struggle with the rest. To address
this [[github:][which-key]] displays key binding sequences in the minibuffer as your typing
them. By doing this you can "discover" the commands as you go along.

**** init
:PROPERTIES:
:ID:       c4aedc23-0be3-46fe-b046-32b5f0738c6b
:END:

#+begin_src emacs-lisp
(use-package which-key
  :hook emacs-startup-hook
  :set
  (which-key-sort-uppercase-first . nil)
  (which-key-max-display-columns  . nil)
  (which-key-add-column-padding   . 1)
  (which-key-min-display-lines    . 6)
  (which-key-side-window-slot     . -10)
  (which-key-sort-order           . #'which-key-prefix-then-key-order)
  (which-key-popup-type           . 'minibuffer)
  (which-key-idle-delay           . 0.8))
#+end_src

**** set line spacing
:PROPERTIES:
:ID:       6abb35f4-c648-4bed-b59a-5a0636857fd8
:END:

#+begin_src emacs-lisp
(defhook! set-line-spacing (which-key-init-buffer-hook)
  (setq line-spacing 3))
#+end_src

*** execute extended command
:PROPERTIES:
:ID:       f17a6b64-f9df-4801-9728-235f6bbb9b4d
:END:

One of the most common--if not the most common--command you use in Emacs is
[[helpfn:execute-extended-command][execute-extended-command]]. This command let's you search any other command and
upon pressing enter, then you execute the command. The fact that this command is
invoked so frequently suggests it should have one of the shortest, easiest to
press bindings. I chose to give it =SPC SPC= and =;=. =SPC SPC= is short and
quick to type as well as consistent with other =SPC= bindings. While =;= is
super fast to press as well and even faster than =SPC SPC=.

#+begin_src emacs-lisp
(bind!
  (:map xl-leader-map "SPC" #'execute-extended-command)
  (:n ";" #'execute-extended-command)
  ("A-x" #'execute-extended-command)
  ("M-x" #'execute-extended-command))
#+end_src

*** space bindings
:PROPERTIES:
:ID:       ed4853ea-c9de-42c8-af93-9e697f2ea014
:END:

This headline contains generic leader bindings that are in my case triggered by
=SPC=.

**** generic app
:PROPERTIES:
:ID:       68945ce0-82fb-4844-b53b-422c328558af
:END:

#+begin_src emacs-lisp
(bind!
  (:prefix "a" :wk "app")
  (:map xl-leader-map)
  ("c" #'org-capture)
  ((:prefix "o" :wk "arg")
   ("a" #'org-agenda)
   ("l" #'org-store-link)
   ("i" #'org-clock-in-last)
   ("o" #'org-clock-out)
   ("c" #'org-capture))
  ("e" #'eshell)
  ("E" #'xl/open-emacs-instance)
  ("d" #'deer)
  ("r" #'ranger))
#+end_src

**** help
:PROPERTIES:
:ID:       f28081e3-451c-4005-80cc-bffeafe0051c
:END:

#+begin_src emacs-lisp
(bind!
  (:map xl-leader-map)
  (:prefix "h" :wk "help")
  ("i" #'info)
  ("m" #'describe-mode)
  ("f" #'describe-function)
  ("v" #'describe-variable)
  ("c" #'describe-char)
  ("k" #'describe-key)
  ("a" #'apropos)
  ("w" #'woman))
#+end_src

**** toggling
:PROPERTIES:
:ID:       b962fa01-d63f-47a9-bf69-b2f82c8b1e61
:END:

I have kind of a loose definition of "toggle" in this headline.

#+begin_src emacs-lisp
(bind!
  (:prefix "t" :wk "toggle")
  (:map xl-leader-map)
  ("r" #'read-only-mode)
  ("t" #'load-theme)
  ("c" #'caps-lock-mode)
  ("d" #'toggle-debug-on-error)
  ("F" #'xl/set-font-face)
  ("f" #'xl/set-font-size))
#+end_src

**** buffer
:PROPERTIES:
:ID:       5fd53168-3eee-4ed4-8213-28efba5d0200
:END:

#+begin_src emacs-lisp
(bind!
  (:prefix "b" :wk "buffer")
  (:map xl-leader-map)
  ("w" #'save-buffer)
  ((:prefix "k" :wk "kill")
   ("c" #'kill-current-buffer)
   ("o" #'xl/kill-other-buffers))
  ("n" #'next-buffer)
  ("p" #'previous-buffer)
  ("d" #'display-buffer)
  ("b" #'consult-buffer))
#+end_src

**** file
:PROPERTIES:
:ID:       3857a17c-1a14-4163-a23b-8811a2dad111
:END:

#+begin_src emacs-lisp
(bind!
  (:prefix "f" :wk "file")
  (:map xl-leader-map)
  ("s" #'save-buffer)
  ("f" #'find-file)
  ("i" #'xl/switch-to-init-file)
  ("r" #'xl/switch-to-readme))
#+end_src

**** code
:PROPERTIES:
:ID:       d6229bf2-9d8d-4f97-bb95-b07ef409e33f
:END:

#+begin_src emacs-lisp
(bind!
  (:prefix "c" :wk "code")
  (:map xl-leader-map)
  ("l" #'lispyville-comment-or-uncomment)
  ("c" #'lispyville-comment-or-uncomment))
#+end_src

**** window management
:PROPERTIES:
:ID:       a8b3223b-d5ba-4230-9fa8-a9601d60b5ad
:END:

***** window movement
:PROPERTIES:
:ID:       f0152373-3b3f-4cf1-abaf-d025c93c64d3
:END:

#+begin_src emacs-lisp
(bind!
  (:prefix "w" :wk "window")
  (:map xl-leader-map)
  ("h" #'windmove-left)
  ("j" #'windmove-down)
  ("k" #'windmove-up)
  ("l" #'windmove-right)
  ("o" #'ace-window)
  ("d" #'delete-window)
  ("D" #'delete-other-windows)
  ("v" #'split-window-horizontally)
  ("s" #'split-window-vertically)
  ("t" #'transpose-frame))
#+end_src

***** window resizing
:PROPERTIES:
:ID:       373e3cf8-68ea-4791-ae71-e0c73b2f218a
:END:

#+begin_src emacs-lisp
(bind!
  (:prefix "w")
  (:map xl-leader-map)
  ("M" #'maximize-window)
  ("m" #'minimize-window)
  ("b" #'window-balance)
  ("z" #'zoom-window-zoom))
#+end_src

**** workspaces
:PROPERTIES:
:ID:       ba627c58-6008-42a2-abc2-7136f77d44d5
:END:

#+begin_src emacs-lisp
(bind!
  (:map xl-leader-map)
  (:prefix "r" :wk "workspace")
  ("c" #'wg-create-workgroup)
  ("b" #'wg-switch-to-workgroup)
  ("a" #'wg-associate-visible-buffers-with-workgroup)
  ("b" #'wg-dissociate-buffer-from-workgroup)
  ((:prefix "o" :wk "reload")
   ("w" #'wg-open-workgroup)
   ("s" #'wg-open-session))
  ((:prefix "s" :wk "save")
   ("s" #'wg-save-session)
   ("c" #'wg-save-wconfig)))
#+end_src

**** eval
:PROPERTIES:
:ID:       3947b258-fc46-4fc9-8350-3fd25a69d749
:END:

#+begin_src emacs-lisp
(bind!
  (:prefix "e" :wk "eval")
  (:map xl-leader-map)
  ("e" #'eval-expression))

(bind-localleader!
 (:prefix "e" :wk "eval")
 (:map emacs-lisp-mode-map)
 ("d" #'eval-defun)
 ("e" #'eval-expression)
 ("l" #'eval-last-sexp)
 ("p" #'eval-print-last-sexp))
#+end_src

**** search

#+begin_src emacs-lisp
(bind!
  (:prefix "s" :wk "search")
  (:map xl-leader-map)
  ((:prefix "w" :wk "web")
   ("d" #'engine/search-duckduckgo)
   ("q" #'engine/search-qwant)
   ("a" #'engine/search-amazon)
   ("w" #'engine/search-wikipedia))
  ("s" #'consult-line)
  ("l" #'consult-line)
  ("h" #'xl/goto-org-heading)
  ("o" #'xl/goto-org-heading))
#+end_src

**** version control
:PROPERTIES:
:ID:       31234afc-a11d-42a8-88af-e0647d44c1b1
:END:

#+begin_src emacs-lisp
(bind!
  (:prefix "v" :wk "version control")
  (:map xl-leader-map)
  ((:prefix "g" :wk "git-gutter+")
   ("u" #'git-gutter+-unstage-whole-buffer)
   ("n" #'git-gutter+-next-hunk)
   ("p" #'git-gutter+-previous-hunk)
   ("s" #'git-gutter+-stage-hunks)
   ("c" #'git-gutter+-commit))
  ("s" #'magit-status))
#+end_src

**** packages
:PROPERTIES:
:ID:       0ec9aee0-8f9a-4700-8928-abff758357e1
:END:

#+begin_src emacs-lisp
(bind!
  (:prefix "p" :wk "packages")
  (:map xl-leader-map)
  ("i" #'straight-use-package)
  ("u" #'straight-pull-package)
  ("r" #'xl-binding:recompile-package)
  ("h" #'straight-visit-package-website)
  ("d" #'visit-package-directory))
#+end_src

**** quit
:PROPERTIES:
:ID:       ae435361-79e7-41c8-b490-8ec0f8d23a59
:END:

There's many ways to quit Emacs. Sometimes I'd like to save all the buffers I
had been working on. Sometimes, when I'm testing something and I mess up
[[helpvar:kill-emacs-hook][kill-emacs-hook]] I want Emacs to just quit even if it means ignoring that hook.
Most of the time, I know what I'm doing when I quit Emacs, so I don't want a
prompt asking me if I'm sure.

#+begin_src emacs-lisp
(bind!
  (:prefix "q" :wk "quit")
  (:map xl-leader-map)
  ("q" #'save-buffers-kill-emacs)
  ("s" #'xl/quit-emacs-no-prompt)
  ("Q" #'evil-save-and-quit)     
  ("x" #'xl/kill-emacs-no-hook)
  ("e" #'xl/kill-emacs-processes)
  ("b" #'xl/kill-emacs-brutally))
#+end_src

* window management
:PROPERTIES:
:ID:       f8f186bd-a701-4bd4-a249-86ec4faff83b
:END:

** window
:PROPERTIES:
:ID:       af27cd7e-2096-4f6d-a749-63e4c38d136c
:END:

#+begin_src emacs-lisp
(use-package window
  :set
  (split-width-threshold . 160))
#+end_src

** workspaces
:PROPERTIES:
:ID:       c979c631-4098-4204-b067-82f58b5b9ebe
:END:

*** tab-bar-mode
:PROPERTIES:
:ID:       0a72fe9a-1948-4022-a300-18a4881da382
:END:

**** settings
:PROPERTIES:
:ID:       bb63f5b2-cc45-454b-a032-be248f801636
:END:

#+begin_src emacs-lisp
(use-package tab-bar-mode
  :hook (tab-bar-mode-hook . tab-bar-history-mode)
  :set
  (tab-bar-new-tab-choice . "*scratch*")
  (tab-bar-history-limit  . 25)
  (tab-bar-tab-hints      . nil)
  (tab-bar-show           . nil))
#+end_src

**** dont actually display the tabs
:PROPERTIES:
:ID:       e4cee146-f6ac-47f1-9e98-f209ae9f9bec
:END:

I want the tabs to exist as a concept, but (ironically) I don't actually want
them displayed.

#+begin_src emacs-lisp
(defadvice! inhibit-tab-display (:after tab-bar-mode make-frame)
  "Inhibit the display of tags in tab-bar-mode."
  (iter (for frame frame-list)
	(set-frame-parameter frame 'tab-bar-lines 0)))
#+end_src

*** files
:PROPERTIES:
:ID:       3ef6cbfa-7b18-470e-9ca7-73da2f1b991a
:END:

**** auto-save stuff
:PROPERTIES:
:ID:       55996779-fdde-469a-8192-033b118db8e5
:END:

Watch out for [[][auto-save-file-name-transforms]] and [[][]]. If you don't
disable backups nor change these variables, Emacs will end up littering backup
files wherever you go. These are usually among the first things new Emacsers
will change.

#+begin_src emacs-lisp
(use-package files
  :set
  (auto-save-file-name-transforms . `((".*" ,(concat XL-CACHE-DIR "auto-save-list/") t)))
  (auto-save-interval                 . 300)
  (auto-save-default                  . nil)
  (auto-save-timeout                  . 30))
#+end_src

**** confirmations
:PROPERTIES:
:ID:       b090f095-e368-47f0-a51f-47547423eaef
:END:

**** files
:PROPERTIES:
:ID:       83549b5b-33e2-48b2-aeaf-cf4734ec4040
:END:

#+begin_src emacs-lisp
(use-package files
  :set
  (confirm-nonexistent-file-or-buffer . nil)
  (backup-by-copying-when-linked      . t)
  (backup-directory-alist             . (list (cons ".*" (concat XL-CACHE-DIR "backup/"))))
  (require-final-newline              . nil)
  (delete-old-versions                . t)
  (auto-mode-case-fold                . nil)
  (confirm-kill-emacs                 . #'y-or-n-p)
  (backup-by-copying                  . t)
  (make-backup-files                  . nil)
  (kept-old-versions                  . 2)
  (kept-new-versions                  . 2)
  (trash-directory                    . (expand-file-name "Trash" "~"))
  (version-control                    . nil))
#+end_src

*** ffap
:PROPERTIES:
:ID:       acdd6407-c7db-40d7-9a7f-3a189d3c40eb
:END:

Don't ping things that look like domain names.

#+begin_src emacs-lisp
(use-package ffap
  :set
  (ffap-machine-p-known . 'reject))
#+end_src

*** tramp
:PROPERTIES:
:ID:       a3ccfafa-dc88-4aac-bbe9-fc4ae0f00997
:END:

#+begin_src emacs-lisp
(use-package tramp
  :set
  (tramp-backup-directory-alist . backup-directory-alist)
  (tramp-persistency-file-name  . (concat XL-CACHE-DIR "tramp-persistency.el"))
  (tramp-auto-save-directory    . (concat XL-CACHE-DIR "tramp-auto-save/")))
#+end_src

*** url
:PROPERTIES:
:ID:       d4c0b77e-7c6c-4ab3-bf20-fb0d335eb771
:END:

#+begin_src emacs-lisp
(use-package url
  :set
  (url-cache-directory         . (concat XL-CACHE-DIR "url/cache/"))
  (url-configuration-directory . (concat XL-CACHE-DIR "url/configuration/")))
#+end_src

*** bytecomp
:PROPERTIES:
:ID:       6b375bfb-a8c3-473c-8dbd-530e692a15ab
:END:

#+begin_src emacs-lisp
(use-package bytecomp
  :set
  (byte-compile-warnings . '(not free-vars unresolved noruntime lexical make-local))
  (byte-compile-verbose  . xl-debug-p))
#+end_src

*** compile
:PROPERTIES:
:ID:       913aa4f2-e42b-4b74-a2d4-e87b1738a5bd
:END:

#+begin_src emacs-lisp
(use-package compile
  :set
  (compilation-ask-about-save . nil)
  (compilation-scroll-output  . 'first-error)
  (compilation-always-kill    . t))
#+end_src

*** uniquify
:PROPERTIES:
:ID:       9ba2726b-3fef-4e9b-9387-a80ab09bdb7d
:END:

#+begin_src emacs-lisp
(use-package uniquify
  :set
  (uniquify-buffer-name-style . 'forward))
#+end_src

*** ansi-color
:PROPERTIES:
:ID:       5feaab76-e5c1-450c-94a6-8fdfb95ddb94
:END:

#+begin_src emacs-lisp
(use-package ansi-color
  :set
  (ansi-color-for-comint-mode . t))
#+end_src

*** image mode
:PROPERTIES:
:ID:       32e2118a-c92b-4e8d-b2db-048428462783
:END:

Non-nil means animated images loop forever, rather than playing once.

#+begin_src emacs-lisp
(use-package image-mode
  :set
  (image-animate-loop . t))
#+end_src

*** mouse
:PROPERTIES:
:ID:       d0d6de11-50fa-4ae2-ad4b-69712f3e2c54
:END:

#+begin_src emacs-lisp
(use-package mouse
  :set
  (mouse-yank-at-point . t))
#+end_src

*** gv
:PROPERTIES:
:ID:       84cc5883-a303-453e-af91-644d4544e3f9
:END:

=gv= is what contains the code for the =setf= macro.
https://emacs.stackexchange.com/questions/59314/how-can-i-make-setf-work-with-plist-get

#+begin_src emacs-lisp
(use-package gv
  :xl-config
  (gv-define-simple-setter plist-get plist-put))
#+end_src

*** nsm
:PROPERTIES:
:ID:       0ca7fc66-5312-4c69-a87d-7607292c7a2a
:END:

#+begin_src emacs-lisp
(use-package nsm
  :set
  (nsm-settings-file . (concat XL-CACHE-DIR "network-settings.data")))
#+end_src

*** bookmarks
:PROPERTIES:
:ID:       a4514b36-6e08-4a66-a595-cd40fc9acc0b
:END:

#+begin_src emacs-lisp
(use-package bookmark
  :set
  (bookmark-default-file . (concat XL-CACHE-DIR "bookmarks")))
#+end_src

* completion
:PROPERTIES:
:ID:       744ac652-aebc-4f5b-883a-4464dd7b07cd
:END:

In this headline I focus on packages that perform completion on a set of
candidates. These candidates may either be in the minibuffer or as text to
complete.

** minibuffer candidate completion
:PROPERTIES:
:ID:       ec3295f0-24b9-4b35-9de6-9498c08e4f15
:END:

Candidate completion is a must in emacs. I had tried helm but it was too slow
for my needs.

*** selectrum
:PROPERTIES:
:ID:       f8a9cdba-a4a9-42aa-a505-e88ad0b4114d
:END:

Selectrum is another completion framework. It distinguishes itself from the rest
by striving to work with the built-in emacs [[helpfn:completing-read][completing-read]] instead of replacing
it like [[https://github.com/emacs-helm/helm][helm]] and [[https://github.com/emacs-helm/helm][ivy]] do. It promises to work with the existing Emacs framework
instead of replacing it as does Ivy and Helm. :recycle:

**** selectrum
:PROPERTIES:
:ID:       6e670980-7794-4505-a285-184416a5b377
:END:

In contrast, any command defined via completing-read should work consistently with
selectrum and its provided features.

Because helm and ivy replace the existing framework, it means that whenever you
want a command be capable of using all of helm or ivy's features, you need to
define it their way. Otherwise, there's no guarantee their features will work at
least any features besides the basic choosing of a single candidate. That's a
big reason why there are helm and ivy packages (there's 216 helm packages and 42
ivy packages in [[helpfn:straight-use-package][straight-use-package]] completion): many of those packages are just ivy and
helm wrappers around existing commands.

#+begin_src emacs-lisp
(use-package selectrum
  :hook emacs-startup-hook
  :set
  (selectrum-max-window-height        . 15)
  (selectrum-num-candidates-displayed . 15)
  (selectrum-fix-minibuffer-height    . t)
  (selectrum-should-sort-p            . t)
  (selectrum-count-style              . nil)
  :config
  (xl-hook-add 'helm-mode-hook #'selectrum-helm-mode))
#+end_src

**** bindings
:PROPERTIES:
:ID:       97dccbf9-4ffd-4191-87e6-813bc99c3df7
:END:

#+begin_src emacs-lisp
(bind!
  (:map selectrum-minibuffer-map)
  (:ie "C-o" #'selectrum-submit-exact-input)
  (:ie "TAB" #'selectrum-next-candidate)
  (:ie "C-k" #'selectrum-previous-candidate)
  (:ie "C-j" #'selectrum-next-candidate)
  (:ie "C-;" #'selectrum-insert-current-candidate)
  (:ie "C-l" #'selectrum/mark-candidate)
  (:ie [backtab] #'selectrum-previous-candidate))
#+end_src

**** selectrum-prescient
:PROPERTIES:
:ID:       70668ed8-9c83-42d2-8dce-d8f7de923569
:END:

The variable names can get really long, no? :joy: Maybe it's better to have sort
of a =:nameless-set= keyword that implies a namespace the same as a package. :bulb:

#+begin_src emacs-lisp
(use-package selectrum-prescient
  :hook selectrum-mode-hook
  :set
  (selectrum-preprocess-candidates-function . #'selectrum-prescient--preprocess))
#+end_src

**** advice for disable
:PROPERTIES:
:ID:       1e39a4d2-8d4a-4413-a86e-3f92547cff14
:END:

For most functions, sorting their candidates is good. But for some, it doesn't
make sense. This is advice specifically designed to disable selectrum sorting.

#+begin_src emacs-lisp
(defun selectrum%disable-sorting (fn)
  "Disable sorting for FN."
  (let ((advice (xl-symbol-intern fn '@no-selectrum-sorting)))
    (defalias advice #'selectrum%disable-selectrum-sorting-advice)
    (xl-log-function advice)
    (advice-add fn :around advice)))

(defun selectrum%disable-selectrum-sorting-advice (orig-fn &rest args)
  (if (bound-and-true-p selectrum-mode)
      (let (selectrum-should-sort-p) (apply orig-fn args))
    (apply orig-fn args)))
#+end_src

**** use-package keyword for disabling sorting
:PROPERTIES:
:ID:       a647122b-f39f-4140-8c5f-a3e14bfe37f3
:END:

#+begin_src emacs-lisp
(use-package%dwim-insert :no-sort)

(defun use-package-handler/:no-sort (name _ fns rest state)
  "Don't sort the functions with selectrum."
  `(,@(loopy (each fn fns)
	     (collect `(selectrum%disable-sorting #',fn)))
    ,@(use-package-process-keywords name rest state)))

(defalias 'use-package-normalize/:no-sort 'use-package-normalize/:gc-pause)
#+end_src

**** lettered candidate index
:PROPERTIES:
:ID:       aae96baa-4acb-43cd-9d1d-0106abc762fd
:END:

When the variable [[helpvar:selectrum-show-indices][selectrum-show-indices]] is set to this function, selectrum
displays letters starting at =a= to [[helpvar:selectrum-num-candidates-displayed][selectrum-num-candidates-displayed]] times
down the alphabet. Fun fact, I actually contributed this feature to selectrum. :confetti-ball:

#+begin_src emacs-lisp
(defun selectrum%show-letter-index-fn (i)
  "Return letter corresponding to index."
  (format "%c " (+ 97 (% (1- i) selectrum-num-candidates-displayed))))
#+end_src

**** show indicators
:PROPERTIES:
:ID:       d0d61c43-88cd-49ed-bd1a-515405c2fa94
:END:

I want to select candidates efficiently. For me this means not having to press
=C-j= multiple times to reach a candidate that's lower in the list (imagine the
number of indices displayed is 15 and the candidate I want is the 14th one). To
address this I create this function. It displays letters next to the candidates.

#+begin_src emacs-lisp
(defun selectrum%select-candidate-by-letter ()
  "Choose selectrum candidate by letter."
  (interactive)
  (let ((selectrum-show-indices #'selectrum%show-letter-index-fn))
    (selectrum--update)
    (alet (read-key)
      (unless (= it 27)
	(selectrum-select-current-candidate (- (1+ it) 97))))))

(bind!
  (:map selectrum-minibuffer-map)
  (:ie "," #'selectrum%select-candidate-by-letter))
#+end_src

*** savehist
:PROPERTIES:
:ID:       dd4b9da7-e54d-4d62-bb70-aa8f7f4a016f
:END:

=savehist= is a built-in feature for saving the minibuffer-history to a file--the
[[helpvar:savehist][savehist]] file. Additionally, it provides the ability to save additional
variables which may or may not be related to minibuffer history. You add the
ones you want to save to [[helpvar:savehist-additional-variables][savehist-additional-variables]].

**** init
:PROPERTIES:
:ID:       54183df6-b4f5-4b01-9ddb-4054ef0583b0
:END:

#+begin_src emacs-lisp
(use-package savehist
  :idle-require custom
  :hook emacs-startup-hook
  :set
  (savehist-save-minibuffer-history . t)
  (savehist-additional-variables    . '(kill-ring search-ring regexp-search-ring))
  (savehist-autosave-interval       . nil)
  (savehist-file                    . (concat XL-CACHE-DIR "savehist")))
#+end_src

**** unpropertize kill ring
:PROPERTIES:
:ID:       da2b6c31-d251-48aa-a6ed-8f01b9fa0b8d
:END:

#+begin_src emacs-lisp
(defhook! unpropertize-kill-ring (kill-emacs-hook :append t)
  "Remove text properties from `kill-ring'."
  (set! (-map-when #'stringp #'substring-no-properties <kill-ring>)))
#+end_src

*** helm
:PROPERTIES:
:ID:       2da24557-b05d-475e-8565-6a24e23309c0
:END:

The reason I have helm installed is because (1) helm has some useful functions
that are not yet implemented for other completion frameworks and (2) selectrum
has a [[helpfn:selectrum-helm-mode][selectrum-helm-mode]] which it can use to "selectrumify" helm functions--at
least to some extent (sometimes the default action doesn't work).

It seems like I may be able to add default actions via an advice. :shrug-tone4:
We'll see. Basically, the idea would be to take reuse the code of helm commands
for presenting candidates and then make the action selection work via an advice
and, of course, add multiple actions via [[id][embark]].

Oh and in regards for using selectrum instead of helm: the main reason is simply
that helm is noticably slower with its command filtering. :turtle:

**** helm
:PROPERTIES:
:ID:       0ef7946e-629b-4a4f-8e47-7d8826d04e7e
:END:

If you're scrolling down a list of candidates, you might be suprised to
find. One "gotcha" in helm is the [[helpvar:helm-candidate-number-limit][helm-candidate-number-limit]]. By default helm
limits the amount of candidates it displays to increase performace.

Selectrum has no problem handling a large amount of candidates, particularly if
you additionally pause garbage collection for the duration of expensive
functions as I do. It handles the 16,143 candidates in [[helpfn:helm-system-packages][helm-system-packages]] on
my T400 instantaneously.

#+begin_src emacs-lisp
(use-package helm
  :set
  (helm-candidate-number-limit . nil))
#+end_src

**** helm-system-packages
:PROPERTIES:
:ID:       3e6dd0e6-0632-454d-a496-d34ecd33b60f
:END:

#+begin_src emacs-lisp
(use-package helm-system-packages
  :gc-pause helm-system-packages
  :no-sort helm-system-packages)
#+end_src

**** swiper-helm
:PROPERTIES:
:ID:       21a5285c-0447-452d-a7ef-e146b6bd60f0
:END:

#+begin_src emacs-lisp
(use-package swiper-helm
  :no-sort swiper-helm
  :gc-pause swiper-helm)
#+end_src

*** prescient
:PROPERTIES:
:ID:       4445c814-9899-4d54-affe-0cee38642690
:END:

This package.

#+begin_src emacs-lisp
(use-package prescient
  :set
  (prescient-save-file . (concat XL-CACHE-DIR "prescient-save-file"))
  :config
  (prescient-persist-mode))
#+end_src

*** orderless
:PROPERTIES:
:ID:       c70fae56-33b4-4b9d-9dd7-12c7a72de2ec
:END:

**** orderless
:PROPERTIES:
:ID:       9702810e-2013-4c41-ba12-0b55de6ceb38
:END:

#+begin_src emacs-lisp
(use-package orderless
  :commands orderless-filter orderless-highlight-matches
  :set
  (selectrum-refine-candidates-function    . #'orderless-filter)
  (selectrum-highlight-candidates-function . #'orderless-highlight-matches))
#+end_src

**** stop selectrum filtering and highlight
:PROPERTIES:
:ID:       a6720cdc-9d51-463b-9ffe-f9341c6bd967
:END:

#+begin_src emacs-lisp
(defadvice! inhibit-filtering-and-highlighting (:around selectrum-prescient-mode)
  "Don't let `selectrum-prescient' filter or highlight. "
  (let ((selectrum-refine-candidates-function selectrum-refine-candidates-function)
	(selectrum-highlight-candidates-function selectrum-highlight-candidates-function))
    (apply <orig-fn> <args>)))
#+end_src

*** consult
:PROPERTIES:
:ID:       921ce22e-59ae-4de1-bef0-66a20e320df5
:END:

=consult= is a package that's akin to =counsel=. It's a library of generally
useful functions which are written in such a way that they can be work across
all the completion frameworks.

#+begin_src emacs-lisp
(use-package consult
  :gc-pause consult-outline consult-line
  :set
  (consult-preview-key . nil)
  :config
  (bind! ([remap switch-to-buffer] #'consult-buffer)))
 #+end_src

*** consult-selectrum
:PROPERTIES:
:ID:       1620151c-77c9-4fe3-a1df-e9041ceca29d
:END:

If I don't include this, I get an.

#+begin_src emacs-lisp
(use-package consult-selectrum
  :after (consult)
  :demand t)
#+end_src

*** marginalia
:PROPERTIES:
:ID:       0ce9957b-8805-4b2b-b5cb-52dc425a3dee
:END:

Marginalia adds descriptions to various commands.

#+begin_src emacs-lisp
(use-package marginalia
  :hook emacs-startup-hook
  :set
  (marginalia-annotators . '(marginalia-annotators-heavy marginalia-annotators-light nil)))
#+end_src

*** embark
:PROPERTIES:
:ID:       9e6a5fc3-5a7f-4067-b35e-ef9fb0605fb8
:END:

This package provides a way of adding actions (think helm) to commands. The
special thing about it is a generic way to do so.

The idea of actions is to minimize code duplication. The scenario is this: you
have an existing commands that allows you to select a candidate from a prompt
and do =X= with a candidate =c= from the set of candidates =C=. You want to
select from the same prompt, but instead you want to do =Y= with =c= not =X=. So
what do you do? You're faced with rewriting the command, copying the code for
the prompt and adding the code to do =Y= (with something like =helm= you'd
rewrite the code in terms of sources and actions). That's a lot of work!
:tired-face: And it's not scalable either you'd need to do this for any other
commands you come accross in the future. This explains why there are so many
=helm= packages.

=embark= provides a way to add actions to an existing command without having to
rewrite it.

Honestly, reading it's documentation can be a bit dizzying :dizzy-face:; not
because the it's bad but because it is hard to wrap your mind around such a
package without seeing it in action.

**** embark
:PROPERTIES:
:ID:       45768441-4ec6-475b-99c6-cfb587edb81d
:END:

As I learn more about embark I will improve this documentation over time.

#+begin_src emacs-lisp
(use-package embark
  :init
  (bind!
    (:map selectrum-minibuffer-map)
    (:ie "C-a" #'embark-act)))

(defhook! pause-selectrum (embark-collect-mode-hook)
  (when (eq embark-collect--kind :live)
    (with-selected-window (active-minibuffer-window)
      (shrink-window selectrum-num-candidates-displayed)
      (setq-local selectrum-num-candidates-displayed 0))))
#+end_src

** company
:PROPERTIES:
:ID:       5579b8d8-9778-4b2d-a56f-ec43754a8d18
:END:

*** setup
:PROPERTIES:
:ID:       5e5393d9-9f58-45be-9ecc-1bc9f0316379
:END:

#+begin_src emacs-lisp
(use-package company
  :hook prog-mode-hook
  :set
  (company-tooltip-align-annotations . t)
  (company-minimum-prefix-length     . 1)
  (company-minimum-prefix-length     . 1)
  (company-dabbrev-downcase          . nil)
  (company-require-match             . 'never)
  (company-tooltip-limit             . 14)
  (company-show-numbers              . t)
  (company-idle-delay                . 0.15)
  (company-frontends                 . '(company-pseudo-tooltip-frontend)))
#+end_src

*** bindings
:PROPERTIES:
:ID:       ba170d95-7d86-4827-af6b-dc5fd4c1b7e5
:END:

#+begin_src emacs-lisp
(bind!
  (:map company-active-map)
  ([tab]     #'company-select-next)
  ([backtab] #'company-select-previous)
  ("C-k"     #'company-select-previous)
  ("C-j"     #'company-select-next))
#+end_src

*** backends
:PROPERTIES:
:ID:       bd47ec52-6428-4f37-80d2-3795f5a42d02
:END:

**** determining which modes are active
:PROPERTIES:
:ID:       b8603ca5-9a24-4684-a75b-e0c3845bfff0
:END:

[[https://stackoverflow.com/questions/1511737/how-do-you-list-the-active-minor-modes-in-emacs][listing active minor modes]]

#+begin_src emacs-lisp
(defun xl-active-minor-modes ()
  "Return active minor modes in current buffer."
  (-select (-andfn #'boundp #'symbol-value) minor-mode-list))
#+end_src

**** backends-alist
:PROPERTIES:
:ID:       dac0a998-e1b1-424f-8c40-e1bc19843153
:END:

#+begin_src emacs-lisp
(defvar company:backend-alist
  '((text-mode :derived (company-dabbrev company-ispell))
    (prog-mode :derived ((:separate company-capf company-yasnippet))))
  "An alist modes to company backends.")
#+end_src

**** initialize backends
:PROPERTIES:
:ID:       4e82e869-b144-44aa-bc19-bb58b8c5ff2a
:END:

When the user

#+begin_src emacs-lisp
(defhook! setup-company-backends (company-mode-hook)
  "Set `company-backends' for the current buffer."
  (alet (company:backends-for-mode major-mode)
    (xl-log "Set up %S backends: %S" major-mode it)
    (set (make-local-variable 'company-backends) it)))
#+end_src

**** get backends
:PROPERTIES:
:ID:       282a2c16-ae5f-4d81-acaa-8d60fb24e762
:END:

#+begin_src emacs-lisp
(cl-defun company:backends-for-mode (&optional (current-major-mode major-mode))
  "Return a list of company backends for major-mode."
  (loopy (with (active-minor-modes (xl-active-minor-modes)))
	 (list (mode type backends) company:backend-alist)
	 (expr derived-p (and (eq type :derived) (derived-mode-p mode)))
	 (expr mm-enabled-p (or (eq current-major-mode mode)
				(and (boundp mode) (symbol-value mode))))
	 (expr active-minor-mode-p (member mode active-minor-modes))
	 (cond ((and (eq type :only) (or mm-enabled-p active-minor-mode-p))
		(return backends))
	       ((or (or derived-p (and (eq type :exact) mm-enabled-p))
		    active-minor-mode-p)
		(append new-backends backends)))))
#+end_src

*** company-prescient
:PROPERTIES:
:ID:       be4bc19d-a25c-4e2d-9f12-5d2946bc9931
:END:

[[https://github.com/raxod502/prescient.el][company-prescient]] is the same as =prescient= but for =company= instead of =ivy=.

#+begin_src emacs-lisp
(use-package company-prescient
  :hook company-mode-hook)
#+end_src

*** close company on escape
:PROPERTIES:
:ID:       a880c155-b860-4880-840d-4a891b4668c4
:END:

#+begin_src emacs-lisp
(defhook! close-tooltip (xl-escape-hook)
  "Close company tooltip."
  (when (and (boundp 'company-mode) (eq company-mode t))
    (company-abort)
    t))
#+end_src

** snippets
:PROPERTIES:
:ID:       505986df-fd35-437f-930b-8ed27f78409f
:END:

*** yasnippet
:PROPERTIES:
:ID:       2c359813-e928-4a2b-982e-b722bf44fac7
:END:

#+begin_src emacs-lisp
(use-package yasnippet
  :hook (prog-mode-hook . yas-minor-mode-on)
  :set
  (yas-snippet-dirs . (list (concat XL-CACHE-DIR "snippets/")))
  (yas-verbosity . (if xl-debug-p 3 0))
  (yas-indent-line . 'auto)
  (yas-prompt-functions . '(yas-completing-prompt yas-ido-prompt))
  (yas-use-menu . nil)
  (yas-triggers-in-field . t)
  :config
  (--each yas-snippet-dirs (mkdir it t))
  (delq #'yas-dropdown-prompt yas-prompt-functions)
  (after! smartparens
    ;; tell smartparens overlays not to interfere with yasnippet keybinds
    (advice-add #'yas-expand :before #'sp-remove-active-pair-overlay)))
#+end_src

*** snippet collection
:PROPERTIES:
:ID:       57af5709-1597-4e3e-b895-77c17285f64d
:END:

#+begin_src emacs-lisp
(use-package yasnippet-snippets
  :after yasnippet
  :init
  (awhen (-first (-partial #'s-contains-p "yasnippet-snippets") load-path)
    (add-to-list 'yas-snippet-dirs it)))
#+end_src

* window management
:PROPERTIES:
:ID:       f8f186bd-a701-4bd4-a249-86ec4faff83b
:END:

** window
:PROPERTIES:
:ID:       af27cd7e-2096-4f6d-a749-63e4c38d136c
:END:

#+begin_src emacs-lisp
(use-package window
  :set
  (split-width-threshold . 160))
#+end_src

** workspaces
:PROPERTIES:
:ID:       c979c631-4098-4204-b067-82f58b5b9ebe
:END:

*** tab-bar-mode
:PROPERTIES:
:ID:       0a72fe9a-1948-4022-a300-18a4881da382
:END:

**** settings
:PROPERTIES:
:ID:       bb63f5b2-cc45-454b-a032-be248f801636
:END:

#+begin_src emacs-lisp
(use-package tab-bar-mode
  :hook (tab-bar-mode-hook . tab-bar-history-mode)
  :set
  (tab-bar-new-tab-choice . "*scratch*")
  (tab-bar-history-limit  . 25)
  (tab-bar-tab-hints      . nil)
  (tab-bar-show           . nil))
#+end_src

**** dont actually display the tabs
:PROPERTIES:
:ID:       e4cee146-f6ac-47f1-9e98-f209ae9f9bec
:END:

I want the tabs to exist as a concept, but (ironically) I don't actually want
them displayed.

#+begin_src emacs-lisp
(defadvice! inhibit-tab-display (:after tab-bar-mode make-frame)
  "Inhibit the display of tags in tab-bar-mode."
  (iter (for frame frame-list)
	(set-frame-parameter frame 'tab-bar-lines 0)))
#+end_src

*** desktop
:PROPERTIES:
:ID:       902a11fc-b9aa-4875-ba92-8d2561a12a50
:END:

=desktop= is a built-in emacs package for saving window configuration setup.

**** some settings
:PROPERTIES:
:ID:       e4c30275-db62-4e6d-890c-6199b0594fd8
:END:

#+begin_src emacs-lisp
(use-package desktop
  :set
  (desktop-save                 . t)
  (desktop-dirname              . XL-CACHE-DIR)
  (desktop-auto-save-timeout    . auto-save-timeout)
  (desktop-base-file-name       . "emacs.desktop")
  (desktop-base-lock-name       . "emacs.desktop.lock")
  (desktop-path                 . (list XL-CACHE-DIR))
  (desktop-missing-file-warning . nil))
#+end_src

**** allowing desktops to go in one directory
:PROPERTIES:
:ID:       22b0be3a-ef36-47d4-8684-602f3a8c8462
:END:

These functions are all based on the =desktop+= functions. The main thing it
does is provide a directory where desktop files can be placed. This should
really have been done by =desktop.el= but oh well.

***** base directory
:PROPERTIES:
:ID:       e1ce2616-2280-435d-85c4-8d71c30c6a75
:END:

#+begin_src emacs-lisp
(defvar desktop:base-dir (concat XL-CACHE-DIR "desktops/")
  "Directory where desktops should go.")
#+end_src

***** generate the base directory
:PROPERTIES:
:ID:       fa173f38-2888-465a-8de4-282233322363
:END:

#+begin_src emacs-lisp
(defun desktop:dirname (name)
  "Return the path where desktop named NAME should go."
  (require 'f)
  (f-join desktop:base-dir name))
#+end_src

***** ensure the base directory
:PROPERTIES:
:ID:       3662ceaa-aed9-4dbc-bea9-7e1878237c87
:END:

#+begin_src emacs-lisp
(defhook! ensure-desktop-directory (desktop-mode-hook)
  "Make `desktop:base-dir' if it does not exist."
  (mkdir desktop:base-dir t))
#+end_src

***** desktop names
:PROPERTIES:
:ID:       5286a22f-dc93-4e32-8a35-3bfbdfda8668
:END:

#+begin_src emacs-lisp
(defun desktop:list ()
  "Return a list of the names of all desktops."
  (-difference (directory-files desktop:base-dir)
	       (list ".." ".")))
#+end_src

***** create a desktop
:PROPERTIES:
:ID:       331367bb-a1eb-414f-89ef-386ba6fc1e60
:END:

#+begin_src emacs-lisp
(defun desktop:create-desktop (name)
  "Create a new desktop named NAME."
  (let ((desktop-dirname (desktop:dirname name)))
    (desktop-kill)
    (make-directory desktop-dirname 'parents)
    (desktop-save desktop-dirname)))
#+end_src

***** load an existing desktop
:PROPERTIES:
:ID:       691dd9bf-b207-4885-9f7c-b8791d972dc1
:END:

#+begin_src emacs-lisp
(defun desktop:load-desktop (name)
  (desktop-change-dir (desktop:dirname name)))
#+end_src

**** create desktop in new tab
:PROPERTIES:
:ID:       4bbb0f3a-bc51-4552-b91f-8404ab19cdd8
:END:

This is an integration with desktop and tab mode.

#+begin_src emacs-lisp
(defun desktop/create-desktop-in-new-tab (name)
  "Create desktop named NAME in new tab.
The tab's new name is the same as the desktop name."
  (interactive
   (list (completing-read "Create desktop:" (desktop:list))))
  (tab-bar-new-tab)
  (tab-bar-rename-tab name)
  (desktop:create-desktop name))
#+end_src

**** load desktop in a new tab
:PROPERTIES:
:ID:       391c0817-bb2f-4334-b320-f039ab23cfb7
:END:

#+begin_src emacs-lisp
(defun desktop/load-desktop-in-new-tab (name)
  "Create desktop named NAME in new tab.
The tab's new name is the same as the desktop name."
  (interactive
   (list (completing-read "Load desktop: " (desktop:list))))
  (tab-bar-new-tab)
  (tab-bar-rename-tab name)
  (desktop:load-desktop name))
#+end_src

**** desktop restore functions
:PROPERTIES:
:ID:       0f82a1dc-d28e-4875-a622-e6116c0d3843
:END:

***** helpful-buffers
:PROPERTIES:
:ID:       f7d3a8ce-7115-47d6-b0ac-2d078741a49a
:END:

#+begin_src emacs-lisp
(defun desktop:restore-helpful-buffer ()
  "Restore helpful buffer.")
#+end_src

*** workgroups2
:PROPERTIES:
:ID:       b5452102-a8fb-409f-8c36-35d404b5a5a6
:END:

There is a need to save buffers and window configurations in their own groups.
Often we'll have a group of buffers we've setup to work on a project or task and
suddenly, in the middle of that task we'll want to work on another task. It's
inconvenient to get rid of the window configuration we've set up just to have to
come back to it and set it up again. This is what workspaces, also called
workgroups, are for. You can save the window configuration you're using and
switch to a new one.

Workgroup provides a. One notable advantage of workgroups is that it does not
use emacs's built-in serialization of window configs. Usually, it is better to
use something that's built-in. However, emacs's serialization has the drawback
that it's not a lisp object; implying that it is not.

**** workgroups2
:PROPERTIES:
:ID:       890c8e5b-524d-44b6-b90e-c830436b9da8
:END:

#+begin_src emacs-lisp
(use-package workgroups2
  :commands wg-switch-workgroup
  :ignore wg-change-modeline
  :silence wg-create-workgroup wg-switch-workgroup
  :set
  (wg-emacs-exit-save-behavior           . 'save)
  (wg-workgroups-mode-exit-save-behavior . 'save)
  (wg-flag-modified                      . nil)
  (wg-mode-line-display-on               . nil)
  (wg-load-last-workgroup                . nil)
  (wg-open-this-wg                       . nil)
  (wg-control-frames                     . nil)
  (wg-session-load-on-start              . nil)
  (wg-flag-modified                      . nil)
  (wg-session-file                       . (concat XL-CACHE-DIR "wg-session")))
#+end_src

** zoom-window
:PROPERTIES:
:ID:       d506fde5-d1bc-4807-a1d0-a8ed5c33def2
:END:

This package provides a command that temporarily makes a window occupy full
screen. And then reverts the window configuration to what it was again
afterwards.

#+begin_src emacs-lisp
(use-package zoom-window
  :commands zoom-window)
#+end_src

** exwm
:PROPERTIES:
:ID:       ff30cdb0-5c9a-454d-9a6c-dbc8e3fa7cfe
:END:

[[https://github.com/ch11ng/exwm][EXWM]] (Emacs X-Window Manager) is a full-featured window manager in Emacs.  There
are benefits and drawbacks to making emacs your window manager. One benefit is
that you get a super consistent window management experience. One drawback is
that if Emacs hangs or crashes you need to restart your computer.

*** init
:PROPERTIES:
:ID:       7b83cab0-d599-46c4-b20c-19ff33345ae3
:END:

#+begin_src emacs-lisp
(use-package exwm
  :os linux
  :before-call browse-url)
#+end_src

*** trigger exwm on =browse-url=
:PROPERTIES:
:ID:       581b8529-00a0-4935-9363-60dba9dbe5f4
:END:

=exwm= provides an option [[helpvar:exwm-replace][exwm-replace]] to deal with the case of an existing
window manager when exwm is initializing itself. There are three
ways. You could replace it with exwm without asking, ask whether to
replace it, or abort the initialization of exwm.

#+begin_src emacs-lisp
(defadvice! init-exwm-maybe (:before browse-url)
  "Try to initialize exwm.
If it's not possible, abort initialization gracefully."
  (require 'exwm)
  ;; Try to enable exwm.
  (let ((exwm-replace nil))
    (if (ignore-errors (exwm-init))
	;; Enable the clipboard.
	(progn (require 'exwm-systemtray)
	       (exwm-systemtray-enable))
      (xl-log "Another window manager is present (or something went wrong)."))))
#+end_src

*** exwm-evil-firefox
:PROPERTIES:
:ID:       e5463b7a-9727-43b1-aa20-831a3617308f
:END:

This package lets you use exwm to control firefox and give it evil bindings. You
can tell exwm to send "fake" keys to firefox corresponding to the key you've
pressed. The only thing I find missing here is a way to quickly select links in
an. One caveat is that mouse clicks only work in insert mode.

#+begin_src emacs-lisp
(use-package exwm-firefox-evil
  :hook (exwm-manage-finished-hook . exwm-firefox-evil-activate-if-firefox)
  :before-call browse-url-firefox)
#+end_src

*** exwm-float
:PROPERTIES:
:ID:       aa59c567-56b6-4ef7-b63c-cb8172e38965
:END:

This package provides a minor mode for configuring floating windows. I still
need to figure out the proper way to lazy load it.

#+begin_src emacs-lisp
(use-package exwm-float
  :set
  (exwm-float-modify-amount . '(:move-slow 20 :move-fast 100 :resize 50))
  (exwm-float-border        . '(:stationary ("navy" . 1) :moving ("maroon" . 2)))
  :config
  (exwm-float-setup)
  (exwm-input-set-key (kbd "C-c M-f") #'exwm-float-mode))
#+end_src

*** org capture from an exwm buffer
:PROPERTIES:
:ID:       5428bdc1-c075-4387-b3ab-080d372c478f
:END:

A common dream among many Org users is to integrate [[info:org#Capture][org-capture]] into their browser.
Indeed, the browser by nature would be a place you'd want to capture from a lot.
However, since graphical browsers are not in emacs the main way to do this was
via a hacky and difficult to set up [[https://orgmode.org/worg/org-contrib/org-protocol.html][org-protocol]].

https://www.reddit.com/r/emacs/comments/f6zzux/capturing_website_url_with_orgcapture_and_exwm/

**** exwm title
:PROPERTIES:
:ID:       ce78d409-e635-4d94-b20e-38c2034ab5e8
:END:

#+begin_src emacs-lisp
(defun exwm::title-info (title)
  "Return the webpage and the program."
  (-let [(_ webpage program) (s-match "\\([^z-a]+\\) - \\([^z-a]+\\)\\'" title)]
    (list webpage program)))
#+end_src

**** download webpage
:PROPERTIES:
:ID:       3798402c-cd8b-43e2-aec5-f54736aafdd4
:END:

#+begin_src emacs-lisp
(defun xl-download-webpage (url)
  "Download webpage at url to webpage folder."
  (call-process "weasyprint" nil nil nil url))
#+end_src

**** replacement for fake id
:PROPERTIES:
:ID:       4f0436c4-bc37-49b0-a8a3-894e212d4d13
:END:

#+begin_src emacs-lisp
(defun exwm-input::fake-key-to-id (event id)
  "Fake a key event equivalent to Emacs event EVENT and send it
 to program with x window ID."
  (let* ((keysym (xcb:keysyms:event->keysym exwm--connection event))
         keycode)
    (when (= 0 (car keysym))
      (user-error "[EXWM] Invalid key: %s" (single-key-description event)))
    (setq keycode (xcb:keysyms:keysym->keycode exwm--connection
					       (car keysym)))
    (when (/= 0 keycode)
      (dolist (class '(xcb:KeyPress xcb:KeyRelease))
        (xcb:+request exwm--connection
	    (make-instance
	     'xcb:SendEvent
	     :propagate 0 :destination id
	     :event-mask xcb:EventMask:NoEvent
	     :event
	     (xcb:marshal
	      (make-instance
	       class
	       :detail keycode :time xcb:Time:CurrentTime
	       :root exwm--root :event id :child 0 :root-x 0 :root-y 0
	       :event-x 0 :event-y 0 :state (cdr keysym) :same-screen 0)
	      exwm--connection)))))
    (xcb:flush exwm--connection)))
#+end_src

**** url from firefox
:PROPERTIES:
:ID:       f407cc8c-0bb9-47fe-adeb-4e9d27b5c5b7
:END:

Emacs simulates a keypress to firefox--specifically the keypresses to select the
current url and to add it to the kill ring.

#+begin_src emacs-lisp
(defun exwm::firefox-url ()
  "Save the current firefox url to kill ring."
  ;; We get the xwindow id of the buffer named Firefox
  (let ((fid (exwm--buffer->id (current-buffer))))
    ;; Send c-l to select url
    (exwm-input::fake-key-to-id 'C-l fid)
    ;; We sleep to avoid race conditions.
    (sleep-for 0 300)
    ;; Copy url to kill ring (note: this is not affected by simulation keys)
    (exwm-input::fake-key-to-id 'C-c fid)
    (sleep-for 0 300)
    ;; try to set the state back
    (exwm-input::fake-key-to-id 'escape fid)
    (current-kill 0)))
#+end_src

**** url from qutebrowser
:PROPERTIES:
:ID:       822cbb61-60b4-445e-9756-4bf797500375
:END:

#+begin_src emacs-lisp
(defun exwm::qutebrowser-url ()
  (interactive)
  (let ((fid (exwm--buffer->id (current-buffer))))
    (sleep-for 0 300)
    ;; if in insert state exit it.
    (exwm-input::fake-key-to-id 'escape fid)
    (sleep-for 0 300)
    (exwm-input::fake-key-to-id 'y fid)
    (sleep-for 0 300)
    (exwm-input::fake-key-to-id 'y fid)
    (sleep-for 0 300)
    (aprog1 (current-kill 0)
      (xl-log "Copied %S to the kill ring." it))))
#+end_src

*** appropriate name for exwm buffers
:PROPERTIES:
:ID: b9712cdc-2cf9-482f-8f62-b2e4f56b9c97
:END:

By default each exwm buffer is named =*EXWM*=. We want them to have
a more descriptive name.

#+begin_src emacs-lisp
(defhook! rename-buffer-to-title (exwm-update-title-hook)
  "Rename buffer to title."
  (exwm-workspace-rename-buffer exwm-title))
#+end_src

*** char mode
:PROPERTIES:
:ID: 790c7f6e-6f66-4074-b51a-56b491bcde99
:END:

=EXWM= has two modes, =line-mode= and =char-mode=. It's best for Emacs and Next to
start with =char-mode= because they both have keys that are important for their
use (like =M-x=) which conflict with Emacs (the instance that's managing the
windows).

**** list of applications
:PROPERTIES:
:ID:       d1bf0601-a995-48f7-ab80-86755ba9269a
:END:

#+begin_src emacs-lisp
(defvar exwm:char-mode-apps (list "emacs" "next" "nyxt" "qutebrowser")
  "List of applications to exwm should start in char-mode.")
#+end_src

**** to start in char mode
:PROPERTIES:
:ID: 790c7f6e-6f66-4074-b51a-56b491bcde99
:END:

#+begin_src emacs-lisp
(defhook! start-in-char-mode (exwm-manage-finish-hook)
  "Start a program in char-mode if it's in `exwm:char-mode-apps'."
  (when (--any-p (string-prefix-p it exwm-instance-name) exwm:char-mode-apps)
    (exwm-input-release-keyboard (exwm--buffer->id (window-buffer)))))
#+end_src

*** exwm-edit
:PROPERTIES:
:ID: 1a167827-b791-4a69-a90e-c2d30bd83abb
:END:

The dream is to do all text editing in Emacs. This package is a big step towards
achieving that dream. =exwm-edit= allows the user to edit text fields in
external packages with an emacs buffer. It acts a lot like =org-edit-src-code=:
it copies any text in the text field to a buffer, you edit the buffer, then
press a binding to insert the buffer text into the text field. It goes without
saying that when the text is in an emacs buffer, you can use the full-force of
Emacs's text editing capabilities on it.

Concerning the loading of exwm-edit. Ideally, I should load it after
certain applications where I'd use it need to be loaded.

#+begin_src emacs-lisp
(use-package exwm-edit
  :commands exwm-edit
  :init
  (after! exwm
    (funcall (get 'exwm-input-global-keys 'custom-set)
	     'exwm-input-global-keys
	     `((,(kbd "C-'") . exwm-edit)))))
#+end_src

*** keybindings
:PROPERTIES:
:ID:       8f8e7106-be2e-4c4f-8e4b-d236f805725b
:END:

#+begin_src emacs-lisp
(after! exwm
  (funcall (get 'exwm-input-global-keys 'custom-set)
           'exwm-input-global-keys
           `((,(kbd "s-R") . exwm-reset)
             (,(kbd "s-x") . exwm-input-toggle-keyboard)
             (,(kbd "s-h") . windmove-left)
             (,(kbd "s-j") . windmove-down)
             (,(kbd "s-k") . windmove-up)
             (,(kbd "s-l") . windmove-right)
             (,(kbd "s-t") . transpose-frame)
             (,(kbd "s-D") . kill-this-buffer)
             (,(kbd "s-b") . switch-to-buffer)
             (,(kbd "s-f") . find-file)
             (,(kbd "s-O") . exwm-layout-toggle-fullscreen)
             (,(kbd "s-p") . previous-buffer)
             (,(kbd "s-n") . next-buffer)
             (,(kbd "s-q") . xl/open-qutebrowser)
             (,(kbd "s-e") . xl/open-emacs-instance))))
#+end_src

** split-right-and-focus
:PROPERTIES:
:ID: 6cb60d94-723b-48e5-850a-3483e78f6647
:END:

#+begin_src emacs-lisp
(defun xl/window-split-right-and-focus ()
  "Split window right and select the window created with the split."
  (interactive)
  (select-window (split-window-right)))
#+end_src

** split-below-and-focus
:PROPERTIES:
:ID: d6a4a81f-007d-4b7e-97a3-e0bba3ff97a4
:END:

#+begin_src emacs-lisp
(defun xl/window-split-below-and-focus ()
  "Split window below and select the window created with the split."
  (interactive)
  (select-window (split-window-below)))
#+end_src

* text editing
:PROPERTIES:
:ID:       40fb1b29-b772-456f-aac6-cf4a3b5cde3f
:END:

** undo-tree
:PROPERTIES:
:ID:       e54f42d0-f146-4816-8226-8798d0746533
:END:

#+begin_src emacs-lisp
(use-package undo-tree
  :config
  (after! evil (setq evil-undo-system 'undo-tree)))
#+end_src

** replace
:PROPERTIES:
:ID:       be049cb6-40d2-43ff-884d-c0b1ea53b6b8
:END:

#+begin_src emacs-lisp
(use-package replace
  :rule ("bottom" "org-description" :newname "\\*Occur\\*"))
#+end_src

** separedit
:PROPERTIES:
:ID:       07021099-6cea-4016-929b-d9310ea305f8
:END:

#+begin_src emacs-lisp
(use-package separedit :commands separedit)
#+end_src

** files
:PROPERTIES:
:ID:       9877ecf6-174b-4068-83b7-a9910008bd13
:END:

*** version control
:PROPERTIES:
:ID:       891975f2-092b-4eb3-9bb3-f158127dead3
:END:

**** git-auto-commit-mode
:PROPERTIES:
:ID:       00a518e9-56ae-4c0b-b2cd-518fb4c5d201
:END:

To avoid losing information. You should commit often in git--like every 10
seconds or so. Obviously doing this manually on the command line (or even on
[[id:d6088ed3-417a-44e8-822b-ce4743f497d0][magit]]) every time is a pain. This package commits your changes every time
you save your file--which for me is all the time because I use [[id:bd455e73-4035-49b9-bbdf-3d59d4906c97][super-save]].

***** settings
:PROPERTIES:
:ID:       8a46cee4-624c-4440-8b99-c6b34d356a6b
:END:

#+begin_src emacs-lisp
(use-package git-auto-commit-mode
  :commands git-auto-commit-mode
  :set
  (gac-automatically-push-p   . nil)
  (gac-ask-for-summary-p      . nil)
  (gac-default-message        . #'gac%commit-message)
  (gac-commit-additional-flag . "-S")
  (gac-silent-message-p       . t))
#+end_src

***** commit message
:PROPERTIES:
:ID:       3f0297a0-5929-4217-a109-545a2a010473
:END:

Committing often as I recommend will inevitably result with commits that are
many bits and pieces of a change. The idea is to then squash together all
related commits for the "polished" result. With this function I create "smart"
commit messages that take advantage of the org headline structure. This makes it
easy to go back and group commits which are related. Note that this function
fails when you have a change that spans across multiple headlines (such as the
replacement of a name throughout a document). This is something I plan to
address later.

#+begin_src emacs-lisp
(defun gac%commit-message (file)
  "Return the commit message for changes to FILE."
  (format "Update %s" (f-base file)))
#+end_src

**** magit
:PROPERTIES:
:ID:       d6088ed3-417a-44e8-822b-ce4743f497d0
:END:

***** transient
:PROPERTIES:
:ID:       1805bd2d-b190-47b6-9c7c-2a200f9cf6a1
:END:

#+begin_src emacs-lisp
(use-package transient
  :set
  (transient-default-level . 5)
  (transient-levels-file . (concat XL-CACHE-DIR "transient/levels"))
  (transient-values-file . (concat XL-CACHE-DIR "transient/values"))
  (transient-history-file . (concat XL-CACHE-DIR "transient/history")))
#+end_src

***** magit
:PROPERTIES:
:ID:       820ce76e-53e4-4be8-9cad-3bf35efeefd7
:END:

#+begin_src emacs-lisp
(use-package magit
  :idle-require f s with-editor git-commit package eieio lv transient
  :gc-pause magit-status magit-commit
  :rule ("bottom" "magit" :newname "magit: ")
  :hook (magit-popup-mode-hook . hide-mode-line-hook)
  :set
  (magit-completing-read-function . #'completing-read)
  (magit-diff-refine-hunk . t)
  (magit-auto-revert-mode . t))
#+end_src

***** quitting
:PROPERTIES:
:ID:       8014eb34-416a-4c79-b21a-7960f77da75e
:END:

#+begin_src emacs-lisp
(defun magit/quit ()
  "Clean up magit buffers after quitting `magit-status'."
  (interactive)
  (let ((buffers (magit-mode-get-buffers)))
    (magit-restore-window-configuration)
    (mapc #'kill-buffer buffers)))
#+end_src

***** evil-magit
:PROPERTIES:
:ID:       a86e7a69-4e0a-41fd-aca7-66e514332e7f
:END:

#+begin_src emacs-lisp
(use-package evil-magit
  :silence evil-magit-init
  :before-call magit-status
  :xl-config
  (evil-magit-init)
  :set
  (evil-magit-state . 'normal))
#+end_src

**** git-gutter+
:PROPERTIES:
:ID:       77fb81e3-29c0-4eb3-a1ff-e1bdbfa41bf2
:END:

=git-gutter= indicates which parts of a file has been modified.

#+begin_src emacs-lisp
(use-package git-gutter+
  :alias (git-commit-mode-font-lock-keywords . ignore))
#+end_src

**** git-commit
:PROPERTIES:
:ID:       2edbbef6-dec3-4af7-a445-8a2c7b1c0397
:END:

#+begin_src emacs-lisp
(use-package git-commit
  :initial-state insert)
#+end_src

*** backup
:PROPERTIES:
:ID:       f55fe748-209b-4450-a948-b0a7f8861dcf
:END:

#+begin_src emacs-lisp
(setq make-backup-files t)
(setq delete-by-moving-to-trash t)
(setq trash-directory (expand-file-name "~/Trash"))
#+end_src

*** super-save
:PROPERTIES:
:ID:       684e788c-6db9-4e6e-826b-d4871c0a3f90
:END:

The default auto-saving feature in emacs saves after a certain number of
characters are typed (see [[helpvar:auto-save-interval][auto-save-interval]]). The problem is that if you're in
the middle of typing and you've just hit the number of characters that trigger a
save, you could experience a lag, particularly if you are dealing with a large
file being saved. Instead of doing this, [[https://github.com/bbatsov/super-save][super-save]] saves buffers during idle
time and after certain commands like [[helpfn:switch-to-buffer][switch-to-buffer]] (see [[helpvar:super-save-triggers][super-save-triggers]]).
Note that this is the same strategy employed by [[id:c550f82a-9608-47e6-972b-eca460015e3c][idle-require]] to load packages.
Saving files like this reduces the likelihood of user delays.

#+begin_src emacs-lisp
(use-package super-save
  :before-call find-file
  :set
  (super-save-auto-save-when-idle . t)
  (super-save-idle-duration       . 5))
#+end_src

**** vc-hook
:PROPERTIES:
:ID:       a8dcb1f6-05a0-46cb-95b5-1d0cd0ad4467
:END:

#+begin_src emacs-lisp
(use-package vc-hooks
  :set
  (vc-follow-symlinks . t)
  (vc-follow-link     . t))
#+end_src

** origami
:PROPERTIES:
:ID:       ac2cc043-331f-435b-b903-39681b84fefe
:END:

=origami= is, as its name suggests, a package that handles folding.

#+begin_src emacs-lisp
(use-package origami
  :hook prog-mode-hook)
#+end_src

** edit-indirect
:PROPERTIES:
:ID:       786b11a6-561b-4793-9c6c-f7630aba3774
:END:

=edit-indirect= is a package that provides a means to edit text in an indirect
buffer. It's the same concept as org-src buffers but is not tied to org-mode.

*** init
:PROPERTIES:
:ID:       d08adcae-ab17-41f1-94c9-1d9a8cb385d7
:END:

#+begin_src emacs-lisp
(use-package edit-indirect :commands edit-indirect)
#+end_src

*** editing org descriptions
:PROPERTIES:
:ID:       bdabe0b9-4116-423b-9fc0-049651bed58a
:END:

This headline contains customizations and extensions to =edit-indirect= so that I
can use it to edit org descriptions in the same way that we edit source blocks.

There are two cases when editing a description. There's the case of an existing
description and there's the case of a new one.

**** init

#+begin_src emacs-lisp
(use-package org-edit-paragraph
  :rule ("bottom" "org description" :newname "\\*Org Desc - .+")
  :xl-config
  (after! (evil evil-surround)
    (xl-hook-add 'org-edit-paragraph:mode-hook #'evil-surround-mode)))
#+end_src

**** description bounds
:PROPERTIES:
:ID:       74367212-cbd0-4871-94d5-24980e997bd7
:END:

#+begin_src emacs-lisp
(defun org-edit-paragraph:bounds ()
  "Return the bounds of description at headline.
If there is no existing description return nil."
  (interactive)
  (let* ((parse-tree (org-ml-parse-subtree-at (point)))
	 (elements '(headline section property-drawer src-block paragraph))
	 (nodes (->> (org-element-map parse-tree elements #'identity)
		     (-split-when (fn! (eq (org-element-type <elt>) 'headline)))
		     (car))))
    (aif (car (-split-when (fn! (not (eq (org-element-type <elt>) 'paragraph))) nodes))
	(cons (org-element-property :begin (-first-item it))
	      (org-element-property :end (-last-item it)))
      (-let* ((section (-first (fn! (eq (org-element-type <elt>) 'section)) nodes))
	      ((property-drawer others) (org-element-contents section)))
	(alet (org-element-property :end (if others property-drawer section))
	  (cons it it))))))
#+end_src

**** default post blanks
:PROPERTIES:
:ID:       117478bf-3759-4a00-b738-9b1aad99ed54
:END:

It is my preference to have one blank line after a description--or any org item
for that matter. I just find it much more readable and less cluttered.

#+begin_src emacs-lisp
(defvar org-edit-paragraph:default-post-blanks 1
  "Number of blank lines that should follow a description.")
#+end_src

**** hooks
:PROPERTIES:
:ID:       6ab3a2cc-17aa-4166-aa3f-8627afe40c1a
:END:

=edit-indirect= has hooks for whenever you want to do a quick thing.

***** goto last non-white
:PROPERTIES:
:ID:       f9afdc3d-ceea-4e9e-a986-9f6bb7e860f6
:END:

Most of the time I will want to add to the end of a description. Therefore, I
want the cursor to start at the last non-whitespace character of the
description.

#+begin_src emacs-lisp
(defun org-edit-paragraph:goto-last-non-white ()
  (goto-char (point-max))
  (skip-chars-backward "\n\s"))
#+end_src

***** add newlines in the beginning
:PROPERTIES:
:ID:       46917f50-8e0b-4c29-8f9b-1aab7e0e9550
:END:

In the case where there was no existing description, we need to add newlines to
the description buffer so that if we end up committing a change the description
will be placed properly in relation to what's below it. This hook is designed to
make sure this happens.

#+begin_src emacs-lisp
(defun org-edit-paragraph:add-newlines ()
  "Add newlines."
  (save-excursion
    (--dotimes (1+ org-edit-paragraph:default-post-blanks)
      (insert "\n"))))
#+end_src

***** maybe remove newline
:PROPERTIES:
:ID:       cfa12a0f-fd23-4684-bb10-b86b2e4e5c58
:END:

When you open a description buffer and close it again, you'd expect the source
buffer to stay the same--and you should expect this. Since we add newlines to
the description buffer when there's no existing description, we could
inadvertently edit the source buffer in this case. So this hook is to remove any
newlines added in the case that nothing was changed.

#+begin_src emacs-lisp
(defun org-edit-paragraph:maybe-remove-newline ()
  "Remove newline if that's all there is."
  (when (and (seq-every-p (fn! (= 10 <>)) (buffer-string))
	     (= (1+ org-edit-paragraph:default-post-blanks) (length (buffer-string))))
    (erase-buffer)))
#+end_src

**** define a minor mode for editing descriptions
:PROPERTIES:
:ID:       8775acdc-0389-40af-a5f4-e74c78144944
:END:

The way I've set things up editing descriptions is it's own "thing". I'm going
to be adding hooks and maybe even binding keys with editing descriptions in mind.
Therefore, I think it's worthy to give it it's own mode.

#+begin_src emacs-lisp
(define-minor-mode org-edit-paragraph:mode
  "Mode for editing org descriptions.")
#+end_src

**** requirements for editing descriptions
:PROPERTIES:
:ID:       9a789e79-84b8-4415-b152-e11fca786587
:END:

The edit description function requires =org-ml= and =edit-indirect=. I don't
know if this is the best way to declare these dependencies. It certaintly is
efficient.

#+begin_src emacs-lisp
(xl-load-before-call 'org-ml #'org/dwim-edit-description)
(xl-load-before-call 'edit-indirect #'org/dwim-edit-description)
#+end_src

**** edit description
:PROPERTIES:
:ID:       3a7da5c8-f445-4592-b0c0-7fbff3be912e
:END:

It is uncough to edit the text of the buffer when we're not commit it--even
worse to have to edit it again afterwards if we don't end up committing
anything. No, instead we should work with the edit indirect buffer.

We need to make sure that we respect [[helpvar:edit-indirect-after-creation-hook][edit-indirect-after-creation-hook]] by doing
our description management stuff before anything is done in that hook. It may be
worth it to consider creating a hook specifically for org descriptions.

#+begin_src emacs-lisp
(defun org/dwim-edit-description ()
  (interactive)
  (-let* (((beg . end) (org-edit-paragraph:bounds))
	  (was-empty-p (= beg end)))
    (unless beg (user-error "No description at headline."))
    (let ((edit-indirect-after-creation-hook edit-indirect-after-creation-hook)
	  (headline (org-get-heading t t t t)))
      (when was-empty-p
	(add-hook 'edit-indirect-after-creation-hook #'org-edit-paragraph:add-newlines 0))
      (add-hook 'edit-indirect-after-creation-hook #'org-edit-paragraph:goto-last-non-white 0)
      (with-current-buffer (edit-indirect-region beg end)
	(rename-buffer (format "*Org Desc - %s*" headline) t)
	(org-edit-paragraph:mode 1)
	(add-hook 'edit-indirect-before-commit-hook
		  #'org-edit-paragraph:maybe-remove-newline nil t)
	(select-window (display-buffer (buffer-name)))))))
#+end_src

**** evil support
:PROPERTIES:
:ID:       f270092b-19ca-40ba-87aa-77b3d314c9a6
:END:

When I open a buffer for editing a description it is very likely that I'll end
up appending more commentary to the existing description. I think it will save
me more time making that common case easier than the cost for the few situations
where I don't do this.

#+begin_src emacs-lisp
(after! evil
  (xl-hook-add 'org-edit-paragraph:mode-hook #'evil-insert-state))
#+end_src

**** custom hooks
:PROPERTIES:
:ID:       240acf8a-621e-4e44-9c11-250b70a0e3dc
:END:

#+begin_src emacs-lisp
(dolist (mode (list #'auto-capitalize-mode
		    #'aggressive-fill-paragraph-mode
		    #'org-link-minor-mode))
  (xl-hook-add 'org-edit-paragraph:mode-hook mode))
#+end_src

*** bindings inside edit-indirect
:PROPERTIES:
:ID: 42992d1e-5d65-4570-ba96-02b3be31b97b
:END:

I want quick, convenient bindings I can use to abort or commit (which is
=edit-indirect= lingo for writing the contents of the buffer back into its source
file, see [[helpfn:edit-indirect-commit][edit-indirect-commit]].

#+begin_src emacs-lisp
(bind-localleader!
 (:map edit-indirect-mode-map)
 ("," #'edit-indirect-commit)
 ("c" #'edit-indirect-commit)
 ("a" #'edit-indirect-abort))
#+end_src

** expand-region
:PROPERTIES:
:ID:       7e873fba-33ea-4720-ad79-bd8d557cc4b3
:END:

[[https://github.com/magnars/expand-region.el][expand-region]] allows me to toggle a key ("v" in my case) to select progressively
larger text objects. It's saves me keystrokes.

*** init
:PROPERTIES:
:ID:       41a1cebc-8da8-4e5c-8258-2ce440f1af50
:END:

#+begin_src emacs-lisp
(use-package expand-region
  :commands er/expand-region er/contract-region er/mark-symbol)
#+end_src

*** quit expand region
:PROPERTIES:
:ID:       639824e1-0dcf-46bc-98b4-c70b9c7cb2a6
:END:

#+begin_src emacs-lisp
(defadvice! quit-expand-region (:before evil-escape)
  "Properly abort an expand-region region."
  (when (memq last-command '(er/expand-region er/contract-region))
    (er/contract-region 0)))
#+end_src

*** expand-region
:PROPERTIES:
:ID: 417c9c53-a776-4779-9afc-1eaa35a145c6
:END:

#+begin_src emacs-lisp
(bind!
  (:v "V" #'er/contract-region)
  (:v "v" #'er/expand-region))
#+end_src

** writing
:PROPERTIES:
:ID:       98b567f1-00ad-4c99-aace-0a12f4d1b353
:END:

This headline is for packages and configuration related to writing such as spell
and grammer checking.

*** plural
:PROPERTIES:
:ID:       bf2ed9b7-144c-4d4b-92ae-74c93dfc6db5
:END:

This package determines whether a noun is plural and provides a function to
convert a singular noun to a plural one. For example ~(plural-pluralize
"goose")~ returns ~"geese"~.

My intended use for this package is to help automate prompts, docstrings or the
like that concern N number of things, where N could be 1 or more things.

#+begin_src emacs-lisp
(use-package plural
  :commands plural-make-plural
  :xl-config
  (push '("\\`is\\'" . "are") plural-knowledge)
  (push '("\\`thas\\'" . "those") plural-knowledge)
  (push '("\\`this\\'" . "these") plural-knowledge))
#+end_src

*** auto-capitalize
:PROPERTIES:
:ID:       4ddfacc1-a25e-466e-ab6b-2a5ec306f3be
:END:

[[https://github.com/emacsmirror/auto-capitalize][auto-capitalize]] automatically capitalizes the first word of a sentence for me.
It will also upcase any word I add to [[helpvar:auto-capitalize-words][auto-capitalize-words]].

#+begin_src emacs-lisp
(use-package auto-capitalize
  :hook text-mode-hook
  :set
  (auto-capitalize-words . '("I" "English" "Emacs")))
#+end_src

*** spell-number
:PROPERTIES:
:ID:       8bf270a6-6003-4430-bb03-0b665d5a162f
:END:

#+begin_src emacs-lisp
(use-package spell-number
  :set
  (spelln-language          . 'english-us)
  (spelln-country           . 'united-states)
  (spelln-period-character  . ?,)
  (spelln-decimal-character . ?.))
#+end_src

*** paragraph
:PROPERTIES:
:ID:       aeb973cb-41ad-4891-94b2-d0ea5c1baa33
:END:

#+begin_src emacs-lisp
(use-package paragraph
  :set
  (sentence-end-double-space . nil))
#+end_src

** xr
:PROPERTIES:
:ID: 75c56163-9ce1-4726-969a-350fcc56395f
:END:

This package is the inverse of =rx=. It takes a regular expression and returns the
=rx= representation.

#+begin_src emacs-lisp
(use-package xr :commands xr)
#+end_src

** spacing & indentation
:PROPERTIES:
:ID:       ae5416cd-ffa2-456a-9c56-afcfc65a33f8
:END:

*** aggressive-fill-paragraph
:PROPERTIES:
:ID: 4f57fd49-b466-4eea-b91a-2cc8f0b07297
:END:

Emacs is very minimal by default. Most reading this will likely be used to.

#+begin_src emacs-lisp
(use-package aggressive-fill-paragraph)
#+end_src

*** aggressive-indent
:PROPERTIES:
:ID: f1b9a36e-26e4-4305-99ae-cbcf6a90013d
:END:

[[https://github.com/Malabarba/aggressive-indent-mode][aggressive-indent]] indents portions of the text your working on as your typing
it. It's pretty smart and very convenient.

#+begin_src emacs-lisp
(use-package aggressive-indent
  :hook emacs-lisp-mode-hook)
#+end_src

*** indent
:PROPERTIES:
:ID:       a5d97d4d-3af9-4fde-ae14-953ad4d28edd
:END:

#+begin_src emacs-lisp
(use-package indent
  :set
  (tab-always-indent . t))
#+end_src

** parentheses
:PROPERTIES:
:ID:       e82d2b4e-659e-4c7d-8071-c413b8e540f7
:END:

*** smartparens
:PROPERTIES:
:ID:       f4ffbb57-1fb6-43ab-a747-470dfcfbd0ac
:END:

**** init
:PROPERTIES:
:ID:       e26f4c55-9585-4544-bed6-9733d50823e7
:END:

#+begin_src emacs-lisp
(use-package smartparens
  :before-call evil-expression evil-ex
  :hook ((prog-mode eshell-mode ielm-mode) . smartparens-strict-mode)
  :set
  (sp-cancel-autoskip-on-backward-movement . nil)
  (sp-highlight-wrap-tag-overlay           . nil)
  (sp-highlight-pair-overlay               . nil)
  (sp-highlight-wrap-overlay               . nil)
  (sp-show-pair-from-inside                . t)
  (sp-show-pair-delay                      . 0.1)
  (sp-max-pair-length                      . 4)
  (sp-max-prefix-length                    . 50)
  (sp-escape-quotes-after-insert           . nil))
#+end_src

**** config
:PROPERTIES:
:ID: f1c64411-ad51-4c24-8dad-b4aa7b8fc3b5
:END:

#+begin_src emacs-lisp
(defhook! init-smartparens-config (smartparens-mode-hook)
  (require 'smartparens-config)
  (sp-local-pair 'minibuffer-inactive-mode "'" nil :actions nil))
#+end_src

**** disable =smartparens-navigate-skip-match=
:PROPERTIES:
:ID: fda1875b-b3f7-4f43-83b1-873f3db3ae77
:END:

#+begin_src emacs-lisp
(use-package smartparens :config
  (defhook! disable-smartparens-navigate-skip-match (after-change-major-mode-hook)
    "Disable smartparents skip match feature."
    (setq sp-navigate-skip-match nil)
    (setq sp-navigate-consider-sgml-tags nil)))
#+end_src

**** autopairing
:PROPERTIES:
:ID: e860ce7e-aaac-477b-a373-a8b01957481d
:END:

#+begin_src emacs-lisp
(defhook! enable-smartparens-maybe (minibuffer-setup-hook)
  "Enable `smartparens-mode' in the minibuffer."
  (when (memq this-command '(eval-expression evil-ex))
    (smartparens-mode 1)))
#+end_src

*** rainbow-delimiters
:PROPERTIES:
:ID:       5b58bb1c-5d3c-4f04-b4fb-c55f1588839e
:END:

[[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]] colors parentheses different colors based on level. This is a
great idea! It makes it really easy to see which parentheses go together.

#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :hook prog-mode-hook reb-mode-hook
  :set
  (rainbow-delimiters-max-face-count . 9))
#+end_src

** evil - the "extensible VI layer"
:PROPERTIES:
:ID:       9639633f-ec3d-4499-9615-db0dcc9650c9
:END:

=evil= is the most complete vim emulation in existence.

*** evil
:PROPERTIES:
:ID:       e74cfb91-a1e8-4747-8c23-6b4fd19aef2e
:END:

[[https://github.com/emacs-evil/evil][evil]] is an extensible vi layer for Emacs. It emulates the main features of Vim,
and provides facilities for writing custom extensions. Also see our page on
[[emacswiki:Evil][EmacsWiki]]. See a brief [[https://bytebucket.org/lyro/evil/raw/default/doc/evil.pdf][manual]]. See the [[https://github.com/noctuid/evil-guide][evil-guide]] by noctuid.

**** evil
:PROPERTIES:
:ID:       e472e5d3-2760-420b-bbe1-2eb043368f67
:END:

#+begin_src emacs-lisp
(use-package evil)
#+end_src

**** evil-core
:PROPERTIES:
:ID:       9aa26d2c-d15a-4f36-a024-3ca9ce568385
:END:

#+begin_src emacs-lisp
(use-package evil-core
  :hook (emacs-startup-hook . evil-mode))
#+end_src

**** evil-vars
:PROPERTIES:
:ID:       af3a9791-76ac-4fd5-96fe-d361cef3b5b3
:END:

#+begin_src emacs-lisp
(use-package evil-vars
  :set
  (evil-want-visual-char-semi-exclusive . t)
  (evil-ex-search-vim-style-regexp      . t)
  (evil-respect-visual-line-mode        . t)
  (evil-insert-skip-empty-lines         . t)
  (evil-want-C-w-in-emacs-state         . nil)
  (evil-ex-substitute-global            . t)
  (evil-ex-visual-char-range            . t)
  (evil-move-beyond-eol                 . nil)
  (evil-move-cursor-back                . nil)
  (evil-indent-convert-tabs             . t)
  (evil-symbol-word-search              . t)
  (evil-mode-line-format                . nil)
  (evil-echo-state                      . nil)
  (evil-magic                           . t))
#+end_src

**** custom
:PROPERTIES:
:ID:       f7ece898-25e2-4b2c-94f3-e832a687114c
:END:

#+begin_src emacs-lisp
(set-default! evil-want-C-u-scroll t)
#+end_src

**** normal state everywhere
:PROPERTIES:
:ID:       e6126bd7-94b8-4ce0-b547-0536b59437ea
:END:

In his excellent [[https://github.com/noctuid/evil-guide][evil-guide]], =noctuid= pointed out that [[https://github.com/noctuid/evil-guide#global-keybindings-and-evil-states][motion state is a
useless state]]. The code in this headline essentially just says =NO= to motion
state and disables it everywhere in favor of normal state.

#+begin_src emacs-lisp
(defhook! make-normal-state-default (evil-mode-hook)
  "Make normal state the default state."
  (set! (append evil-emacs-state-modes evil-motion-state-modes <evil-normal-state-modes>))
  (setq evil-emacs-state-modes nil)
  (setq evil-motion-state-modes nil))

(defadvice! replace-motion-with-normal (:around evil-make-overriding-map)
  "Advice for `evil-make-overriding-map' that inhibits motion state."
  (-let (((keymap state copy) <args>))
    (funcall <orig-fn> keymap (if (eq state 'motion) 'normal state) copy)))

(defadvice! replace-motion-with-normal (:around evil-set-initial-state)
  (-let (((mode state) <args>))
    (funcall <orig-fn> mode (if (eq state 'motion) 'normal state))))

(xl-advice-add #'evil-motion-state :override #'evil-normal-state)
#+end_src

**** cursors
:PROPERTIES:
:ID: a5f558fb-221c-4b33-a7cd-29308ef74b0d
:END:

It's nice to have cursors change colors (and sometimes shape) depending on the
current evil state. It makes it easy to tell which state you're in. I define
some colors here. Evil has a cursor variable for each state. The cursor variable
for insert state, for example, is [[helpvar:evil-insert-state-cursor][evil-insert-state-cursor]]. Its value is of the
form: ~((CURSOR-SHAPE . CURSOR-WIDTH) COLOR)~.

***** colors and shapes
:PROPERTIES:
:ID: 3f3cd5c9-1f6d-4c3b-b73f-82c9ee00395e
:END:

Changing the cursor shape and color depending on the state is a convenient and
asthetically pleasing way of determining which state you're in. Some add some
modeline indicator for this but I find that the cursor suffices.

#+begin_src emacs-lisp
(defhook! setup-cursor (evil-mode-hook)
  "Initialize the default cursor shape and size."
  (setq evil-insert-state-cursor   '((bar . 3)   "chartreuse3"))
  (setq evil-emacs-state-cursor    '((bar . 3)   "SkyBlue2"))
  (setq evil-normal-state-cursor   '( box        "DarkGoldenrod2"))
  (setq evil-visual-state-cursor   '((hollow)    "dark gray"))
  (setq evil-operator-state-cursor '((hbar . 10) "hot pink"))
  (setq evil-replace-state-cursor  '( box        "chocolate"))
  (setq evil-motion-state-cursor   '( box        "plum3")))
#+end_src

***** updating cursors
:PROPERTIES:
:ID: ea4da6d4-4a2c-42cf-b397-cea1555781ce
:END:

After a theme is loaded, the cursor color won't automatically update. Therefore,
I add a hook in [[helpvar:xl-after-load-theme-hook][xl-after-load-theme-hook]]. Now after a new theme is loaded, the
cursor color will update.

#+begin_src emacs-lisp
(defhook! refresh-evil-cursor (xl-after-load-theme-hook)
  "Enable cursor refreshing after theme change."
  (when (bound-and-true-p evil-mode)
    (evil-refresh-cursor)))
#+end_src

**** insert state in minibuffer
:PROPERTIES:
:ID: a23137c5-62a0-4e77-9e51-6a7372dac703
:END:

Before I just used ~(evil-change-state evil-previous-state)~ to revert the
state back to what it last was. But this fails with ~evil-force-normal-state~
which is what I'm currently using to exit the minibuffer because then the
last state is normal state if the minibuffer is aborted. Using a
=evil:state-before-minibuffer= ensures that the state will be reverted to
the correct one.

#+begin_src emacs-lisp
(defhook! preserve-prior-evil-state (minibuffer-enter-hook)
  "Save state before entering the minibuffer and enter insert state."
  (when (bound-and-true-p evil-mode)
    (setq evil:state-before-minibuffer evil-state)
    (evil-insert-state)))

(defhook! restore-prior-evil-state (minibuffer-exit-hook)
  "Restore state after minibuffer."
  (when (bound-and-true-p evil-mode)
    (evil-change-state evil:state-before-minibuffer)
    (setq evil:state-before-minibuffer nil)))
#+end_src

**** escape
:PROPERTIES:
:ID: ea9378de-e5c5-482c-b53b-743a81e3bc8e
:END:

We want escape to be a "quit everything" keybinding.

#+begin_src emacs-lisp
(bind! (:ei [escape] #'evil-force-normal-state))

(defadvice! exit-everything (:after evil-force-normal-state lispyville-normal-state)
  "Exits out of whatever is happening after escape."
  (cond ((minibuffer-window-active-p (minibuffer-window))
         (abort-recursive-edit))
        ((run-hook-with-args-until-success 'xl-escape-hook))
        ((or defining-kbd-macro executing-kbd-macro) nil)
        (t (keyboard-quit))))
#+end_src

**** text objects
:PROPERTIES:
:ID:       0edef735-cec9-4015-bfd5-cf36e816cbc3
:END:

To edit text efficiently Vim has the concept of [[https://blog.carbonfive.com/2011/10/17/vim-text-objects-the-definitive-guide/][text objects]]. Text objects are
structures that are seen in text. For example, a set of words followed by a
period is a sentence. A words between two closing parentheses is a sexp.

***** general delimiter text object
:PROPERTIES:
:ID:       0066093b-7991-4193-8ce2-ef9f17af211a
:END:

I discovered this the =form= text object from using [[https://github.com/luxbock/evil-cleverparens][evil-cleverparens]] in the past.
The package =evil-cleverparens= was too slow for my taste; noctuid's [[https://github.com/sp3ctum/evil-lispy][evil-lispy]] is
much faster and gave me the functionality that I needed most from
=evil-cleverparens=: deleting and copying text with parentheses intelligently.
However, many of the ideas of =evil-cleverparens= were excellent. One particular
idea was to have a general =form= text object. Instead of specifying the
particular surrounding bounds when doing an evil operator command you just use a
single key for them. It's kind of like a =Do-What-I-Mean= surround operator. This
is suprisingly useful because it takes significant time to specify whether you
want =[]= or ={=}= or =()= or =""=. The main drawback you cannot distinguish between
surround characters at multiple levels--it just takes the closest one. In
practice, this is rarely an issue.

***** inner
:PROPERTIES:
:ID:       dc06e55b-ce4d-4921-b478-ae7b7927df82
:END:

#+begin_src emacs-lisp
(after! evil
  (evil-define-text-object evil:textobj-inner-form (count &rest _)
    "Inner sexp object."
    (-if-let ((beg . end)
	      (->> (list (lispy--bounds-list) (lispy--bounds-string))
		   (-non-nil)
		   (--sort (< (- (cdr it) (car it)) (- (cdr other) (car other))))
		   (car)))
	(evil-range (1+ beg) (1- end) 'inclusive :expanded t)
      (error "No surrounding form found."))))
#+end_src

***** outer
:PROPERTIES:
:ID:       6068a56f-d162-4da2-801f-6f72357fdd62
:END:

#+begin_src emacs-lisp
(after! evil
  (evil-define-text-object evil:textobj-outer-form (count &rest _)
    "Smartparens inner sexp object."
    (-if-let ((beg . end)
              (->> (list (lispy--bounds-list) (lispy--bounds-string))
                   (-non-nil)
                   (--sort (< (- (cdr it) (car it)) (- (cdr other) (car other))))
                   (car)))
        (evil-range beg end 'inclusive :expanded t)
      (error "No surrounding form found."))))
#+end_src

***** bindings
:PROPERTIES:
:ID:       4bf10f8e-2ae6-44b1-9087-5d1e2af028f1
:END:

#+begin_src emacs-lisp
(bind!
  (:map evil-inner-text-objects-map "f" #'evil:textobj-inner-form)
  (:map evil-outer-text-objects-map "f" #'evil:textobj-outer-form))
#+end_src

***** fix vim/evil around =""=
:PROPERTIES:
:ID:       b91726b4-7e7e-442a-9858-df5d51c751c8
:END:

=Vim= and =Evil= both have the interesting (inconsistent?) behavior that doing an
outer text object operator on a comment grabs some whitespace on the left side.
Try doing =va"= to ~(progn "hello world")~ and you'll see that =\s"hello world"= is
selected instead of just "hello world".

Why not just go to the end of the ="= like any other around operator?

#+begin_src emacs-lisp
(after! evil
  (evil-define-text-object evil:textobj-a-string (count &rest _)
    "An outer comment text object as defined by `lispy--bounds-string'."
    (-if-let ((beg . end) (lispy--bounds-string))
        (evil-range beg end 'exclusive :expanded t)
      (error "Not inside a comment.")))

  (bind!
    (:map evil-outer-text-objects-map)
    ("\"" #'evil:textobj-a-string)))
#+end_src

*** evil-visualstar
:PROPERTIES:
:ID:       ae15f6a4-59a5-49ca-9add-1b90d393b09c
:END:

[[https://github.com/bling/evil-visualstar][evil-visualstar]]

#+begin_src emacs-lisp
(use-package evil-visualstar)

(bind! (:map evil-visual-state-map)
  ("#" #'evil-visualstar/begin-search-backward)
  ("*" #'evil-visualstar/begin-search-forward))
#+end_src

*** evil-lion
:PROPERTIES:
:ID:       95d248be-601e-4dbd-b318-febcd0e49d71
:END:

=evil-lion= provides a very useful way of aligning text.

#+begin_src emacs-lisp
(use-package evil-lion
  :commands evil-lion-right evil-lion-left)

(bind!
  (:prefix "g")
  (:nv "l" #'evil-lion-left)
  (:nv "L" #'evil-lion-right))
#+end_src

*** evil-surround
:PROPERTIES:
:ID:       9ab88644-3c33-463c-8f24-3b048209e082
:END:

#+begin_src emacs-lisp
(use-package evil-surround
  :hook prog-mode-hook text-mode-hook)
#+end_src

*** evil-easymotion
:PROPERTIES:
:ID:       b18190a1-e0b3-4311-ad20-76d79f56c3a6
:END:

#+begin_src emacs-lisp
(use-package evil-easymotion)
;; (setq avy-style 'at)
;; (evilem-make-motion evil-easymotion:word-begin #'evil-forward-word-begin)
;; (evilem-make-motion-plain evil-easymotion:find-char #'evil-find-char)
;; (general-def 'normal "w" #'evil-easymotion:word-begin)
;; (general-def 'normal "f" #'evil-easymotion:find-char)
#+end_src

*** evil-goggles
:PROPERTIES:
:ID:       30d19955-dabf-472f-a485-22114e1eaaa4
:END:

#+begin_src emacs-lisp
(use-package evil-goggles)
#+end_src

*** evil-god-state
:PROPERTIES:
:ID:       4374e82c-bac1-4c9e-9ab9-70799140f5a7
:END:

** key-chord
:PROPERTIES:
:ID:       20d6d9c1-50a1-4699-a67c-e6f04d3b5576
:END:

Sometimes we dont have access to a convenient escape key--I mean that caps-lock
is not bound to escape. Or, perhaps, we might find it faster or preferable to
press jk really quickly to invoke escape.

This is better than evil escape as it only binds in insert.

#+begin_src emacs-lisp
(use-package key-chord
  :silence key-chord-mode
  :before-call evil-insert-state evil-emacs-state
  )
#+end_src

** paren
:PROPERTIES:
:ID:       c4d415da-a408-4e59-ac6a-c5ab17e2e32d
:END:

#+begin_src emacs-lisp
(use-package paren
  :hook (prog-mode . show-paren-mode)
  :set
  (show-paren-delay . 0))
#+end_src

** lispyville
:PROPERTIES:
:ID:       120baacb-4835-4e96-a7cb-e8bb7496d7be
:END:

[[https://github.com/noctuid/lispyville][lispyville]] helps vim commands work better with lisp by providing
commands (like [[helpfn:lispyville-delete][lispyville-delete]]) which preserve parentheses.

*** initialize
:PROPERTIES:
:ID:       fad4cb7c-ff1e-485d-99d1-f55384c26402
:END:

#+begin_src emacs-lisp
(use-package lispyville :hook emacs-lisp-mode-hook)
#+end_src

*** remappings
:PROPERTIES:
:ID:       411cb6e1-311a-458a-a241-d9b9aef45d25
:END:

#+begin_src emacs-lisp
(bind!
  (:map lispyville-mode-map)
  ([remap evil-yank]                 #'lispyville-yank)
  ([remap evil-delete]               #'lispyville-delete)
  ([remap evil-change]               #'lispyville-change)
  ([remap evil-yank-line]            #'lispyville-yank-line)
  ([remap evil-delete-line]          #'lispyville-delete-line)
  ([remap evil-change-line]          #'lispyville-change-line)
  ([remap evil-delete-char]          #'lispyville-delete-char-or-splice)
  ([remap evil-delete-backward-char] #'lispyville-delete-char-or-splice-backwards)
  ([remap evil-substitute]           #'lispyville-substitute)
  ([remap evil-change-whole-line]    #'lispyville-change-whole-line)
  ([remap evil-join]                 #'lispyville-join))
#+end_src

*** inner text objects
:PROPERTIES:
:ID:       f9f82ebe-5749-452f-ba49-269e60526b04
:END:

#+begin_src emacs-lisp
(bind!
  (:map evil-inner-text-objects-map)
  ("a" #'lispyville-inner-atom)
  ("l" #'lispyville-inner-list)
  ("x" #'lispyville-inner-sexp)
  ("c" #'lispyville-inner-comment)
  ("s" #'lispyville-inner-string))
#+end_src

*** outer text objects
:PROPERTIES:
:ID:       9dda9a1b-c76f-4537-9554-45ad3c77977a
:END:

#+begin_src emacs-lisp
(bind!
  (:map evil-outer-text-objects-map)
  ("a" #'lispyville-a-atom)
  ("l" #'lispyville-a-list)
  ("x" #'lispyville-a-sexp)
  ("c" #'lispyville-a-comment)
  ("s" #'lispyville-a-string))
#+end_src

*** slurp/barf
:PROPERTIES:
:ID:       2b70a90f-6d5a-437e-99e9-e72224d64079
:END:

#+begin_src emacs-lisp
(bind!
  (:map lispyville-mode-map)
  (:n ">" #'lispyville-slurp)
  (:n "<" #'lispyville-barf))
#+end_src

*** escape
:PROPERTIES:
:ID:       6469110b-e5bf-4276-a9de-a5c1e1eb2385
:END:

=lispyville= binds escape to [[helpfn:lipyville-normal-state][lispyville-normal-state]]. So for =xl-escape-hook=
to still happen on escape, I need to add [[helpfn:evil:escape-a][evil:escape-a]] as advice to
=lispyville-normal-state=.

Sometimes =evil-normal-state= enters visual state.

#+begin_src emacs-lisp
(bind!
  (:map lispyville-mode-map)
  ([escape] #'lispyville-normal-state))
#+end_src

*** additional
:PROPERTIES:
:ID:       af8b96f7-183a-4f87-a985-7f7328e6feb7
:END:

#+begin_src emacs-lisp
(bind!
  (:map lispyville-mode-map)
  (:ei "SPC" #'lispy-space)
  (:ei ";"   #'lispy-comment)
  (:nv "M-j" #'lispyville-drag-forward)
  (:nv "M-k" #'lispyville-drag-backward)
  (:nv "M-R" #'lispyville-raise-list)
  (:nv "M-v" #'lispy-convolute-sexp))
#+end_src

* notifications
:PROPERTIES:
:ID:       4b3bd59b-9867-4b2a-a29a-693fd0aa68b7
:END:

** ednc
:PROPERTIES:
:ID:       e72dfee2-3c80-4206-b2ea-d4a25fffc75c
:END:

This is a replacement for things like =dunst= except written completely en Emacs
lisp.

#+begin_src emacs-lisp
(use-package ednc)
#+end_src

** egg-timer
:PROPERTIES:
:ID:       a98d0f06-5b2a-449d-8719-bcc8d3d0a241
:END:

#+begin_src emacs-lisp
(use-package egg-timer)
#+end_src

* languages
:PROPERTIES:
:ID:       fa8dc2fc-96f4-4820-b368-4d61d1db0ee5
:END:

** lisp
:PROPERTIES:
:ID:       2b7db121-f807-4274-9347-70c996d3c6f7
:END:

This headline is for packages and configuration which pertain to editing lisp
code.

*** lispyville
:PROPERTIES:
:ID:       120baacb-4835-4e96-a7cb-e8bb7496d7be
:END:

[[https://github.com/noctuid/lispyville][lispyville]] helps vim commands work better with lisp by providing
commands (like [[helpfn:lispyville-delete][lispyville-delete]]) which preserve parentheses.

**** initialize
:PROPERTIES:
:ID:       fad4cb7c-ff1e-485d-99d1-f55384c26402
:END:

#+begin_src emacs-lisp
(use-package lispyville :hook emacs-lisp-mode-hook)
#+end_src

**** remappings
:PROPERTIES:
:ID:       f14083fc-13d1-41c6-9fca-eb686a1d50a3
:END:

#+begin_src emacs-lisp
(bind!
  (:map lispyville-mode-map)
  ([remap evil-yank]                 #'lispyville-yank)
  ([remap evil-delete]               #'lispyville-delete)
  ([remap evil-change]               #'lispyville-change)
  ([remap evil-yank-line]            #'lispyville-yank-line)
  ([remap evil-delete-line]          #'lispyville-delete-line)
  ([remap evil-change-line]          #'lispyville-change-line)
  ([remap evil-delete-char]          #'lispyville-delete-char-or-splice)
  ([remap evil-delete-backward-char] #'lispyville-delete-char-or-splice-backwards)
  ([remap evil-substitute]           #'lispyville-substitute)
  ([remap evil-change-whole-line]    #'lispyville-change-whole-line)
  ([remap evil-join]                 #'lispyville-join))
#+end_src

**** inner text objects
:PROPERTIES:
:ID:       f9f82ebe-5749-452f-ba49-269e60526b04
:END:

#+begin_src emacs-lisp
(bind!
 (:map evil-inner-text-objects-map)
 ("a" #'lispyville-inner-atom)
 ("l" #'lispyville-inner-list)
 ("x" #'lispyville-inner-sexp)
 ("c" #'lispyville-inner-comment)
 ("s" #'lispyville-inner-string))
#+end_src

**** outer text objects
:PROPERTIES:
:ID:       9dda9a1b-c76f-4537-9554-45ad3c77977a
:END:

#+begin_src emacs-lisp
(bind!
  (:map evil-outer-text-objects-map)
  ("a" #'lispyville-a-atom)
  ("l" #'lispyville-a-list)
  ("x" #'lispyville-a-sexp)
  ("c" #'lispyville-a-comment)
  ("s" #'lispyville-a-string))
#+end_src

**** slurp/barf
:PROPERTIES:
:ID: 21626641-98e3-4134-958d-03227e4da6b5
:END:

#+begin_src emacs-lisp
(bind!
  (:map lispyville-mode-map)
  (:n ">" #'lispyville-slurp)
  (:n "<" #'lispyville-barf))
#+end_src

**** escape
:PROPERTIES:
:ID: b355e1a1-6242-47f5-b357-5c3f5adbd200
:END:

=lispyville= binds escape to [[helpfn:lipyville-normal-state][lispyville-normal-state]]. So for =xl-escape-hook=
to still happen on escape, I need to add [[helpfn:evil:escape-a][evil:escape-a]] as advice to
=lispyville-normal-state=.

Sometimes =evil-normal-state= enters visual state.

#+begin_src emacs-lisp
(bind!
  (:map lispyville-mode-map)
  (:ei [escape] #'lispyville-normal-state))
#+end_src

**** additional
:PROPERTIES:
:ID: 1fbafa78-87a0-45ee-9c7c-0c703df2ac66
:END:

#+begin_src emacs-lisp
(bind!
  (:map lispyville-mode-map)
  (:ei "SPC" #'lispy-space)
  (:ei ";"   #'lispy-comment)
  (:nv "M-j" #'lispyville-drag-forward)
  (:nv "M-k" #'lispyville-drag-backward)
  (:nv "M-R" #'lispyville-raise-list)
  (:nv "M-v" #'lispy-convolute-sexp))
#+end_src

*** highlight-quoted
:PROPERTIES:
:ID:       d0973dce-693b-45ca-88e3-27da1bb217f7
:END:

[[https://github.com/Fanael/highlight-quoted][highlight-quoted]] highlights quotes, backticks and.

#+begin_src emacs-lisp
(use-package highlight-quoted
  :hook emacs-lisp-mode-hook)
#+end_src

*** macrostep
:PROPERTIES:
:ID:       fefc5700-3bd7-4a89-ae7b-bf68368e8bc4
:END:

#+begin_src emacs-lisp
(use-package macrostep
  :commands macrostep-expand)

(bind-localleader!
 (:map emacs-lisp-mode-map)
 (:prefix "m" :wk "macrostep")
 ("e" #'macrostep-expand)
 ("c" #'macrostep-collapse)
 ("C" #'macrostep-collapse-all))
#+end_src

*** elisp

**** eros
:PROPERTIES:
:ID:       76a70683-bd59-4ec4-9574-d307ccdc36cd
:END:

=eros= displays the result of evaluating elisp expressions as overlays.

#+begin_src emacs-lisp
(use-package eros
  :hook emacs-lisp-mode-hook
  :set (eros-eval-result-prefix . " ")
  :config (bind! ([remap eval-last-sexp] #'eros-eval-last-sexp)))
#+end_src

**** fix elisp indentation
:PROPERTIES:
:ID:       834eff05-1b96-4295-a46c-d14f81b43ad6
:END:

A problem with elisp indentation is indents quoted lists the way functions
should be indented. It has been discussed in at least three stackoverflow
questions [[https://emacs.stackexchange.com/questions/10230/how-to-indent-keywords-aligned/10233#10233][here]], [[https://stackoverflow.com/questions/49222433/align-symbols-in-plist][here]] and [[https://stackoverflow.com/questions/22166895/customize-elisp-plist-indentation][here]]. In all these questions the solutions have not
been satisfactory. Some of them recommend using [[helpfn:common-lisp-indent-function][common-lisp-indent-function]] as
the value of [[helpvar:lisp-indent-function][lisp-indent-function]]. This works for indenting a quoted list
properly, but at the expense of changing the way that many other elisp forms are
indented. Common Lisp's indentation is different from Elisp's. Others recommend
using [[https://github.com/Fuco1/.emacs.d/blob/af82072196564fa57726bdbabf97f1d35c43b7f7/site-lisp/redef.el#L12-L94][Fuco1's lisp indent function hack]]. This also is not ideal. For one thing it
only works for quoted lists with keywords but not generic symbols. Another thing
is that the change should really be occurring in [[helpfn:calculate-lisp-indent][calculate-lisp-indent]].
~calculate-lisp-indent~ is a function that returns what the indentation should be
for the line at point. Since Fuco1 did not modify ~calculate-lisp-indent~ the
*wrong* indentation still returned by this function and the modified
~lisp-indent-function~ just cleans up the mess. Better is just fixing the source
of the problem. You can check out a more in-depth explanation looking at my
[[https://www.reddit.com/r/emacs/comments/d7x7x8/finally_fixing_indentation_of_quoted_lists/][reddit-post]] or looking at an answer I gave to [[https://emacs.stackexchange.com/questions/10230/how-to-indent-keywords-aligned][this question]].

#+begin_src emacs-lisp
(defadvice! properly-calculate-indent (:override calculate-lisp-indent)
  "Add better indentation for quoted and backquoted lists.
The change to this function."
  (defvar calculate-lisp-indent-last-sexp)
  (save-excursion
    (beginning-of-line)
    (let ((indent-point (point))
          state
          ;; setting this to a number inhibits calling hook
          (desired-indent nil)
          (retry t)
          calculate-lisp-indent-last-sexp containing-sexp)
      (cond ((or (markerp <parse-start>) (integerp <parse-start>))
             (goto-char <parse-start>))
            ((null <parse-start>) (beginning-of-defun))
            (t (setq state <parse-start>)))
      (unless state
        ;; Find outermost containing sexp
        (while (< (point) indent-point)
          (setq state (parse-partial-sexp (point) indent-point 0))))
      ;; Find innermost containing sexp
      (while (and retry
                  state
                  (> (elt state 0) 0))
        (setq retry nil)
        (setq calculate-lisp-indent-last-sexp (elt state 2))
        (setq containing-sexp (elt state 1))
        ;; Position following last unclosed open.
        (goto-char (1+ containing-sexp))
        ;; Is there a complete sexp since then?
        (if (and calculate-lisp-indent-last-sexp
                 (> calculate-lisp-indent-last-sexp (point)))
            ;; Yes, but is there a containing sexp after that?
            (let ((peek (parse-partial-sexp calculate-lisp-indent-last-sexp
                                            indent-point 0)))
              (if (setq retry (car (cdr peek))) (setq state peek)))))
      (if retry
          nil
        ;; Innermost containing sexp found
        (goto-char (1+ containing-sexp))
        (if (not calculate-lisp-indent-last-sexp)
            ;; indent-point immediately follows open paren.
            ;; Don't call hook.
            (setq desired-indent (current-column))
          ;; Find the start of first element of containing sexp.
          (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
          (cond ((looking-at "\\s(")
                 ;; First element of containing sexp is a list.
                 ;; Indent under that list.
                 )
                ((> (save-excursion (forward-line 1) (point))
                    calculate-lisp-indent-last-sexp)
                 ;; This is the first line to start within the containing sexp.
                 ;; It's almost certainly a function call.
                 (if (or
                      (= (point) calculate-lisp-indent-last-sexp)

                      (when-let (after (char-after (1+ containing-sexp)))
                        (char-equal after ?:))

                      (when-let (point (char-before containing-sexp))
                        (char-equal point ?'))

                      (let ((quoted-p nil)
                            (point nil)
                            (positions (nreverse (butlast (elt state 9)))))
                        (while (and positions (not quoted-p))
                          (setq point (pop positions))
                          (setq quoted-p
                                (or
                                 (and (char-before point)
                                      (char-equal (char-before point) ?'))
                                 (save-excursion
                                   (goto-char (1+ point))
                                   (looking-at-p "quote[\t\n\f\s]+(")))))
                        quoted-p))
                     ;; Containing sexp has nothing before this line
                     ;; except the first element.  Indent under that element.
                     nil
                   ;; Skip the first element, find start of second (the first
                   ;; argument of the function call) and indent under.
                   (progn (forward-sexp 1)
                          (parse-partial-sexp (point)
                                              calculate-lisp-indent-last-sexp
                                              0 t)))
                 (backward-prefix-chars))
                (t
                 ;; Indent beneath first sexp on same line as
                 ;; `calculate-lisp-indent-last-sexp'.  Again, it's
                 ;; almost certainly a function call.
                 (goto-char calculate-lisp-indent-last-sexp)
                 (beginning-of-line)
                 (parse-partial-sexp (point) calculate-lisp-indent-last-sexp
                                     0 t)
                 (backward-prefix-chars)))))
      ;; Point is at the point to indent under unless we are inside a string.
      ;; Call indentation hook except when overridden by lisp-indent-offset
      ;; or if the desired indentation has already been computed.
      (let ((normal-indent (current-column)))
        (cond ((elt state 3)
               ;; Inside a string, don't change indentation.
               nil)
              ((and (integerp lisp-indent-offset) containing-sexp)
               ;; Indent by constant offset
               (goto-char containing-sexp)
               (+ (current-column) lisp-indent-offset))
              ;; in this case calculate-lisp-indent-last-sexp is not nil
              (calculate-lisp-indent-last-sexp
               (or
                ;; try to align the parameters of a known function
                (and lisp-indent-function
                     (not retry)
                     (funcall lisp-indent-function indent-point state))
                ;; If the function has no special alignment
                ;; or it does not apply to this argument,
                ;; try to align a constant-symbol under the last
                ;; preceding constant symbol, if there is such one of
                ;; the last 2 preceding symbols, in the previous
                ;; uncommented line.
                (and (save-excursion
                       (goto-char indent-point)
                       (skip-chars-forward " \t")
                       (looking-at ":"))
                     ;; The last sexp may not be at the indentation
                     ;; where it begins, so find that one, instead.
                     (save-excursion
                       (goto-char calculate-lisp-indent-last-sexp)
                       ;; Handle prefix characters and whitespace
                       ;; following an open paren.  (Bug#1012)
                       (backward-prefix-chars)
                       (while (not (or (looking-back "^[ \t]*\\|([ \t]+"
                                                     (line-beginning-position))
                                       (and containing-sexp
                                            (>= (1+ containing-sexp) (point)))))
                         (forward-sexp -1)
                         (backward-prefix-chars))
                       (setq calculate-lisp-indent-last-sexp (point)))
                     (> calculate-lisp-indent-last-sexp
                        (save-excursion
                          (goto-char (1+ containing-sexp))
                          (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
                          (point)))
                     (let ((parse-sexp-ignore-comments t)
                           indent)
                       (goto-char calculate-lisp-indent-last-sexp)
                       (or (and (looking-at ":")
                                (setq indent (current-column)))
                           (and (< (line-beginning-position)
                                   (prog2 (backward-sexp) (point)))
                                (looking-at ":")
                                (setq indent (current-column))))
                       indent))
                ;; another symbols or constants not preceded by a constant
                ;; as defined above.
                normal-indent))
              ;; in this case calculate-lisp-indent-last-sexp is nil
              (desired-indent)
              (t
               normal-indent))))))
#+end_src

**** debugging
:PROPERTIES:
:ID:       9390181f-fbe9-4316-beb6-c07c12e4f911
:END:

My config file is so large that bugs matter. I need reliable ways of determining.

***** backtrace
:PROPERTIES:
:ID:       63fe8a26-512e-41c6-8b8d-a9f3ba495bc9
:END:

This built-in emacs package is opens a buffer with a list.

#+begin_src emacs-lisp
(use-package backtrace
  :rule ("bottom" "backtrace" :newname "\\*Backtrace\\*"))
#+end_src

***** ert
:PROPERTIES:
:ID:       5fbf293e-84ae-4f47-bdcd-850ff552465a
:END:

#+begin_src emacs-lisp
(use-package ert
  :rule ("bottom" "ert" :newname "\\*ert\\*")
  :assume-yes ert-delete-all-tests)
#+end_src

***** ert-expectations
:PROPERTIES:
:ID:       3062b8a4-4261-49fc-9bdb-895ba75bbd19
:END:

#+begin_src emacs-lisp
(use-package ert-expectations)

(autoload 'expect "ert-expectations" nil nil 'macro)
(autoload 'expectations "ert-expectations" nil nil 'macro)
#+end_src

***** el-mock
:PROPERTIES:
:ID:       46df66b0-5820-4550-aa99-c913d3022fe1
:END:

#+begin_src emacs-lisp
(use-package el-mock)
#+end_src

***** assess
:PROPERTIES:
:ID:       cea20fcd-0c75-42dc-be7f-e9eda7b932b1
:END:

=assess= is similar to =ert-expectations=. It is a wrapper around the built in
[[][ert-deftest] that provides a cleaner syntax for writing tests.

#+begin_src emacs-lisp
(use-package assess)
#+end_src

***** bug-hunter
:PROPERTIES:
:ID:       30196ef6-7b34-4a6c-b084-8e613010abd4
:END:

=bug-hunter= is a package that automates [[https://en.wikipedia.org/wiki/Bisection_(software_engineering)][code-bisection]], the process of trying
parts of your code at a time until you find out where the bug is. You can find
the culprit of a problem by [[][code bisection].

#+begin_src emacs-lisp
(use-package bug-hunter)
#+end_src

**** ppp
:PROPERTIES:
:ID:       82dbb88a-4bce-4ca3-90fe-38cfbea7abc6
:END:

This is a pretty printer.

Sometimes you want to see what an object looks like represented as text so you
know what you're dealing with. For example, I've wanted to see what a straight
recipe looks like. The problem is by default [[][]] prints something on one
line. And to avoid long lines, emacs truncates the output so you can't even see
the whole thing.

#+begin_src emacs-lisp
(use-package ppp)
#+end_src

**** elisp-demos
:PROPERTIES:
:ID:       2c419004-a7c1-4de5-bada-8420505cea90
:END:

This package has a good idea--namely it provides a systematic way to add
function/macro demos to documentation. Still, I have a few problems with this
package. For one thing, it adds the examples along with the ugly "begin/end_src"
lines. I'd rather have something like the comment arrow ~;=>~. Also, I'd like to
integrate it with writing tests. Wouldn't it be great if I could write tests for
a function and simultaneously add those tests as examples for how to use the
function?

#+begin_src emacs-lisp
(use-package elisp-demos
  :advice (:after (helpful-update . elisp-demos-advice-helpful-update)))
#+end_src

** org
:PROPERTIES:
:ID:       63748940-c1b9-47ea-b1ce-d6519453ad03
:END:

=org= mode.

*** important files and directories
:PROPERTIES:
:ID:       97a3bb5a-f485-45d0-a7f4-4bdd3963a16b
:END:

For now, I define these variables after org mode. These are important files and
directories that I need to reference multiple times.

#+begin_src emacs-lisp
(defconst XL-ORG-DIR (f-full "~/Documents/org/")
  "Directory where org files are kept.")

(defconst XL-CAPTURE-FILE (concat XL-ORG-DIR "capture.org")
  "Org file where capture template captures should go.")

(defconst XL-CODE-FILE (concat XL-ORG-DIR "capture.org")
  "Org file where code snippets should go.")

(defconst XL-TEST-FILE (concat XL-ORG-DIR "test.org")
  "Org file tests should go.")
#+end_src

*** org-version
:PROPERTIES:
:ID:       0b2cfe2b-a75c-48ea-9470-19c92521e2cf
:END:

#+begin_src emacs-lisp
(advice-add #'org-version :override (-const "10"))
#+end_src

*** bindings
:PROPERTIES:
:ID:       4ca3fe54-54b1-47ca-90f1-a14b3df1cc59
:END:

Org mode demands its own editing.

**** define a state for org mode
:PROPERTIES:
:ID:       9f548349-632e-41c3-b602-73ac97beb8dc
:END:

=org-mode= editing is so different that I think it's worth it to define an
entirely new state for org mode.

**** org mode local bindings
:PROPERTIES:
:ID:       a950d732-b0d2-46b9-82ce-1b9a474e7d76
:END:

#+begin_src emacs-lisp
(bind-localleader!
 (:map org-mode-map)
 ((:prefix "i")
  ("b" #'org/dwim-insert-elisp-block)
  ("k" #'org/insert-heading-above)
  ("j" #'org/insert-heading-below))
 ("p" #'org-set-property)
 ("o" #'outorg-edit-as-org)
 ("w" #'widen)
 ("n" #'org-narrow-to-subtree)
 ("k" #'org-cut-subtree)
 ("c" #'org-copy-subtree)
 ("r" #'org-refile)
 ("j" #'org/avy-goto-headline)
 ("E" #'org-babel-execute-subtree)
 ("d" #'org/dwim-edit-description)
 ("H" #'(lambda () (interactive) (org-up-heading-safe)))
 ("h" #'org-promote-subtree)
 ("l" #'org-demote-subtree)
 ("e" #'org/dwim-edit-source-block)
 ("," #'org/dwim-edit-source-block))
#+end_src

**** generic org bindings
:PROPERTIES:
:ID:       583bd7ac-64e0-48ea-bd75-5b6a20f2deae
:END:

Org mode just does not lend itself to typical evil bindings. These bindings are
much more useful considering the specific structure of org mode documents.

#+begin_src emacs-lisp
(bind!
  (:map org-mode-map)
  (:states normal)
  ("j" #'org-next-visible-heading)
  ("k" #'org-previous-visible-heading)
  ("E" #'org/dwim-eval-block)
  ("e" #'org/dwim-eval-block)
  ("b" #'org/dwim-insert-elisp-block)
  ("o" #'org/insert-heading-below)
  ("O" #'org/insert-heading-above)
  ("h" #'org-up-heading-safe)
  ("l" #'org-do-demote)
  ("H" #'org-promote-subtree)
  ("S" #'org-demote-subtree)
  (">" #'org-shiftmetaright)
  ("<" #'org-shiftmetaleft)
  ("t" #'org-set-tags-command)
  ("c" #'org-capture)
  ("s" #'org/dwim-edit-source-block)
  ("R" #'org-refile)
  ("r" #'org/refile-to-current-file)
  ("T" #'org-todo)
  ("D" #'org-cut-subtree)
  ("Y" #'org-copy-subtree)
  ("K" #'org-metaup)
  ("J" #'org-metadown))
#+end_src

**** bindings
:PROPERTIES:
:ID:       3f4144ee-a780-478e-a1ad-47591f181ff3
:END:

#+begin_src emacs-lisp
(bind! ([remap org-cycle] #'outline-toggle-children))
#+end_src

*** commands
:PROPERTIES:
:ID:       cdf84156-cbdb-4f08-a380-ecce4bbc98d2
:END:

**** goto start of heading
:PROPERTIES:
:ID:       0431e49f-ef6b-4edb-854c-6427479e5ee2
:END:

#+begin_src emacs-lisp
(defun org%heading-goto-start ()
  "Go to the end of headline."
  (save-match-data
    (beginning-of-line)
    (when (looking-at (rx (1+ "*")))
      (goto-char (1- (match-end 0))))))
#+end_src

**** do the right thing after jumping to headline
:PROPERTIES:
:ID:       2ca61454-a0ca-47b3-8622-91d7969653da
:END:

When I search for a headline with [[helpfn:void/goto-line][xl/goto-line]] or [[helpfn:void/goto-headline][xl/goto-headline]] or even their
counsel equivalents, the proper headlines aren't automatically revealed.

[[screenshot:][This]] is what headline structure looks after using counsel/ivy's [[helpfn:swiper][swiper]] to find
the word =xl/goto-line= in my emacs. You can see that only the headline that has
the target word is revealed but it's parents are (akwardly) hidden. I never want
headlines to be unfolded like this.

***** show branch
:PROPERTIES:
:ID:       d95fab52-7d8f-439f-9221-188490f4ad5f
:END:

This shows all headlines that make up the branch of the current headine and
their children. This is the typical behavior you would expect in any outlining
program.

As it stands =org-mode= will keep the parents of a headline you jump to akwardly
hidden.

#+begin_src emacs-lisp
(defun org%show-branch ()
  "Reveal the current org branch.
Show all of the current headine's parents and their children. This includes this
headline."
  (save-excursion
    (loopy (before-do (org-back-to-heading t)
		      (outline-show-children))
	   (while (org-up-heading-safe))
	   (do (outline-show-children)))))
#+end_src

***** show as much of the heading as possible
:PROPERTIES:
:ID:       26700e25-7939-459a-b483-56b882d41f66
:END:

Typically when we jump to a headline we want to see its contents.

#+begin_src emacs-lisp
#+end_src

***** show branch after jumping to point
:PROPERTIES:
:ID:       251e5df0-0a7d-4bf9-8fd9-69991d89a074
:END:

Note that I use points to store the heading points and go back to them inreverse
order. This is important because org does not unfold headlines properly if you
start from an invisible subheading.

Notably, I do not try to conserve the return value of =xl/goto-line= or
=xl/jump-to-headline= because these functions are and should only be used for
their side-effects.

#+begin_src emacs-lisp
(defadvice! show-current-branch-in-org-mode (:after xl/goto-line org/goto-headline)
  "Properly unfold nearby headlines and reveal current headline."
  (when (eq major-mode 'org-mode)
    (org%show-branch)))
#+end_src

**** return
:PROPERTIES:
:ID:       8314f2e0-da63-4f2f-ad89-b97987ca5843
:END:

#+begin_src emacs-lisp
(defun org/dwim-return ()
  "Do what I mean."
  (interactive)
  (cond ((org-at-heading-p)
         (org/insert-heading-below))
        (t
         (call-interactively #'org-return))))
#+end_src

***** next-line
:PROPERTIES:
:ID:       63c8c25d-4b79-41ac-96ef-276913ce5e51
:END:

#+begin_src emacs-lisp
(defun org/dwim-next-line (&optional backward)
  "Go to the start of the next heading.
If DIR is a negative integer, go the opposite direction: the start of the
  previous heading."
  (interactive)
  (outline-next-visible-heading (if backward -1 1))
  (when (org-at-heading-p)
    (org%heading-goto-start)))
#+end_src

**** navigation
:PROPERTIES:
:ID:       3d9ea885-e679-46e5-9541-dea0436d05ec
:END:

***** next-line
:PROPERTIES:
:ID: d8d118a7-78e8-4602-81b3-17fd1d8ab79c
:END:

#+begin_src emacs-lisp
(defun org/dwim-next-line (&optional backward)
  "Go to the start of the next heading.
If DIR is a negative integer, go the opposite direction: the start of the
  previous heading."
  (interactive)
  (outline-next-visible-heading (if backward -1 1))
  (when (org-at-heading-p)
    (org%heading-goto-start)))
#+end_src

***** previous-line
:PROPERTIES:
:ID:       682ec141-fb93-4b55-9c3d-d40aacada205
:END:

#+begin_src emacs-lisp
(defun org/dwim-previous-line (&optional forward)
  (interactive)
  (funcall #'org/dwim-next-line (not forward)))
#+end_src

**** inserting
:PROPERTIES:
:ID:       9ff51c40-5b4a-4861-834f-df1ddb0fc709
:END:

In my eyes, many Org functions are unnecessarily complicated and long. Often they
need to perform a simple task (like inserting a heading) but lose their
fundamental purpose in their inclusion of numerous obscure and opinionated
options. For this reason I wrote my own insert heading functions.

***** newlines between headings
:PROPERTIES:
:ID:       995ac71b-8428-4eec-83ac-1ba50383f600
:END:

#+begin_src emacs-lisp
(defvar org%newlines-between-headings "\n\n"
  "Number of newlines between headings.")
#+end_src

***** heading above
:PROPERTIES:
:ID:       545a9192-b312-4667-b4f0-000ddb47b4a1
:END:

#+begin_src emacs-lisp
(defun org/insert-heading-above (&optional below)
  "Insert a heading above the current heading."
  (interactive)
  (funcall #'org/insert-heading-below (not below)))
#+end_src

***** heading below
:PROPERTIES:
:ID: b059a431-e29c-4f2c-ab5e-8d2d02636405
:END:

#+begin_src emacs-lisp
(defun org/insert-heading-below (&optional above)
  "Insert heading below."
  (interactive)
  (let* ((on-heading-p (ignore-errors (org-back-to-heading)))
         (newlines org%newlines-between-headings)
         (level (or (org-current-level) 1))
         (heading (concat (make-string level ?*) "\s")))
    (cond ((not on-heading-p)
           (insert heading))
          (above
           (goto-char (line-beginning-position))
           (insert heading)
           (save-excursion (insert newlines)))
          (t ; below
           (org-end-of-subtree)
           (insert (concat newlines heading))))
    ;; From `org-insert-heading'
    (pcase (get-char-property-and-overlay (point) 'invisible)
      (`(outline . ,o)
       (move-overlay o (overlay-start o) (line-end-position 0)))
      (_ nil))
    (run-hooks 'org-insert-heading-hook)))
#+end_src

***** subheading
:PROPERTIES:
:ID:       38cc6c74-4b2c-4aa8-b672-86bb7f4fcd7d
:END:

#+begin_src emacs-lisp
(defun org/insert-subheading ()
  "Insert subheading below current heading."
  (interactive)
  (org/insert-heading-below)
  (org-demote))
#+end_src

***** elisp block
:PROPERTIES:
:ID:       e03149e3-500f-45d6-a4c1-b2f69947b4d5
:END:

#+begin_src emacs-lisp
(defun org/dwim-insert-elisp-block ()
  "Insert elisp block."
  (interactive)
  (save-excursion
    (unless (org-at-heading-p)
      (org-back-to-heading))
    (org-end-of-subtree)
    (goto-char (line-end-position))
    (insert (concat "\n\n"
                    "#+begin_src emacs-lisp"
                    "\n"
                    "#+end_src"))
    (forward-line -1)))
#+end_src

**** org choose tags
:PROPERTIES:
:ID:       b8b0c3a2-2cdc-424f-9cd6-ef3ad3d1512c
:END:

#+begin_src emacs-lisp
(defun org/choose-tags ()
  "Select tags to add to headline."
  (interactive)
  (let* ((current (org-get-tags (point)))
         (selected (->> (org-get-buffer-tags)
                        (completing-read-multiple "Select org tag(s): "))))
    (alet (-distinct (append (-difference current selected)
                             (-difference selected current)))
      (org-set-tags it))))
#+end_src

**** dwim insert source block
:PROPERTIES:
:ID:       0025e89d-23a9-42bf-87bb-a4f6d8fbe5a3
:END:

#+begin_src emacs-lisp
(defun org/dwim-edit-source-block ()
  "Edit close source block from point."
  (interactive)
  (unless (org-in-src-block-p)
    (org-next-block 1))
  (org-edit-src-code))
#+end_src

**** eval
:PROPERTIES:
:ID:       1a7d5dde-ab85-4159-b3c7-9da093a30de0
:END:

#+begin_src emacs-lisp
(defun org/dwim-eval-block ()
  "Eval block contents."
  (interactive)
  (unless (org-at-heading-p)
    (user-error "Not in source block"))
  (save-window-excursion
    (org-babel-execute-subtree)))
#+end_src

*** suppress deleting-windows
:PROPERTIES:
:ID:       9a991acc-a24c-4b28-bafa-876a7f973b90
:END:

Org has a nasty tendency of deleting windows. This advice needs to be added to
various functions in org mode.

#+begin_src emacs-lisp
(defun xl--suppress-delete-windows-advice (orig-fn &rest args)
  "Inhibit the deletion of windows."
  (cl-letf (((symbol-function #'delete-window) #'ignore)
	    ((symbol-function #'delete-other-windows) #'ignore))
    (apply orig-fn args)))
#+end_src

*** org
:PROPERTIES:
:ID:       b0aa3f0b-876a-4527-b8ba-4fdac5e7ebe8
:END:

#+begin_src emacs-lisp
(use-package org
  :xl-advice
  (org-add-log-note . suppress-delete-windows)
  (org-fast-tag-selection . suppress-delete-windows)
  (org-fast-todo-selection . suppress-delete-windows)
  :set
  (org-directory                      . (concat "~/Documents/org/"))
  (org-default-notes-file             . (concat org-directory "notes.org"))
  (org-fontify-emphasized-text        . t)
  (org-hide-emphasis-markers          . t)
  (org-pretty-entities                . t)
  (org-fontify-whole-heading-line     . t)
  (org-fontify-done-headline          . t)
  (org-fontify-quote-and-verse-blocks . t)
  (org-adapt-indentation              . nil)
  (org-cycle-separator-lines          . 2)
  (outline-blank-line                 . t)
  (org-enforce-todo-dependencies      . t)
  (org-use-fast-tag-selection         . nil)
  (org-tags-column                    . 0)
  (org-log-done                       . 'time))
#+end_src

*** tangld
:PROPERTIES:
:ID:       03016895-7b3a-4809-a72d-ae635c3f0d01
:END:

=tangled= is currently in its early development stages--meaning it is not
working yet.

#+begin_src emacs-lisp
(use-package tangld)
#+end_src

**** org-annotate-code
:PROPERTIES:
:ID:       a8c5199d-1f4d-44a5-b6f1-2f8f264b181d
:END:

This package lets you annotate files in a separate org file.

#+begin_src emacs-lisp
(use-package org-annotate-code
  :set (org-annotate-code-org-file . (concat XL-ORG-DIR "annotations.org")))
#+end_src

*** org-archive
:PROPERTIES:
:ID:       e53743e9-79ec-42b9-9a4e-5aa87fe936ac
:END:

#+begin_src emacs-lisp
(use-package org-archive
  :set
  (org-archive-location . (concat org-directory "archive.org::")))
#+end_src

*** org-super-links
:PROPERTIES:
:ID:       f3eed884-408f-44cb-becc-17c1431060c5
:END:

#+begin_src emacs-lisp
(use-package org-superlinks
  :commands org-super-links-link
  :set
  (org-super-links-backlink-prefix      . nil)
  (org-super-links-related-into-drawer  . "LINKS")
  (org-super-links-backlink-into-drawer . "LINKS"))
#+end_src

*** org-link-minor-mode
:PROPERTIES:
:ID:       25b93a1f-b105-47aa-9647-5015d23a4ac3
:END:

This is a minor mode for displaying links in non-org buffers.

#+begin_src emacs-lisp
(use-package org-link-minor-mode
  :hook outshine-mode-hook)
#+end_src

*** org-todo-keywords
:PROPERTIES:
:ID:       aaa98680-d9b4-4726-b3ba-a50b3442e8e8
:END:

I like the terms "issue" and "closed" because they are more general than the
corresponding "todo" and "done". "Issue" simply implies a problem that needs to
be fixed. When I use =todo= I feel obligated to write what I have to do and
often I don't know that. Who knows? It could even be that nothing needs to be
done.

#+begin_src emacs-lisp
(set! org-todo-keywords
      '((sequence "TODO" "NEXT" "|" "DONE" "CANCELLED")))
#+end_src

*** org-ml
:PROPERTIES:
:ID:       7f3ec0ad-45f8-4100-970e-773cfb9a625b
:END:

#+begin_src emacs-lisp
(use-package org-ml)
#+end_src

*** org-journal
:PROPERTIES:
:ID:       c3056303-5fa1-49f9-ae2d-294942e25f54
:END:

=org-journal= is a package that provides functions to maintain a simple
diary/journal using =org-mode=.

#+begin_src emacs-lisp
(use-package org-journal
  :commands org-journal-new-entry
  :set
  (org-journal-file-type . 'yearly)
  (org-journal-find-file . 'find-file)
  (org-journal-dir       . (concat org-directory "journal/")))
#+end_src

*** org-src
:PROPERTIES:
:ID:       e00378a1-adcf-4e83-8533-b6b442b5f362
:END:

#+begin_src emacs-lisp
(use-package org-src
  :idle-require t
  :rule ("bottom" "org source" :newfile "\\*Org Src")
  :set
  (org-src-window-setup                        . 'plain)
  (org-src-ask-before-returning-to-edit-buffer . nil)
  (org-edit-src-persistent-message             . nil)
  (org-src-preserve-indentation                . t)
  (org-confirm-babel-evaluate                  . nil)
  (org-src-tab-acts-natively                   . t)
  (org-src-fontify-natively                    . t)
  (org-babel-default-header-args               . '((:session . "none")
						   (:results . "silent")
						   (:exports . "code")
						   (:cache   .   "no")
						   (:initeb  .  "no")
						   (:hlines  .  "no")
						   (:tangle  .  "yes"))))
#+end_src

**** bindings in source block
:PROPERTIES:
:ID:       df270638-f6a7-4f0e-abe7-dd0c4e7df7ce
:END:

Note that you should have bindings that are different for entering and exiting
source blocks.

#+begin_src emacs-lisp
(defhook! enable-org-exit-src-bindings (org-src-mode-hook)
  ;; "," (list :def #'org-edit-src-exit  :wk "exit source block")
  ;; "a" (list :def #'org-edit-src-abort :wk "abort source block")
  ;; "c" (list :def #'org-edit-src-exit  :wk "exit source block")
  )
#+end_src

*** org-capture
:PROPERTIES:
:ID:       3225bbc4-9685-4e7b-ae32-41a26780d191
:END:

=org-capture= is a feature that allows you to quickly save a thought that popped
into your head while keeing disctractions to a minimum.

**** org-capture
:PROPERTIES:
:ID:       8fc5d248-ff21-45e4-a48b-57cecd57b7a3
:END:

My capture templates use =ts= and =org-ml= so I make sure to load those library
before org-capture is loaded.

#+begin_src emacs-lisp
(use-package org-capture
  :idle-require t
  :initial-state insert
  :before-call
  (ts     . org-capture)
  (org-ml . org-capture)
  :rule ("bottom" "capture" :newname "\\`CAPTURE-.+")
  :config
  (after! org-agenda
    (callf2 cl-adjoin XL-CAPTURE-FILE org-agenda-files :test #'string=)))
#+end_src

**** remove capture headerline
:PROPERTIES:
:ID:       dacaf33d-3914-49e4-a1d0-e6bb41b1a44e
:END:

By default org capture templates display a header line. This was the answer to [[https://emacs.stackexchange.com/questions/53648/eliminate-org-capture-message][my
question]]. I need to disable =org-capture's= header-line.

#+begin_src emacs-lisp
(defhook! disable-header-line (org-capture-mode-hook)
  "Turn of the header line message."
  (setq-local header-line-format nil))
#+end_src

**** doct
:PROPERTIES:
:ID:       fa37f618-b58c-449b-a216-9d2f80ed12c6
:END:

[[https://github.com/progfolio/doct][doct]] is a package designed to ease writing and understanding capture templates
by allowing you to write them in a declarative style (see [[helpfn:doct][doct docstring]]).
In org mode, capture templates are [[info:org#Capture templates][represented as plain lists]]. This makes
it easy to forget what a certain element meant or to accidentally omit a capture
template element as you're writing it.

#+begin_src emacs-lisp
(use-package doct
  :before-call org-capture)
#+end_src

**** completing-read org-capture
:PROPERTIES:
:ID:       ad2cc056-edda-490a-8cf9-10b370a21dc0
:END:

Org provides it's own default interface for capturing. To be consistent with how
we complete everything else--via [[helpfn:][completing-read]], I create a function which
let's me choose the template via completing-read.

***** capture templates
:PROPERTIES:
:ID:       c4fdb186-3509-42f1-9c3e-8bf80a5e6b47
:END:

#+begin_src emacs-lisp
(defun org-capture%template-list ()
  "Return a list of capture templates."
  (thread-first org-capture-templates
    (org-capture-upgrade-templates)
    (org-contextualize-keys org-capture-templates-contexts)))
#+end_src

***** replacement for =org-capture=
:PROPERTIES:
:ID:       4dd55ff4-7e6e-41f5-82f8-0db597959a17
:END:

#+begin_src emacs-lisp
(defun org-capture/choose-template ()
  (interactive)
  (require 'org-capture)
  (let* ((read-string (-map (fn! (format "%s %s" (car <>) (cadr <>)))
			    (org-capture%template-list)))
	 (selection (completing-read "Capture template: " read-string nil :require-match))
	 (key (car (split-string selection "\s" t))))
    (org-capture nil key)))

(bind! ([remap org-capture] #'org-capture/choose-template))
#+end_src

**** capture templates
:PROPERTIES:
:ID:       a2a3f682-322a-450f-91bf-169d90f040c0
:END:

***** todo
:PROPERTIES:
:ID:       ef103d28-b746-42ba-ac1a-0462a19f03cd
:END:

****** todo capture template string
:PROPERTIES:
:ID:       a58f1de7-2049-4195-abfb-daad93a6ff2a
:END:

Instead of passing in the string I use =org-ml= to print the string.

#+begin_src emacs-lisp
(defun org-capture%todo-template ()
  "Return capture template for an todo."
  (->> (org-ml-build-headline! :title-text "%?")
       (org-ml-headline-set-node-property "ID" (org-id-new))
       (org-ml-set-property :todo-keyword "TODO")
       (org-ml-to-trimmed-string)))
#+end_src

****** template
:PROPERTIES:
:ID:       5fd30ac2-57c1-4249-a5e7-4048e9597dc1
:END:

#+begin_src emacs-lisp
(defmacro doct%set-template! (name &rest rest)
  "Specify the doct arguments to create a capture template."
  (declare (indent defun))
  `(after! org-capture
     (alet (doct (list (list "todo" ,@rest)))
       (cl-callf2 cl-adjoin (car it) org-capture-templates))))
#+end_src

****** todo
:PROPERTIES:
:ID:       2682910c-9620-4cbf-ab71-371ed29e25a1
:END:

#+begin_src emacs-lisp
(doct%set-template! "todo"
  :keys "t"
  :template #'org-capture%todo-template
  :file XL-CAPTURE-FILE
  :prepend t
  :empty-lines 1)
#+end_src

****** annotation
:PROPERTIES:
:ID:       4ec64ef5-b005-4974-8ed8-fbcdc05d828c
:END:

#+begin_src emacs-lisp
(doct%set-template! "annotate"
  :keys "a"
  :type 'plain
  :target #'org-annotate-code-capture-finding-location
  :file org-annotate-code-org-file
  :template "%?")
#+end_src

***** test
:PROPERTIES:
:ID:       e5f5fc62-4791-4f25-ae0a-1517ac5ed598
:HEADER-ARGS: :tangle no
:END:

The purpose of this template is to create tests for specific blocks of code.
This template will add a headline to.

****** template
:PROPERTIES:
:ID:       12a0bbc8-24a3-4d28-b14c-0050d268f901
:HEADER-ARGS: :tangle no
:END:

#+begin_src emacs-lisp
(defun org-capture%test-template ()
  "Return capture template for an todo."
  (->> (org-ml-build-headline! :title-text "%?")
       (org-ml-headline-set-node-property "ID" "1234")
       (org-ml-to-trimmed-string)))
#+end_src

****** test
:PROPERTIES:
:ID:       c5456618-d2d8-4347-aa2a-dfbf487046bd
:END:

#+begin_src emacs-lisp
(doct%set-template! "test"
  :keys "T"
  :template #'
  :file XL-TEST-FILE
  :prepend t
  :empty-lines 1)
#+end_src

***** question
:PROPERTIES:
:ID:       28b75872-0ed1-4852-8838-f015f0000bd5
:HEADER-ARGS: :tangle no
:END:

The purpose of this template is to create headlines for questions I'd like
answered.

*** org-clock
:PROPERTIES:
:ID:       d378471c-89df-48c9-a755-b79880f27308
:END:

=org-clock= is a built-in package that provides time logging functions for
tracking the time you spend on a particular task.

#+begin_src emacs-lisp
(use-package org-clock
  :idle-require t
  :commands org-clock-in org-clock-goto
  :hook (kill-emacs-hook . org-clock-save)
  :set
  (org-clock-persist      . 'history)
  (org-clock-persist-file . (concat XL-CACHE-DIR "org-clock-save.el"))
  (org-clock-in-resume    . t)
  :config
  (org-clock-persistence-insinuate))
#+end_src

*** org-ql
:PROPERTIES:
:ID:       f2b2f464-f9f0-4ba4-9808-4bf5cb75aaf8
:END:

This package provides an org query language for looking up org headline.

#+begin_src emacs-lisp
(use-package org-ql)
#+end_src

*** calfw
:PROPERTIES:
:ID:       4b317202-0f4c-40e9-b708-484cd995c9b8
:END:

This package displays a calendar.

#+begin_src emacs-lisp
(use-package calfw)
#+end_src

*** org-agenda
:PROPERTIES:
:ID:       389bcdde-e2fb-401d-b4ec-47c73c8cf545
:END:

For any todo workflow, having a way to get an overview of the essential tasks
for a certain block of time is a must. =org-agenda= is this overview.

**** org-agenda
:PROPERTIES:
:ID:       efa9d237-b055-4bfb-a1f9-86d964b5f007
:END:
:LINKS:
[[info:org#Weekly/daily agenda][info:org#Weekly/daily agenda]]
:END:

#+begin_src emacs-lisp
(use-package org-agenda
  :idle-require t
  :rule ("top" "org agenda" :newname "\\*Org Agenda\\*")
  :before-call (org-ql . org-agenda)
  :gc-pause org-agenda-list
  :xl-advice (org-agenda-get-restriction-and-command . suppress-delete-windows)
  :set
  (org-agenda-include-diary . t)
  (org-agenda-text-search-extra-files . '(agenda-archives))
  (org-agenda-skip-unavailable-files  . t)
  (org-agenda-files                   . (list XL-CAPTURE-FILE))
  (org-agenda-start-on-weekday        . 0)
  (org-agenda-timegrid-use-ampm       . nil)
  (org-agenda-time-leading-zero       . t)
  (org-agenda-dim-blocked-tasks       . t)
  (org-agenda-inhibit-startup         . t))
#+end_src

**** respect display-buffer
:PROPERTIES:
:ID:       50933d82-1208-481d-8dc7-42630f3f3b41
:END:

=org= functions are known to try to configure buffer displays themselves. This
forces agenda view to rely on [[helpvar:display-buffer-alist][display-buffer-alist]] for it's display.

#+begin_src emacs-lisp
(defadvice! use-display-buffer (:override (abuf filter-alist) org-agenda-prepare-window)
  "Use `display-buffer' to display the agenda buffer.
Unlike `org-agenda-prepare-window', this function does not store the window configuration."
  (display-buffer abuf)
  (setq org-agenda-tag-filter (cdr (assq 'tag filter-alist)))
  (setq org-agenda-category-filter (cdr (assq 'cat filter-alist)))
  (setq org-agenda-effort-filter (cdr (assq 'effort filter-alist)))
  (setq org-agenda-regexp-filter (cdr (assq 're filter-alist)))

  (unless (equal (current-buffer) abuf)
    (pop-to-buffer-same-window abuf)))
#+end_src

**** filter candidates in agenda command
:PROPERTIES:
:ID:       377ded57-7431-4929-8be9-e04f8f172c38
:END:
:LINKS:
https://emacs.stackexchange.com/questions/53028/how-to-show-only-time-grid-without-todo-items-in-org-agenda
https://emacs.stackexchange.com/questions/15309/is-there-a-way-to-show-an-agenda-with-just-a-time-grid
:END:

The goal is to achieve, an agenda with only items in the time grid. There was a
[[https://emacs.stackexchange.com/questions/15309/is-there-a-way-to-show-an-agenda-with-just-a-time-grid][question]] asked about this. This is theoretically possible by creating a
skip function that skips all items that aren't in the time frame of the grid.
Ideally, what we'd want is to use =org-ql=.

Fortunately, there's a function =org-= that takes a =POM= (point or marker)
which is perfect for getting the agenda.

#+begin_src emacs-lisp
(defun org-agenda%skip-if-not-today ()
  (let* ((time (org-entry-get (point) "DEADLINE"))
	 (dtime (when time (ts-parse-org time)))
	 (now (ts-now)))
    (if (and dtime
	     (= (ts-day dtime) (ts-day now))
	     (= (ts-year dtime) (ts-year now))
	     (= (ts-month-num dtime) (ts-month-num now)))
	nil
      (org-entry-end-position))))
#+end_src

**** org-agenda-custom-commands
:PROPERTIES:
:ID:       b7023041-df49-4750-8b27-91b7175bd1ee
:END:
:LINKS:
https://llazarek.github.io/2018/09/improving-the-agenda-part-2-custom-views.html
https://blog.aaronbieber.com/2016/09/24/an-agenda-for-life-with-org-mode.html
https://orgmode.org/worg/org-tutorials/org-custom-agenda-commands.html
https://github.com/remyhonig/org-query
[[info:org#Filtering/limiting agenda items][info:org#Filtering/limiting agenda items]]
https://github.com/alphapapa/org-ql
:END:

The default org agenda display is pretty crude, particularly with several items.
To customize the default agenda view you can checkout
[[helpfvar:org-agenda-custom-commands][org-agenda-custom-commands]]. For sections of the agenda I suggest using
[[helpfn:org-ql-block][org-ql-block]]. It makes things easier and is likely much faster than the default
Emacs. In the future I want to divide these sections into their own function (or
variables?) so that I can easily piece together different agenda views.

#+begin_src emacs-lisp
(setq org-agenda-custom-commands
      '(("c" "My custom agenda"
         ((agenda ""
	   ((org-agenda-span 'day)
	    (org-agenda-overriding-header "")
	    (org-agenda-skip-function #'org-agenda%skip-if-not-today)))
	  (org-ql-block '(and (todo "TODO") (deadline))
	   ((org-ql-block-header "Most Pressing Todos")
	    (org-agenda-sorting-strategy '(deadline-down priority-up))
	    (org-agenda-max-entries 5)))
	  (org-ql-block '(and (todo "TODO") (tags "emacs") (deadline))
	   ((org-ql-block-header "Emacs Tasks")
	    (org-agenda-sorting-strategy '(deadline-down))
	    (org-agenda-max-entries 5)))))))
#+end_src

**** call custom agenda directly
:PROPERTIES:
:ID:       bb813af0-118a-49ff-ae69-4d4995dadcac
:END:

I don't like the org mode agenda dispatcher--or any of org-mode's interfaces to
be exact. Therefore, I define a function I can use instead.

#+begin_src emacs-lisp
(defun xl/org-agenda ()
  (interactive)
  (org-agenda nil "c"))
#+end_src

*** org-refile
:PROPERTIES:
:ID:       84874c02-f683-4d24-9f17-b11c8940a0b2
:END:

**** org-refile
:PROPERTIES:
:ID:       6dfc0415-2945-4259-a782-b569fcb397ea
:END:

=org-refile= is a built-in package that.

#+begin_src emacs-lisp
(use-package org-refile
  :idle-require t
  :set
  (org-refile-targets                     . `((,XL-README-FILE . (:level . 10))))
  (org-refile-use-outline-path            . 'file)
  (org-refile-allow-creating-parent-nodes . t)
  (org-reverse-note-order                 . t)
  (org-outline-path-complete-in-steps     . nil))
#+end_src

**** refile in current buffer
:PROPERTIES:
:ID:       c24b2065-4533-4e43-80a9-c1b2c891ead8
:END:

#+begin_src emacs-lisp
(defun org/refile-to-current-file (arg &optional file)
  (interactive "P")
  (let ((org-refile-targets `((,XL-README-FILE :maxlevel . 10)))
	(org-refile-use-outline-path t)
	(selectrum-should-sort nil)
        (org-refile-keep arg)
        current-prefix-arg)
    (call-interactively #'org-refile)))
#+end_src

*** org-goto
:PROPERTIES:
:ID:       900250ad-ed09-4000-ab1c-be9f4d461951
:END:

#+begin_src emacs-lisp
(use-package org-goto
  :xl-advice (org-goto-location . suppress-delete-windows))
#+end_src

*** ox
:PROPERTIES:
:ID:       5f8eac7d-cc1f-4bba-bd65-77ead98c8e0c
:END:

This package stands for "org-export".

#+begin_src emacs-lisp
(use-package ox
  :xl-advice (org-export--dispatch-ui . suppress-delete-windows))
#+end_src

*** org-id
:PROPERTIES:
:ID:       95f2a096-2cf4-4634-aa32-13f00b31ea19
:END:

=org-id= is a built-in package that creates that provides tools for creating and
storing universally unique IDs. This is primarily used to disguish and
referenance org headlines.

#+begin_src emacs-lisp
(use-package org-id
  :idle-require t
  :hook (org-insert-heading-hook . org-id-get-create)
  :set
  (org-id-locations-file-relative . t)
  (org-id-link-to-org-use-id      . 'create-if-interactive-and-no-custom-id)
  (org-id-locations-file          . (concat XL-CACHE-DIR "org-id-locations"))
  (org-id-files                   . (list (f-full "~/README.org"))))
#+end_src

*** org-superstar
:PROPERTIES:
:ID:       c4428756-a804-47e8-9586-f63b82dd1561
:END:

#+begin_src emacs-lisp
(use-package org-superstar
  :hook org-mode-hook
  :set
  (org-superstar-leading-bullet     . ?\s)
  (org-superstar-special-todo-items . t))
#+end_src

*** org-fancy-priorities
:PROPERTIES:
:ID:       c4ff4407-774c-4028-bb9d-01412fdfc8d2
:END:

#+begin_src emacs-lisp
(use-package org-fancy-priorities
  :hook org-mode-hook)
#+end_src

*** org-pretty-tags
:PROPERTIES:
:ID:       7f024968-89ea-4e24-90a9-63771d8342b3
:END:

#+begin_src emacs-lisp
(use-package org-pretty-tags
  :hook org-mode-hook)
#+end_src

*** org-toc
:PROPERTIES:
:ID:       aca910e9-364f-4631-a7eb-d7d6275b6472
:END:

This package creates a table of contents for your org file at the first headline
with the tag =:TOC:= on it. As you might have guessed [[helpvar:toc-org-max-depth][toc-org-max-depth]] is the
maximum dept at which toc will make the table of contents.

#+begin_src emacs-lisp
(use-package toc-org
  :hook org-mode-hook
  :set
  (toc-org-max-depth . 2))
#+end_src

*** org-babel
:PROPERTIES:
:ID:       bac221d6-ab49-425f-8f89-d2bf741d3b3d
:END:

As I've mentioned, org-babel is increadibly slow. So slow that I don't think
even increasing the gc-cons-threshold will help enough. But here goes nothing.

#+begin_src emacs-lisp
(use-package ob-tangle
  :gc-pause org-babel-tangle)
#+end_src

* asthetic
:PROPERTIES:
:ID:       d7d657d2-6eb7-4840-ae67-b3a84b100fd9
:END:

It's easy to underestimate how much of a difference having an asthetically
pleasing Emacs configuration can have. Ugliness really can take its toll.

** text scaling
:PROPERTIES:
:ID:       5d242d0e-eeab-46de-bcee-ecfd79b2bffc
:END:

I change the text scale frequently because in some cases, such as viewing my
main org file, I want a birds-eye view where I can see the structure of a
document at a glance. However, when I'm doing something like editing a source
block I want to focus on a very specific thing totally; therefore, I want the
text to take up most of the screen.

*** zoom-frm
:PROPERTIES:
:ID:       15b8577e-3f98-420a-81a5-c7b91292aca3
:END:

This package increases or decreases the font of the current frame. It differs
from [[helpfn:text-scale-increase][text-scale-increase]] and [[helpfn:text-scale-decrease][text-scale-decrease]] in that it applies this
"zooming" to the whole frame instead of the current buffer.

#+begin_src emacs-lisp
(use-package zoom-frm
  :set
  (frame-zoom-font-difference . 0.5)
  (zoom-frame/buffer          . 'buffer))
#+end_src

** hide-mode-line
:PROPERTIES:
:ID:       e8f53422-9d24-4119-9b0f-9b6d1e10c1b0
:END:

#+begin_src emacs-lisp
(use-package hide-mode-line
  :commands hide-mode-line-mode)
#+end_src

** emojis
:PROPERTIES:
:ID:       d3e15439-f690-4ced-b701-0882fb911a5c
:END:

This is a package that displays emojis! :D A major focus of my config is having
the ability to express myself well--in ways that is simply impossible with mere
documentation. This includes using emojis. Also, using emojis makes
documentation *much* more fun. :joy-cat:

#+begin_src emacs-lisp
(use-package emojify
  :hook org-mode-hook
  ;; :on-install (emojify-in)
  :set
  (emojify-emojis-dir . (concat XL-CACHE-DIR "emojis/")))
#+end_src

** mini-modeline
:PROPERTIES:
:ID:       51768ba1-170f-497b-9479-541e7c6aadd6
:END:

*** setup
:PROPERTIES:
:ID:       d9acb47b-089f-4b18-8fdd-94ffefb2ef86
:END:

These variables do stuff with displaying lines and separators to make the
modeline more visible. I do that myself with =window-divider= so I don't need
this.

#+begin_src emacs-lisp
(use-package mini-modeline
  :demand t
  :hook (emacs-startup-hook . mini-modeline-mode)
  :set
  (mini-modeline-enhance-visual . nil)
  (mini-modeline-display-gui-line . nil))
#+end_src

*** default face
:PROPERTIES:
:ID:       1aab03cd-83b2-4d3a-bf3b-71f52dc6158d
:END:

If you don't set this, mini-modeline's background color won't
update with the theme. This is probably what the default value of this
variable should be anyway.

#+begin_src emacs-lisp
(use-package mini-modeline
  :set
  (mini-modeline-face-attr . '(:inherit default)))
#+end_src

*** left format
:PROPERTIES:
:ID:       a7d11a8b-e792-43e5-9992-10df562e17ea
:END:

#+begin_src emacs-lisp
(setq mini-modeline-l-format
      '("%e" mode-line-buffer-identification))
#+end_src

*** right format
:PROPERTIES:
:ID:       fd79e9cb-40d7-4320-9b1d-248da4330bca
:END:

#+begin_src emacs-lisp
(setq mini-modeline-r-format
      '("%e"
	(:eval (awhen (mini-modeline:display-current-workgroup)
		(concat it " ")))
	(:eval (format-time-string "%a %m/%d %T"))))
#+end_src

*** set the modeline display
:PROPERTIES:
:ID:       37f062a8-b9d9-4533-ba8e-d675a1d5f10a
:END:

#+begin_src emacs-lisp
(defun mini-modeline:display-current-workgroup ()
  "Return the name of the current workgroup."
  (awhen (and (featurep 'workgroups2)
	      (wg-workgroup-name (wg-current-workgroup)))
    it))
#+end_src

*** dont redisplay
:PROPERTIES:
:ID:       b3afd056-7b0a-485f-8691-5cc7e4765ca1
:END:

Enabling =mini-modeline-mode= triggers a call to [[helpfn:redisplay][redisplay]]. During startup, this
takes a long time and makes emacs unresponsive for a few seconds. This redisplay
does not seem to be needed (feebleline doesn't do it and it works fine).

#+begin_src emacs-lisp
(defadvice! dont-redisplay (:around mini-modeline-mode)
  (cl-letf (((symbol-function #'redisplay) #'ignore))
    (apply <orig-fn> <args>)))
#+end_src

** info
:PROPERTIES:
:ID:       d49f83c4-ba8f-477e-beef-8156ed8b974b
:END:

This headline is for customizing info nodes.

#+begin_src emacs-lisp
(use-package info
  :rule ("top" "info" :newname "\\*info"))
#+end_src

** helpful
:PROPERTIES:
:ID:       5340ddb3-92bc-42e5-bf0e-9f9650c41cd9
:END:

[[github:wilfred/helpful][helpful]] provides a complete replacement for the built-in Emacs help facility
which provides much more contextual information in a better format.

#+begin_src emacs-lisp
(use-package helpful
  :rule ("bottom" "help" :newname "\\*help.+"))

(bind!
 ([remap describe-function] #'helpful-callable)
 ([remap describe-command]  #'helpful-command)
 ([remap describe-variable] #'helpful-variable)
 ([remap describe-key]      #'helpful-key))
#+end_src

** dashboard
:PROPERTIES:
:ID: 20926522-b78b-4bca-b70e-9ef4213c4344
:END:

[[https://github.com/emacs-dashboard/emacs-dashboard][dashboard]] is an extensible emacs startup screen. I love the idea of =dashboard=:
having an extensible, fast, nice-looking dashboard when starting emacs is
nice. It's not only nice asthetically, it's also strategic too. First, you can
use it as a launching point to get to your tasks quicker. And second, it doesn't
require any expensive modes. I've often been starting out with the scratch
buffer and I've wanted to have the scratch buffer start off with
=emacs-lisp-mode=, but I don't want it to trigger =company=, =yasnippet=, etc. on
startup. If I start my emacs with =dashboard= I can avoid this.

*** random logo
:PROPERTIES:
:ID:       80e5fa17-d18a-4ec0-af8d-728d77843c69
:END:

=dashboard= provides three text pictures which are referred to by number and two
images which referred to by the symbols =official= and =logo=.

#+begin_src emacs-lisp
(defun dashboard%random-logo ()
  "Display a random logo."
  (seq-random-elt
   (append '(1 2 3) (if (display-graphic-p) '(official logo)))))
#+end_src

*** require
:PROPERTIES:
:ID:       73d00f99-4b70-44d1-8359-01bd2c94b330
:END:

#+begin_src emacs-lisp
(use-package dashboard
  :demand t
  :hook (window-setup-hook . dashboard-insert-startupify-lists)
  :set
  (dashboard-items . nil)
  (dashboard-startup-banner . (dashboard%random-logo))
  (dashboard-center-content . t)
  (initial-buffer-choice . #'startup%initial-buffer-choice))
#+end_src

*** open dashboard at startup
:PROPERTIES:
:ID:       1bcc371e-61fa-480e-bdae-4a999d3b10c9
:END:

#+begin_src emacs-lisp
(defadvice! open-dashboard-instead (:around startup%initial-buffer-choice)
  (get-buffer-create "*dashboard*"))
#+end_src

*** dashboard-init-info
:PROPERTIES:
:ID:       09019b05-a696-4b15-a5f8-b36b23c42e1a
:END:

[[helpvar:xl-init-time][xl-init-time]] is more accurate than dashboard's init time measure. So I use it
instead.

#+begin_src emacs-lisp
(defadvice! show-package-load-time (:before dashboard-insert-startupify-lists)
  (setq dashboard-init-info
        (format "%d packages loaded in %.2f seconds"
                (cond ((featurep 'straight)
		       (hash-table-size straight--profile-cache))
                      ((featurep 'package)
		       (length package-activated-list))
                      (t
		       0))
                (string-to-number (emacs-init-time)))))
#+end_src

*** add icons to dashboard
:PROPERTIES:
:ID:       d4714639-919c-4691-9f7f-004cfa627089
:END:

#+begin_src emacs-lisp
#+end_src

** window divider
:PROPERTIES:
:ID:       2cdd6e24-5153-4585-8f1f-206b33445359
:END:

Emacs can add border to windows using a mode called [[helpfn:window-divider-mode][window-divider-mode]].
Often in emacs you have multiple windows displaying different buffers on the
screen. By default the border between these windows is very thin, so it can be
hard to distinguish windows sometimes. The point of adding borders to windows is
to distinguish them easily from one another.

Window dividers are useful in general so I don't get confused about when one
window ends and another begins (see [[helpfn:window-divider-mode][window-divider-mode]]). When using [[I like emacs][exwm]] it
makes emacs feel like a window manager with gaps.

*** init
:PROPERTIES:
:ID:       c3e2fda8-89c8-4f3b-951a-113e936d6206
:END:

#+begin_src emacs-lisp
(use-package window-divider
  :hook (window-setup-hook . window-divider-mode)
  :set
  (window-divider-default-bottom-width . 7)
  (window-divider-default-right-width  . 7)
  (window-divider-default-places       . t))
#+end_src

*** window divider face
:PROPERTIES:
:ID:       61157149-dcce-40a9-8bfa-76a6af24838a
:END:

#+begin_src emacs-lisp
(defhook! set-window-divider-face (load-theme)
  :config window-divider
  (set-face-foreground 'window-divider "black"))
#+end_src

*** update on theme change
:PROPERTIES:
:ID:       ceff91e5-8172-4b26-81de-681c0864bc4b
:END:

#+begin_src emacs-lisp
(defhook! update-window-divider (xl-after-load-theme-hook)
  "Ensure window divider persists after theme change."
  :config window-divider
  (unless (bound-and-true-p window-divider-mode)
    (window-divider-mode 1)))
#+end_src

*** adjust window divider gap size
:PROPERTIES:
:ID:       5485c926-fac0-4e87-ae97-f7bf25d0a55c
:END:

**** TODO increase gap size
:PROPERTIES:
:ID:       867fad5c-b4d4-4cba-929e-0dc23f007c5b
:END:

Somtimes I might want to adjust this.

#+begin_src emacs-lisp
(defun frame:adjust-window-divider-size (amount)
  "Adjust the gap size of window-divider by AMOUNT."
  (general-setq window-divider-default-bottom-width
                (+ amount window-divider-default-bottom-width))
  (general-setq window-divider-default-right-width
                (+ amount window-divider-default-right-width)))
#+end_src

**** increase
:PROPERTIES:
:ID:       ebd6b013-6213-42a1-9e95-fefc7e7da991
:END:

#+begin_src emacs-lisp
(defun frame/increment-window-divider-size ()
  "Increase window divider size."
  (interactive)
  (frame:adjust-window-divider-size 1))
#+end_src

**** decrease
:PROPERTIES:
:ID:       6b1eb1cd-1cfd-4b82-a413-cb61fa13e0a4
:END:

#+begin_src emacs-lisp
(defun frame/decrement-window-divider-size ()
  "Decrease window divider size."
  (interactive)
  (frame:adjust-window-divider-size -1))
#+end_src

** zone
:PROPERTIES:
:ID:       fe176959-3134-4b18-8abb-a962347b8df0
:END:

#+begin_src emacs-lisp
(use-package zone)
#+end_src

** modus themes
:PROPERTIES:
:ID:       b825b4a0-13e4-483e-b793-c0fcd6223897
:END:

#+begin_src emacs-lisp
(use-package modus-themes
  :set
  (modus-themes-syntax . 'green-strings)
  (modus-themes-slanted-constructs . t)
  (modus-themes-bold-constructs . nil)
  (modus-themes-region . 'no-extend)
  (modus-themes-org-blocks . t)
  (modus-themes-no-mixed-fonts . t))
#+end_src

* web browsing
:PROPERTIES:
:ID:       0be0a36f-67dc-4db5-8d0a-321d19bae08a
:END:

** engine-mode
:PROPERTIES:
:ID:       d701f44f-85eb-4849-8f2d-15423eb41a02
:END:

*** init
:PROPERTIES:
:ID:       f5a2c47b-01df-4dcf-b012-b6311cf79683
:END:

#+begin_src emacs-lisp
(use-package engine-mode)
#+end_src

*** different engines
:PROPERTIES:
:ID:       2f5c974e-b26e-4080-a9b3-acd6406ab118
:END:

This package essentially automates the creation of an interactive web searching
functions.

#+begin_src emacs-lisp
(use-package engine-mode :xl-config
  (defengine amazon
    "http://www.amazon.com/s/ref=nb_sb_noss?url=search-alias%3Daps&field-keywords=%s")
  (defengine duckduckgo
    "https://duckduckgo.com/?q=%s")
  (defengine qwant
    "https://www.qwant.com/?q=%s")
  (defengine wikipedia
    "http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s"))
#+end_src

** browse-url
:PROPERTIES:
:ID:       ab7cf98c-47ca-49e1-ba8c-ee52ce04debe
:END:

=browse-url= is a built-in package that provides a uniform interface for
browsing the web.

*** browse-url
:PROPERTIES:
:ID:       e59dc362-5615-45a8-8010-a111ddc5e835
:END:

=browse-url= is a built-in package that provides a useful abstraction for browsing
the web.

#+begin_src emacs-lisp
(use-package browse-url
  :set
  (browse-url-firefox-new-window-is-tab . nil)
  (browse-url-firefox-arguments         . nil)
  (browse-url-new-window-flag           . t)
  :xl-config
  (alet (list (cons (rx "http://www.wikipedia.org/search") #'eww)
	      (cons "." #'browse-url-firefox))
    (setq browse-url-browser-function it)))
#+end_src

** eww
:PROPERTIES:
:ID:       77d23774-7f42-45ee-90ec-5f28efddee65
:END:

*** ability to add new windows
:PROPERTIES:
:ID:       54dc52bb-f7e5-4a86-a306-aa42482cbd6d
:END:

=eww= doesn't create new buffers by default when you do a new search. Instead, it
replaces the existing buffer. I got this code snippet from [[https://stackoverflow.com/questions/28458784/emacs-and-eww-open-links-in-new-window][this-question]].

#+begin_src emacs-lisp
(defhook! create-new-buffer (eww-after-render-hook)
  (let* ((title  (plist-get eww-data :title))
	 (url    (plist-get eww-data :url))
	 (result (concat "*eww-" (or title
				     (if (string-match "://" url)
					 (substring url (match-beginning 0))
				       url)) "*")))
    (rename-buffer result t)))
#+end_src

** w3m
:PROPERTIES:
:ID: e5e13423-bc70-49b0-969e-94897c798d54
:END:

[[http://w3m.sourceforge.net/][w3m]] is a text-based web browser. There are many other text-based browsers out
there, but =w3m= has the benefit of having comprehensive [[https://github.com/emacs-w3m/emacs-w3m][emacs interface]]. Why
use this when you can use the GUI browser? Well, using the Emacs interface I can
view an Emacs webpage as plain text, which means I can perform searches on it
with [[https://github.com/abo-abo/swiper.git][swiper]], or any other Emacs operation on it. Another advantage is that
because the w3m interface's backend is a terminal application, it will (I'm
guessing; no benchmarks made) typically be faster than browsers at rendering
plain text webpages. Of course, the main limitation is that w3m will typically
only display text based web pages well--not ones with lots of interactive
javascript code.

* utility
:PROPERTIES:
:ID:       30be2ae6-3405-4496-8a45-d84caf9bb0c1
:END:

** chess
:PROPERTIES:
:ID:       1197be6f-a2ff-4cf1-8b78-02ebceb43317
:END:

#+begin_src emacs-lisp
(use-package chess)
#+end_src

** mu4e
:PROPERTIES:
:ID:       905ba1b5-bafc-4855-b772-fa750c294327
:END:

=mu4e= is the most popular Emacs email client--and for good reason. It's fast,
tag-based, and has great documentation. One annoying quirk for me is that unlike
all other Emacs packages it does not come uncoupled from the external program it
uses. What this means is that you need to tell Emacs where the mu4e =.el= files
are :pouting-cat:. It also means it's more difficult to incorporate it with the
contribution workflow that [[https://github.com/raxod502/straight.el][straight.el]] encourages. I haven't figured out
how to automate this across multiple OSes.

This is annoying, but minor. =mu4e= itself is a great package.

*** load-path
:PROPERTIES:
:ID:       8b4ab179-11c6-429c-9c8d-9296dfb215dc
:END:

#+begin_src emacs-lisp
(defun mu4e%load-path-guix ()
  "Return load-path for mu4e."
  (loopy (with (regexp "\\`[[:alnum:]]+-mu-\\(?:[[:digit:]]\\|\\.\\)+")
	       (base-dir "/gnu/store/"))
	 (list file (directory-files base-dir))
	 (expr full-path (f-expand file base-dir))
	 (when (and (string-match-p regexp file) (f-dir-p full-path))
	   (expr mu4e-path (f-expand "share/emacs/site-lisp/" full-path))
	   (when (f-dir-p mu4e-path)
	     (return mu4e-path)))))
#+end_src

*** maildir
:PROPERTIES:
:ID:       49debca7-6ae7-40e4-9bd0-73c3bba40539
:END:

#+begin_src emacs-lisp
(defun xl-mail-dir (&rest others)
  (apply #'concat (f-full "~/.mail") others))

(defalias 'mu4e%mail-dir 'xl-mail-dir)
#+end_src

*** list email accounts
:PROPERTIES:
:ID:       0b7dcf44-b245-4ca8-9407-3d3c043e1d96
:END:

I'm storing all my email account passwords using =pass=. I can use the encrypted
files in my pass directory to determine what my email accounts are and, in turn,
how to automate this.

#+begin_src emacs-lisp
(defalias 'mu4e%mail-accounts 'password-store:email-accounts)
#+end_src

*** add mu4e to the load-path
:PROPERTIES:
:ID:       9dccb5e4-5d8e-4da6-99ae-9f8ed3bd8a5d
:END:

#+begin_src emacs-lisp
(use-package mu4e :commands mu4e)
#+end_src

*** mu4e-vars
:PROPERTIES:
:ID:       25cf40b9-901b-40f4-800f-3fa577ee22c3
:END:

=mu4e-var= contains many miscellaneous variables. Some highlights.

#+begin_src emacs-lisp
(use-package mu4e-vars
  :set
  (mu4e-completing-read-function . #'completing-read)
  (mu4e-get-mail-command         . "mbsync -a")
  (mu4e-update-interval          . nil)
  (mu4e-context-policy           . 'pick-first)
  (mu4e-use-fancy-chars          . (display-graphic-p))
  (mu4e-org-support              . t)
  (mu4e-index-cleanup            . t)
  (mu4e-split-view               . 'vertical)
  (mu4e-index-lazy-check         . nil)
  (mu4e-hide-index-messages      . t)
  (mu4e-confirm-quit             . nil))
#+end_src

**** mu4e
:PROPERTIES:
:ID: 565eff90-8626-4ec8-a576-4ff3dfb307ae
:END:

#+begin_src emacs-lisp
(setq mu4e-html2text-command
      (if (executable-find "w3m") "w3m -dump -T text/html" #'mu4e-shr2text))
#+end_src

*** mu4e-views
:PROPERTIES:
:ID:       5ebeddaa-94ae-4acc-9659-5aae8cb4a2f0
:END:

#+begin_src emacs-lisp
(use-package mu4e-view
  :set
  (mu4e-view-show-images     . t)
  (mu4e-view-image-max-width . 800)
  (mu4e-view-show-addresses  . t)
  (mu4e-date-format          . "%c"))
#+end_src

*** mu4e-compose
:PROPERTIES:
:ID:       cd07286d-2a94-4953-99bf-8e06b3edcf15
:END:

#+begin_src emacs-lisp
(use-package mu4e-compose
  :set
  (mu4e-compose-context-policy . 'ask-if-none))
#+end_src

*** mu4e-drafts
:PROPERTIES:
:ID:       5de3eca7-968b-4228-a1d9-ca872f18f58b
:END:

#+begin_src emacs-lisp
(use-package mu4e-drafts
  :set
  (mu4e-compose-signature-auto-include . t)
  (mu4e-compose-format-flowed          . t))
#+end_src

*** mu4e-headers
:PROPERTIES:
:ID:       8bc93633-f3a0-494d-ae61-c05f6490cd87
:HEADER-ARGS: :tangle no
:END:

These are custom icons used to spice up the =mu4e= display.

#+begin_src emacs-lisp
(use-package mu4e-headers
  :set
  (mu4e-headers-auto-update    . t)
  (mu4e-headers-draft-mark     . (cons "D" (all-the-icons-faicon "pencil")))
  (mu4e-headers-flagged-mark   . (cons "F" (all-the-icons-faicon "flag")))
  (mu4e-headers-new-mark       . (cons "N" (all-the-icons-material "fiber_new")))
  (mu4e-headers-passed-mark    . (cons "P" (all-the-icons-faicon "arrow-right")))
  (mu4e-headers-seen-mark      . (cons "S" (all-the-icons-faicon "eye")))
  (mu4e-headers-attach-mark    . (cons "a" (all-the-icons-material "attach_file")))
  (mu4e-headers-replied-mark   . (cons "R" (all-the-icons-faicon "reply")))
  (mu4e-headers-unread-mark    . (cons "u" (all-the-icons-faicon "eye-slash")))
  (mu4e-headers-encrypted-mark . (cons "x" (all-the-icons-octicon "lock")))
  (mu4e-headers-signed-mark    . (cons "s" (all-the-icons-faicon "certificate")))
  (mu4e-headers-trash-mark     . (cons "T" (all-the-icons-faicon "trash"))))
#+end_src

*** mu4e-org
:PROPERTIES:
:ID:       eaa1577b-bcb9-4f6e-9927-8c6d8042dda2
:END:

Mu4e's org integration lets you write emails in org mode and convert it to html
before sending--very interesting indeed :grinning:. I have yet to explore this feature but
it is definitely on my list of things to try out.

#+begin_src emacs-lisp
(use-package mu4e-org
  :hook (mu4e-compose-mode-hook . org-mu4e-compose-org-mode)
  :set
  (mu4e-org-link-query-in-headers-mode . nil)
  (mu4e-org-convert-to-html            . t))
#+end_src

**** hook
:PROPERTIES:
:ID:       fcdbaa17-20c6-4322-baed-27df5a0ad9a2
:END:

Only render to html once. If the first send fails for whatever reason,
org-mu4e would do so each time you try again.

#+begin_src emacs-lisp
(defhook! org-mu4e-render-html-only-once (message-send-hook)
  (setq-local org-mu4e-convert-to-html nil))
#+end_src

*** initializing mu4e
:PROPERTIES:
:ID:       93cffd11-a812-4cda-b7dd-a06f70367afe
:END:

This headline attempts to automate the initialization of mu4e. The goal is for
me to do as little as possible by (by which I mean nothing :joy:) to get a
working mu4e setup. In other words, after I initialize my dotfiles and install
all my system packages, I want mu4e to /just work/. There should be no prompts
asking me to run anything or do anything at all.

The idea is to do preliminary things before the main entry point--the function
[[helpfn:mu4e][mu4e]]--is called.

**** mu4e database location
:PROPERTIES:
:ID:       fe8f10c1-3035-4a97-9657-98236f50d0a8
:END:

This is the place where the mu4e database is stored. The existence of this
database is used to determine whether we'll run =mu init= or not.

#+begin_src emacs-lisp
(defvar mu4e%mu-database-path (expand-file-name "~/.cache/mu/xapian")
  "Path where mu database should go.")
#+end_src

**** init mu4e database
:PROPERTIES:
:ID:       4d107050-db05-4d7e-ae44-4bf356a44fd0
:HEADER-ARGS: :tangle no
:END:

The first time you run =mu= it needs to [initialize it's database]. This is done
with the command =mu init --maildir=~/Maildir=.

#+begin_src emacs-lisp
(defadvice! init-database-maybe (:before mu4e)
  "Initialize the mu4e database if it does not exist."
  (unless (file-exists-p mu4e%mu-database-path)
    (-each (mu4e%mail-accounts)
      (fn! (call-process-shell-command (format "mu init --my-address=%s" <account>))))))
#+end_src

**** ensuring email directories
:PROPERTIES:
:ID:       704b7049-fac5-4fa7-b710-1bbfe50cea5f
:END:

Make sure mail directories exist. =mbsync= will fail if they don't.

#+begin_src emacs-lisp
(defadvice! ensure-mail-dirs (:before mu4e)
  "Create mail directories if they don't exist."
  (mapc (fn! (mkdir <dir> t))
	(mapcar #'mu4e%mail-dir (mu4e:mail-accounts))))
#+end_src

**** contexts
:PROPERTIES:
:ID:       0e580010-d5b2-4708-a7dc-c586908409b5
:END:

[[info:mu4e#What are contexts][Contexts]]. This headline attempts to automate context creation. Context are
probably the hardest part of setting up =mu4e= for elisp. [[https://jherrlin.github.io/posts/emacs-mu4e/][this article]]. If you
don't make contexts, =mu4e= will be confused and think that.

***** default enter and exit
:PROPERTIES:
:ID:       f2e2148b-dcab-4503-a1b1-75e48e35018f
:END:

Contexts provide the ability to specify an enter and exist function for each
context. Right now I haven't had any special idea in mind for what the enter and
leave function =mu4e= provides should do switching to a new context. So for now
all I'll do is log the entering/leaving of a context for debugging purposes.

#+begin_src emacs-lisp
(defun mu4e-context::generate-switch-func (mail-address &optional leave)
  "Return a function that enters the context of MAIL-ADDRESS."
  (let* ((to (if leave 'leave 'enter))
	 (name (xl-symbol-intern 'mu4e-context: mail-address '- to '-func))
	 (message (format "%s %s context." to mail-address))
	 (fn `(lambda () (xl-log ,message))))
    (fset name fn)
    name))
#+end_src

***** enter func
:PROPERTIES:
:ID:       432f2ee9-1c41-4593-b27f-dbc837f8bcd2
:END:

#+begin_src emacs-lisp
(defun mu4e-context::generate-enter-func (email-address)
  (mu4e-context::generate-switch-func mail-address))
#+end_src

***** exit func
:PROPERTIES:
:ID:       0bafa172-2ea6-4b4e-aa4e-1fe2b0808b94
:END:

#+begin_src emacs-lisp
(defun mu4e-context::generate-leave-func (email-address)
  (mu4e-context::generate-switch-func mail-address t))
#+end_src

***** default match fn
:PROPERTIES:
:ID:       41ddf901-0ae9-4b00-bc06-b1b7b49ec8f2
:END:

The match fn take a =message= object. This is for dynamically setting the
context based on what message you're dealing with. Right now, I don't have any
special rules. The rule that I set basically uses the.

#+begin_src emacs-lisp
(defun mu4e-context::generate-match-func (mail-address)
  "Return a default matcher for MAIL-ADDRESS."
  (aprog1 (xl-symbol-intern 'mu4e-context: mail-address '-match-func)
    (fset it
	  `(lambda (msg)
	     (when msg
	       (-any-p (fn! (mu4e-message-contact-field-matches msg <field> ,mail-address))
		       (list :to :from :cc :bcc)))))))
#+end_src

***** default vars
:PROPERTIES:
:ID:       d8892b2c-7056-4d92-819b-8cb4d8c2eeb1
:END:

These are the default.

#+begin_src emacs-lisp
(defun mu4e-context::generate-vars (mail-address)
  "Return default variables for MAIL-ADDRESS."
  (let ((entry (format "email/%s" mail-address))
	(folder (format "/%s" mail-address)))
    `((user-mail-address     . ,mail-address)
      (smtpmail-smtp-server  . ,(password-store-get-field entry "server"))
      (smtpmail-smtp-service . ,(password-store-get-field entry "port"))
      (mu4e-drafts-folder    . ,(concat folder "/drafts"))
      (mu4e-trash-folder     . ,(concat folder "/trash"))
      (mu4e-sent-folder      . ,(concat folder "/sent")))))
#+end_src

***** context arguments
:PROPERTIES:
:ID:       ceb57afe-e899-462c-bc4e-42b284f36605
:END:

#+begin_src emacs-lisp
(defun mu4e-context::context-arguments (mail-address)
  "Return arguments for `mu4e' context."
  (loopy (with (args (list :name mail-address)))
	 (list key '(:enter-func :leave-func :match-func :vars))
	 (expr keyname (xl-keyword-name key))
	 (expr generate-fn (xl-symbol-intern 'mu4e-context:: 'generate- keyname))
	 (expr fn (funcall generate-fn mail-address))
	 (append args (list key fn))))
#+end_src

***** make a context
:PROPERTIES:
:ID:       4e45264d-e7cc-43f7-854b-8b22d4d4151e
:END:

Create a context.

#+begin_src emacs-lisp
(defun mu4e-context::make-context (mail-address)
  "Create a new context with default values."
  (apply #'make-mu4e-context (mu4e-context::context-arguments mail-address)))
#+end_src

***** add a context
:PROPERTIES:
:ID:       c488a02f-743a-492c-9775-5c8216f0b2b0
:END:

#+begin_src emacs-lisp
(defun mu4e-context::add-context (mail-address)
  "Create and add context."
  (push (mu4e-context::make-context mail-address) mu4e-contexts))
#+end_src

***** init contexts
:PROPERTIES:
:ID:       e74512a7-1d1f-4241-b245-5863e7730398
:END:

After mu4e is loaded, setup contexts. In the future, perhaps add this as an
advice before [[helpfn:mu4e][mu4e]] so that I can check if the right emails are set up every
time. This could be useful if I add an email and don't want to restart Emacs.

#+begin_src emacs-lisp
(defhook! init-contexts (mu4e-after-load-hook)
  "Define a context for each email account."
  (-each (password-store:email-accounts) #'mu4e-context::add-context))
#+end_src

** file browsing
:PROPERTIES:
:ID:       324ede5f-4606-40f2-a424-1cdf0c974853
:END:

*** all-the-icons-dired
:PROPERTIES:
:ID:       8e2fe483-5da1-47c7-8d80-a8e68b21fa39
:END:

#+begin_src emacs-lisp
(use-package all-the-icons-dired
  :hook dired-mode-hook)
#+end_src

*** dired
:PROPERTIES:
:ID:       877b66c0-7952-4b37-839a-4a9aa5af164a
:END:

**** dired
:PROPERTIES:
:ID:       8a5f8bb6-dce2-4fac-b9c4-068e39f4cfcc
:END:

If you don't set [[helpvar:dired-recursive-deletes][dired-recursive-deletes]], emacs will prompt you every time you
try to delete a directory asking you whether you want to recursively delete its
contents. If you're actually permenently deleting it this is a good idea to
prevent accidental deletion, but I set [[helpvar:delete-by-moving-to-trash][delete-by-moving-to-trash]] to =t=. So
worst case I'll accidentally move a directory to the trash folder.

#+begin_src emacs-lisp
(use-package dired
  :set
  (dired-recursive-copies                      . 'always)
  (dired-recursive-deletes                     . 'always)
  (dired-hide-details-hide-symlink-targets     . nil)
  (dired-clean-confirm-killing-deleted-buffers . nil))
#+end_src

**** sort directories first
:PROPERTIES:
:ID:       8db5ffba-3f74-4146-96e0-03a46213e77d
:END:

#+begin_src emacs-lisp
(defhook! dired:sort-directories-first (dired-after-readin-hook)
  "List directories first in dired buffers."
  (save-excursion
    (let (buffer-read-only)
      (forward-line 2) ;; beyond dir. header
      (sort-regexp-fields t "^.*$" "[ ]*." (point) (point-max))))
  (and (featurep 'xemacs)
       (fboundp 'dired-insert-set-properties)
       (dired-insert-set-properties (point-min) (point-max)))
  (set-buffer-modified-p nil))
#+end_src

***** create non-existent directory
:PROPERTIES:
:ID:       d6151903-ab72-48d7-b9ef-fd13880d3dd2
:END:

#+begin_src emacs-lisp
(defun dired:create-non-existent-directory-h ()
  "Automatically create missing directories when creating new file."
  (let ((parent-directory (file-name-directory buffer-file-name)))
    (when (and (not (file-exists-p parent-directory))
               (y-or-n-p (format "Directory `%s' does not exist! Create it?" parent-directory)))
      (make-directory parent-directory t))))

(after! dired
  (add-to-list 'find-file-not-found-functions 'dired:create-non-existent-directory-h nil #'eq))
#+end_src

*** ranger
:PROPERTIES:
:ID:       1791aeb9-1146-43c8-85d6-149335eb9d8f
:END:

[[github:ralesi/ranger.el][ranger]] is a file browser built on top of dired that seeks to emulate [[github:ranger/ranger][a VIM
inspired file manager]] of also called =ranger=.

**** make sure that =;= uses =M-x=
:PROPERTIES:
:ID:       c63911ca-6d26-4d7c-be76-246639fb6c7a
:END:

#+begin_src emacs-lisp
(bind!
  (:map ranger-mode-map)
  (";" #'execute-extended-command)
  ("u" #'dired-unmark))
#+end_src

**** entry
:PROPERTIES:
:ID:       19047e0c-927d-46a6-babe-9c096f4fbcc7
:END:

#+begin_src emacs-lisp
(use-package ranger
  :commands deer ranger
  :silence ranger-window-check
  :set
  (ranger-override-dired-mode . t)
  (ranger-cleanup-eagerly     . t)
  (ranger-cleanup-on-disable  . t)
  (ranger-omit-regexp         . "^.DS_Store$")
  (ranger-excluded-extensions .'("mkv" "iso" "mp4"))
  (ranger-deer-show-details   . nil)
  (ranger-max-preview-size    . 10)
  (ranger-modify-header       . t)
  (ranger-hide-cursor         . t)
  (ranger-dont-show-binary    . t))
#+end_src

**** refresh contents
:PROPERTIES:
:ID:       cef37397-53aa-47e1-a519-ef56a311ae30
:END:

Ranger doesn't refresh the buffer after stuff like moving and pasting has
happend. It results in a very jarring display.

#+begin_src emacs-lisp
(defadvice! refresh-contents (:after ranger-paste dired-do-rename)
  "Refresh contents."
  (when (eq major-mode 'ranger-mode)
    (ranger-refresh)))
#+end_src

** avy
:PROPERTIES:
:ID:       78064d92-2dde-4067-8a10-208ca6e88852
:END:

#+begin_src emacs-lisp
(use-package avy
  :set
  (avy-style . 'pre)
  (avy-keys . (number-sequence ?a ?z)))
#+end_src

** man
:PROPERTIES:
:ID:       3982b034-90e1-4961-90d9-224e913c0b8c
:END:

#+begin_src emacs-lisp
(use-package man
  :rule ("left" "man" :newname "\\*man.+"))
#+end_src

** passwords and security
:PROPERTIES:
:ID:       7ca7587e-d94b-408b-8656-c6a09d6ee8b6
:END:

I build my =mbsyncrc= and my =msmtprc= via tangling.

*** pass
:PROPERTIES:
:ID:       6f3268a1-4606-435d-9bf4-05d1c54c28a9
:END:

#+begin_src emacs-lisp
(use-package pass)
#+end_src

*** password-store
:PROPERTIES:
:ID:       3c57590c-1507-4369-b615-795965d4b182
:END:

#+begin_src emacs-lisp
(use-package password-store)
#+end_src

*** email accounts
:PROPERTIES:
:ID:       3a3c6778-dc5d-45cf-87d1-1c6aacbbae46
:END:

Whatever emails I may use, I'll be adding their password in my password store so
why not use this as a way to get email information?

#+begin_src emacs-lisp
(defun password-store:email-accounts ()
  "Return a list of email accounts."
  (->> (expand-file-name "email/" (password-store-dir))
       (directory-files)
       (cddr)
       (mapcar (fn! (s-chop-suffix ".gpg" <>)))))
#+end_src

*** epa
:PROPERTIES:
:ID:       ad3f6134-4fa6-492e-93a6-b94235ecad3d
:END:
:LINKS:
https://vxlabs.com/2021/03/21/gnupg-pinentry-via-the-emacs-minibuffer/
:END:

Setting these variables in coordination with [[id:58a65d49-cd9f-4b5d-86d7-d43209424cf3][my gpg-agent config]] lets me enter my
gpg passphrase via emacs.

#+begin_src emacs-lisp
(use-package epa-config
  :set
  (epg-gpg-program   . "gpg2")
  (epa-pinentry-mode . 'loopback))
#+end_src

** nameless
:PROPERTIES:
:ID:       695aeb73-89d3-47f8-bee8-2721111dd2bf
:END:

=nameless= is a package that truncates namespace prefixes that you specify
in. Shortening aliases allows for more concise, easier to read, and less
redundant code.

#+begin_src emacs-lisp
(use-package nameless
  :hook emacs-lisp-mode-hook
  :set (nameless-private-prefix . t))
#+end_src

** fortune-cookie
:PROPERTIES:
:ID:       8105dadd-4d4a-4f57-a5f9-5cae1b14ef3a
:END:

#+begin_src emacs-lisp
(use-package fortune-cookie
  :commands fortune-cookie)
#+end_src

** figlet
:PROPERTIES:
:ID:       b5be9427-a814-4a91-92ab-ad393375ec41
:END:

#+begin_src emacs-lisp
(use-package figlet :commands figlet)
#+end_src

** grugru
:PROPERTIES:
:ID:       9d96a611-355a-4b62-bb0e-18e9d4af92c9
:END:

#+begin_src emacs-lisp
(use-package grugru)
#+end_src

** system-packages
:PROPERTIES:
:ID:       74bd0e5a-f6b0-48eb-a91e-3932eae23516
:END:

=system-packages= provides an api for installing system packages. This api strives
to abstract package installation on different operating systems. Unfortunately,
it does not include an interactive function that uses [[helpfn:completing-read][completing-read]] to list
packages

*** init
:PROPERTIES:
:ID:       08bf0487-2a57-483d-8d22-8253ebda6d9d
:END:

#+begin_src emacs-lisp
(use-package system-packages
  :rule ("bottom" "system-packages" :newname "\\*system-packages")
  :set (system-packages-noconfirm . t))
#+end_src

*** use yay for arch
:PROPERTIES:
:ID:       2fc48e66-83f3-4e35-8b2c-ef9113cb9b45
:END:

If we're in arch and we have yay intalled, use that.

#+begin_src emacs-lisp
(after! system-packages
  (when (and (eq system-packages-package-manager 'pacman)
             (system-packages-package-installed-p "yay"))
    (alet (alist-get 'pacman system-packages-supported-package-managers)
      (push `(yay (default-sudo . nil)
                  ,@(-map (-lambda ((action . command))
			    (cons action (s-replace "pacman" "yay" command)))
                          (cdr it)))
            system-packages-supported-package-managers))
    (setq system-packages-package-manager 'yay)))
#+end_src

** ellocate
:PROPERTIES:
:ID:       e3590042-52fb-47ee-a5eb-a7860a3cdb17
:END:

=ellocate= is replacement for.

#+begin_src emacs-lisp
(use-package ellocate
  :commands ellocate
  :set
  (ellocate-scan-dirs . `(("~/" . ,(concat XL-CACHE-DIR "ellocate"))))
  (ellocate-gc-mem    . most-positive-fixnum))
#+end_src

** pdf-tools
:PROPERTIES:
:ID:       63343f9d-6b19-43de-8302-d1344d571949
:END:

*** init
:PROPERTIES:
:ID:       e19d0200-5e41-4295-ae54-fa71bfeadb06
:END:

#+begin_src emacs-lisp
(use-package pdf-tools
  :magic ("%PDF" . pdf-view-mode)
  :init
  (push '("\\.[pP][dD][fF]\\'" . pdf-view-mode) auto-mode-alist))
#+end_src

*** epd-pdf-info-program
:PROPERTIES:
:ID:       25826061-a4a7-4f8a-8d3b-bdd5a80f70d0
:END:

#+begin_src emacs-lisp
(defadvice! build-pdf-into-program-maybe (:before pdf-view-mode)
  "Build the pdf-info program if it hasn't already been built."
  (unless (file-executable-p pdf-info-epdfinfo-program)
    (let ((wconf (current-window-configuration)))
      (pdf-tools-install)
      (message "Building epdfinfo, this will take a moment...")
      (-each (buffer-list)
        (fn! (with-current-buffer <buffer>
	       (when (eq major-mode 'pdf-view-mode)
		 (fundamental-mode)))))
      (while compilation-in-progress
        ;; Block until `pdf-tools-install' is done
        (redisplay)
        (sleep-for 1))
      ;; HACK If pdf-tools was loaded by you opening a pdf file, once
      ;;      `pdf-tools-install' completes, `pdf-view-mode' will throw an error
      ;;      because the compilation buffer is focused, not the pdf buffer.
      ;;      Therefore, it is imperative that the window config is restored.
      (when (file-executable-p pdf-info-epdfinfo-program)
        (set-window-configuration wconf)))))
#+end_src

*** bindings
:PROPERTIES:
:ID:       506c568c-0473-4db6-82b6-cc91174b0ce4
:END:

#+begin_src emacs-lisp
(bind!
  (:states normal)
  (:map pdf-view-mode-map)
  ("j" #'pdf-view-next-line-or-next-page)
  ("k" #'pdf-view-previous-line-or-previous-page)
  ("0" #'pdf-view-first-page)
  ("9" #'pdf-view-last-page)
  ("s" #'pdf-view-fit-width-to-window))
#+end_src

** restart-emacs
:PROPERTIES:
:ID:       7412bc2f-0db1-44e9-8ea7-0dc595a04fca
:END:

#+begin_src emacs-lisp
(use-package restart-emacs
  :commands restart-emacs)
#+end_src

** multimedia
:PROPERTIES:
:ID:       5675cbbc-beb1-4470-a1d2-08f253bb4535
:END:

*** screenshots
:PROPERTIES:
:ID:       26d59d00-72e3-4b8c-9845-e5d9627cd4aa
:END:

This headline contains utilities for taking screenshots. As I see it,
screenshots are vital. I use maim to take screenshots because. I will note that
when I used [[][escr]] to take screenshots, those screenshots would not show
exwm windows. =escr= used [[][]]'s import.

**** screenshot name
:PROPERTIES:
:ID:       7210e8a8-7cbc-40ec-bd70-f8cfc6a32c56
:END:

The name for the screenshot.

***** xl-screenshot-path
:PROPERTIES:
:ID:       a6a75a8c-8d00-4f26-9df0-7f24af577e87
:END:

#+begin_src emacs-lisp
(defun xl-screenshot-path (name)
  "Return the full path where screenshot named NAME should go."
  (format "%s%s.png" (xl-screenshot-dir) name))
#+end_src

***** whether to prompt for screenshots
:PROPERTIES:
:ID:       1c280e62-2a1b-41f8-8ff9-039528652fcf
:END:

#+begin_src emacs-lisp
(defvar xl-prompt-for-screenshot-name-p t
  "If non-nil, prompt for screenshot name.")
#+end_src

***** name passed into prompt
:PROPERTIES:
:ID:       e8a21618-50f6-45ba-9a38-bff5c6d0a924
:END:

#+begin_src emacs-lisp
(defun xl-prompt-screenshot-name ()
  "Prompt for screenshot name."
  (when xl-prompt-for-screenshot-name-p
    (alet (read-string "Image Name: ")
      (unless (string-empty-p it)
	(xl-screenshot-path it)))))
#+end_src

***** default screenshot name
:PROPERTIES:
:ID:       58405f4f-e891-494e-afc7-a227415ec12b
:END:

#+begin_src emacs-lisp
(defun xl-default-screenshot-name ()
  "Return the default screenshot name."
  (alet (format-time-string "%Y-%m-%d-%H%M%S" (current-time))
    (xl-screenshot-path it)))
#+end_src

**** interactive screenshot functions
:PROPERTIES:
:ID:       27089aef-5937-4a7e-9af1-794fbeb835f2
:END:

When I first implemented these functions I prompted for the name first, but this
had the side-effect of displaying the prompt in the screenshot which is not what
I want. To avoid this, I decided to create the screenshot with the default name
and then prompt to rename the file afterwards.

***** fullscreen
:PROPERTIES:
:ID:       5cb29bb2-459a-4c84-9bf8-df179d2d2e8e
:END:

Take a s

#+begin_src emacs-lisp
(defun xl/take-fullscreen-screenshot ()
  "Take a fullscreen screenshot."
  (interactive)
  (let ((name (xl-default-screenshot-name)))
    (call-process "maim" nil nil nil "-u" name)
    (awhen (xl-prompt-screenshot-name)
      (rename-file name it t))))
#+end_src

***** window
:PROPERTIES:
:ID:       1a8724bb-24be-43fd-a3f6-3a41f7380fe8
:END:

#+begin_src emacs-lisp
(defun xl/take-window-screenshot ()
  "Take a screenshot of the current Emacs window."
  (interactive)
  (-let* ((name (xl-default-screenshot-name))
	  ((x y w h) (window-pixel-edges))
	  (geometry (format "%dx%d+%d+%d" w h x y)))
    (call-process "maim" nil nil nil "-u" "--geometry" geometry name)
    (awhen (xl-prompt-screenshot-name)
      (rename-file name it t))))
#+end_src

*** elfeed
:PROPERTIES:
:ID:       45a52b98-9eba-45ab-9269-e8f930499e1c
:END:

=elfeed= is a newsfeed reader to Emacs. It's used over gnus because it is
generally faster and more "modern".

**** elfeed
:PROPERTIES:
:ID:       6aa4ece0-0b94-48b6-9a99-4b85cd1f7ccd
:END:

#+begin_src emacs-lisp
(use-package elfeed
  :rule ("right" "elfeed" :newname "\\*elfeed.+")
  :commands elfeed
  :set
  (elfeed-db-directory           . (concat XL-CACHE-DIR "elfeed"))
  (elfeed-search-title-max-width . 100))
#+end_src

**** elfeed-score
:PROPERTIES:
:ID:       20d1a501-4a52-43b8-b124-be1f62265b73
:END:

#+begin_src emacs-lisp
(use-package elfeed-score)
#+end_src

**** elfeed-org
:PROPERTIES:
:ID:       f646640b-6982-478f-bd1b-babd0ee00165
:END:

#+begin_src emacs-lisp
(use-package elfeed-org
  ;; :init
  ;; (defvar elfeed-org%public-newsfeed-file (xl-org-dir "newsfeeds.org")
  ;;   "Newsfeeds.")
  ;; :set
  ;; (rmh-elfeed-org-files . (list elfeed-org%public-newsfeed-file))
  )
#+end_src

**** newsfeeds
:PROPERTIES:
:ID:       6d64a62c-a3f7-449c-833d-0738c1e5f28a
:END:

These are my newsfeed for =elfeed-org=.

***** [[https://planet.emacslife.com/][planet emacslife]]
:PROPERTIES:
:ID:       c042350e-6c21-4c98-82b1-332ef808cba5
:END:

*** gif-screencast
:PROPERTIES:
:ID:       d8553132-c244-4319-bcc9-51905a296e34
:END:

#+begin_src emacs-lisp
(use-package gif-screencast
  :commands gif-screencast-start-or-stop
  :set 
  (gif-screencast-program . "scrot")
  (gif-screencast-args . '("--quality" "25" "--focused"))
  (gif-screencast-cropping-program . "mogrify")
  (gif-screencast-optimize-program . "gifsicle")
  (gif-screencast-capture-format . "png"))
#+end_src

*** videos
:PROPERTIES:
:ID:       a8c1f6aa-25f6-47aa-a625-2c870f322a8c
:END:

**** ytel
:PROPERTIES:
:ID:       dea17f59-bebc-426e-ae7a-56f8d8971260
:END:

***** get video
:PROPERTIES:
:ID:       2a0e30c8-7a82-4bea-a79c-6d77eca6893a
:END:

*** emms
:PROPERTIES:
:ID:       6f3eaa69-bbbb-458e-bcad-1c121a3174e9
:END:

[[https://www.gnu.org/software/emms/][emms]] is a very complete music player.

**** emms
:PROPERTIES:
:ID: 5d28b703-a87f-47ca-b320-785e7589fea6
:END:

#+begin_src emacs-lisp
(use-package emms
  :set
  (emms-source-file-directory-tree-function . 'emms-source-file-directory-tree-find)
  (emms-source-file-default-directory       . "~/Multimedia/music")
  (emms-playlist-buffer-name                . "*EMMS-PLAYLIST*")
  (emms-seek-seconds                        . 5)
  (emms-directory                           . (concat XL-CACHE-DIR "emms/"))
  (emms-player-list                         . '(emms-player-mpv)))
#+end_src

**** quitting
:PROPERTIES:
:ID: 545e6534-f289-4a89-838a-2a65ac74fe72
:END:

#+begin_src emacs-lisp
(defhook! quit-emms (kill-emacs-hook)
  "Shut down EMMS."
  (when emms-player-playing-p (emms-pause))
  (emms-stop))
#+end_src

** eshell
:PROPERTIES:
:ID: 5f04a252-2985-46b4-ab0b-eb4567de5dd9
:END:

[[info:eshell#Top][eshell]] is a built-in shell written entirely in elisp. This means that it's as
portable and customizable as emacs itself. It can run elisp functions as
commands. There's a good article about it in [[https://masteringemacs.org/article/complete-guide-mastering-eshell][mastering-emacs]]. Other articles I
have like about eshell: [[https://ambrevar.xyz/emacs-eshell/][ambrevar's eshell post]], [[http://www.howardism.org/Technical/Emacs/eshell-fun.html][Howard Abram's Post]].

*** eshell
:PROPERTIES:
:ID:       b2b473c8-78d7-4f41-9be3-842b6c5acdbb
:END:

#+begin_src emacs-lisp
(use-package eshell
  :rule ("bottom" "eshell" :newname "\\*eshell\\*")
  :set
  (eshell-directory-name             . (concat XL-CACHE-DIR "eshell/"))
  (eshell-history-file-name          . (concat eshell-directory-name "history"))
  (eshell-banner-message             . "")
  (eshell-prefer-lisp-functions      . nil)
  (eshell-scroll-to-bottom-on-input  . 'all)
  (eshell-scroll-to-bottom-on-output . 'all)
  (eshell-buffer-shorthand           . t)
  (eshell-kill-processes-on-exit     . t)
  (eshell-hist-ignoredups            . t)
  (eshell-input-filter               . #'eshell-input-filter-initial-space)
  (eshell-glob-case-insensitive      . t)
  (eshell-error-if-no-glob           . t))
#+end_src

*** em-hist
:PROPERTIES:
:ID:       aaea54da-bd51-4a73-9dad-fe0b49d0f617
:END:

#+begin_src emacs-lisp
(use-package em-hist
  :idle-require t
  :set
  (eshell-history-file-name    . (concat eshell-directory-name "history"))
  (eshell-history-size         . 2000)
  (eshell-hist-ignoredups      . nil)
  (eshell-save-history-on-exit . t))
#+end_src

*** em-term
:PROPERTIES:
:ID:       d2afb853-15c3-4d3f-b8fa-a1075f84bbac
:END:

#+begin_src emacs-lisp
(use-package em-term
  :idle-require t
  :config
  (-each '("tmux" "htop" "bash" "zsh" "fish" "vim" "nvim" "ncmpcpp")
    (fn! (pushnew <command> eshell-visual-commands))))
#+end_src

*** em-alias
:PROPERTIES:
:ID:       694a8c17-8318-4222-b461-abfc1d8a78ea
:END:

#+begin_src emacs-lisp
(use-package em-alias
  :idle-require t)
#+end_src

*** eshell-z
:PROPERTIES:
:ID: 497798a0-7b62-4779-bf15-f67500528f03
:END:

#+begin_src emacs-lisp
(use-package eshell-z
  :commands eshell-z
  :set
  (eshell-z-freq-dir-hash-table-file-name . (expand-file-name "z" eshell-directory-name)))
#+end_src

*** eshell-up
:PROPERTIES:
:ID: 478219b9-1c6f-4907-b428-a2dfe0f45e5c
:END:

This is an Emacs package for quickly navigating to a specific parent directory
in ~eshell~ without having to repeatedly typing ~cd ..~.

#+begin_src emacs-lisp
(use-package eshell-up
  ;; :alias
  ;; (eshell/up . eshell-up)
  ;; (eshell/peek . eshell-up-peek)
  )
#+end_src


** shrink-path
:PROPERTIES:
:ID: bd21a69a-794c-4ff1-97d0-9e5911a26ad7
:END:

It's easy to underestimate how much of a difference having an asthetically
pleasing Emacs configuration can have. Ugliness really can take its toll.

** text scaling
:PROPERTIES:
:ID:       5d242d0e-eeab-46de-bcee-ecfd79b2bffc
:END:

I change the text scale frequently because in some cases, such as viewing my
main org file, I want a birds-eye view where I can see the structure of a
document at a glance. However, when I'm doing something like editing a source
block I want to focus on a very specific thing totally; therefore, I want the
text to take up most of the screen.

*** zoom-frm
:PROPERTIES:
:ID:       15b8577e-3f98-420a-81a5-c7b91292aca3
:END:

This package increases or decreases the font of the current frame. It differs
from [[helpfn:text-scale-increase][text-scale-increase]] and [[helpfn:text-scale-decrease][text-scale-decrease]] in that it applies this
"zooming" to the whole frame instead of the current buffer.

#+begin_src emacs-lisp
(use-package zoom-frm
  :set
  (frame-zoom-font-difference . 0.5)
  (zoom-frame/buffer          . 'buffer))
#+end_src


** file browsing
:PROPERTIES:
:ID:       d3e15439-f690-4ced-b701-0882fb911a5c
:END:

This is a package that displays emojis! :D A major focus of my config is having
the ability to express myself well--in ways that is simply impossible with mere
documentation. This includes using emojis. Also, using emojis makes
documentation *much* more fun. :joy-cat:

#+begin_src emacs-lisp
(use-package emojify
  :hook org-mode-hook
  :set
  (emojify-emojis-dir . (concat XL-CACHE-DIR "emojis/")))
#+end_src

** info
:PROPERTIES:
:ID:       d49f83c4-ba8f-477e-beef-8156ed8b974b
:END:

This headline is for customizing info nodes.

#+begin_src emacs-lisp
(use-package info
  :rule ("top" "info" :newname "\\*info"))
#+end_src

** saveplace
:PROPERTIES:
:ID:       41cb3357-9b4b-4205-987d-ff72f9a35df3
:END:

This package takes you to the last point you were at when you visited a file.

*** recenter cursor
:PROPERTIES:
:ID:       dda57b64-b645-4eda-be54-9dda4af35404
:END:

#+begin_src emacs-lisp
(defadvice! recenter-on-load (:after-while save-place-find-file-hook)
  "Recenter on cursor when loading a saved place."
  (when buffer-file-name (ignore-errors (recenter))))
#+end_src

*** saveplace
:PROPERTIES:
:ID:       63b04114-bcb9-4a2e-ad45-be4db8d4a269
:END:

As its name suggests, =save-place= is a built-in package that stores the buffer
location you left off at in a particular buffer. When you visit that buffer
again, you are taken to the location you left off. This is very convenient.

#+begin_src emacs-lisp
(use-package saveplace
  :after-call after-find-file
  :xl-config
  (save-place-mode)
  :set
  (save-place-file . (concat XL-CACHE-DIR "saveplace"))
  (save-place-limit . nil))
#+end_src

** recentf
:PROPERTIES:
:ID:       5ab47c35-53bd-460f-ba41-6f3075bd1222
:END:

=recentf= is a built-in program that tracks the files you've opened recently
persistently. This is a great idea because these are the files you'll likely
revisit. In practice, I look at this list of files in addition to the buffers I
already have open using a [[id:f26bedb3-a172-4543-afd0-4c47f5872d15][completion-framework]]. Because of this I rarely
have to set out to look for a file with =dired=.

#+begin_src emacs-lisp
(use-package recentf
  :before-call find-file
  :idle-require easymenu tree-widget timer
  :hook (kill-emacs-hook . recentf-save-list)
  :advice (:before (recentf-save-list . recentf-cleanup))
  :silence recentf-mode recentf-cleanup recentf-save-list
  :set
  (recentf-max-menu-items    . 0)
  (recentf-max-saved-items   . 700)
  (recentf-save-file         . (concat XL-CACHE-DIR "recentf"))
  (recentf-auto-cleanup      . (* 60 10))
  (recentf-filename-handlers . '(file-truename abbreviate-file-name))
  :config
  (recentf-mode 1)
  (run-with-idle-timer (* 60 10) t #'recentf-save-list))
#+end_src

