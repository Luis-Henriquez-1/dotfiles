#+title: email.org
#+author: Luis Henriquez-Perez

* TODO notmuch
:PROPERTIES:
:ID:       f286edb9-4586-43e0-b208-dd1dd0e9f459
:END:

* TODO gnus
:PROPERTIES:
:ID:       c7131b43-cfac-4c0f-8395-0c4b8e9d4078
:END:

* mu4e
:PROPERTIES:
:ID:       905ba1b5-bafc-4855-b772-fa750c294327
:END:

=mu4e= is the most popular Emacs email client--and for good reason. It's fast,
tag-based, and has great documentation. One annoying quirk for me is that unlike
all other Emacs packages it does not come uncoupled from the external program it
uses. What this means is that you need to tell Emacs where the mu4e =.el= files
are :pouting-cat:. It also means it's more difficult to incorporate it with the
contribution workflow that [[https://github.com/raxod502/straight.el][straight.el]] encourages. I haven't figured out
how to automate this across multiple OSes.

This is annoying, but minor. =mu4e= itself is a great package.

** load-path :email:mu4e:loadpath:guix:emacs:config:
:PROPERTIES:
:ID:       8b4ab179-11c6-429c-9c8d-9296dfb215dc
:END:

#+begin_src emacs-lisp
(defun mu4e%load-path-guix ()
  "Return load-path for mu4e."
  (loopy (with (regexp "\\`[[:alnum:]]+-mu-\\(?:[[:digit:]]\\|\\.\\)+")
	       (base-dir "/gnu/store/"))
	 (list file (directory-files base-dir))
	 (expr full-path (f-expand file base-dir))
	 (when (and (string-match-p regexp file) (f-dir-p full-path))
	   (expr mu4e-path (f-expand "share/emacs/site-lisp/" full-path))
	   (when (f-dir-p mu4e-path)
	     (return mu4e-path)))))
#+end_src

** maildir :email:mu4e:emacs:config:
:PROPERTIES:
:ID:       49debca7-6ae7-40e4-9bd0-73c3bba40539
:END:

#+begin_src emacs-lisp
(defun xl-mail-dir (&rest others)
  (apply #'concat (f-full "~/.mail") others))

(defalias 'mu4e%mail-dir 'xl-mail-dir)
#+end_src

** list email accounts :email:mu4e:emacs:config:
:PROPERTIES:
:ID:       0b7dcf44-b245-4ca8-9407-3d3c043e1d96
:END:

I'm storing all my email account passwords using =pass=. I can use the encrypted
files in my pass directory to determine what my email accounts are and, in turn,
how to automate this.

#+begin_src emacs-lisp
(defalias 'mu4e%mail-accounts 'password-store:email-accounts)
#+end_src

** add mu4e to the load-path :email:mu4e:loadpath:emacs:config:
:PROPERTIES:
:ID:       9dccb5e4-5d8e-4da6-99ae-9f8ed3bd8a5d
:END:

#+begin_src emacs-lisp
(use-package mu4e :commands mu4e)
#+end_src

** mu4e-vars :email:mu4e:emacs:config:
:PROPERTIES:
:ID:       25cf40b9-901b-40f4-800f-3fa577ee22c3
:END:

=mu4e-var= contains many miscellaneous variables. Some highlights.

#+begin_src emacs-lisp
(use-package mu4e-vars
  :set
  (mu4e-completing-read-function . #'completing-read)
  (mu4e-get-mail-command         . "mbsync -a")
  (mu4e-update-interval          . nil)
  (mu4e-context-policy           . 'pick-first)
  (mu4e-use-fancy-chars          . (display-graphic-p))
  (mu4e-org-support              . t)
  (mu4e-index-cleanup            . t)
  (mu4e-split-view               . 'vertical)
  (mu4e-index-lazy-check         . nil)
  (mu4e-hide-index-messages      . t)
  (mu4e-confirm-quit             . nil))
#+end_src

*** mu4e
:PROPERTIES:
:ID: 565eff90-8626-4ec8-a576-4ff3dfb307ae
:END:

#+begin_src emacs-lisp
(setq mu4e-html2text-command
      (if (executable-find "w3m") "w3m -dump -T text/html" #'mu4e-shr2text))
#+end_src

** mu4e-views :email:mu4e:emacs:config:
:PROPERTIES:
:ID:       5ebeddaa-94ae-4acc-9659-5aae8cb4a2f0
:END:

#+begin_src emacs-lisp
(use-package mu4e-view
  :set
  (mu4e-view-show-images     . t)
  (mu4e-view-image-max-width . 800)
  (mu4e-view-show-addresses  . t)
  (mu4e-date-format          . "%c"))
#+end_src

** mu4e-compose :email:mu4e:emacs:config:
:PROPERTIES:
:ID:       cd07286d-2a94-4953-99bf-8e06b3edcf15
:END:

#+begin_src emacs-lisp
(use-package mu4e-compose
  :set
  (mu4e-compose-context-policy . 'ask-if-none))
#+end_src

** mu4e-drafts :email:mu4e:emacs:config:
:PROPERTIES:
:ID:       5de3eca7-968b-4228-a1d9-ca872f18f58b
:END:

#+begin_src emacs-lisp
(use-package mu4e-drafts
  :set
  (mu4e-compose-signature-auto-include . t)
  (mu4e-compose-format-flowed          . t))
#+end_src

** mu4e-headers :email:mu4e:emacs:config:
:PROPERTIES:
:ID:       8bc93633-f3a0-494d-ae61-c05f6490cd87
:HEADER-ARGS: :tangle no
:END:

These are custom icons used to spice up the =mu4e= display.

#+begin_src emacs-lisp
(use-package mu4e-headers
  :set
  (mu4e-headers-auto-update    . t)
  (mu4e-headers-draft-mark     . (cons "D" (all-the-icons-faicon "pencil")))
  (mu4e-headers-flagged-mark   . (cons "F" (all-the-icons-faicon "flag")))
  (mu4e-headers-new-mark       . (cons "N" (all-the-icons-material "fiber_new")))
  (mu4e-headers-passed-mark    . (cons "P" (all-the-icons-faicon "arrow-right")))
  (mu4e-headers-seen-mark      . (cons "S" (all-the-icons-faicon "eye")))
  (mu4e-headers-attach-mark    . (cons "a" (all-the-icons-material "attach_file")))
  (mu4e-headers-replied-mark   . (cons "R" (all-the-icons-faicon "reply")))
  (mu4e-headers-unread-mark    . (cons "u" (all-the-icons-faicon "eye-slash")))
  (mu4e-headers-encrypted-mark . (cons "x" (all-the-icons-octicon "lock")))
  (mu4e-headers-signed-mark    . (cons "s" (all-the-icons-faicon "certificate")))
  (mu4e-headers-trash-mark     . (cons "T" (all-the-icons-faicon "trash"))))
#+end_src

** mu4e-org :email:mu4e:org:emacs:config:
:PROPERTIES:
:ID:       eaa1577b-bcb9-4f6e-9927-8c6d8042dda2
:END:

Mu4e's org integration lets you write emails in org mode and convert it to html
before sending--very interesting indeed :grinning:. I have yet to explore this feature but
it is definitely on my list of things to try out.

#+begin_src emacs-lisp
(use-package mu4e-org
  :hook (mu4e-compose-mode-hook . org-mu4e-compose-org-mode)
  :set
  (mu4e-org-link-query-in-headers-mode . nil)
  (mu4e-org-convert-to-html            . t))
#+end_src

*** hook
:PROPERTIES:
:ID:       fcdbaa17-20c6-4322-baed-27df5a0ad9a2
:END:

Only render to html once. If the first send fails for whatever reason,
org-mu4e would do so each time you try again.

#+begin_src emacs-lisp
(defhook! org-mu4e-render-html-only-once (message-send-hook)
  (setq-local org-mu4e-convert-to-html nil))
#+end_src

** initializing mu4e :email:mu4e:emacs:config:
:PROPERTIES:
:ID:       93cffd11-a812-4cda-b7dd-a06f70367afe
:END:

This headline attempts to automate the initialization of mu4e. The goal is for
me to do as little as possible by (by which I mean nothing :joy:) to get a
working mu4e setup. In other words, after I initialize my dotfiles and install
all my system packages, I want mu4e to /just work/. There should be no prompts
asking me to run anything or do anything at all.

The idea is to do preliminary things before the main entry point--the function
[[helpfn:mu4e][mu4e]]--is called.

** mu4e database location
:PROPERTIES:
:ID:       fe8f10c1-3035-4a97-9657-98236f50d0a8
:END:

This is the place where the mu4e database is stored. The existence of this
database is used to determine whether we'll run =mu init= or not.

#+begin_src emacs-lisp
(defvar mu4e%mu-database-path (expand-file-name "~/.cache/mu/xapian")
  "Path where mu database should go.")
#+end_src

** init mu4e database
:PROPERTIES:
:ID:       4d107050-db05-4d7e-ae44-4bf356a44fd0
:HEADER-ARGS: :tangle no
:END:

The first time you run =mu= it needs to [initialize it's database]. This is done
with the command =mu init --maildir=~/Maildir=.

#+begin_src emacs-lisp
(defadvice! init-database-maybe (:before mu4e)
  "Initialize the mu4e database if it does not exist."
  (unless (file-exists-p mu4e%mu-database-path)
    (-each (mu4e%mail-accounts)
      (fn! (call-process-shell-command (format "mu init --my-address=%s" <account>))))))
#+end_src

** ensuring email directories
:PROPERTIES:
:ID:       704b7049-fac5-4fa7-b710-1bbfe50cea5f
:END:

Make sure mail directories exist. =mbsync= will fail if they don't.

#+begin_src emacs-lisp
(defadvice! ensure-mail-dirs (:before mu4e)
  "Create mail directories if they don't exist."
  (iter (with (dirs (mapcar #'mu4e%mail-dir (mu4e:mail-accounts))))
	(each dir dirs)
	(mkdir dir t)))
#+end_src

** contexts
:PROPERTIES:
:ID:       0e580010-d5b2-4708-a7dc-c586908409b5
:END:

[[info:mu4e#What are contexts][Contexts]]. This headline attempts to automate context creation. Context are
probably the hardest part of setting up =mu4e= for elisp. [[https://jherrlin.github.io/posts/emacs-mu4e/][this article]]. If you
don't make contexts, =mu4e= will be confused and think that.

*** default enter and exit
:PROPERTIES:
:ID:       f2e2148b-dcab-4503-a1b1-75e48e35018f
:END:

Contexts provide the ability to specify an enter and exist function for each
context. Right now I haven't had any special idea in mind for what the enter and
leave function =mu4e= provides should do switching to a new context. So for now
all I'll do is log the entering/leaving of a context for debugging purposes.

#+begin_src emacs-lisp
(defun mu4e-context::generate-switch-func (mail-address &optional leave)
  "Return a function that enters the context of MAIL-ADDRESS."
  (let* ((to (if leave 'leave 'enter))
	 (name (xl-symbol-intern 'mu4e-context: mail-address '- to '-func))
	 (message (format "%s %s context." to mail-address))
	 (fn `(lambda () (xl-log ,message))))
    (fset name fn)
    name))
#+end_src

*** enter func
:PROPERTIES:
:ID:       432f2ee9-1c41-4593-b27f-dbc837f8bcd2
:END:

#+begin_src emacs-lisp
(defun mu4e-context::generate-enter-func (email-address)
  (mu4e-context::generate-switch-func mail-address))
#+end_src

*** exit func
:PROPERTIES:
:ID:       0bafa172-2ea6-4b4e-aa4e-1fe2b0808b94
:END:

#+begin_src emacs-lisp
(defun mu4e-context::generate-leave-func (email-address)
  (mu4e-context::generate-switch-func mail-address t))
#+end_src

*** default match fn
:PROPERTIES:
:ID:       41ddf901-0ae9-4b00-bc06-b1b7b49ec8f2
:END:

The match fn take a =message= object. This is for dynamically setting the
context based on what message you're dealing with. Right now, I don't have any
special rules. The rule that I set basically uses the.

#+begin_src emacs-lisp
(defun mu4e-context::generate-match-func (mail-address)
  "Return a default matcher for MAIL-ADDRESS."
  (aprog1 (xl-symbol-intern 'mu4e-context: mail-address '-match-func)
    (fset it
	  `(lambda (msg)
	     (when msg
	       (-any-p (fn! (mu4e-message-contact-field-matches msg <field> ,mail-address))
		       (list :to :from :cc :bcc)))))))
#+end_src

*** default vars
:PROPERTIES:
:ID:       d8892b2c-7056-4d92-819b-8cb4d8c2eeb1
:END:

These are the default.

#+begin_src emacs-lisp
(defun mu4e-context::generate-vars (mail-address)
  "Return default variables for MAIL-ADDRESS."
  (let ((entry (format "email/%s" mail-address))
	(folder (format "/%s" mail-address)))
    `((user-mail-address     . ,mail-address)
      (smtpmail-smtp-server  . ,(password-store-get-field entry "server"))
      (smtpmail-smtp-service . ,(password-store-get-field entry "port"))
      (mu4e-drafts-folder    . ,(concat folder "/drafts"))
      (mu4e-trash-folder     . ,(concat folder "/trash"))
      (mu4e-sent-folder      . ,(concat folder "/sent")))))
#+end_src

*** context arguments
:PROPERTIES:
:ID:       ceb57afe-e899-462c-bc4e-42b284f36605
:END:

#+begin_src emacs-lisp
(defun mu4e-context::context-arguments (mail-address)
  "Return arguments for `mu4e' context."
  (loopy (with (args (list :name mail-address)))
	 (list key '(:enter-func :leave-func :match-func :vars))
	 (expr keyname (xl-keyword-name key))
	 (expr generate-fn (xl-symbol-intern 'mu4e-context:: 'generate- keyname))
	 (expr fn (funcall generate-fn mail-address))
	 (append args (list key fn))))
#+end_src

*** make a context
:PROPERTIES:
:ID:       4e45264d-e7cc-43f7-854b-8b22d4d4151e
:END:

Create a context.

#+begin_src emacs-lisp
(defun mu4e-context::make-context (mail-address)
  "Create a new context with default values."
  (apply #'make-mu4e-context (mu4e-context::context-arguments mail-address)))
#+end_src

*** add a context
:PROPERTIES:
:ID:       c488a02f-743a-492c-9775-5c8216f0b2b0
:END:

#+begin_src emacs-lisp
(defun mu4e-context::add-context (mail-address)
  "Create and add context."
  (push (mu4e-context::make-context mail-address) mu4e-contexts))
#+end_src

*** init contexts
:PROPERTIES:
:ID:       e74512a7-1d1f-4241-b245-5863e7730398
:END:

After mu4e is loaded, setup contexts. In the future, perhaps add this as an
advice before [[helpfn:mu4e][mu4e]] so that I can check if the right emails are set up every
time. This could be useful if I add an email and don't want to restart Emacs.

#+begin_src emacs-lisp
(defhook! init-contexts (mu4e-after-load-hook)
  "Define a context for each email account."
  (-each (password-store:email-accounts) #'mu4e-context::add-context))
#+end_src

