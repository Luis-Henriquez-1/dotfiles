#+title: org.org
#+author: Luis Henriquez-Perez
#+tags: emacs config lang org

* TODO add a todo-keyword for adding a doc :org:doc:todo:
:PROPERTIES:
:ID:       6bd0e450-19a4-4ef5-9938-5d8eea3615bd
:END:

This keyword means I need to add documentation to a headline.

#+begin_src emacs-lisp
(defafter! add-doc-keyword (org)
  (cl-callf2 cl-adjoin '(sequence "DOC" "|") org-todo-keywords))
#+end_src

* TODO add bug to use-package keywords :org:todo:debug:
:PROPERTIES:
:ID:       083e2975-eea0-4ebb-a903-f681194aae74
:END:

#+begin_src emacs-lisp
(defafter! add-bug-keyword (org)
  (cl-callf2 cl-adjoin '(sequence "BUG" "|") org-todo-keywords))
#+end_src

* TODO org-version
:PROPERTIES:
:ID:       0b2cfe2b-a75c-48ea-9470-19c92521e2cf
:END:

#+begin_src emacs-lisp
(advice-add #'org-version :override (-const "10"))
#+end_src

* commands :command:
:PROPERTIES:
:ID:       6f3aa588-6d08-4c5f-af74-f03891abc020
:END:

** next-line
:PROPERTIES:
:ID:       3566b78b-56f8-4628-ad77-ae040f82eaaf
:END:

#+begin_src emacs-lisp
(defun org/dwim-next-line (&optional backward)
  "Go to the start of the next heading.
If DIR is a negative integer, go the opposite direction: the start of the
  previous heading."
  (interactive)
  (outline-next-visible-heading (if backward -1 1))
  (when (org-at-heading-p)
    (org%heading-goto-start)))
#+end_src

** show branch
:PROPERTIES:
:ID:       d95fab52-7d8f-439f-9221-188490f4ad5f
:END:

This shows all headlines that make up the branch of the current headine and
their children. This is the typical behavior you would expect in any outlining
program.

As it stands =org-mode= will keep the parents of a headline you jump to akwardly
hidden.

#+begin_src emacs-lisp
(defun org%show-branch ()
  "Reveal the current org branch.
Show all of the current headine's parents and their children. This includes this
headline."
  (save-excursion
    (loopy (before-do (org-back-to-heading t)
		      (outline-show-children))
	   (while (org-up-heading-safe))
	   (do (outline-show-children)))))
#+end_src

** show branch after jumping to point
:PROPERTIES:
:ID:       251e5df0-0a7d-4bf9-8fd9-69991d89a074
:END:

Note that I use points to store the heading points and go back to them inreverse
order. This is important because org does not unfold headlines properly if you
start from an invisible subheading.

Notably, I do not try to conserve the return value of =xl/goto-line= or
=xl/jump-to-headline= because these functions are and should only be used for
their side-effects.

#+begin_src emacs-lisp
(defadvice! show-current-branch-in-org-mode (:after xl/goto-line org/goto-headline)
  "Properly unfold nearby headlines and reveal current headline."
  (when (eq major-mode 'org-mode)
    (org%show-branch)))
#+end_src

** tangle asynchronously :tangle:
:PROPERTIES:
:ID:       9fcff539-5c1c-4ec8-8aa7-ac8fb82d3392
:END:

Tangling is extremely slow using [[helpfn:org-babel-tangle][org-babel-tangle]]. With a large org file like mine there's
a significant lag and Emacs is blocked while it is tangling.

#+begin_src emacs-lisp
(defun xl/tangle-config-async ()
  "Tangle the readme file asynchronously."
  (interactive)
  (let ((input (expand-file-name "init.org" "~/.tangld/src/emacs/"))
	(output (expand-file-name "init.el" "~/.config/emacs/")))
    (async-start
     `(lambda ()
	(require 'org)
	(require 'ob-tangle)
	(require 'rx)
	(setq org-confirm-babel-evaluate nil)
	(let ((gc-cons-threshold most-positive-fixnum)
	      (org-confirm-babel-evaluate nil))
	  (mkdir "~/.config/emacs/" t)
	  (org-babel-tangle-file ,input ,output)))
     `(lambda (result)
	(message (if result "Successfully tangled %s" "Failed to tangle %s") ,output)))))
#+end_src

** previous-line
:PROPERTIES:
:ID:       682ec141-fb93-4b55-9c3d-d40aacada205
:END:

#+begin_src emacs-lisp
(defun org/dwim-previous-line (&optional forward)
  (interactive)
  (funcall #'org/dwim-next-line (not forward)))
#+end_src

** heading below
:PROPERTIES:
:ID: b059a431-e29c-4f2c-ab5e-8d2d02636405
:END:

#+begin_src emacs-lisp
(defun org/insert-heading-below (&optional above)
  "Insert heading below."
  (interactive)
  (let* ((on-heading-p (ignore-errors (org-back-to-heading)))
         (newlines org%newlines-between-headings)
         (level (or (org-current-level) 1))
         (heading (concat (make-string level ?*) "\s")))
    (cond ((not on-heading-p)
           (insert heading))
          (above
           (goto-char (line-beginning-position))
           (insert heading)
           (save-excursion (insert newlines)))
          (t ; below
           (org-end-of-subtree)
           (insert (concat newlines heading))))
    ;; From `org-insert-heading'
    (pcase (get-char-property-and-overlay (point) 'invisible)
      (`(outline . ,o)
       (move-overlay o (overlay-start o) (line-end-position 0)))
      (_ nil))
    (run-hooks 'org-insert-heading-hook)))
#+end_src

** heading above
:PROPERTIES:
:ID:       545a9192-b312-4667-b4f0-000ddb47b4a1
:END:

#+begin_src emacs-lisp
(defun org/insert-heading-above (&optional below)
  "Insert a heading above the current heading."
  (interactive)
  (funcall #'org/insert-heading-below (not below)))
#+end_src

** subheading
:PROPERTIES:
:ID:       38cc6c74-4b2c-4aa8-b672-86bb7f4fcd7d
:END:

#+begin_src emacs-lisp
(defun org/insert-subheading ()
  "Insert subheading below current heading."
  (interactive)
  (org/insert-heading-below)
  (org-demote))
#+end_src

** dwim insert source block
:PROPERTIES:
:ID:       0025e89d-23a9-42bf-87bb-a4f6d8fbe5a3
:END:

#+begin_src emacs-lisp
(defun org/dwim-edit-source-block ()
  "Edit close source block from point."
  (interactive)
  (unless (org-in-src-block-p)
    (org-next-block 1))
  (org-edit-src-code))
#+end_src

** elisp block
:PROPERTIES:
:ID:       e03149e3-500f-45d6-a4c1-b2f69947b4d5
:END:

#+begin_src emacs-lisp
(defun org/dwim-insert-elisp-block ()
  "Insert elisp block."
  (interactive)
  (save-excursion
    (unless (org-at-heading-p)
      (org-back-to-heading))
    (org-end-of-subtree)
    (goto-char (line-end-position))
    (insert (concat "\n\n"
                    "#+begin_src emacs-lisp"
                    "\n"
                    "#+end_src"))
    (forward-line -1)))
#+end_src

** eval
:PROPERTIES:
:ID:       1a7d5dde-ab85-4159-b3c7-9da093a30de0
:END:

#+begin_src emacs-lisp
(defun org/dwim-eval-block ()
  "Eval block contents."
  (interactive)
  (unless (org-at-heading-p)
    (user-error "Not in source block"))
  (save-window-excursion
    (org-babel-execute-subtree)))
#+end_src

** jump to line
:PROPERTIES:
:ID:       47480f9a-2e82-435a-a098-6a1a9a11c2f0
:END:

A simplified version of [[helpfn:consult-line][consult-line]] that only works in org mode. Thing
is, although consult line looks prettier I find it less useful to see fontified
headlines and would rather view the entire path.

#+begin_src emacs-lisp
(defun xl/goto-org-heading ()
  "Jump to an org heading."
  (interactive)
  (let ((selectrum-should-sort-p nil)
        (org-outline-path-complete-in-steps)
        (org-goto-interface 'outline-path-completion)
	(org-goto-max-level 10))
    (org-goto))
  (when (eq major-mode 'org-mode) (org%show-branch)))
#+end_src

** org choose tags
:PROPERTIES:
:ID:       b8b0c3a2-2cdc-424f-9cd6-ef3ad3d1512c
:END:

#+begin_src emacs-lisp
(defun org/choose-tags ()
  "Select tags to add to headline."
  (interactive)
  (let* ((current (org-get-tags (point)))
         (selected (->> (org-get-buffer-tags)
                        (completing-read-multiple "Select org tag(s): "))))
    (alet (-distinct (append (-difference current selected)
                             (-difference selected current)))
      (org-set-tags it))))
#+end_src

** return
:PROPERTIES:
:ID:       8314f2e0-da63-4f2f-ad89-b97987ca5843
:END:

#+begin_src emacs-lisp
(defun org/dwim-return ()
  "Do what I mean."
  (interactive)
  (cond ((org-at-heading-p)
         (org/insert-heading-below))
        (t
         (call-interactively #'org-return))))
#+end_src

* important files and directories
:PROPERTIES:
:ID:       97a3bb5a-f485-45d0-a7f4-4bdd3963a16b
:END:

For now, I define these variables after org mode. These are important files and
directories that I need to reference multiple times.

#+begin_src emacs-lisp
(defconst XL-ORG-DIR (f-full "~/Documents/org/")
  "Directory where org files are kept.")

(defconst XL-CAPTURE-FILE (concat XL-ORG-DIR "capture.org")
  "Org file where capture template captures should go.")

(defconst XL-CODE-FILE (concat XL-ORG-DIR "capture.org")
  "Org file where code snippets should go.")

(defconst XL-TEST-FILE (concat XL-ORG-DIR "test.org")
  "Org file tests should go.")
#+end_src

* bind :bind:
:PROPERTIES:
:ID:       66e694fb-c8db-47a9-869d-101ee34aa6bd
:END:

** org mode local bindings
:PROPERTIES:
:ID:       a950d732-b0d2-46b9-82ce-1b9a474e7d76
:END:

#+begin_src emacs-lisp
(bind-localleader!
 (:map org-mode-map)
 ((:prefix "i")
  ("b" #'org/dwim-insert-elisp-block)
  ("k" #'org/insert-heading-above)
  ("j" #'org/insert-heading-below))
 ("p" #'org-set-property)
 ("o" #'outorg-edit-as-org)
 ("w" #'widen)
 ("n" #'org-narrow-to-subtree)
 ("k" #'org-cut-subtree)
 ("c" #'org-copy-subtree)
 ("r" #'org-refile)
 ("j" #'org/avy-goto-headline)
 ("E" #'org-babel-execute-subtree)
 ("d" #'org/dwim-edit-description)
 ("H" #'(lambda () (interactive) (org-up-heading-safe)))
 ("h" #'org-promote-subtree)
 ("l" #'org-demote-subtree)
 ("e" #'org/dwim-edit-source-block)
 ("," #'org/dwim-edit-source-block))
#+end_src

** generic org bindings
:PROPERTIES:
:ID:       583bd7ac-64e0-48ea-bd75-5b6a20f2deae
:END:

Org mode just does not lend itself to typical evil bindings. These bindings are
much more useful considering the specific structure of org mode documents.

#+begin_src emacs-lisp
(bind!
  (:map org-mode-map)
  (:states normal)
  ("j" #'org-next-visible-heading)
  ("k" #'org-previous-visible-heading)
  ("E" #'org/dwim-eval-block)
  ("e" #'org/dwim-eval-block)
  ("b" #'org/dwim-insert-elisp-block)
  ("o" #'org/insert-heading-below)
  ("O" #'org/insert-heading-above)
  ("h" #'org-up-heading-safe)
  ("l" #'org-do-demote)
  ("H" #'org-promote-subtree)
  ("S" #'org-demote-subtree)
  (">" #'org-shiftmetaright)
  ("<" #'org-shiftmetaleft)
  ("t" #'org-set-tags-command)
  ("c" #'org-capture)
  ("s" #'org/dwim-edit-source-block)
  ("R" #'org-refile)
  ("r" #'org/refile-to-current-file)
  ("T" #'org-todo)
  ("D" #'org-cut-subtree)
  ("Y" #'org-copy-subtree)
  ("K" #'org-metaup)
  ("J" #'org-metadown))
#+end_src

** bindings
:PROPERTIES:
:ID:       3f4144ee-a780-478e-a1ad-47591f181ff3
:END:

#+begin_src emacs-lisp
(bind! ([remap org-cycle] #'outline-toggle-children))
#+end_src

** goto start of heading
:PROPERTIES:
:ID:       0431e49f-ef6b-4edb-854c-6427479e5ee2
:END:

#+begin_src emacs-lisp
(defun org%heading-goto-start ()
  "Go to the end of headline."
  (save-match-data
    (beginning-of-line)
    (when (looking-at (rx (1+ "*")))
      (goto-char (1- (match-end 0))))))
#+end_src

* do the right thing after jumping to headline
:PROPERTIES:
:ID:       2ca61454-a0ca-47b3-8622-91d7969653da
:END:

When I search for a headline with [[helpfn:void/goto-line][xl/goto-line]] or [[helpfn:void/goto-headline][xl/goto-headline]] or even their
counsel equivalents, the proper headlines aren't automatically revealed.

[[screenshot:][This]] is what headline structure looks after using counsel/ivy's [[helpfn:swiper][swiper]] to find
the word =xl/goto-line= in my emacs. You can see that only the headline that has
the target word is revealed but it's parents are (akwardly) hidden. I never want
headlines to be unfolded like this.

* inserting
:PROPERTIES:
:ID:       9ff51c40-5b4a-4861-834f-df1ddb0fc709
:END:

In my eyes, many Org functions are unnecessarily complicated and long. Often they
need to perform a simple task (like inserting a heading) but lose their
fundamental purpose in their inclusion of numerous obscure and opinionated
options. For this reason I wrote my own insert heading functions.

* newlines between headings
:PROPERTIES:
:ID:       995ac71b-8428-4eec-83ac-1ba50383f600
:END:

#+begin_src emacs-lisp
(defvar org%newlines-between-headings "\n\n"
  "Number of newlines between headings.")
#+end_src

* suppress deleting-windows :popup:
:PROPERTIES:
:ID:       9a991acc-a24c-4b28-bafa-876a7f973b90
:END:

Org has a nasty tendency of deleting windows. This advice needs to be added to
various functions in org mode.

#+begin_src emacs-lisp
(defgadvice! suppress-delete-windows (orig-fn &rest args)
  "Inhibit the deletion of windows."
  (cl-letf (((symbol-function #'delete-window) #'ignore)
	    ((symbol-function #'delete-other-windows) #'ignore))
    (apply orig-fn args)))
#+end_src

* org
:PROPERTIES:
:ID:       b0aa3f0b-876a-4527-b8ba-4fdac5e7ebe8
:END:

#+begin_src emacs-lisp
(use-package org
  :gadvice
  (org-add-log-note . suppress-delete-windows)
  (org-fast-tag-selection . suppress-delete-windows)
  (org-fast-todo-selection . suppress-delete-windows)
  :set
  (org-directory                      . (concat "~/Documents/org/"))
  (org-default-notes-file             . (concat org-directory "notes.org"))
  (org-fontify-emphasized-text        . t)
  (org-hide-emphasis-markers          . t)
  (org-pretty-entities                . t)
  (org-fontify-whole-heading-line     . t)
  (org-fontify-done-headline          . t)
  (org-fontify-quote-and-verse-blocks . t)
  (org-adapt-indentation              . nil)
  (org-cycle-separator-lines          . 2)
  (outline-blank-line                 . t)
  (org-enforce-todo-dependencies      . t)
  (org-use-fast-tag-selection         . nil)
  (org-tags-column                    . 0)
  (org-log-done                       . 'time))
#+end_src

* tangld
:PROPERTIES:
:ID:       03016895-7b3a-4809-a72d-ae635c3f0d01
:END:

=tangled= is currently in its early development stages--meaning it is not
working yet.

#+begin_src emacs-lisp
(use-package tangld)
#+end_src

* org-annotate-code
:PROPERTIES:
:ID:       a8c5199d-1f4d-44a5-b6f1-2f8f264b181d
:END:

This package lets you annotate files in a separate org file.

#+begin_src emacs-lisp
(use-package org-annotate-code
  :set (org-annotate-code-org-file . (concat XL-ORG-DIR "annotations.org")))
#+end_src

* org-archive
:PROPERTIES:
:ID:       e53743e9-79ec-42b9-9a4e-5aa87fe936ac
:END:

#+begin_src emacs-lisp
(use-package org-archive
  :set
  (org-archive-location . (concat org-directory "archive.org::")))
#+end_src

* org-super-links
:PROPERTIES:
:ID:       f3eed884-408f-44cb-becc-17c1431060c5
:END:

#+begin_src emacs-lisp
(use-package org-superlinks
  :commands org-super-links-link
  :set
  (org-super-links-backlink-prefix      . nil)
  (org-super-links-related-into-drawer  . "LINKS")
  (org-super-links-backlink-into-drawer . "LINKS"))
#+end_src

* org-todo-keywords
:PROPERTIES:
:ID:       aaa98680-d9b4-4726-b3ba-a50b3442e8e8
:END:

I like the terms "issue" and "closed" because they are more general than the
corresponding "todo" and "done". "Issue" simply implies a problem that needs to
be fixed. When I use =todo= I feel obligated to write what I have to do and
often I don't know that. Who knows? It could even be that nothing needs to be
done.

#+begin_src emacs-lisp
(setq org-todo-keywords
      '((sequence "TODO" "NEXT" "|" "DONE" "CANCELLED")))
#+end_src

* org-ml
:PROPERTIES:
:ID:       7f3ec0ad-45f8-4100-970e-773cfb9a625b
:END:

#+begin_src emacs-lisp
(use-package org-ml)
#+end_src

* org-journal
:PROPERTIES:
:ID:       c3056303-5fa1-49f9-ae2d-294942e25f54
:END:

=org-journal= is a package that provides functions to maintain a simple
diary/journal using =org-mode=.

#+begin_src emacs-lisp
(use-package org-journal
  :commands org-journal-new-entry
  :set
  (org-journal-file-type . 'yearly)
  (org-journal-find-file . 'find-file)
  (org-journal-dir       . (concat org-directory "journal/")))
#+end_src

* org-src
:PROPERTIES:
:ID:       e00378a1-adcf-4e83-8533-b6b442b5f362
:END:

#+begin_src emacs-lisp
(use-package org-src
  :idle-require t
  :rule ("bottom" "org source" :newfile "\\*Org Src")
  :set
  (org-src-window-setup                        . 'plain)
  (org-src-ask-before-returning-to-edit-buffer . nil)
  (org-edit-src-persistent-message             . nil)
  (org-src-preserve-indentation                . t)
  (org-confirm-babel-evaluate                  . nil)
  (org-src-tab-acts-natively                   . t)
  (org-src-fontify-natively                    . t))
#+end_src

** bindings in source block
:PROPERTIES:
:ID:       df270638-f6a7-4f0e-abe7-dd0c4e7df7ce
:END:

Note that you should have bindings that are different for entering and exiting
source blocks.

#+begin_src emacs-lisp
;; (defhook! enable-org-exit-src-bindings (org-src-mode-hook)
;;   ;; "," (list :def #'org-edit-src-exit  :wk "exit source block")
;;   ;; "a" (list :def #'org-edit-src-abort :wk "abort source block")
;;   ;; "c" (list :def #'org-edit-src-exit  :wk "exit source block")
;;   )
#+end_src

* set default header arguments
:PROPERTIES:
:ID:       6151eadc-434b-427f-9e01-9003b3ffab05
:END:

#+begin_src emacs-lisp
(defafter! set-the-default-header-args (org-src)
  (setf org-babel-default-header-args
	'((:session . "none")
	  (:results . "silent")
	  (:exports . "code")
	  (:cache   .  "no")
	  (:noweb   .  "no")
	  (:hlines  .  "no")
	  (:tangle  .  "yes"))))
#+end_src

* org-capture
:PROPERTIES:
:ID:       c9d34e33-f2bc-4351-a654-64e91f4814b1
:END:

=org-capture= is a feature that allows you to quickly save a thought that popped
into your head while keeing disctractions to a minimum.

** org-capture
:PROPERTIES:
:ID:       8fc5d248-ff21-45e4-a48b-57cecd57b7a3
:END:

My capture templates use =ts= and =org-ml= so I make sure to load those library
before org-capture is loaded.

#+begin_src emacs-lisp
(use-package org-capture
  :idle-require t
  :initial-state insert
  :before-call
  (ts     . org-capture)
  (org-ml . org-capture)
  :rule ("bottom" "capture" :newname "\\`CAPTURE-.+"))
#+end_src

** TODO remove capture headerline
:PROPERTIES:
:ID:       dacaf33d-3914-49e4-a1d0-e6bb41b1a44e
:END:

By default org capture templates display a header line. This was the answer to [[https://emacs.stackexchange.com/questions/53648/eliminate-org-capture-message][my
question]]. I need to disable =org-capture's= header-line.

#+begin_src emacs-lisp
(defhook! disable-header-line (org-capture-mode-hook)
  "Turn of the header line message."
  ;; (:feature org)
  (setq-local header-line-format nil))
#+end_src

** doct
:PROPERTIES:
:ID:       fa37f618-b58c-449b-a216-9d2f80ed12c6
:END:

[[https://github.com/progfolio/doct][doct]] is a package designed to ease writing and understanding capture templates
by allowing you to write them in a declarative style (see [[helpfn:doct][doct docstring]]).
In org mode, capture templates are [[info:org#Capture templates][represented as plain lists]]. This makes
it easy to forget what a certain element meant or to accidentally omit a capture
template element as you're writing it.

#+begin_src emacs-lisp
(use-package doct
  :before-call org-capture)
#+end_src

** register org capture files
:PROPERTIES:
:ID:       c3c072c9-71b1-44c1-b472-5dc129a19963
:END:

#+begin_src emacs-lisp
(defafter! register-capture-file (org-capture)
  "Add the file I use for capturing to `org-agenda-files'."
  (callf2 cl-adjoin XL-CAPTURE-FILE org-agenda-files :test #'string=))
#+end_src

** completing-read org-capture :bind:
:PROPERTIES:
:ID:       ad2cc056-edda-490a-8cf9-10b370a21dc0
:END:

Org provides it's own default interface for capturing. To be consistent with how
we complete everything else--via [[helpfn:][completing-read]], I create a function which
let's me choose the template via completing-read.

#+begin_src emacs-lisp
(defun org-capture/choose-template ()
  (interactive)
  (require 'org-capture)
  (let* ((read-string (-map (fn! (format "%s %s" (car <>) (cadr <>)))
			    (org-capture%template-list)))
	 (selection (completing-read "Capture template: " read-string nil :require-match))
	 (key (car (split-string selection "\s" t))))
    (org-capture nil key)))

(bind! ([remap org-capture] #'org-capture/choose-template))
#+end_src

** capture templates
:PROPERTIES:
:ID:       c4fdb186-3509-42f1-9c3e-8bf80a5e6b47
:END:

#+begin_src emacs-lisp
(defun org-capture%template-list ()
  "Return a list of capture templates."
  (thread-first org-capture-templates
    (org-capture-upgrade-templates)
    (org-contextualize-keys org-capture-templates-contexts)))
#+end_src

** capture templates
:PROPERTIES:
:ID:       a2a3f682-322a-450f-91bf-169d90f040c0
:END:

*** todo
:PROPERTIES:
:ID:       ef103d28-b746-42ba-ac1a-0462a19f03cd
:END:

**** todo capture template string
:PROPERTIES:
:ID:       a58f1de7-2049-4195-abfb-daad93a6ff2a
:END:

Instead of passing in the string I use =org-ml= to print the string.

#+begin_src emacs-lisp
(defun org-capture%todo-template ()
  "Return capture template for an todo."
  (->> (org-ml-build-headline! :title-text "%?")
       (org-ml-headline-set-node-property "ID" (org-id-new))
       (org-ml-set-property :todo-keyword "TODO")
       (org-ml-to-trimmed-string)))
#+end_src

**** template
:PROPERTIES:
:ID:       5fd30ac2-57c1-4249-a5e7-4048e9597dc1
:END:

#+begin_src emacs-lisp
(defmacro doct%set-template! (name &rest rest)
  "Specify the doct arguments to create a capture template."
  (declare (indent defun))
  `(after! org-capture
     (alet (doct (list (list "todo" ,@rest)))
       (cl-callf2 cl-adjoin (car it) org-capture-templates))))
#+end_src

**** todo
:PROPERTIES:
:ID:       2682910c-9620-4cbf-ab71-371ed29e25a1
:END:

#+begin_src emacs-lisp
(doct%set-template! "todo"
  :keys "t"
  :template #'org-capture%todo-template
  :file XL-CAPTURE-FILE
  :prepend t
  :empty-lines 1)
#+end_src

**** annotation
:PROPERTIES:
:ID:       4ec64ef5-b005-4974-8ed8-fbcdc05d828c
:END:

#+begin_src emacs-lisp
(doct%set-template! "annotate"
  :keys "a"
  :type 'plain
  :target #'org-annotate-code-capture-finding-location
  :file org-annotate-code-org-file
  :template "%?")
#+end_src

*** test
:PROPERTIES:
:ID:       e5f5fc62-4791-4f25-ae0a-1517ac5ed598
:HEADER-ARGS: :tangle no
:END:

The purpose of this template is to create tests for specific blocks of code.
This template will add a headline to.

**** template
:PROPERTIES:
:ID:       12a0bbc8-24a3-4d28-b14c-0050d268f901
:HEADER-ARGS: :tangle no
:END:

#+begin_src emacs-lisp
(defun org-capture%test-template ()
  "Return capture template for an todo."
  (->> (org-ml-build-headline! :title-text "%?")
       (org-ml-headline-set-node-property "ID" "1234")
       (org-ml-to-trimmed-string)))
#+end_src

**** test
:PROPERTIES:
:ID:       c5456618-d2d8-4347-aa2a-dfbf487046bd
:END:

#+begin_src emacs-lisp
(doct%set-template! "test"
  :keys "T"
  :template #'
  :file XL-TEST-FILE
  :prepend t
  :empty-lines 1)
#+end_src

*** question
:PROPERTIES:
:ID:       28b75872-0ed1-4852-8838-f015f0000bd5
:HEADER-ARGS: :tangle no
:END:

The purpose of this template is to create headlines for questions I'd like
answered.

* org-clock
:PROPERTIES:
:ID:       d378471c-89df-48c9-a755-b79880f27308
:END:

=org-clock= is a built-in package that provides time logging functions for
tracking the time you spend on a particular task.

#+begin_src emacs-lisp
(use-package org-clock
  :idle-require t
  :commands org-clock-in org-clock-goto
  :hook (kill-emacs-hook . org-clock-save)
  :set
  (org-clock-persist      . 'history)
  (org-clock-persist-file . (concat XL-CACHE-DIR "org-clock-save.el"))
  (org-clock-in-resume    . t)
  :config
  (org-clock-persistence-insinuate))
#+end_src

* org-ql
:PROPERTIES:
:ID:       f2b2f464-f9f0-4ba4-9808-4bf5cb75aaf8
:END:

This package provides an org query language for looking up org headline.

#+begin_src emacs-lisp
(use-package org-ql)
#+end_src

* calfw
:PROPERTIES:
:ID:       4b317202-0f4c-40e9-b708-484cd995c9b8
:END:

This package displays a calendar.

#+begin_src emacs-lisp
(use-package calfw)
#+end_src

* org-agenda
:PROPERTIES:
:ID:       72fba07e-df2e-420a-8ddd-40b9e27bf28f
:END:

** org-agenda :popup:
:PROPERTIES:
:ID:       efa9d237-b055-4bfb-a1f9-86d964b5f007
:END:
:LINKS:
[[info:org#Weekly/daily agenda][info:org#Weekly/daily agenda]]
:END:

#+begin_src emacs-lisp
(use-package org-agenda
  :idle-require t
  :rule ("top" "org agenda" :newname "\\*Org Agenda\\*")
  :before-call (org-ql . org-agenda)
  :gc-pause org-agenda-list
  :gadvice (org-agenda-get-restriction-and-command . suppress-delete-windows)
  :set
  (org-agenda-include-diary . t)
  (org-agenda-text-search-extra-files . '(agenda-archives))
  (org-agenda-skip-unavailable-files  . t)
  (org-agenda-files                   . (list XL-CAPTURE-FILE))
  (org-agenda-warning-days . 10)
  (org-agenda-start-on-weekday        . 0)
  (org-agenda-timegrid-use-ampm       . nil)
  (org-agenda-time-leading-zero       . t)
  (org-agenda-dim-blocked-tasks       . t)
  (org-agenda-inhibit-startup         . t))
#+end_src

** respect display-buffer :popup:
:PROPERTIES:
:ID:       50933d82-1208-481d-8dc7-42630f3f3b41
:END:

=org= functions are known to try to configure buffer displays themselves. This
forces agenda view to rely on [[helpvar:display-buffer-alist][display-buffer-alist]] for it's display.

#+begin_src emacs-lisp
(defun! use-display-buffer (abuf filter-alist)
  "Use `display-buffer' to display the agenda buffer.
Unlike `org-agenda-prepare-window', this function does not store the window configuration."
  :override org-agenda-prepare-window
  (display-buffer abuf)
  (setq org-agenda-tag-filter (cdr (assq 'tag filter-alist)))
  (setq org-agenda-category-filter (cdr (assq 'cat filter-alist)))
  (setq org-agenda-effort-filter (cdr (assq 'effort filter-alist)))
  (setq org-agenda-regexp-filter (cdr (assq 're filter-alist)))

  (unless (equal (current-buffer) abuf)
    (pop-to-buffer-same-window abuf)))
#+end_src

** filter candidates in agenda command :org:lang:
:PROPERTIES:
:ID:       377ded57-7431-4929-8be9-e04f8f172c38
:END:
:LINKS:
https://emacs.stackexchange.com/questions/53028/how-to-show-only-time-grid-without-todo-items-in-org-agenda
https://emacs.stackexchange.com/questions/15309/is-there-a-way-to-show-an-agenda-with-just-a-time-grid
:END:

The goal is to achieve, an agenda with only items in the time grid. There was a
[[https://emacs.stackexchange.com/questions/15309/is-there-a-way-to-show-an-agenda-with-just-a-time-grid][question]] asked about this. This is theoretically possible by creating a
skip function that skips all items that aren't in the time frame of the grid.
Ideally, what we'd want is to use =org-ql=.

Fortunately, there's a function =org-= that takes a =POM= (point or marker)
which is perfect for getting the agenda.

#+begin_src emacs-lisp
(defun! org-agenda%skip-if-not-today ()
  (let* ((time (org-entry-get (point) "DEADLINE"))
	 (dtime (when time (ts-parse-org time)))
	 (now (ts-now)))
    (if (and dtime
	     (= (ts-day dtime) (ts-day now))
	     (= (ts-year dtime) (ts-year now))
	     (= (ts-month-num dtime) (ts-month-num now)))
	nil
      (org-entry-end-position))))
#+end_src

** org-agenda-custom-commands :org:lang:
:PROPERTIES:
:ID:       b7023041-df49-4750-8b27-91b7175bd1ee
:END:
:LINKS:
https://llazarek.github.io/2018/09/improving-the-agenda-part-2-custom-views.html
https://blog.aaronbieber.com/2016/09/24/an-agenda-for-life-with-org-mode.html
https://orgmode.org/worg/org-tutorials/org-custom-agenda-commands.html
https://github.com/remyhonig/org-query
[[info:org#Filtering/limiting agenda items][info:org#Filtering/limiting agenda items]]
https://github.com/alphapapa/org-ql
:END:

The default org agenda display is pretty crude, particularly with several items.
To customize the default agenda view you can checkout
[[helpfvar:org-agenda-custom-commands][org-agenda-custom-commands]]. For sections of the agenda I suggest using
[[helpfn:org-ql-block][org-ql-block]]. It makes things easier and is likely much faster than the default
Emacs. In the future I want to divide these sections into their own function (or
variables?) so that I can easily piece together different agenda views.

#+begin_src emacs-lisp
(setq org-agenda-custom-commands
      '(("c" "My custom agenda"
         ((agenda ""
	   ((org-agenda-span 'day)
	    (org-agenda-overriding-header "")
	    (org-agenda-skip-function #'org-agenda%skip-if-not-today)))
	  (org-ql-block '(and (todo "TODO") (deadline))
	   ((org-ql-block-header "Most Pressing Todos")
	    (org-agenda-sorting-strategy '(deadline-down priority-up))
	    (org-agenda-max-entries 5)))
	  (org-ql-block '(and (todo "TODO") (tags "emacs") (deadline))
	   ((org-ql-block-header "Emacs Tasks")
	    (org-agenda-sorting-strategy '(deadline-down))
	    (org-agenda-max-entries 5)))))))
#+end_src

** call custom agenda directly :command:org:agenda:
:PROPERTIES:
:ID:       bb813af0-118a-49ff-ae69-4d4995dadcac
:END:

I don't like the org mode agenda dispatcher--or any of org-mode's interfaces to
be exact. Therefore, I define a function I can use instead.

#+begin_src emacs-lisp
(defun xl/org-agenda ()
  (interactive)
  (org-agenda nil "c"))
#+end_src

* org refile :refile:
:PROPERTIES:
:ID:       9999ac00-f663-43ff-a708-3d7c90d3dc21
:END:

** DOC org-refile
:PROPERTIES:
:ID:       6dfc0415-2945-4259-a782-b569fcb397ea
:END:

=org-refile= is a built-in package that.

#+begin_src emacs-lisp
(use-package org-refile
  :idle-require t
  :set
  (org-refile-targets                     . `((,XL-README-FILE . (:level . 10))))
  (org-refile-use-outline-path            . 'file)
  (org-refile-allow-creating-parent-nodes . t)
  (org-reverse-note-order                 . t)
  (org-outline-path-complete-in-steps     . nil))
#+end_src

** TODO allow refiling to any org file in Emacs dir :org:refile:xl:command:
:PROPERTIES:
:ID:       712d53c5-f4db-4968-b78f-0ab407b33814
:END:

#+begin_src emacs-lisp
(defun org/refile-to-emacs-config ()
  "Refile to any file in my emacs config."
  (interactive)
  (let ((org-refile-targets))
    (callf2 cl-adjoin (cons (xl-tangle-files) (cons :level 0)) org-refile-targets)
    (call-interactively #'org-refile)))
#+end_src

** TODO refile in current buffer :command:org:refile:
:PROPERTIES:
:ID:       c24b2065-4533-4e43-80a9-c1b2c891ead8
:END:

#+begin_src emacs-lisp
(defun org/refile-to-current-file (arg &optional file)
  "Refile heading at point to some other heading in current file."
  (interactive "P")
  (let ((org-refile-targets `((,(buffer-file-name) :maxlevel . 10)))
	(org-refile-use-outline-path t)
	(selectrum-should-sort nil)
        (org-refile-keep arg)
        current-prefix-arg)
    (call-interactively #'org-refile)))
#+end_src

* org-goto
:PROPERTIES:
:ID:       900250ad-ed09-4000-ab1c-be9f4d461951
:END:

#+begin_src emacs-lisp
(use-package org-goto
  :gadvice (org-goto-location . suppress-delete-windows))
#+end_src

* ox
:PROPERTIES:
:ID:       5f8eac7d-cc1f-4bba-bd65-77ead98c8e0c
:END:

This package stands for "org-export".

#+begin_src emacs-lisp
(use-package ox
  :gadvice (org-export--dispatch-ui . suppress-delete-windows))
#+end_src

* org-id
:PROPERTIES:
:ID:       95f2a096-2cf4-4634-aa32-13f00b31ea19
:END:

=org-id= is a built-in package that creates that provides tools for creating and
storing universally unique IDs. This is primarily used to disguish and
referenance org headlines.

#+begin_src emacs-lisp
(use-package org-id
  :idle-require t
  :hook (org-insert-heading-hook . org-id-get-create)
  :set
  (org-id-locations-file-relative . t)
  (org-id-link-to-org-use-id      . 'create-if-interactive-and-no-custom-id)
  (org-id-locations-file          . (concat XL-CACHE-DIR "org-id-locations"))
  (org-id-files                   . (list (f-full "~/README.org"))))
#+end_src

* asthetic :asthetic:
:PROPERTIES:
:ID:       f17ad3f4-3f21-49e2-a078-37304aad5138
:END:

** org-superstar
:PROPERTIES:
:ID:       c4428756-a804-47e8-9586-f63b82dd1561
:END:

#+begin_src emacs-lisp
(use-package org-superstar
  :hook org-mode-hook
  :set
  (org-superstar-leading-bullet     . ?\s)
  (org-superstar-special-todo-items . t))
#+end_src

** org-fancy-priorities
:PROPERTIES:
:ID:       c4ff4407-774c-4028-bb9d-01412fdfc8d2
:END:

#+begin_src emacs-lisp
(use-package org-fancy-priorities
  :hook org-mode-hook)
#+end_src

** org-pretty-tags
:PROPERTIES:
:ID:       7f024968-89ea-4e24-90a9-63771d8342b3
:END:

#+begin_src emacs-lisp
(use-package org-pretty-tags
  :hook org-mode-hook)
#+end_src

** org-babel-hide-markers-mode
:PROPERTIES:
:ID:       a7b3c769-985d-4ed1-90ec-f4923275ecd6
:END:

#+begin_src emacs-lisp
(use-package org-babel-hide-markers-mode)
#+end_src

** org-link-minor-mode
:PROPERTIES:
:ID:       25b93a1f-b105-47aa-9647-5015d23a4ac3
:END:

This is a minor mode for displaying links in non-org buffers.

#+begin_src emacs-lisp
(use-package org-link-minor-mode
  :hook outshine-mode-hook)
#+end_src

* org-toc
:PROPERTIES:
:ID:       aca910e9-364f-4631-a7eb-d7d6275b6472
:END:

This package creates a table of contents for your org file at the first headline
with the tag =:TOC:= on it. As you might have guessed [[helpvar:toc-org-max-depth][toc-org-max-depth]] is the
maximum dept at which toc will make the table of contents.

#+begin_src emacs-lisp
(use-package toc-org
  :hook org-mode-hook
  :set
  (toc-org-max-depth . 2))
#+end_src

* org-babel
:PROPERTIES:
:ID:       bac221d6-ab49-425f-8f89-d2bf741d3b3d
:END:

As I've mentioned, org-babel is increadibly slow. So slow that I don't think
even increasing the gc-cons-threshold will help enough. But here goes nothing.

#+begin_src emacs-lisp
(use-package ob-tangle
  :gc-pause org-babel-tangle)
#+end_src

