#+title: miscellaneous.org
#+author: Luis Henriquez-Perez
#+property: header-args :tangle ~/.config/emacs/lisp/

* key-chord :keybind:
:PROPERTIES:
:ID:       20d6d9c1-50a1-4699-a67c-e6f04d3b5576
:END:

Sometimes we donâ€™t have access to a convenient escape key--I mean that caps-lock
is not bound to escape. Or, perhaps, we might find it faster or preferable to
press jk really quickly to invoke escape.

This is better than evil escape as it only binds in insert.

#+begin_src emacs-lisp
(use-package key-chord
  :silence key-chord-mode
  :before-call evil-insert-state evil-emacs-state)
#+end_src

* TODO key-chord :disabled:
:PROPERTIES:
:ID:       65bb49db-7df4-4503-977d-b1285c7a48f3
:END:

#+begin_src emacs-lisp
(defafter! use-j-k-as-escape (key-chord evil)
  ())
#+end_src

* nameless :elisp:prog:
:PROPERTIES:
:ID:       695aeb73-89d3-47f8-bee8-2721111dd2bf
:END:

=nameless= is a package that truncates namespace prefixes that you specify
in. Shortening aliases allows for more concise, easier to read, and less
redundant code.

#+begin_src emacs-lisp
(use-package nameless
  :hook emacs-lisp-mode-hook
  :set (nameless-private-prefix . t))
#+end_src

* avy :navigation:interface:
:PROPERTIES:
:ID:       78064d92-2dde-4067-8a10-208ca6e88852
:END:

#+begin_src emacs-lisp
(use-package avy
  :set
  (avy-style . 'pre)
  (avy-keys . (number-sequence ?a ?z)))
#+end_src

* TODO zone :amusement:
:PROPERTIES:
:ID:       fe176959-3134-4b18-8abb-a962347b8df0
:END:

#+begin_src emacs-lisp
(use-package zone)
#+end_src

* zoom-frm :text:interface:
:PROPERTIES:
:ID:       15b8577e-3f98-420a-81a5-c7b91292aca3
:END:

This package increases or decreases the font of the current frame. It differs
from [[helpfn:text-scale-increase][text-scale-increase]] and [[helpfn:text-scale-decrease][text-scale-decrease]] in that it applies this
"zooming" to the whole frame instead of the current buffer.

#+begin_src emacs-lisp
(use-package zoom-frm
  :set
  (frame-zoom-font-difference . 0.5)
  (zoom-frame/buffer          . 'buffer))
#+end_src


* gc cons threshold :performance:core:
:PROPERTIES:
:ID:       50e19a55-a04b-4ca0-8024-a88b23b5b41f
:END:

I define three levels on frequency with which emacs should perform garbage
collection.

#+begin_src emacs-lisp
;; (defun xl-gc-cons-threshold ()
;;   "Return the gc-cons threshold."
;;   (* XL-GC-CONS-THRESHOLD-MULTIPLIER gc-cons-threshold))

;; (defcustom XL-GC-CONS-THRESHOLD-MULTIPLIER nil "The number multiplied")

(defconst XL-GC-CONS-THRESHOLD-MAX most-positive-fixnum
  "The upper limit for `gc-cons-threshold'.
When VOID is performing computationally intensive operations,
`gc-cons-threshold' is set to this value.")

(defconst XL-GC-CONS-THRESHOLD (eval-when-compile (* 16 1024 1024))
  "The default value for `gc-cons-threshold'.
This is the value of `gc-cons-threshold' that should be used in typical usages.")

(defconst XL-GC-CONS-THRESHOLD-MIN (eval-when-compile (* 4 1024 1024))
  "The value for `gc-cons-threshold'.")
#+end_src

* tramp :cache:
:PROPERTIES:
:ID:       a3ccfafa-dc88-4aac-bbe9-fc4ae0f00997
:END:

#+begin_src emacs-lisp
(use-package tramp
  :set
  (tramp-backup-directory-alist . backup-directory-alist)
  (tramp-persistency-file-name  . (concat XL-CACHE-DIR "tramp-persistency.el"))
  (tramp-auto-save-directory    . (concat XL-CACHE-DIR "tramp-auto-save/")))
#+end_src

* restart-emacs
:PROPERTIES:
:ID:       7412bc2f-0db1-44e9-8ea7-0dc595a04fca
:END:

#+begin_src emacs-lisp
(use-package restart-emacs
  :commands restart-emacs)
#+end_src

* elisp-demos :interface:elisp:
:PROPERTIES:
:ID:       2c419004-a7c1-4de5-bada-8420505cea90
:END:

This package has a good idea--namely it provides a systematic way to add
function/macro demos to documentation. Still, I have a few problems with this
package. For one thing, it adds the examples along with the ugly "begin/end_src"
lines. I'd rather have something like the comment arrow ~;=>~. Also, I'd like to
integrate it with writing tests. Wouldn't it be great if I could write tests for
a function and simultaneously add those tests as examples for how to use the
function?

#+begin_src emacs-lisp
(use-package elisp-demos
  :advice (:after (helpful-update . elisp-demos-advice-helpful-update)))
#+end_src

* bookmarks
:PROPERTIES:
:ID:       a4514b36-6e08-4a66-a595-cd40fc9acc0b
:END:

#+begin_src emacs-lisp
(use-package bookmark
  :set
  (bookmark-default-file . (concat XL-CACHE-DIR "bookmarks")))
#+end_src

* nsm
:PROPERTIES:
:ID:       0ca7fc66-5312-4c69-a87d-7607292c7a2a
:END:

#+begin_src emacs-lisp
(use-package nsm
  :set
  (nsm-settings-file . (concat XL-CACHE-DIR "network-settings.data")))
#+end_src

* mouse :mouse:
:PROPERTIES:
:ID:       d0d6de11-50fa-4ae2-ad4b-69712f3e2c54
:END:

#+begin_src emacs-lisp
(use-package mouse
  :set
  (mouse-yank-at-point . t))
#+end_src

* ansi-color
:PROPERTIES:
:ID:       5feaab76-e5c1-450c-94a6-8fdfb95ddb94
:END:

#+begin_src emacs-lisp
(use-package ansi-color
  :set
  (ansi-color-for-comint-mode . t))
#+end_src

* gv
:PROPERTIES:
:ID:       84cc5883-a303-453e-af91-644d4544e3f9
:END:

=gv= is what contains the code for the =setf= macro.
https://emacs.stackexchange.com/questions/59314/how-can-i-make-setf-work-with-plist-get

#+begin_src emacs-lisp
(use-package gv
  :xl-config
  (gv-define-simple-setter plist-get plist-put))
#+end_src

* image mode
:PROPERTIES:
:ID:       32e2118a-c92b-4e8d-b2db-048428462783
:END:

Non-nil means animated images loop forever, rather than playing once.

#+begin_src emacs-lisp
(use-package image-mode
  :set
  (image-animate-loop . t))
#+end_src

* uniquify :buffer:
:PROPERTIES:
:ID:       9ba2726b-3fef-4e9b-9387-a80ab09bdb7d
:END:

#+begin_src emacs-lisp
(use-package uniquify
  :set
  (uniquify-buffer-name-style . 'forward))
#+end_src

* compile
:PROPERTIES:
:ID:       913aa4f2-e42b-4b74-a2d4-e87b1738a5bd
:END:

#+begin_src emacs-lisp
(use-package compile
  :set
  (compilation-ask-about-save . nil)
  (compilation-scroll-output  . 'first-error)
  (compilation-always-kill    . t))
#+end_src

* bytecomp
:PROPERTIES:
:ID:       6b375bfb-a8c3-473c-8dbd-530e692a15ab
:END:

#+begin_src emacs-lisp
(use-package bytecomp
  :set
  (byte-compile-warnings . '(not free-vars unresolved noruntime lexical make-local))
  (byte-compile-verbose  . xl-debug-p))
#+end_src

* url :cache:
:PROPERTIES:
:ID:       d4c0b77e-7c6c-4ab3-bf20-fb0d335eb771
:END:

#+begin_src emacs-lisp
(use-package url
  :set
  (url-cache-directory         . (concat XL-CACHE-DIR "url/cache/"))
  (url-configuration-directory . (concat XL-CACHE-DIR "url/configuration/")))
#+end_src

* ffap
:PROPERTIES:
:ID:       acdd6407-c7db-40d7-9a7f-3a189d3c40eb
:END:

Don't ping things that look like domain names.

#+begin_src emacs-lisp
(use-package ffap
  :set
  (ffap-machine-p-known . 'reject))
#+end_src

* passwords and security :security:
:PROPERTIES:
:ID:       7ca7587e-d94b-408b-8656-c6a09d6ee8b6
:END:

I build my =mbsyncrc= and my =msmtprc= via tangling.

** pass
:PROPERTIES:
:ID:       6f3268a1-4606-435d-9bf4-05d1c54c28a9
:END:

#+begin_src emacs-lisp
(use-package pass)
#+end_src

** password-store
:PROPERTIES:
:ID:       3c57590c-1507-4369-b615-795965d4b182
:END:

#+begin_src emacs-lisp
(use-package password-store)
#+end_src

** email accounts :email:
:PROPERTIES:
:ID:       3a3c6778-dc5d-45cf-87d1-1c6aacbbae46
:END:

Whatever emails I may use, I'll be adding their password in my password store so
why not use this as a way to get email information?

#+begin_src emacs-lisp
(defun password-store:email-accounts ()
  "Return a list of email accounts."
  (->> (expand-file-name "email/" (password-store-dir))
       (directory-files)
       (cddr)
       (mapcar (fn! (s-chop-suffix ".gpg" <>)))))
#+end_src

** epa :gpg:
:PROPERTIES:
:ID:       ad3f6134-4fa6-492e-93a6-b94235ecad3d
:END:
:LINKS:
https://vxlabs.com/2021/03/21/gnupg-pinentry-via-the-emacs-minibuffer/
:END:

Setting these variables in coordination with [[id:58a65d49-cd9f-4b5d-86d7-d43209424cf3][my gpg-agent config]] lets me enter my
gpg passphrase via emacs.

#+begin_src emacs-lisp
(use-package epa-config
  :set
  (epg-gpg-program   . "gpg2")
  (epa-pinentry-mode . 'loopback))
#+end_src

* chess :amusement:
:PROPERTIES:
:ID:       1197be6f-a2ff-4cf1-8b78-02ebceb43317
:END:

#+begin_src emacs-lisp
(use-package chess)
#+end_src

* gcmh :performance:core:
:PROPERTIES:
:ID:       86653a5a-f273-4ce4-b89b-f288d5d46d44
:END:

=gcmh= does three things. It reduces garbage collection by setting, it adds a
hook telling Emacs to gargbage collect during idle time, and it tells Emacs
to garbage collect more frequently when it's idle.

Note that I add gcmh mode hook at the end so that all the other hook commands
are done before setting the =gc-cons-threshold= back to a normal value.

#+begin_src emacs-lisp
(use-package gcmh
  :hook emacs-startup-hook
  :set
  (gcmh-idle-delay          . 5)
  (gcmh-verbose             . xl-debug-p)
  (gcmh-high-cons-threshold . XL-GC-CONS-THRESHOLD)
  (gcmh-low-cons-threshold  . XL-GC-CONS-THRESHOLD-MIN))
#+end_src

* readme org file
:PROPERTIES:
:ID:       ceb0caee-f950-4ab5-a6e9-aad436334469
:END:

#+begin_src emacs-lisp
(defun xl/switch-to-readme ()
  "Switch to README."
  (interactive)
  (find-file (f-full "~/README.org")))
#+end_src

* idle-require :defer:
:PROPERTIES:
:ID:       0d619336-e852-4c6a-89a8-38ccbb71a077
:END:

Idle require is a tool for loading autoload functions, files or features during
idle time. The way to use this is to idle-require many small packages that
individually don't take too much time. This helps ensure that in emacs loading
of big packages like org-mode is snappy.

When emacs goes idle for [[helpvar:idle-require-idle-delay][idle-require-idle-delay]] seconds, the features will
start loading. [[helpvar:idle-require-load-break][idle-require-load-break]] is the break between features idle
require loads.

=idle-require= messages us to tell us when a package is being idle required and
when it has finished idle-requiring packages. I don't want to see the message
unless I'm debugging.

Since we're evaluating a good amount of lisp expressions, we should boost
garbage collection during this time.

#+begin_src emacs-lisp
(use-package idle-require
  :demand t
  ;; :xl-use-xl-log idle-require-mode idle-require-load-next
  :gc-pause idle-require-load-next
  :set
  (idle-require-load-break . 2)
  (idle-require-idle-delay . 10))
#+end_src

* hideshow :prog:
:PROPERTIES:
:ID:       2222cf6a-5274-4a33-ae74-357676fbd61d
:END:

#+begin_src emacs-lisp
(use-package hideshow
  :hook (prog-mode-hook . hs-minor-mode))
#+end_src

* commands :command:
:PROPERTIES:
:ID:       d4d49eb7-8fb3-414e-ad13-6ee353ee3466
:END:

** elisp init file
:PROPERTIES:
:ID:       74ad3337-4a36-4524-87c1-6b46b2dc24dd
:END:

#+begin_src emacs-lisp
(defun xl/switch-to-init-file ()
  "Switch to init file."
  (interactive)
  (find-file user-init-file))
#+end_src

** emacs directory
:PROPERTIES:
:ID:       7ea118cb-4eb6-4ffb-9d82-6ae65ff7a961
:END:

#+begin_src emacs-lisp
(defun xl/open-dired-at-emacs-dir ()
  "Switch to a dired buffer at emacs directory."
  (interactive)
  (dired user-emacs-directory))
#+end_src

** setting font size
:PROPERTIES:
:ID:       b138b662-4087-4199-abe5-ecacb22dfb2a
:END:

#+begin_src emacs-lisp
(defun xl/set-font-size ()
  "Set the font size interactively.
Inhibit accidentally setting font size too high or too low."
  (interactive)
  (let* ((old-size (/ (face-attribute 'default :height) 10))
         (prompt "The font size is currently %d. What do you want to change it to? ")
         (new-size (string-to-number (read-string (format prompt old-size)))))
    (cond ((> new-size XL-FONT-MAX-SIZE)
	   ;; (message "That font size is too large. It should be below %d." XL-FONT-MAX-SIZE)
	   (call-interactively #'xl/set-font-size))
	  ((< new-size XL-FONT-MIN-SIZE)
	   ;; (message "That font size is too small. It should be above %d." XL-FONT-MIN-SIZE)
	   (call-interactively #'xl/set-font-size))
	  (t
	   (xl-set-font-size new-size)
	   (message "Font set from %d to %d." old-size new-size)))))
#+end_src

** kill Emacs processes
:PROPERTIES:
:ID:       811f6b55-6f54-4854-9098-8754359b4f85
:END:

#+begin_src emacs-lisp
(defun xl/kill-emacs-processes ()
  "Kill all emacs processes."
  (interactive)
  (loopy (with (count 1) (process "emacs"))
	 (while (ignore-errors (kill-process process)))
	 (expr process (format "emacs<%d>" count))
	 (do (incf count))
	 (finally (message "killed %d processes" count))))
#+end_src

** font-face
:PROPERTIES:
:ID:       1bf8b603-ba11-422f-80d2-53dd8483fdbb
:END:

There is also no interactive function for setting the font face.

I will note that I use [[helpfn:xl-list-fonts][x-list-fonts]] intentionally, because it gives you options.

#+begin_src emacs-lisp
(defun xl/set-font-face ()
  "Apply an existing xfont to all graphical frames."
  (interactive)
  (alet (completing-read "Choose font: " (x-list-fonts "*"))
    (set-frame-font it nil t)))
#+end_src

** open Emacs instance
:PROPERTIES:
:ID:       287537bc-f1a7-4c04-bbb6-c372df540e04
:END:

#+begin_src emacs-lisp
(defun xl/open-emacs-instance ()
  "Open a new emacs instance in debug-mode."
  (interactive)
  (cond ((eq system-type 'darwin)
         (start-process-shell-command
          "emacs"
          nil "open -n /Applications/Emacs.app --args --debug-init"))
        ((eq system-type 'gnu/linux)
         (start-process "emacs" nil "emacs" "--debug-init"))))
#+end_src

