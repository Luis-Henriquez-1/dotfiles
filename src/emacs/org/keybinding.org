#+title: keybindings.org
#+author: Luis-Henriquez-Perez
#+tags: emacs config core bind

The goal is to efficiently setup the bindings we need to use Emacs. It's
important to remember that not matter how powerful the commands you have, if you
don't invest the time into binding them to useful keys you'll be very
inefficient, having to press =M-x= between any non built-in command. Its
important to bind them and to do it in an organized way so you can always find
the bindings you need when you need it.

* leaders
:PROPERTIES:
:ID:       1e4dac95-9c16-41db-9f99-63a250b447c2
:END:

The way I organize my keys is via leader keys. The leader will be the root of a
keybinding tree. And once you know the leader, you can "discover" the other
bindings as you need to. You can see the concept of the leader used in Emacs
distributions such as [[https://github.com/syl20bnr/spacemacs][Spacemacs]] and [[https://github.com/hlissner/doom-emacs][Doom Emacs]].

** evil leaders :evil:
:PROPERTIES:
:ID:       47c4c3c5-3859-46a4-a4ef-3d27c552eec0
:END:

These leaders are specifically for evil mode states (not including insert and
Emacs). I choose the space (=SPC=) key for evil leaders because it is one of if
not the easiest key to press because of its central placement on the keyboard
and its sheer size--at least on the [[https://en.wikipedia.org/wiki/QWERTY][qwerty]] keyboard that I use. The choice
of =SPC m= for the major mode specific keys is simply for the pnemonic =m= which
stands for "major mode". The short major mode prefix key =,= is for cases when I
want to shorten a key binding. Although obviously not as easy to remember as
=m=, it provides me with one shorter keypress in certain situations.

#+begin_src emacs-lisp
(defconst XL-EVIL-LEADER-KEY "SPC"
  "The evil leader prefix key.")

(defconst XL-EVIL-LOCALLEADER-KEY "SPC m"
  "The localleader prefix key for major-mode specific commands.")

(defconst XL-EVIL-LOCALLEADER-SHORT-KEY ","
  "A shorter alternative `xl-localleader-key'.")
#+end_src

** emacs leaders
:PROPERTIES:
:ID:       f3299c73-837e-46f9-a29e-9932c4570858
:END:

These leaders are for evil insert and emacs states as well as vanilla
Emacs. Note that evil Emacs state is different from vanilla Emacs. One of the
goals with these bindings is to set up keybindings in the case that I disable
evil mode or in the case that I want to use my bindings in insert or Emacs
state--or even vanilla Emacs. The choice behind the bindings is the same as
[[id:][before]], except I just prepended the =Meta= (a.k.a. the =Alt= key) to everything.

#+begin_src emacs-lisp
(defconst XL-EMACS-LEADER-KEY "M-SPC"
  "The leader prefix key used for Insert and Emacs states.")

(defconst XL-EMACS-LOCALLEADER-KEY "M-SPC m"
  "The localleader prefix key for major-mode specific commands.")

(defconst XL-EMACS-LOCALLEADER-SHORT-KEY "M-,"
  "A short non-normal  `xl-localleader-key'.")
#+end_src

* prefix commands
:PROPERTIES:
:ID:       2cf36d16-eafc-46d8-8b19-e1eb02d39c0d
:END:

A quote from [[https://github.com/hlissner/doom-emacs/blob/develop/core/core-keybinds.el#L182][Doom Emacs]]:

We use a prefix commands instead of general's :prefix/:non-normal-prefix
properties because general is incredibly slow binding keys en mass with them in
conjunction with :states -- an effective doubling of Doom's startup time!

#+begin_src emacs-lisp
(defvar xl-leader-map (make-sparse-keymap))

(define-prefix-command 'xl/leader 'xl-leader-map)
#+end_src

* bind! :extension:
:PROPERTIES:
:ID:       b6f3d4bc-b4e3-4e0d-a8db-4654f8dfe5ca
:END:

This headline is concerned with the definition of =bind!=, a general purpose
mapping macro similar to [[https://github.com/hlissner/doom-emacs/blob/develop/core/core-keybinds.el][doom's map macro]], [[https://github.com/justbur/emacs-bind-map][bind-map]], and [[https://github.com/priyadarshan/bind-key][bind]] used in
use-package (of these though it is most similar to doom's macro). The purpose is
to provide a versatile, non-repetative, and extensible syntax that does what I
mean. Overall I want to abstract the act of keybinding and to not concern myself
with the automatable (not a word probably) details of binding keys.

** evil key to states :evil:
:PROPERTIES:
:ID:       672841ed-1c4b-4351-ac68-e7107cc0bea2
:END:

I want to specify evil states via keywords just like Doom Emacs's =map!=
macro. So, for example =:nm= in front of a binding would mean the binding should
be bound in =normal= and =motion= state. The reason for doing this is that (1)
it is more concise than naming the actual states and (2) it allows us to specify
bindings of different states in the same form as opposed to [[helpfn:evil-define-key*][evil-define-key*]].

#+begin_src emacs-lisp
(defun xl-bind%evil-keyword-to-states (evil-keyword)
  "Return list of evil states specified by EVIL-KEYWORD.
EVIL-KEYWORD is a keyword whose letters correspond to the first letters of evil
states (e.g. :i \"i\" would correspond to \"insert\" state).
If any letter in EVIL-KEYWORD does not correspond to an evil state, return nil."
  (loopy (with (evil-states '(normal visual emacs insert operator motion)))
	 (seq char (seq-uniq (xl-keyword-name evil-keyword)))
	 (expr state (--first (->> (symbol-name it)
				   (seq-first)
				   (char-equal char))
			      evil-states))
	 (unless state (return nil))
	 (collect state)))
#+end_src

** deferring keymaps
:PROPERTIES:
:ID:       76200d2b-839d-4111-863a-08021e18c7e4
:END:

As it stands =define-key= and friends raise an error if the keymap you specified
has not been defined. We want the =bind!= macro to do what we mean: if a key's
keymap is not defined, then bind the key when it is.

*** deferred binding forms
:PROPERTIES:
:ID:       e03e1a47-41d1-4dd8-9f1a-8151de76da2a
:END:

To do this, the first step is creating a variable that will store the binding
forms that need to be evaluated when a keymap is loaded.

#+begin_src emacs-lisp
(defvar xl-bind%deferred-bindings nil
  "Alist of deferred bindings.
Each element is of the form (KEYMAP . BINDING-FORMS).
KEYMAP is a keymap that has not yet been bound. BINDING-FORMS are the forms to
be evaluated when KEYMAP is bound.")
#+end_src

*** updating deferred bindings
:PROPERTIES:
:ID:       fa345a49-e002-4efd-ba68-5f533d42aebb
:END:

This hook will traverse the alist of deferred bindings, checking to see whether
a keymap in the alist is bound. If it is we evaluate its corresponding forms.

#+begin_src emacs-lisp
(defun xl-bind%update-deferred-bindings (deferred-bindings)
  "Evaluate bindings whose keymap now exist.
Return any keymaps whose keymaps still don't exist."
  (iter (each (elt &as keymap . forms) deferred-bindings)
	(cond ((boundp keymap)
	       (xl-log "bind %s keys" keymap)
	       (funcall `(lambda () (progn ,@forms))))
	      (t
	       (collect elt)))))
#+end_src

*** hook for deferred bindings
:PROPERTIES:
:ID:       a95d82f1-9614-4ec5-a2e5-a2f29f514e2b
:END:

We also need to add a hook to [[helpfn:after-load-functions][after-load-functions]]. The hook
=after-load-functions= is abnormal because it does not end in =-hook=. It is run
after any file is loaded. We put use this hook so we can be sure to catch any
new keymaps.

#+begin_src emacs-lisp
(defhook! eval-deferred-bindings (after-load-functions)
  "Evaluate deferred bindings whose keymap is now bound."
  (cl-callf xl-bind%update-deferred-bindings xl-bind%deferred-bindings))
#+end_src

*** with-deferred-keymap!
:PROPERTIES:
:ID:       ddb17e5c-74e8-445e-b659-cf94f4831a46
:END:

The final touch is to create a macro that evaluates its body only if a specified
keymap is already bound. If the keymap is not bound then it simply updates
[[helpvar:xl-bind%deferred-bindings][xl-bind:deferred-bindings]]. I wrap every individual binding with this form.

#+begin_src emacs-lisp
(defmacro with-deferred-map! (map &rest forms)
  "Defer the evaluation of FORMS until MAP is loaded.
If MAP is already loaded, evaluate forms immediately."
  (declare (indent defun))
  (pcase map
    ((or (pred boundp) 'local-map 'global-map)
     `(progn ,@forms))
    (_
     `(cl-callf a-update xl-bind%deferred-bindings ',map #'append ',forms))))
#+end_src

** read a clause
:PROPERTIES:
:ID:       255730df-5715-4808-8a7d-6c37bd1333e5
:END:

#+begin_src emacs-lisp
(defun xl-bind%read-clause (clauses)
  "Return CLAUSES."
  (loopy (with (clauses (--splice (listp (car it)) (xl-bind%read-clause it) clauses)))
	 (list clause clauses)
	 (cond ((or (xl-bind%binding-p clause)
		    (xl-bind%binding-p (-butlast clause)))
		(collect bindings clause))
	       (t
		(append common-args clause)))
	 (finally-return (-map (-partial #'append common-args) bindings))))
#+end_src

** whether is a binding
:PROPERTIES:
:ID:       743e3fdb-fb0c-44ba-a5e9-7282b20cfdcc
:END:

#+begin_src emacs-lisp
(defun xl-bind%binding-p (clause)
  "Return non-nil if CLAUSE contains a keybinding."
  (pcase (-take-last 2 clause)
    (`(,(or (pred stringp) (pred vectorp) (pred symbolp)) ,(pred xl-quoted-p)) t)
    (_ nil)))
#+end_src

** normalization
:PROPERTIES:
:ID:       56abc5a3-bcf7-4943-a941-939e16d46dea
:END:

The purpose of normalization is to make the clauses homogenous and into a form
that is easily.

*** fix the keybinding
:PROPERTIES:
:ID:       0202c1a2-75a3-45ac-a226-8b6b906d96ac
:END:

This means that the keybinding should always be last.

#+begin_src emacs-lisp
(defun xl-bind%normalize-keybinding (clause)
  "Return clause with proper keybinding."
  (append (-drop-last 2 clause)
	  (-interleave '(:key :def) (-take-last 2 clause))))
#+end_src

*** fix the evil state :evil:
:PROPERTIES:
:ID:       1a8f4cf8-1013-4e0c-8fd1-21b69c2e6b8b
:END:

#+begin_src emacs-lisp
(defun xl-bind%normalize-evil-state (clause)
  "Return clause with proper evil-state."
  (pcase (-take-last 5 clause)
    (`(,(and (pred keywordp) ekey) :key ,_ :def ,_) t
     `(,@(-drop-last 5 clause) :states ,(xl-bind%evil-keyword-to-states ekey)
       ,@(-take-last 4 clause)))
    (_ clause)))
#+end_src

*** flatten plist values
:PROPERTIES:
:ID:       6be10885-4bbe-47e2-bd47-0c14f51b9065
:END:

Remember, that the goal of normalization is to end up with a list of plists with.

#+begin_src emacs-lisp
(defun xl-bind%flatten-plist-values (plist)
  "Expand clause."
  (loopy (cons (key val . rest) plist #'cddr)
	 (cond ((or (atom val) (xl-quoted-p val))
		(append new (list key val)))
	       ((= 1 (length val))
		(append new (list key (car val))))
	       (t
		(expr tails (xl-bind%flatten-plist-values `(,key ,(cdr val) ,@rest)))
		(subloop (list tail tails)
			 (collect flattened (append new tail)))
		(append new (list key (car val)))))
	 (finally-return (cons new flattened))))
#+end_src

*** make clause into proper plist
:PROPERTIES:
:ID:       e836329e-c2b9-4978-a3d7-9ba32c160f04
:END:

#+begin_src emacs-lisp
(defun xl-bind%make-proper-plist (list)
  "Ensure every key in LIST has only one value."
  (loopy (with (list `(,@list :done)))
	 (while list)
	 (expr elt (pop list))
	 (expr next (car list))
	 (cond ((keywordp elt)
		(expr key elt))
	       (t
		(collect values elt)))
	 (when (keywordp next)
	   (append plist (list key (xl-dwim-single values)))
	   (expr values nil))
	 (finally-return plist)))
#+end_src

*** merge multiple plist values
:PROPERTIES:
:ID:       d50cb073-54c0-4b96-8df1-2ae195ac4651
:END:

#+begin_src emacs-lisp
(defun xl-bind%merge-duplicate-plist-keys (plist)
  "Merge duplicate keys in PLIST."
  (iter (conses (key val . _) plist #'cddr)
	(cond ((assoc key alist)
	       (expr var (alist-get key alist))
	       (set var (append (symbol-value var) (list val))))
	      (t
	       (expr var (gensym (symbol-name key)))
	       (set var (list val))
	       (collect alist (cons key var))))
	(fret (loopy (list (key . var) alist)
		     (append (list key (xl-dwim-single (symbol-value var))))))))
#+end_src

*** normalize the list
:PROPERTIES:
:ID:       377bcdf9-3798-4dff-83e5-13f3a59e112e
:END:

#+begin_src emacs-lisp
(defun xl-bind%normalize-plist (plist)
  "Return the list normalized."
  (loopy (while plist)
	 (expr key (pop plist))
	 (expr values (loopy (while (and plist (not (keywordp (car plist)))))
			     (collect (pop plist))))
	 (expr alist (a-update alist key #'append (list values)))
	 (finally-return alist)))
#+end_src

*** ensure-keymap
:PROPERTIES:
:ID:       1fb99451-7b0e-4bef-b980-7f4e038dd38d
:END:

#+begin_src emacs-lisp
(defun xl-bind%ensure-keymap (token)
  (if (not (plist-get token :map))
      `(:map global-map ,@token)
    token))
#+end_src

*** apply-prefix
:PROPERTIES:
:ID:       5c1aa062-8660-453b-ba8e-04610bec043a
:END:

#+begin_src emacs-lisp
(defun xl-bind%apply-prefix (token)
  (-let [(&plist :prefix :key) token]
    (if (and prefix key (stringp key))
	`(:key ,(concat prefix "\s" key) ,@token)
      token)))
#+end_src

*** convert lists
:PROPERTIES:
:ID:       74298919-c3f2-4e7e-8377-bd8a87def771
:END:

#+begin_src emacs-lisp
(defun xl-bind%process-prefix (plist)
  (loopy (cons (key val . _) plist #'cddr)
	 (cond ((and (eq key :prefix) (listp val))
		(append (list key (s-join "\s" val))))
	       (t
		(append (list key val))))))
#+end_src

** converting tokens to forms
:PROPERTIES:
:ID:       aade9ecc-ee16-407d-a451-03da731daeb2
:END:

This section is about actually converting define key clauses that have already
been parsed and processed into lisp forms that actually correspond to
bindings. The design of this step follows a =use-package=.

*** convert logic
:PROPERTIES:
:ID:       9c779428-a8b5-4e2c-b3d3-c369f7f161b0
:END:

What list of converters should be used to edit the token depends on the token
itself. Some converters imply not using others. Some should only be used in
certain circumstances.

#+begin_src emacs-lisp
(defvar xl-bind%converters
  '((evil-which-key which-key)
    which-key
    defer-map
    kbd
    (evil-bind bind)
    bind))
#+end_src

*** decide on which converters to use
:PROPERTIES:
:ID:       09ad63c3-c438-47d2-9e4e-789bc0a4b488
:END:

Code that is split into appropriate parts is easier to read and write.

#+begin_src emacs-lisp
(defun xl-bind%converters (token)
  "Return a list of converters for TOKEN."
  (loopy (with (converters xl-bind%converters))
	 (list (name . exclude) (-map #'-list converters))
	 (expr convert-fn (xl-symbol-intern 'xl-bind%convert- name))
	 (expr pred (xl-symbol-intern 'xl-bind%predicate- name))
	 (when (and (funcall pred token) (not (member name excluded)))
	   (collect fns convert-fn)
	   (append excluded exclude))
	 (finally-return fns)))
#+end_src

*** convert token to forms
:PROPERTIES:
:ID:       10116109-b7a6-4e6e-94b2-6b41d4fc9f1f
:END:

#+begin_src emacs-lisp
(defun xl-bind%convert-token-to-forms (token converters)
  "Convert TOKEN to a list of forms."
  (-let [(converter . rest) converters]
    (funcall (or converter #'ignore) token rest)))
#+end_src

*** binding-forms
:PROPERTIES:
:ID:       31d4d497-afac-4ccf-a426-afa8f159e242
:END:

#+begin_src emacs-lisp
(defun xl-bind%binding-forms (tokens)
  "Convert BIND-TOKENS to binding forms.
Return a list of forms that binds keys specified by BIND-TOKENS."
  (loopy (list token tokens)
	 (expr converters (xl-bind%converters token))
	 (expr forms (xl-bind%convert-token-to-forms token converters))
	 (append forms)))
#+end_src

*** converting to forms
:PROPERTIES:
:ID:       7fd1a756-b8aa-41e4-8dae-7a0dfdd1e17b
:END:

**** which-key
:PROPERTIES:
:ID:       076b2b4d-7c12-4ebd-8f84-1d649487ae72
:END:

#+begin_src emacs-lisp
(defun xl-bind%predicate-which-key (token)
  "Return non-nil if TOKEN has a which-key."
  (--all-p (plist-get token it) '(:key :map :wk :prefix)))

(defun xl-bind%convert-which-key (token converters)
  "Add needed which-key form."
  (-let* (((&plist :key :map :wk :prefix) token))
    `((after! which-key
	(which-key-add-keymap-based-replacements ,map ,prefix ,wk))
      ,@(xl-bind%convert-token-to-forms token converters))))
#+end_src

**** evil which-key :evil:
:PROPERTIES:
:ID:       290cceaf-30b1-48d0-a688-b7db49728f01
:END:

The way evil works is that for an existing map (such as =org-mode-map=), it
creates an evil variant for each state. And this is the keymap that actually has
priority over original keymap when the given state is enabled. You can access
this keymap via the function [[helpfn:evil-get-auxiliary-keymap][evil-get-auxiliary-keymap]].

#+begin_src emacs-lisp
(defun xl-bind%predicate-evil-which-key (token)
  (and (xl-bind%predicate-which-key token)
       (xl-bind%predicate-evil-bind token)))

(defun xl-bind%convert-evil-which-key (token converters)
  "Return which key forms for an evil token."
  (loopy (with ((&plist :states :map :prefix :key :wk) token)
	       (rest (xl-bind%convert-token-to-forms token converters)))
	 (list state states)
	 (expr keymap `(evil-get-auxiliary-keymap ,map ',state))
	 (collect forms `(which-key-add-keymap-based-replacements ,keymap ,prefix ,wk))
	 (finally-return `((after! which-key ,@forms) ,@rest))))
#+end_src

**** evil-bind :evil:
:PROPERTIES:
:ID:       7d69d323-2eeb-4d90-88c8-cfde7f7768d3
:END:

#+begin_src emacs-lisp
(defun xl-bind%predicate-evil-bind (token)
  "Return non-nil if TOKEN."
  (and (xl-bind%predicate-bind token)
       (plist-get token :states)
       t))

(cl-defun xl-bind%convert-evil-bind (token converters)
  "Return evil binding form for TOKEN."
  (-let [(&plist :states :map :key :def) token]
    `((after! evil (evil-define-key* ',states ,map ,key ,def))
      ,@(xl-bind%convert-token-to-forms token converters))))
#+end_src

**** bind
:PROPERTIES:
:ID:       be633966-63b6-40ef-a5fe-79444218caf2
:END:

#+begin_src emacs-lisp
(defun xl-bind%predicate-bind (token)
  (-all-p (-partial #'plist-get token) '(:map :key :def)))

(defun xl-bind%convert-bind (token converters)
  "Add binding form for token."
  (-let [(&plist :prefix :map :key :def :states) token]
    `((define-key ,map ,key ,def)
      ,@(xl-bind%convert-token-to-forms token converters))))
#+end_src

**** defer binding
:PROPERTIES:
:ID:       f8892022-1921-44de-b157-7182bbcba31c
:END:

#+begin_src emacs-lisp
(defun xl-bind%predicate-defer-map (token)
  (xl-bind%predicate-bind token))

(defun xl-bind%convert-defer-map (token converters)
  `((with-deferred-map! ,(plist-get token :map)
      ,@(xl-bind%convert-token-to-forms token converters))))
#+end_src

**** kbd
:PROPERTIES:
:ID:       cdf12c08-799d-4cbc-be73-88ca77efc16f
:END:

This is the final step. The purpose of the binding tokens is to conveniently
provide the data needed about each binding so that we can write our own custom
function to generate binding forms. Obviously, this is very customizable.

#+begin_src emacs-lisp
(defun xl-bind%predicate-kbd (token)
  (and (plist-get token :kbd) (not (vectorp (plist-get token :key))) t))

(defun xl-bind%convert-kbd (token converters)
  (-let [(&plist :kbd :key) token]
    (-> (if kbd (map-insert token :key `(kbd ,key)) token)
	(xl-bind%convert-token-to-forms converters))))
#+end_src

*** localleader :evil:
:PROPERTIES:
:ID:       e83756c1-2472-4b69-8a9e-4a9328af32a7
:END:

This is a wrapper macro around =bind!= that applies. Eventually, I want to
implement this macro as a =:localleader= keyword, so I can use just one macro,
=bind!= for everything. But this was easier to implement quickly.

#+begin_src emacs-lisp
(defmacro bind-localleader! (&rest clause)
  "Apply localleader to bindings."
  `(bind!
     ((:prefix ,XL-EMACS-LOCALLEADER-KEY ,XL-EMACS-LOCALLEADER-SHORT-KEY)
      ,@clause)
     ((:prefix ,XL-EMACS-LOCALLEADER-KEY ,XL-EMACS-LOCALLEADER-SHORT-KEY)
      (:states insert emacs)
      ,@clause)
     ((:prefix ,XL-EVIL-LOCALLEADER-KEY ,XL-EVIL-LOCALLEADER-SHORT-KEY)
      (:states normal visual motion)
      ,@clause)))
#+end_src

** bind!
:PROPERTIES:
:ID:       0ce28150-7971-466f-b9b7-3cf33c496393
:END:

Finally, our main macro is here.

#+begin_src emacs-lisp
(defmacro bind! (&rest clauses)
  "Define bindings based on CLAUSES."
  (declare (indent defun))
  `(progn
     ,@(->> (xl-bind%read-clause (cons '(:kbd t) clauses))
	    (-map #'xl-bind%normalize-keybinding)
	    (-map #'xl-bind%normalize-evil-state)
	    (-map #'xl-bind%make-proper-plist)
	    (-mapcat #'xl-bind%flatten-plist-values)
	    (-map #'xl-bind%merge-duplicate-plist-keys)
	    (-map #'xl-bind%process-prefix)
	    (-map #'xl-bind%apply-prefix)
	    (-mapcat #'xl-bind%flatten-plist-values)
	    (-map #'xl-bind%ensure-keymap)
	    (xl-bind%binding-forms))))
#+end_src

* ensuring high keymap precedence
:PROPERTIES:
:ID:       e06bcfa0-63e9-429e-8ff7-4263cbd4f9b1
:END:

In Emacs, there's a [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Searching-Keymaps.html][hierarchy of keymaps]] that consulted when determining which
keymap takes precedence. The steps I take in this headline are also in [[https://github.com/noctuid/evil-guide#preventing-certain-keys-from-being-overridden][noctuid's
evil-guide]].

** minor mode
:PROPERTIES:
:ID:       9863dc90-fc8c-422c-918f-3d75d52e8a14
:END:

Creating a minor mode to hold the leader map allows us to toggle our leader
bindings on or off.

Enabling =override-mode= needs to be the first thing we do in
=emacs-startup-hook=, or at least it needs to be before modes that set
keybindings like evil. Otherwise, your bindings might not take effect
immediately. This is why I set the advice dept to =-100=.

#+begin_src emacs-lisp
(defvar xl-override-mode-map (make-sparse-keymap))

(define-minor-mode xl-override-mode
  "Global minor mode for higher precedence evil keybindings."
  :keymap xl-override-mode-map
  :global t)

(xl-hook-add 'emacs-startup-hook #'xl-override-mode -100)
#+end_src

** take precedence over Emacs bindings
:PROPERTIES:
:ID:       9248fb7f-1901-4beb-8b3a-faded48cdddc
:END:

Looking at the [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Searching-Keymaps.html][Emacs keymap hierarchy]], emulation mode maps is pretty up
there. The [[helpvar:emulation-mode-map-alists][emulation-mode-map-alists]] takes an ali.

#+begin_src emacs-lisp
(push '((xl-override-mode . xl-override-mode-map)) emulation-mode-map-alists)
#+end_src

** make an overriding map
:PROPERTIES:
:ID:       f52fbd32-58a0-4b60-a382-b29112f5d972
:END:

The whole point of the leader bindings is that they be available everywhere and
at all times. Accordingly, we want to ensure our leaders and all their child
bindings take precedence over other Emacs bindings. To do this I create a keymap
that will override all other keymaps, aptly named =XL-OVERRIDE-MAP=.

#+begin_src emacs-lisp
(define-key xl-override-mode-map (kbd XL-EMACS-LEADER-KEY) #'xl/leader)
#+end_src

** registering override map with evil :evil:
:PROPERTIES:
:ID:       23b55b9c-ea38-485a-b986-ac62d60a6f75
:END:

To ensure that =xl-override-mode-map= takes priority over evil states, we need
to make it an intercept map for all evil states. In evil, intercept maps are
maps that take priority (intercept) evil bindings when they have a different
binding for the same key (this is opposed to =overriding-maps=, which completely
override an evil keymap).

#+begin_src emacs-lisp
(defhook! make-intercept-map (evil-mode-hook)
  "Register `xl-override-map' as an intercept map."
  (iter (each state '(normal motion visual insert emacs))
	(evil-make-intercept-map xl-override-mode-map state t)))
#+end_src

** binding the leader keys to the prefix map :evil:
:PROPERTIES:
:ID:       d710cbf7-66c5-4934-a2d4-998fdb6f7731
:END:

These keys need to be bound before =evil-mode-hook=, specifically right after
evil is loaded. Otherwise, the bindings won't take effect immediately in buffers
that have already been created by emacs (such as =*scratch*= and
=*Messages*=). Instead, they will only work after you switch states once.

#+begin_src emacs-lisp
(bind!
 (:map xl-override-mode-map)
 (:ie XL-EMACS-LEADER-KEY 'xl/leader)
 (:mnv XL-EVIL-LEADER-KEY 'xl/leader))
#+end_src

* execute extended command
:PROPERTIES:
:ID:       f17a6b64-f9df-4801-9728-235f6bbb9b4d
:END:

One of the most common--if not the most common--command you use in Emacs is
[[helpfn:execute-extended-command][execute-extended-command]]. This command let's you search any other command and
upon pressing enter, then you execute the command. The fact that this command is
invoked so frequently suggests it should have one of the shortest, easiest to
press bindings. I chose to give it =SPC SPC= and =;=. =SPC SPC= is short and
quick to type as well as consistent with other =SPC= bindings. While =;= is
super fast to press as well and even faster than =SPC SPC=.

#+begin_src emacs-lisp
(bind!
  (:map xl-leader-map "SPC" #'execute-extended-command)
  (:n ";" #'execute-extended-command)
  ("A-x" #'execute-extended-command)
  ("M-x" #'execute-extended-command))
#+end_src

* space bindings
:PROPERTIES:
:ID:       90c3de63-f4f4-438b-8221-a4aedc7a1968
:END:

** generic app
:PROPERTIES:
:ID:       68945ce0-82fb-4844-b53b-422c328558af
:END:

#+begin_src emacs-lisp
(bind!
  (:prefix "a" :wk "app")
  (:map xl-leader-map)
  ("c" #'org-capture)
  ((:prefix "o" :wk "arg")
   ("a" #'org-agenda)
   ("l" #'org-store-link)
   ("i" #'org-clock-in-last)
   ("o" #'org-clock-out)
   ("c" #'org-capture))
  ("l" #'xl--log-open-log)
  ("e" #'eshell)
  ("E" #'xl/open-emacs-instance)
  ("d" #'deer)
  ("r" #'ranger))
#+end_src

** help
:PROPERTIES:
:ID:       f28081e3-451c-4005-80cc-bffeafe0051c
:END:

#+begin_src emacs-lisp
(bind!
  (:map xl-leader-map)
  (:prefix "h" :wk "help")
  ("i" #'info)
  ("m" #'describe-mode)
  ("f" #'describe-function)
  ("v" #'describe-variable)
  ("c" #'describe-char)
  ("k" #'describe-key)
  ("a" #'apropos)
  ("w" #'woman))
#+end_src

** toggling
:PROPERTIES:
:ID:       b962fa01-d63f-47a9-bf69-b2f82c8b1e61
:END:

I have kind of a loose definition of "toggle" in this headline.

#+begin_src emacs-lisp
(bind!
  (:prefix "t" :wk "toggle")
  (:map xl-leader-map)
  ("r" #'read-only-mode)
  ("t" #'load-theme)
  ("c" #'caps-lock-mode)
  ("d" #'toggle-debug-on-error)
  ("F" #'xl/set-font-face)
  ("f" #'xl/set-font-size))
#+end_src

** buffer
:PROPERTIES:
:ID:       5fd53168-3eee-4ed4-8213-28efba5d0200
:END:

#+begin_src emacs-lisp
(bind!
  (:prefix "b" :wk "buffer")
  (:map xl-leader-map)
  ("w" #'save-buffer)
  ((:prefix "k" :wk "kill")
   ("c" #'kill-current-buffer)
   ("o" #'xl/kill-other-buffers))
  ("n" #'next-buffer)
  ("p" #'previous-buffer)
  ("d" #'display-buffer)
  ("b" #'consult-buffer))
#+end_src

** file
:PROPERTIES:
:ID:       3857a17c-1a14-4163-a23b-8811a2dad111
:END:

#+begin_src emacs-lisp
(bind!
  (:prefix "f" :wk "file")
  (:map xl-leader-map)
  ("s" #'save-buffer)
  ("f" #'find-file)
  ("i" #'xl/switch-to-init-file)
  ("r" #'xl/switch-to-readme))
#+end_src

** code
:PROPERTIES:
:ID:       d6229bf2-9d8d-4f97-bb95-b07ef409e33f
:END:

#+begin_src emacs-lisp
(bind!
  (:prefix "c" :wk "code")
  (:map xl-leader-map)
  ("l" #'lispyville-comment-or-uncomment)
  ("c" #'lispyville-comment-or-uncomment))
#+end_src

** eval
:PROPERTIES:
:ID:       3947b258-fc46-4fc9-8350-3fd25a69d749
:END:

#+begin_src emacs-lisp
(bind!
  (:prefix "e" :wk "eval")
  (:map xl-leader-map)
  ("e" #'eval-expression))

(bind-localleader!
 (:prefix "e" :wk "eval")
 (:map emacs-lisp-mode-map)
 ("d" #'eval-defun)
 ("e" #'eval-expression)
 ("l" #'eval-last-sexp)
 ("p" #'eval-print-last-sexp))
#+end_src

** search

#+begin_src emacs-lisp
(bind!
  (:prefix "s" :wk "search")
  (:map xl-leader-map)
  ((:prefix "w" :wk "web")
   ("d" #'engine/search-duckduckgo)
   ("q" #'engine/search-qwant)
   ("a" #'engine/search-amazon)
   ("w" #'engine/search-wikipedia))
  ("s" #'consult-line)
  ("l" #'consult-line)
  ("h" #'consult-outline)
  ("o" #'consult-outline))
#+end_src

** version control
:PROPERTIES:
:ID:       31234afc-a11d-42a8-88af-e0647d44c1b1
:END:

#+begin_src emacs-lisp
(bind!
  (:prefix "v" :wk "version control")
  (:map xl-leader-map)
  ((:prefix "g" :wk "git-gutter+")
   ("u" #'git-gutter+-unstage-whole-buffer)
   ("n" #'git-gutter+-next-hunk)
   ("p" #'git-gutter+-previous-hunk)
   ("s" #'git-gutter+-stage-hunks)
   ("c" #'git-gutter+-commit))
  ("s" #'magit-status))
#+end_src

** packages
:PROPERTIES:
:ID:       0ec9aee0-8f9a-4700-8928-abff758357e1
:END:

#+begin_src emacs-lisp
(bind!
  (:prefix "p" :wk "packages")
  (:map xl-leader-map)
  ("i" #'straight-use-package)
  ("u" #'straight-pull-package)
  ("r" #'straight-rebuild-package)
  ("h" #'straight-visit-package-website)
  ("d" #'visit-package-directory))
#+end_src

** quit
:PROPERTIES:
:ID:       ae435361-79e7-41c8-b490-8ec0f8d23a59
:END:

There's many ways to quit Emacs. Sometimes I'd like to save all the buffers I
had been working on. Sometimes, when I'm testing something and I mess up
[[helpvar:kill-emacs-hook][kill-emacs-hook]] I want Emacs to just quit even if it means ignoring that hook.
Most of the time, I know what I'm doing when I quit Emacs, so I don't want a
prompt asking me if I'm sure.

#+begin_src emacs-lisp
(bind!
  (:prefix "q" :wk "quit")
  (:map xl-leader-map)
  ("q" #'save-buffers-kill-emacs)
  ("s" #'xl/quit-emacs-no-prompt)
  ("Q" #'evil-save-and-quit)     
  ("x" #'xl/kill-emacs-no-hook)
  ("e" #'xl/kill-emacs-processes)
  ("b" #'xl/kill-emacs-brutally))
#+end_src

