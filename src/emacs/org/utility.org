#+title: utility.org
#+author: Luis Henriquez-Perez

* TODO origami
:PROPERTIES:
:ID:       ac2cc043-331f-435b-b903-39681b84fefe
:END:

=origami= is, as its name suggests, a package that handles folding.

#+begin_src emacs-lisp
(use-package origami)
#+end_src

* pdf-tools :pdf:exec:
:PROPERTIES:
:ID:       63343f9d-6b19-43de-8302-d1344d571949
:END:

** pdf-tools
:PROPERTIES:
:ID:       e19d0200-5e41-4295-ae54-fa71bfeadb06
:END:

#+begin_src emacs-lisp
(use-package pdf-tools
  :magic ("%PDF" . pdf-view-mode)
  :init
  (push '("\\.[pP][dD][fF]\\'" . pdf-view-mode) auto-mode-alist))
#+end_src

** epd-pdf-info-program :startup:
:PROPERTIES:
:ID:       25826061-a4a7-4f8a-8d3b-bdd5a80f70d0
:END:

#+begin_src emacs-lisp
(defun! build-pdf-into-program-maybe ()
  "Build the pdf-info program if it hasn't already been built."
  (:before pdf-view-mode)
  (unless (file-executable-p pdf-info-epdfinfo-program)
    (let ((wconf (current-window-configuration)))
      (pdf-tools-install)
      (message "Building epdfinfo, this will take a moment...")
      (with-current-buffer buffer
	(iter (each buffer buffer-list)
	      (when (eq major-mode 'pdf-view-mode) (fundamental-mode))))
      (while compilation-in-progress
        ;; Block until `pdf-tools-install' is done
        (redisplay)
        (sleep-for 1))
      ;; HACK If pdf-tools was loaded by you opening a pdf file, once
      ;;      `pdf-tools-install' completes, `pdf-view-mode' will throw an error
      ;;      because the compilation buffer is focused, not the pdf buffer.
      ;;      Therefore, it is imperative that the window config is restored.
      (when (file-executable-p pdf-info-epdfinfo-program)
        (set-window-configuration wconf)))))
#+end_src

** bindings :bind:
:PROPERTIES:
:ID:       506c568c-0473-4db6-82b6-cc91174b0ce4
:END:

#+begin_src emacs-lisp
(bind!
  (:states normal)
  (:map pdf-view-mode-map)
  ("j" #'pdf-view-next-line-or-next-page)
  ("k" #'pdf-view-previous-line-or-previous-page)
  ("0" #'pdf-view-first-page)
  ("9" #'pdf-view-last-page)
  ("s" #'pdf-view-fit-width-to-window))
#+end_src

* ednc :notify:
:PROPERTIES:
:ID:       e72dfee2-3c80-4206-b2ea-d4a25fffc75c
:END:

This is a replacement for things like =dunst= except written completely en Emacs
lisp.

#+begin_src emacs-lisp
(use-package ednc)
#+end_src

* egg-timer :notify:
:PROPERTIES:
:ID:       a98d0f06-5b2a-449d-8719-bcc8d3d0a241
:END:

#+begin_src emacs-lisp
(use-package egg-timer)
#+end_src

* multimedia :multimedia:
:PROPERTIES:
:ID:       5675cbbc-beb1-4470-a1d2-08f253bb4535
:END:

** screenshots :screenshot:
:PROPERTIES:
:ID:       26d59d00-72e3-4b8c-9845-e5d9627cd4aa
:END:

This headline contains utilities for taking screenshots. As I see it,
screenshots are vital. I use maim to take screenshots because. I will note that
when I used [[][escr]] to take screenshots, those screenshots would not show
exwm windows. =escr= used [[][]]'s import.

*** screenshot name
:PROPERTIES:
:ID:       7210e8a8-7cbc-40ec-bd70-f8cfc6a32c56
:END:

The name for the screenshot.

**** xl-screenshot-path
:PROPERTIES:
:ID:       a6a75a8c-8d00-4f26-9df0-7f24af577e87
:END:

#+begin_src emacs-lisp
(defun xl-screenshot-path (name)
  "Return the full path where screenshot named NAME should go."
  (format "%s%s.png" (xl-screenshot-dir) name))
#+end_src

**** whether to prompt for screenshots
:PROPERTIES:
:ID:       1c280e62-2a1b-41f8-8ff9-039528652fcf
:END:

#+begin_src emacs-lisp
(defvar xl-prompt-for-screenshot-name-p t
  "If non-nil, prompt for screenshot name.")
#+end_src

**** name passed into prompt
:PROPERTIES:
:ID:       e8a21618-50f6-45ba-9a38-bff5c6d0a924
:END:

#+begin_src emacs-lisp
(defun xl-prompt-screenshot-name ()
  "Prompt for screenshot name."
  (when xl-prompt-for-screenshot-name-p
    (alet (read-string "Image Name: ")
      (unless (string-empty-p it)
	(xl-screenshot-path it)))))
#+end_src

**** default screenshot name
:PROPERTIES:
:ID:       58405f4f-e891-494e-afc7-a227415ec12b
:END:

#+begin_src emacs-lisp
(defun xl-default-screenshot-name ()
  "Return the default screenshot name."
  (alet (format-time-string "%Y-%m-%d-%H%M%S" (current-time))
    (xl-screenshot-path it)))
#+end_src

*** interactive screenshot functions
:PROPERTIES:
:ID:       27089aef-5937-4a7e-9af1-794fbeb835f2
:END:

When I first implemented these functions I prompted for the name first, but this
had the side-effect of displaying the prompt in the screenshot which is not what
I want. To avoid this, I decided to create the screenshot with the default name
and then prompt to rename the file afterwards.

**** fullscreen
:PROPERTIES:
:ID:       5cb29bb2-459a-4c84-9bf8-df179d2d2e8e
:END:

Take a s

#+begin_src emacs-lisp
(defun xl/take-fullscreen-screenshot ()
  "Take a fullscreen screenshot."
  (interactive)
  (let ((name (xl-default-screenshot-name)))
    (call-process "maim" nil nil nil "-u" name)
    (awhen (xl-prompt-screenshot-name)
      (rename-file name it t))))
#+end_src

**** window
:PROPERTIES:
:ID:       1a8724bb-24be-43fd-a3f6-3a41f7380fe8
:END:

#+begin_src emacs-lisp
(defun xl/take-window-screenshot ()
  "Take a screenshot of the current Emacs window."
  (interactive)
  (-let* ((name (xl-default-screenshot-name))
	  ((x y w h) (window-pixel-edges))
	  (geometry (format "%dx%d+%d+%d" w h x y)))
    (call-process "maim" nil nil nil "-u" "--geometry" geometry name)
    (awhen (xl-prompt-screenshot-name)
      (rename-file name it t))))
#+end_src

** elfeed :newfeed:
:PROPERTIES:
:ID:       45a52b98-9eba-45ab-9269-e8f930499e1c
:END:

=elfeed= is a newsfeed reader to Emacs. It's used over gnus because it is
generally faster and more "modern".

*** elfeed
:PROPERTIES:
:ID:       6aa4ece0-0b94-48b6-9a99-4b85cd1f7ccd
:END:

#+begin_src emacs-lisp
(use-package elfeed
  :rule ("right" "elfeed" :newname "\\*elfeed.+")
  :commands elfeed
  :set
  (elfeed-db-directory           . (concat XL-CACHE-DIR "elfeed"))
  (elfeed-search-title-max-width . 100))
#+end_src

*** elfeed-score
:PROPERTIES:
:ID:       20d1a501-4a52-43b8-b124-be1f62265b73
:END:

#+begin_src emacs-lisp
(use-package elfeed-score)
#+end_src

*** elfeed-org
:PROPERTIES:
:ID:       f646640b-6982-478f-bd1b-babd0ee00165
:END:

#+begin_src emacs-lisp
(use-package elfeed-org
  ;; :init
  ;; (defvar elfeed-org%public-newsfeed-file (xl-org-dir "newsfeeds.org")
  ;;   "Newsfeeds.")
  ;; :set
  ;; (rmh-elfeed-org-files . (list elfeed-org%public-newsfeed-file))
  )
#+end_src

*** newsfeeds
:PROPERTIES:
:ID:       6d64a62c-a3f7-449c-833d-0738c1e5f28a
:END:

These are my newsfeed for =elfeed-org=.

**** [[https://planet.emacslife.com/][planet emacslife]]
:PROPERTIES:
:ID:       c042350e-6c21-4c98-82b1-332ef808cba5
:END:

** gif-screencast :exec:
:PROPERTIES:
:ID:       d8553132-c244-4319-bcc9-51905a296e34
:END:

#+begin_src emacs-lisp
(use-package gif-screencast
  :commands gif-screencast-start-or-stop
  :set 
  (gif-screencast-program . "scrot")
  (gif-screencast-args . '("--quality" "25" "--focused"))
  (gif-screencast-cropping-program . "mogrify")
  (gif-screencast-optimize-program . "gifsicle")
  (gif-screencast-capture-format . "png"))
#+end_src

** videos :video:
:PROPERTIES:
:ID:       a8c1f6aa-25f6-47aa-a625-2c870f322a8c
:END:

*** ytel
:PROPERTIES:
:ID:       dea17f59-bebc-426e-ae7a-56f8d8971260
:END:

**** get video
:PROPERTIES:
:ID:       2a0e30c8-7a82-4bea-a79c-6d77eca6893a
:END:

** emms :music:
:PROPERTIES:
:ID:       6f3eaa69-bbbb-458e-bcad-1c121a3174e9
:END:

[[https://www.gnu.org/software/emms/][emms]] is a very complete music player.

*** emms
:PROPERTIES:
:ID: 5d28b703-a87f-47ca-b320-785e7589fea6
:END:

#+begin_src emacs-lisp
(use-package emms
  :set
  (emms-source-file-directory-tree-function . 'emms-source-file-directory-tree-find)
  (emms-source-file-default-directory       . "~/Multimedia/music")
  (emms-playlist-buffer-name                . "*EMMS-PLAYLIST*")
  (emms-seek-seconds                        . 5)
  (emms-directory                           . (concat XL-CACHE-DIR "emms/"))
  (emms-player-list                         . '(emms-player-mpv)))
#+end_src

*** quitting
:PROPERTIES:
:ID: 545e6534-f289-4a89-838a-2a65ac74fe72
:END:

#+begin_src emacs-lisp
(after! emms
  (defhook! quit-emms (kill-emacs-hook)
    "Shut down EMMS."
    (when emms-player-playing-p (emms-pause))
    (emms-stop)))
#+end_src

* xr :regexp:
:PROPERTIES:
:ID: 75c56163-9ce1-4726-969a-350fcc56395f
:END:

This package is the inverse of =rx=. It takes a regular expression and returns the
=rx= representation.

#+begin_src emacs-lisp
(use-package xr :commands xr)
#+end_src

* man :exec:
:PROPERTIES:
:ID:       3982b034-90e1-4961-90d9-224e913c0b8c
:END:

#+begin_src emacs-lisp
(use-package man
  :rule ("left" "man" :newname "\\*man.+"))
#+end_src

* eping :exec:
:PROPERTIES:
:ID:       37004f10-66d5-4b5a-a9eb-31107464e5a5
:END:

#+begin_src emacs-lisp
(use-package eping)
#+end_src

* grugru :write:edit:
:PROPERTIES:
:ID:       9d96a611-355a-4b62-bb0e-18e9d4af92c9
:END:

#+begin_src emacs-lisp
(use-package grugru)
#+end_src

* fortune-cookie :exec:
:PROPERTIES:
:ID:       8105dadd-4d4a-4f57-a5f9-5cae1b14ef3a
:END:

#+begin_src emacs-lisp
(use-package fortune-cookie
  :commands fortune-cookie)
#+end_src

* figlet :exec:
:PROPERTIES:
:ID:       b5be9427-a814-4a91-92ab-ad393375ec41
:END:

#+begin_src emacs-lisp
(use-package figlet :commands figlet)
#+end_src

* system-packages :pacman:exec:
:PROPERTIES:
:ID:       74bd0e5a-f6b0-48eb-a91e-3932eae23516
:END:

=system-packages= provides an api for installing system packages. This api strives
to abstract package installation on different operating systems. Unfortunately,
it does not include an interactive function that uses [[helpfn:completing-read][completing-read]] to list
packages

** init
:PROPERTIES:
:ID:       08bf0487-2a57-483d-8d22-8253ebda6d9d
:END:

#+begin_src emacs-lisp
(use-package system-packages
  :rule ("bottom" "system-packages" :newname "\\*system-packages")
  :set (system-packages-noconfirm . t))
#+end_src

** use yay for arch
:PROPERTIES:
:ID:       2fc48e66-83f3-4e35-8b2c-ef9113cb9b45
:END:

If we're in arch and we have yay intalled, use that.

#+begin_src emacs-lisp
(after! system-packages
  (when (and (eq system-packages-package-manager 'pacman)
             (system-packages-package-installed-p "yay"))
    (alet (alist-get 'pacman system-packages-supported-package-managers)
      (push `(yay (default-sudo . nil)
                  ,@(-map (-lambda ((action . command))
			    (cons action (s-replace "pacman" "yay" command)))
                          (cdr it)))
            system-packages-supported-package-managers))
    (setq system-packages-package-manager 'yay)))
#+end_src

* fix elisp indentation :elisp:lang:
:PROPERTIES:
:ID:       834eff05-1b96-4295-a46c-d14f81b43ad6
:END:

A problem with elisp indentation is indents quoted lists the way functions
should be indented. It has been discussed in at least three stackoverflow
questions [[https://emacs.stackexchange.com/questions/10230/how-to-indent-keywords-aligned/10233#10233][here]], [[https://stackoverflow.com/questions/49222433/align-symbols-in-plist][here]] and [[https://stackoverflow.com/questions/22166895/customize-elisp-plist-indentation][here]]. In all these questions the solutions have not
been satisfactory. Some of them recommend using [[helpfn:common-lisp-indent-function][common-lisp-indent-function]] as
the value of [[helpvar:lisp-indent-function][lisp-indent-function]]. This works for indenting a quoted list
properly, but at the expense of changing the way that many other elisp forms are
indented. Common Lisp's indentation is different from Elisp's. Others recommend
using [[https://github.com/Fuco1/.emacs.d/blob/af82072196564fa57726bdbabf97f1d35c43b7f7/site-lisp/redef.el#L12-L94][Fuco1's lisp indent function hack]]. This also is not ideal. For one thing it
only works for quoted lists with keywords but not generic symbols. Another thing
is that the change should really be occurring in [[helpfn:calculate-lisp-indent][calculate-lisp-indent]].
~calculate-lisp-indent~ is a function that returns what the indentation should be
for the line at point. Since Fuco1 did not modify ~calculate-lisp-indent~ the
*wrong* indentation still returned by this function and the modified
~lisp-indent-function~ just cleans up the mess. Better is just fixing the source
of the problem. You can check out a more in-depth explanation looking at my
[[https://www.reddit.com/r/emacs/comments/d7x7x8/finally_fixing_indentation_of_quoted_lists/][reddit-post]] or looking at an answer I gave to [[https://emacs.stackexchange.com/questions/10230/how-to-indent-keywords-aligned][this question]].

#+begin_src emacs-lisp
(defun! properly-calculate-indent (&optional parse-start)
  "Add better indentation for quoted and backquoted lists. "
  (:override calculate-lisp-indent)
  (defvar calculate-lisp-indent-last-sexp)
  (save-excursion
    (beginning-of-line)
    (let ((indent-point (point))
          state
          ;; setting this to a number inhibits calling hook
          (desired-indent nil)
          (retry t)
          calculate-lisp-indent-last-sexp containing-sexp)
      (cond ((or (markerp parse-start) (integerp parse-start))
	     (goto-char parse-start))
            ((null parse-start) (beginning-of-defun))
            (t (setq state parse-start)))
      (unless state
        ;; Find outermost containing sexp
        (while (< (point) indent-point)
          (setq state (parse-partial-sexp (point) indent-point 0))))
      ;; Find innermost containing sexp
      (while (and retry
                  state
                  (> (elt state 0) 0))
        (setq retry nil)
        (setq calculate-lisp-indent-last-sexp (elt state 2))
        (setq containing-sexp (elt state 1))
        ;; Position following last unclosed open.
        (goto-char (1+ containing-sexp))
        ;; Is there a complete sexp since then?
        (if (and calculate-lisp-indent-last-sexp
                 (> calculate-lisp-indent-last-sexp (point)))
            ;; Yes, but is there a containing sexp after that?
            (let ((peek (parse-partial-sexp calculate-lisp-indent-last-sexp
                                            indent-point 0)))
	      (if (setq retry (car (cdr peek))) (setq state peek)))))
      (if retry
          nil
        ;; Innermost containing sexp found
        (goto-char (1+ containing-sexp))
        (if (not calculate-lisp-indent-last-sexp)
            ;; indent-point immediately follows open paren.
            ;; Don't call hook.
            (setq desired-indent (current-column))
          ;; Find the start of first element of containing sexp.
          (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
          (cond ((looking-at "\\s(")
                 ;; First element of containing sexp is a list.
                 ;; Indent under that list.
                 )
                ((> (save-excursion (forward-line 1) (point))
                    calculate-lisp-indent-last-sexp)
                 ;; This is the first line to start within the containing sexp.
                 ;; It's almost certainly a function call.
                 (if (or
		      (= (point) calculate-lisp-indent-last-sexp)

		      (when-let (after (char-after (1+ containing-sexp)))
                        (char-equal after ?:))

		      (when-let (point (char-before containing-sexp))
                        (char-equal point ?'))

		      (let ((quoted-p nil)
                            (point nil)
                            (positions (nreverse (butlast (elt state 9)))))
                        (while (and positions (not quoted-p))
                          (setq point (pop positions))
                          (setq quoted-p
                                (or
                                 (and (char-before point)
				      (char-equal (char-before point) ?'))
                                 (save-excursion
                                   (goto-char (1+ point))
                                   (looking-at-p "quote[\t\n\f\s]+(")))))
                        quoted-p))
                     ;; Containing sexp has nothing before this line
                     ;; except the first element.  Indent under that element.
                     nil
                   ;; Skip the first element, find start of second (the first
                   ;; argument of the function call) and indent under.
                   (progn (forward-sexp 1)
                          (parse-partial-sexp (point)
					      calculate-lisp-indent-last-sexp
					      0 t)))
                 (backward-prefix-chars))
                (t
                 ;; Indent beneath first sexp on same line as
                 ;; `calculate-lisp-indent-last-sexp'.  Again, it's
                 ;; almost certainly a function call.
                 (goto-char calculate-lisp-indent-last-sexp)
                 (beginning-of-line)
                 (parse-partial-sexp (point) calculate-lisp-indent-last-sexp
                                     0 t)
                 (backward-prefix-chars)))))
      ;; Point is at the point to indent under unless we are inside a string.
      ;; Call indentation hook except when overridden by lisp-indent-offset
      ;; or if the desired indentation has already been computed.
      (let ((normal-indent (current-column)))
        (cond ((elt state 3)
	       ;; Inside a string, don't change indentation.
	       nil)
	      ((and (integerp lisp-indent-offset) containing-sexp)
	       ;; Indent by constant offset
	       (goto-char containing-sexp)
	       (+ (current-column) lisp-indent-offset))
	      ;; in this case calculate-lisp-indent-last-sexp is not nil
	      (calculate-lisp-indent-last-sexp
	       (or
                ;; try to align the parameters of a known function
                (and lisp-indent-function
                     (not retry)
                     (funcall lisp-indent-function indent-point state))
                ;; If the function has no special alignment
                ;; or it does not apply to this argument,
                ;; try to align a constant-symbol under the last
                ;; preceding constant symbol, if there is such one of
                ;; the last 2 preceding symbols, in the previous
                ;; uncommented line.
                (and (save-excursion
		       (goto-char indent-point)
		       (skip-chars-forward " \t")
		       (looking-at ":"))
                     ;; The last sexp may not be at the indentation
                     ;; where it begins, so find that one, instead.
                     (save-excursion
		       (goto-char calculate-lisp-indent-last-sexp)
		       ;; Handle prefix characters and whitespace
		       ;; following an open paren.  (Bug#1012)
		       (backward-prefix-chars)
		       (while (not (or (looking-back "^[ \t]*\\|([ \t]+"
                                                     (line-beginning-position))
				       (and containing-sexp
                                            (>= (1+ containing-sexp) (point)))))
                         (forward-sexp -1)
                         (backward-prefix-chars))
		       (setq calculate-lisp-indent-last-sexp (point)))
                     (> calculate-lisp-indent-last-sexp
                        (save-excursion
                          (goto-char (1+ containing-sexp))
                          (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
                          (point)))
                     (let ((parse-sexp-ignore-comments t)
                           indent)
		       (goto-char calculate-lisp-indent-last-sexp)
		       (or (and (looking-at ":")
                                (setq indent (current-column)))
                           (and (< (line-beginning-position)
                                   (prog2 (backward-sexp) (point)))
                                (looking-at ":")
                                (setq indent (current-column))))
		       indent))
                ;; another symbols or constants not preceded by a constant
                ;; as defined above.
                normal-indent))
	      ;; in this case calculate-lisp-indent-last-sexp is nil
	      (desired-indent)
	      (t
	       normal-indent))))))
#+end_src

* eros :elisp:lang:
:PROPERTIES:
:ID:       76a70683-bd59-4ec4-9574-d307ccdc36cd
:END:

=eros= displays the result of evaluating elisp expressions as overlays.

#+begin_src emacs-lisp
(use-package eros
  :hook emacs-lisp-mode-hook
  :set (eros-eval-result-prefix . "⟹ ")
  :config (bind! ([remap eval-last-sexp] #'eros-eval-last-sexp)))
#+end_src

* macrostep :elisp:lang:keybind:prog:
:PROPERTIES:
:ID:       fefc5700-3bd7-4a89-ae7b-bf68368e8bc4
:END:

#+begin_src emacs-lisp
(use-package macrostep
  :commands macrostep-expand)

(bind-localleader!
 (:map emacs-lisp-mode-map)
 (:prefix "m" :wk "macrostep")
 ("e" #'macrostep-expand)
 ("c" #'macrostep-collapse)
 ("C" #'macrostep-collapse-all))
#+end_src

* savehist :cache:
:PROPERTIES:
:ID:       dd4b9da7-e54d-4d62-bb70-aa8f7f4a016f
:END:

=savehist= is a built-in feature for saving the minibuffer-history to a file--the
[[helpvar:savehist][savehist]] file. Additionally, it provides the ability to save additional
variables which may or may not be related to minibuffer history. You add the
ones you want to save to [[helpvar:savehist-additional-variables][savehist-additional-variables]].

** savehist
:PROPERTIES:
:ID:       54183df6-b4f5-4b01-9ddb-4054ef0583b0
:END:

#+begin_src emacs-lisp
(use-package savehist
  :idle-require custom
  :hook emacs-startup-hook
  :set
  (savehist-save-minibuffer-history . t)
  (savehist-additional-variables    . '(kill-ring search-ring regexp-search-ring))
  (savehist-autosave-interval       . nil)
  (savehist-file                    . (concat XL-CACHE-DIR "savehist")))
#+end_src

** unpropertize kill ring
:PROPERTIES:
:ID:       da2b6c31-d251-48aa-a6ed-8f01b9fa0b8d
:END:

#+begin_src emacs-lisp
(defhook! unpropertize-kill-ring (kill-emacs-hook :append t)
  "Remove text properties from `kill-ring'."
  (set! (-map-when #'stringp #'substring-no-properties <kill-ring>)))
#+end_src

* ellocate :search:
:PROPERTIES:
:ID:       e3590042-52fb-47ee-a5eb-a7860a3cdb17
:END:

=ellocate= is replacement for.

#+begin_src emacs-lisp
(use-package ellocate
  :commands ellocate
  :set
  (ellocate-scan-dirs . `(("~/" . ,(concat XL-CACHE-DIR "ellocate"))))
  (ellocate-gc-mem    . most-positive-fixnum))
#+end_src

* saveplace :cache:
:PROPERTIES:
:ID:       63b04114-bcb9-4a2e-ad45-be4db8d4a269
:END:

As its name suggests, =save-place= is a built-in package that stores the buffer
location you left off at in a particular buffer. When you visit that buffer
again, you are taken to the location you left off. This is very convenient.

#+begin_src emacs-lisp
(use-package saveplace
  :after-call after-find-file
  :xl-config
  (save-place-mode)
  :set
  (save-place-file . (concat XL-CACHE-DIR "saveplace"))
  (save-place-limit . nil))
#+end_src

* recentf :emacs:config:cache:
:PROPERTIES:
:ID:       5ab47c35-53bd-460f-ba41-6f3075bd1222
:END:

=recentf= is a built-in program that tracks the files you've opened recently
persistently. This is a great idea because these are the files you'll likely
revisit. In practice, I look at this list of files in addition to the buffers I
already have open using a [[id:f26bedb3-a172-4543-afd0-4c47f5872d15][completion-framework]]. Because of this I rarely
have to set out to look for a file with =dired=.

#+begin_src emacs-lisp
(use-package recentf
  :before-call find-file
  :idle-require easymenu tree-widget timer
  :idle recentf-save-list
  :hook (kill-emacs-hook . recentf-save-list)
  :advice (:before (recentf-save-list . recentf-cleanup))
  :silence recentf-mode recentf-cleanup recentf-save-list
  :set
  (recentf-max-menu-items    . 0)
  (recentf-max-saved-items   . 700)
  (recentf-save-file         . (concat XL-CACHE-DIR "recentf"))
  (recentf-auto-cleanup      . (* 60 10))
  (recentf-filename-handlers . '(file-truename abbreviate-file-name))
  :config
  (recentf-mode 1))
#+end_src

* all-the-icons-dired :icon:asthetic:
:PROPERTIES:
:ID:       8e2fe483-5da1-47c7-8d80-a8e68b21fa39
:END:

#+begin_src emacs-lisp
(use-package all-the-icons-dired
  :hook dired-mode-hook)
#+end_src

* dired :file:
:PROPERTIES:
:ID:       877b66c0-7952-4b37-839a-4a9aa5af164a
:END:

** dired
:PROPERTIES:
:ID:       8a5f8bb6-dce2-4fac-b9c4-068e39f4cfcc
:END:

If you don't set [[helpvar:dired-recursive-deletes][dired-recursive-deletes]], emacs will prompt you every time you
try to delete a directory asking you whether you want to recursively delete its
contents. If you're actually permenently deleting it this is a good idea to
prevent accidental deletion, but I set [[helpvar:delete-by-moving-to-trash][delete-by-moving-to-trash]] to =t=. So
worst case I'll accidentally move a directory to the trash folder.

#+begin_src emacs-lisp
(use-package dired
  :set
  (dired-recursive-copies                      . 'always)
  (dired-recursive-deletes                     . 'always)
  (dired-hide-details-hide-symlink-targets     . nil)
  (dired-clean-confirm-killing-deleted-buffers . nil))
#+end_src

** sort directories first
:PROPERTIES:
:ID:       8db5ffba-3f74-4146-96e0-03a46213e77d
:END:

#+begin_src emacs-lisp
(defhook! dired:sort-directories-first (dired-after-readin-hook)
  "List directories first in dired buffers."
  (save-excursion
    (let (buffer-read-only)
      (forward-line 2) ;; beyond dir. header
      (sort-regexp-fields t "^.*$" "[ ]*." (point) (point-max))))
  (and (featurep 'xemacs)
       (fboundp 'dired-insert-set-properties)
       (dired-insert-set-properties (point-min) (point-max)))
  (set-buffer-modified-p nil))
#+end_src

*** create non-existent directory
:PROPERTIES:
:ID:       d6151903-ab72-48d7-b9ef-fd13880d3dd2
:END:

#+begin_src emacs-lisp
(defun dired:create-non-existent-directory-h ()
  "Automatically create missing directories when creating new file."
  (let ((parent-directory (file-name-directory buffer-file-name)))
    (when (and (not (file-exists-p parent-directory))
               (y-or-n-p (format "Directory `%s' does not exist! Create it?" parent-directory)))
      (make-directory parent-directory t))))

(after! dired
  (add-to-list 'find-file-not-found-functions 'dired:create-non-existent-directory-h nil #'eq))
#+end_src

* ranger :file:
:PROPERTIES:
:ID:       1791aeb9-1146-43c8-85d6-149335eb9d8f
:END:

[[github:ralesi/ranger.el][ranger]] is a file browser built on top of dired that seeks to emulate [[github:ranger/ranger][a VIM
inspired file manager]] of also called =ranger=.

** make sure that =;= uses =M-x=
:PROPERTIES:
:ID:       c63911ca-6d26-4d7c-be76-246639fb6c7a
:END:

#+begin_src emacs-lisp
(bind!
  (:map ranger-mode-map)
  (";" #'execute-extended-command)
  ("u" #'dired-unmark))
#+end_src

** entry
:PROPERTIES:
:ID:       19047e0c-927d-46a6-babe-9c096f4fbcc7
:END:

#+begin_src emacs-lisp
(use-package ranger
  :commands deer ranger
  :silence ranger-window-check
  :set
  (ranger-override-dired-mode . t)
  (ranger-cleanup-eagerly     . t)
  (ranger-cleanup-on-disable  . t)
  (ranger-omit-regexp         . "^.DS_Store$")
  (ranger-excluded-extensions .'("mkv" "iso" "mp4"))
  (ranger-deer-show-details   . nil)
  (ranger-max-preview-size    . 10)
  (ranger-modify-header       . t)
  (ranger-hide-cursor         . t)
  (ranger-dont-show-binary    . t))
#+end_src

** refresh contents
:PROPERTIES:
:ID:       cef37397-53aa-47e1-a519-ef56a311ae30
:END:

Ranger doesn't refresh the buffer after stuff like moving and pasting has
happend. It results in a very jarring display.

#+begin_src emacs-lisp
(defadvice! refresh-contents (:after ranger-paste dired-do-rename)
  "Refresh contents."
  (when (eq major-mode 'ranger-mode)
    (ranger-refresh)))
#+end_src

* info :popup:help:
:PROPERTIES:
:ID:       d49f83c4-ba8f-477e-beef-8156ed8b974b
:END:

This headline is for customizing info nodes.

#+begin_src emacs-lisp
(use-package info
  :rule ("top" "info" :newname "\\*info"))
#+end_src

* eshell :shell:
:PROPERTIES:
:ID:       58423f45-5f3d-4ba6-8f00-e21dfe3ec2ec
:END:

[[info:eshell#Top][eshell]] is a built-in shell written entirely in elisp. This means that it's as
portable and customizable as emacs itself. It can run elisp functions as
commands. There's a good article about it in [[https://masteringemacs.org/article/complete-guide-mastering-eshell][mastering-emacs]]. Other articles I
have like about eshell: [[https://ambrevar.xyz/emacs-eshell/][ambrevar's eshell post]], [[http://www.howardism.org/Technical/Emacs/eshell-fun.html][Howard Abram's Post]].

** eshell
:PROPERTIES:
:ID:       b2b473c8-78d7-4f41-9be3-842b6c5acdbb
:END:

#+begin_src emacs-lisp
(use-package eshell
  :rule ("bottom" "eshell" :newname "\\*eshell\\*")
  :set
  (eshell-directory-name             . (concat XL-CACHE-DIR "eshell/"))
  (eshell-history-file-name          . (concat eshell-directory-name "history"))
  (eshell-banner-message             . "")
  (eshell-prefer-lisp-functions      . nil)
  (eshell-scroll-to-bottom-on-input  . 'all)
  (eshell-scroll-to-bottom-on-output . 'all)
  (eshell-buffer-shorthand           . t)
  (eshell-kill-processes-on-exit     . t)
  (eshell-hist-ignoredups            . t)
  (eshell-input-filter               . #'eshell-input-filter-initial-space)
  (eshell-glob-case-insensitive      . t)
  (eshell-error-if-no-glob           . t))
#+end_src

** em-hist
:PROPERTIES:
:ID:       aaea54da-bd51-4a73-9dad-fe0b49d0f617
:END:

#+begin_src emacs-lisp
(use-package em-hist
  :idle-require t
  :set
  (eshell-history-file-name    . (concat eshell-directory-name "history"))
  (eshell-history-size         . 2000)
  (eshell-hist-ignoredups      . nil)
  (eshell-save-history-on-exit . t))
#+end_src

** em-term
:PROPERTIES:
:ID:       d2afb853-15c3-4d3f-b8fa-a1075f84bbac
:END:

#+begin_src emacs-lisp
(use-package em-term
  :idle-require t
  :config
  (-each '("tmux" "htop" "bash" "zsh" "fish" "vim" "nvim" "ncmpcpp")
    (fn! (pushnew <command> eshell-visual-commands))))
#+end_src

** em-alias
:PROPERTIES:
:ID:       694a8c17-8318-4222-b461-abfc1d8a78ea
:END:

#+begin_src emacs-lisp
(use-package em-alias
  :idle-require t)
#+end_src

** eshell-z
:PROPERTIES:
:ID: 497798a0-7b62-4779-bf15-f67500528f03
:END:

#+begin_src emacs-lisp
(use-package eshell-z
  :commands eshell-z
  :set
  (eshell-z-freq-dir-hash-table-file-name . (expand-file-name "z" eshell-directory-name)))
#+end_src

** eshell-up
:PROPERTIES:
:ID: 478219b9-1c6f-4907-b428-a2dfe0f45e5c
:END:

This is an Emacs package for quickly navigating to a specific parent directory
in ~eshell~ without having to repeatedly typing ~cd ..~.

#+begin_src emacs-lisp
(use-package eshell-up
  ;; :alias
  ;; (eshell/up . eshell-up)
  ;; (eshell/peek . eshell-up-peek)
  )
#+end_src


* shrink-path :file:
:PROPERTIES:
:ID:       7edc1484-1e21-45b7-8db6-904b1ef913a6
:END:

It's easy to underestimate how much of a difference having an asthetically
pleasing Emacs configuration can have. Ugliness really can take its toll.

* helpful :help:bind:interface:
:PROPERTIES:
:ID:       5340ddb3-92bc-42e5-bf0e-9f9650c41cd9
:END:

[[github:wilfred/helpful][helpful]] provides a complete replacement for the built-in Emacs help facility
which provides much more contextual information in a better format.

#+begin_src emacs-lisp
(use-package helpful
  :rule ("bottom" "help" :newname "\\*help.+"))

(bind!
 ([remap describe-function] #'helpful-callable)
 ([remap describe-command]  #'helpful-command)
 ([remap describe-variable] #'helpful-variable)
 ([remap describe-key]      #'helpful-key))
#+end_src

