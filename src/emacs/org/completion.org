#+title: completion
#+author: Luis Henriquez-Perez
#+tags: emacs config completion

* embark
:PROPERTIES:
:ID:       9e6a5fc3-5a7f-4067-b35e-ef9fb0605fb8
:END:

This package provides a way of adding actions (think helm) to commands. The
special thing about it is a generic way to do so.

The idea of actions is to minimize code duplication. The scenario is this: you
have an existing commands that allows you to select a candidate from a prompt
and do =X= with a candidate =c= from the set of candidates =C=. You want to
select from the same prompt, but instead you want to do =Y= with =c= not =X=. So
what do you do? You're faced with rewriting the command, copying the code for
the prompt and adding the code to do =Y= (with something like =helm= you'd
rewrite the code in terms of sources and actions). That's a lot of work!
:tired-face: And it's not scalable either you'd need to do this for any other
commands you come accross in the future. This explains why there are so many
=helm= packages.

=embark= provides a way to add actions to an existing command without having to
rewrite it.

Honestly, reading it's documentation can be a bit dizzying :dizzy-face:; not
because the it's bad but because it is hard to wrap your mind around such a
package without seeing it in action.

** embark
:PROPERTIES:
:ID:       45768441-4ec6-475b-99c6-cfb587edb81d
:END:

As I learn more about embark I will improve this documentation over time.

#+begin_src emacs-lisp
(use-package embark
  :init
  (bind!
    (:map selectrum-minibuffer-map)
    (:ie "C-a" #'embark-act)))

(defhook! pause-selectrum (embark-collect-mode-hook)
  (when (eq embark-collect--kind :live)
    (with-selected-window (active-minibuffer-window)
      (shrink-window selectrum-num-candidates-displayed)
      (setq-local selectrum-num-candidates-displayed 0))))
#+end_src

* marginalia
:PROPERTIES:
:ID:       0ce9957b-8805-4b2b-b5cb-52dc425a3dee
:END:

Marginalia adds descriptions to various commands.

#+begin_src emacs-lisp
(use-package marginalia
  :hook emacs-startup-hook
  :set
  (marginalia-annotators . '(marginalia-annotators-heavy marginalia-annotators-light nil)))
#+end_src

* orderless
:PROPERTIES:
:ID:       9702810e-2013-4c41-ba12-0b55de6ceb38
:END:

#+begin_src emacs-lisp
(use-package orderless
  :commands orderless-filter orderless-highlight-matches
  :set
  (selectrum-refine-candidates-function    . #'orderless-filter)
  (selectrum-highlight-candidates-function . #'orderless-highlight-matches))
#+end_src

* TODO vertico
:PROPERTIES:
:ID:       ccc096ce-222a-402a-b0a8-5dff543419c8
:END:

* TODO ivy :ivy:
:PROPERTIES:
:ID:       82854114-2325-4fa6-b3c8-08cd61f54153
:END:

* TODO helm :helm:
:PROPERTIES:
:ID:       2da24557-b05d-475e-8565-6a24e23309c0
:END:

The reason I have helm installed is because (1) helm has some useful functions
that are not yet implemented for other completion frameworks and (2) selectrum
has a [[helpfn:selectrum-helm-mode][selectrum-helm-mode]] which it can use to "selectrumify" helm functions--at
least to some extent (sometimes the default action doesn't work).

It seems like I may be able to add default actions via an advice. :shrug-tone4:
We'll see. Basically, the idea would be to take reuse the code of helm commands
for presenting candidates and then make the action selection work via an advice
and, of course, add multiple actions via [[id][embark]].

Oh and in regards for using selectrum instead of helm: the main reason is simply
that helm is noticably slower with its command filtering. :turtle:

** helm
:PROPERTIES:
:ID:       0ef7946e-629b-4a4f-8e47-7d8826d04e7e
:END:

If you're scrolling down a list of candidates, you might be suprised to
find. One "gotcha" in helm is the [[helpvar:helm-candidate-number-limit][helm-candidate-number-limit]]. By default helm
limits the amount of candidates it displays to increase performace.

Selectrum has no problem handling a large amount of candidates, particularly if
you additionally pause garbage collection for the duration of expensive
functions as I do. It handles the 16,143 candidates in [[helpfn:helm-system-packages][helm-system-packages]] on
my T400 instantaneously.

#+begin_src emacs-lisp
(use-package helm
  :set
  (helm-candidate-number-limit . nil))
#+end_src

** helm-system-packages
:PROPERTIES:
:ID:       3e6dd0e6-0632-454d-a496-d34ecd33b60f
:END:

#+begin_src emacs-lisp
(use-package helm-system-packages
  :gc-pause helm-system-packages
  :no-sort helm-system-packages)
#+end_src

** swiper-helm
:PROPERTIES:
:ID:       21a5285c-0447-452d-a7ef-e146b6bd60f0
:END:

#+begin_src emacs-lisp
(use-package swiper-helm
  :no-sort swiper-helm
  :gc-pause swiper-helm)
#+end_src

* enable helm-mode
:PROPERTIES:
:ID:       bd0ba1cb-a16d-413a-938e-cf3f399916f1
:END:

#+begin_src emacs-lisp
(defafter! enable-helm-mode (helm)
  (xl-hook-add 'helm-mode-hook #'selectrum-helm-mode))
#+end_src

* prescient :cache:
:PROPERTIES:
:ID:       4445c814-9899-4d54-affe-0cee38642690
:END:

This package.

#+begin_src emacs-lisp
(use-package prescient
  :idle prescient--save
  :set
  (prescient-save-file . (concat XL-CACHE-DIR "prescient-save-file"))
  :config
  (prescient-persist-mode))
#+end_src

* selectrum :selectrum:
:PROPERTIES:
:ID:       f8a9cdba-a4a9-42aa-a505-e88ad0b4114d
:END:

Selectrum is another completion framework. It distinguishes itself from the rest
by striving to work with the built-in emacs [[helpfn:completing-read][completing-read]] instead of replacing
it like [[https://github.com/emacs-helm/helm][helm]] and [[https://github.com/emacs-helm/helm][ivy]] do. It promises to work with the existing Emacs framework
instead of replacing it as does Ivy and Helm. :recycle:

** selectrum-prescient :cache:
:PROPERTIES:
:ID:       70668ed8-9c83-42d2-8dce-d8f7de923569
:END:

The variable names can get really long, no? :joy: Maybe it's better to have sort
of a =:nameless-set= keyword that implies a namespace the same as a package. :bulb:

#+begin_src emacs-lisp
(use-package selectrum-prescient
  :hook selectrum-mode-hook
  :set
  (selectrum-preprocess-candidates-function . #'selectrum-prescient--preprocess))
#+end_src

** lettered candidate index :selectrum:
:PROPERTIES:
:ID:       aae96baa-4acb-43cd-9d1d-0106abc762fd
:END:

When the variable [[helpvar:selectrum-show-indices][selectrum-show-indices]] is set to this function, selectrum
displays letters starting at =a= to [[helpvar:selectrum-num-candidates-displayed][selectrum-num-candidates-displayed]] times
down the alphabet. Fun fact, I actually contributed this feature to selectrum. :confetti-ball:

#+begin_src emacs-lisp
(defun selectrum%show-letter-index-fn (i)
  "Return letter corresponding to index."
  (format "%c " (+ 97 (% (1- i) selectrum-num-candidates-displayed))))
#+end_src

** stop selectrum filtering and highlight
:PROPERTIES:
:ID:       a6720cdc-9d51-463b-9ffe-f9341c6bd967
:END:

#+begin_src emacs-lisp
(defun! inhibit-filtering-and-highlighting (orig-fn &rest args)
  "Don't let `selectrum-prescient' filter or highlight. "
  (:around selectrum-prescient-mode)
  (let ((selectrum-refine-candidates-function selectrum-refine-candidates-function)
	(selectrum-highlight-candidates-function selectrum-highlight-candidates-function))
    (apply orig-fn args)))
#+end_src

** bindings :bind:
:PROPERTIES:
:ID:       97dccbf9-4ffd-4191-87e6-813bc99c3df7
:END:

#+begin_src emacs-lisp
(bind!
  (:map selectrum-minibuffer-map)
  (:ie "C-o" #'selectrum-submit-exact-input)
  (:ie "TAB" #'selectrum-next-candidate)
  (:ie "C-k" #'selectrum-previous-candidate)
  (:ie "C-j" #'selectrum-next-candidate)
  (:ie "C-;" #'selectrum-insert-current-candidate)
  (:ie "C-l" #'selectrum/mark-candidate)
  (:ie [backtab] #'selectrum-previous-candidate))
#+end_src

** show indicators :interface:completion:
:PROPERTIES:
:ID:       d0d61c43-88cd-49ed-bd1a-515405c2fa94
:END:

I want to select candidates efficiently. For me this means not having to press
=C-j= multiple times to reach a candidate that's lower in the list (imagine the
number of indices displayed is 15 and the candidate I want is the 14th one). To
address this I create this function. It displays letters next to the candidates.

#+begin_src emacs-lisp
(defun selectrum%select-candidate-by-letter ()
  "Choose selectrum candidate by letter."
  (interactive)
  (let ((selectrum-show-indices #'selectrum%show-letter-index-fn))
    (selectrum--update)
    (alet (read-key)
      (unless (= it 27)
	(selectrum-select-current-candidate (- (1+ it) 97))))))

(bind!
  (:map selectrum-minibuffer-map)
  (:ie "," #'selectrum%select-candidate-by-letter))
#+end_src

** consult-selectrum
:PROPERTIES:
:ID:       1620151c-77c9-4fe3-a1df-e9041ceca29d
:END:

If I don't include this, I get an.

#+begin_src emacs-lisp
(use-package consult-selectrum
  :after (consult)
  :demand t)
#+end_src

** selectrum
:PROPERTIES:
:ID:       6e670980-7794-4505-a285-184416a5b377
:END:

In contrast, any command defined via completing-read should work consistently with
selectrum and its provided features.

Because helm and ivy replace the existing framework, it means that whenever you
want a command be capable of using all of helm or ivy's features, you need to
define it their way. Otherwise, there's no guarantee their features will work at
least any features besides the basic choosing of a single candidate. That's a
big reason why there are helm and ivy packages (there's 216 helm packages and 42
ivy packages in [[helpfn:straight-use-package][straight-use-package]] completion): many of those packages are just ivy and
helm wrappers around existing commands.

#+begin_src emacs-lisp
(use-package selectrum
  :hook emacs-startup-hook
  :set
  (selectrum-max-window-height        . 15)
  (selectrum-num-candidates-displayed . 15)
  (selectrum-fix-minibuffer-height    . t)
  (selectrum-should-sort-p            . t)
  (selectrum-count-style              . nil))
#+end_src

* company
:PROPERTIES:
:ID:       5579b8d8-9778-4b2d-a56f-ec43754a8d18
:END:

** company
:PROPERTIES:
:ID:       5e5393d9-9f58-45be-9ecc-1bc9f0316379
:END:

#+begin_src emacs-lisp
(use-package company
  :hook prog-mode-hook
  :set
  (company-tooltip-align-annotations . t)
  (company-minimum-prefix-length     . 1)
  (company-minimum-prefix-length     . 1)
  (company-dabbrev-downcase          . nil)
  (company-require-match             . 'never)
  (company-tooltip-limit             . 14)
  (company-show-numbers              . t)
  (company-idle-delay                . 0.15)
  (company-frontends                 . '(company-pseudo-tooltip-frontend)))
#+end_src

** bindings
:PROPERTIES:
:ID:       ba170d95-7d86-4827-af6b-dc5fd4c1b7e5
:END:

#+begin_src emacs-lisp
(bind!
  (:map company-active-map)
  ([tab]     #'company-select-next)
  ([backtab] #'company-select-previous)
  ("C-k"     #'company-select-previous)
  ("C-j"     #'company-select-next))
#+end_src

** determining which modes are active
:PROPERTIES:
:ID:       b8603ca5-9a24-4684-a75b-e0c3845bfff0
:END:

[[https://stackoverflow.com/questions/1511737/how-do-you-list-the-active-minor-modes-in-emacs][listing active minor modes]]

#+begin_src emacs-lisp
(defun xl-active-minor-modes ()
  "Return active minor modes in current buffer."
  (-select (-andfn #'boundp #'symbol-value) minor-mode-list))
#+end_src

** backends-alist
:PROPERTIES:
:ID:       dac0a998-e1b1-424f-8c40-e1bc19843153
:END:

#+begin_src emacs-lisp
(defvar company:backend-alist
  '((text-mode :derived (company-dabbrev company-ispell))
    (prog-mode :derived ((:separate company-capf company-yasnippet))))
  "An alist modes to company backends.")
#+end_src

** initialize backends
:PROPERTIES:
:ID:       4e82e869-b144-44aa-bc19-bb58b8c5ff2a
:END:

When the user

#+begin_src emacs-lisp
(defhook! setup-company-backends (company-mode-hook)
  "Set `company-backends' for the current buffer."
  (alet (company:backends-for-mode major-mode)
    (xl-log "set up %S backends: %S" major-mode it)
    (set (make-local-variable 'company-backends) it)))
#+end_src

** get backends
:PROPERTIES:
:ID:       282a2c16-ae5f-4d81-acaa-8d60fb24e762
:END:

#+begin_src emacs-lisp
(cl-defun company:backends-for-mode (&optional (current-major-mode major-mode))
  "Return a list of company backends for major-mode."
  (loopy (with (active-minor-modes (xl-active-minor-modes)))
	 (list (mode type backends) company:backend-alist)
	 (expr derived-p (and (eq type :derived) (derived-mode-p mode)))
	 (expr mm-enabled-p (or (eq current-major-mode mode)
				(and (boundp mode) (symbol-value mode))))
	 (expr active-minor-mode-p (member mode active-minor-modes))
	 (cond ((and (eq type :only) (or mm-enabled-p active-minor-mode-p))
		(return backends))
	       ((or (or derived-p (and (eq type :exact) mm-enabled-p))
		    active-minor-mode-p)
		(append new-backends backends)))))
#+end_src

** company-prescient
:PROPERTIES:
:ID:       be4bc19d-a25c-4e2d-9f12-5d2946bc9931
:END:

[[https://github.com/raxod502/prescient.el][company-prescient]] is the same as =prescient= but for =company= instead of =ivy=.

#+begin_src emacs-lisp
(use-package company-prescient
  :hook company-mode-hook)
#+end_src

** close company on escape
:PROPERTIES:
:ID:       a880c155-b860-4880-840d-4a891b4668c4
:END:

#+begin_src emacs-lisp
(defhook! close-tooltip (xl-escape-hook)
  "Close company tooltip."
  (when (and (boundp 'company-mode) (eq company-mode t))
    (company-abort)
    t))
#+end_src

* yasnippet
:PROPERTIES:
:ID:       611fa6f5-d889-4399-a090-37aeb043cd13
:END:

** yasnippet
:PROPERTIES:
:ID:       41958449-b3b1-4c5b-915a-7cef7c5aa41d
:END:

#+begin_src emacs-lisp
(use-package yasnippet
  :hook (prog-mode-hook . yas-minor-mode-on)
  :set
  (yas-snippet-dirs . (list (concat XL-CACHE-DIR "snippets/")))
  (yas-verbosity . (if xl-debug-p 3 0))
  (yas-indent-line . 'auto)
  (yas-prompt-functions . '(yas-completing-prompt yas-ido-prompt))
  (yas-use-menu . nil)
  (yas-triggers-in-field . t)
  :config
  (delq #'yas-dropdown-prompt yas-prompt-functions))
#+end_src

** don't interfere with yasnippet bindings
:PROPERTIES:
:ID:       2c359813-e928-4a2b-982e-b722bf44fac7
:END:

#+begin_src emacs-lisp
(defafter! dont-interfere-with-yasnippet-bindings (smartparens yasnippet)
  "Don't interfere with yasnippet bindings."
  (advice-add #'yas-expand :before #'sp-remove-active-pair-overlay))
#+end_src

** ensure yasnippet directories
:PROPERTIES:
:ID:       bf48e5dd-32ba-4141-a26c-a5e549e7d878
:END:

#+begin_src emacs-lisp
(defafter! ensure-yasnippet-dirs (yasnippet)
  "Ensure that yasnippet dirs exist."
  (iter (each elt yas-snippet-dirs)
	(expr dir (if (symbolp elt) (symbol-value elt) elt))
	(mkdir dir t)))
#+end_src

** yasnippet-snippets
:PROPERTIES:
:ID:       57af5709-1597-4e3e-b895-77c17285f64d
:END:

#+begin_src emacs-lisp
(use-package yasnippet-snippets)
#+end_src

* consult
:PROPERTIES:
:ID:       921ce22e-59ae-4de1-bef0-66a20e320df5
:END:

=consult= is a package that's akin to =counsel=. It's a library of generally
useful functions which are written in such a way that they can be work across
all the completion frameworks.

#+begin_src emacs-lisp
(use-package consult
  :gc-pause consult-outline consult-line
  :set
  (consult-preview-key . nil)
  :config
  (bind! ([remap switch-to-buffer] #'consult-buffer)))
 #+end_src

