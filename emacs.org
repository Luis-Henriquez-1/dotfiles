#+title: emacs.org
#+author: Luis M Henriquez
#+property: header-args :tangle ~/.config/emacs/init.el

[[file:../multimedia/screenshots/emacs-logo.png]]

* README :doc:
:PROPERTIES:
:ID:       53ec10a9-c123-46ad-8a21-99229b02a496
:END:

This is heading tries to explain my Emacs config, why I made it the way did.

** goals and principles
:PROPERTIES:
:ID:       83ec82d2-0387-4d47-b0f9-d2429c2d777f
:END:

*** almost impervious to loading order
:PROPERTIES:
:ID:       c8e53df8-acf3-40f1-a551-c26a1d58bd4f
:END:

*** reproducible
:PROPERTIES:
:ID:       30b0deee-bc8d-4f00-9105-b43f0b3433ed
:END:

I want my configuration to be completely reproducible. That is, using my
[[file:recipes.org][recipes]], this file as well as my version of Emacs, you should be able to
completely reproduce my setup.

I choose to.

*** effective and elegant set of macros
:PROPERTIES:
:ID:       90a118c1-7f18-48dd-aad7-6b9b8edba36e
:END:

*** asthetic and minimalistic design
:PROPERTIES:
:ID:       433777aa-8cfd-4189-9ce8-b06b5f86e349
:END:

*** fast and efficient
:PROPERTIES:
:ID:       fcb9e85e-b466-49d1-9493-6b72e3c66c1a
:END:

* core :core:
:PROPERTIES:
:ID:       b9128118-e381-4abc-b078-776e437ef31c
:END:

This headline contains all headlines that need to be loaded in a certain order.
In other words, it should not matter in which order code blocks not in this
headline are loaded.

** early-init
:PROPERTIES:
:ID:       e5df5609-ebc1-40ac-a615-1841d8c1781e
:header-args: :tangle ~/.config/emacs/early-init.el
:END:

*** DOC pause garbage collection :performance:
:PROPERTIES:
:ID:       33c4ed1f-9382-49ff-9706-6ce5c0fd0d7c
:END:

During computationally intensive tasks, it is better stop garbage collecting
until the task is done. Initializing emacs is such a task. Therefore, I
effectively stop garbage collection by setting the [[helpvar:gc-cons-threshold][gc-cons-threshold]] to
[[helpvar:most-positive-fixnum][most-positive-fixnum]].

#+begin_src emacs-lisp
(setq gc-cons-threshold most-positive-fixnum)
#+end_src

*** DOC disable tool bar, menu bar, and scroll bar :appearance:
:PROPERTIES:
:ID:       f439de9a-b2b1-4926-a4ae-3d94ff83d05a
:END:

By default the frame is initialized with the tool-bar, menu-bar, and
scroll-bar. Many emacs users, me included, prefer not to see these things. Since
I operate via keybindings I would never use them anyway. But because emacs loads
the init file after the initialization of the frame, it used to be the case that
it was inevitable to catch a glipse of these UI elements during your Emacs
initializaition. Not is it distracting, but rendering those things also
contributed significantly to startup time.

Before the advent of the [[helpvar:early-init-file][early-init-file]], the only way to prevent it was to set
up an [[https://wiki.archlinux.org/index.php/X_resources][xresources]].

#+begin_src emacs-lisp
(push '(menu-bar-lines . 0) default-frame-alist)
(push '(tool-bar-lines . 0) default-frame-alist)
(push '(vertical-scroll-bars) default-frame-alist)
#+end_src

*** compute the font upon tangling :font:
:PROPERTIES:
:ID:       62b28647-262f-4657-a57e-79e8a98c2a11
:END:

There's a chicken and egg problem with fonts. What you'd like to do to have a
robust emacs config is have a list of backup fonts that you check in order of
preference until you find the one that is available on your system. Moreover, to
be efficient, you'd like to do this check before the frame is initialized.
Problem is the functions emacs provide to check system fonts depend on the
initialization of the emacs frame.

Note I have not yet tested this. I'm not sure if the frame is created when I run
Emacs from a script. :confused: I'm sure there's some way to do it.

#+name: font
#+begin_src emacs-lisp :tangle no
(cl-block nil
  (let ((fonts (list "fira code" "jetbrains mono" "hermit" "mononoki" "anonymous-pro"))
	(font nil)
	(available nil))
    (dolist (font fonts)
      (setq available (x-list-fonts font))
      (when available
	(setq font (font-spec :name (cl-first available)))
	(cl-return (format "%S" (font-xlfd-name font)))))))
#+end_src

*** set the font :font:
:PROPERTIES:
:ID:       54d9be27-74b3-49fd-9bdb-b6d1e024b80b
:END:

This is the most efficient way to set the font. Reason being, it's done before
the initialization of the frame and it avoids the usage of functions like
[[helpfn:set-frame-font][set-frame-font]], which more than just set the font. A caveat is that this will
cause your emacs to crash if the font you specify does not exist. And, you can't
check the existing fonts at this time either because the [[https://emacs.stackexchange.com/questions/62318/storing-string-in-variable-fails-to-work-in-early-init-el/62320?noredirect=1#comment98194_62320][frame hasn't been
initialized yet]] so functions like [[helpfn:font-family-list][font-family-list]] and [[helpfn:find-font][find-font]] will not return
reliable values (trust me, I tried).

#+begin_src emacs-lisp :noweb yes
(push (cons 'font <<font()>>) default-frame-alist)
#+end_src

*** disable fringes :appearance:
:PROPERTIES:
:ID:       bb1264f6-1580-4463-9d72-d2913771ebb4
:END:

#+begin_src emacs-lisp
(push '(left-fringe  . 0) default-frame-alist)
(push '(right-fringe . 0) default-frame-alist)
#+end_src

*** stop package.el from writing in our init file
:PROPERTIES:
:ID:       c5df3859-6099-4d99-9780-8d33383c3626
:END:

In Emacs 27+, package initialization occurs before [[helpvar:user-init-file][user-init-file]] is
loaded, but after [[helpvar:early-init-file][early-init-file]].

#+begin_src emacs-lisp
(setq package-enable-at-startup nil)
(advice-add #'package--ensure-init-file :override #'ignore)
#+end_src

*** ignore x-resources
:PROPERTIES:
:ID:       51391771-ed2f-42f7-b904-3f655b86cac0
:END:

Ignore X resources; its settings would be redundant with the other settings in
this file and can conflict with later config (particularly where the cursor
color is concerned). [[id:f439de9a-b2b1-4926-a4ae-3d94ff83d05a][Like I said]], we no longer need xresources anymore.

#+begin_src elisp
(advice-add #'x-apply-session-resources :override #'ignore)
#+end_src

*** prevent default mode line from showing :appearance:
:PROPERTIES:
:ID:       0177fd1a-617d-47c6-bd03-db64439fd4cc
:END:

While the modeline is a huge point of interest among emacs users, I find it
distracting and space-consuming. The modeline is displayed in every buffer,
which means that it does not scale well with vertical splits. It will consume an
additional line for every additional window. And yet, I (and I suspect everyone
else) only ever focus on one window at a time. This is why I opt for disabling
the modeline (I use [[https://github.com/kiennq/emacs-mini-modeline][mini-modeline]] instead). Similar to the gui bars it is enabled
by default and will be rendered during the initialization of the frame. If I
don't disable it here.

#+begin_src elisp
(unless after-init-time
  (setq-default mode-line-format nil))
#+end_src

*** maximize frame :appearance:
:PROPERTIES:
:ID:       3d208962-52ad-491a-8bf4-c9248c692fc7
:END:

Emacs is the interface with which I deal with everything else. I want it to be
full screen, especially when I'm using emacs as my window manager. For the same
reasons that setting the font is efficient, this is too.

#+begin_src emacs-lisp
(push '(fullscreen . maximized) default-frame-alist)
#+end_src

** DOC init :init:
:PROPERTIES:
:ID:       255e2012-7789-4f3d-8cf3-17b5dd810143
:END:

*** DOC ensure lexical binding :performance:
:PROPERTIES:
:ID:       2b8148c3-1418-4896-ba53-1673d2d82659
:END:

Emacs by default uses dynamic binding. Lexical binding is a [[https://nullprogram.com/blog/2016/12/22/][known way to boost
startup speed]]. To enable it you add the following [[info:elisp#Using Lexical Binding][buffer-local variable]] on the
top of your elisp file.

#+begin_src emacs-lisp
;; -*- lexical-binding: t -*-
#+end_src

*** config files and directores :core:dir:
:PROPERTIES:
:ID:       be8993d3-c8f7-451b-8cb4-04a9138e5c4e
:END:

It's useful to store directories which I reference frequently in variables and
functions. This way I can reference the full path. Certain directories are
important; and I end up referencing them alot.

#+begin_src emacs-lisp
(defvaralias 'XL-INIT-FILE 'user-init-file)

(defvaralias 'XL-EMACS-DIR 'user-emacs-directory)

(defconst XL-LOCAL-DIR (concat XL-EMACS-DIR ".local/")
  "Directory where I store files that need to exist, but I don't want to see.")

(defconst XL-CACHE-DIR (concat XL-LOCAL-DIR "cache/")
  "Directory where I store files used for caching information.")

(defconst XL-RECIPE-FILE (concat XL-EMACS-DIR "recipes.el")
  "File that stores the recipes for all the packages I install.")

(defconst XL-PACKAGES-DIR (concat XL-LOCAL-DIR "packages/")
  "Directory where packages are stored.")
#+end_src

*** garbage collection :performance:
:PROPERTIES:
:ID:       dda841d2-25f3-4595-ab6a-87cb1bb72dba
:END:

Emacs garbage collects too frequently for most modern machines. This makes emacs
less performant especially when performing a large number of calculations,
because it spends resources garbage collecting when it doesn't have to. Indeed,
increasing the value of [[helpvar:gc-cons-threshold][gc-cons-threshold]], the number of bytes of consing
between garbage collections, is known to make a notable difference in user
startup time. By default it is only 800 KB.

**** gc cons threshold
:PROPERTIES:
:ID:       50e19a55-a04b-4ca0-8024-a88b23b5b41f
:END:

I define three levels on frequency with which emacs should perform garbage
collection.

#+begin_src emacs-lisp
(defconst XL-GC-CONS-THRESHOLD-MAX most-positive-fixnum
  "The upper limit for `gc-cons-threshold'.
When VOID is performing computationally intensive operations,
`gc-cons-threshold' is set to this value.")

(defconst XL-GC-CONS-THRESHOLD (eval-when-compile (* 16 1024 1024))
  "The default value for `gc-cons-threshold'.
This is the value of `gc-cons-threshold' that should be used in typical usages.")

(defconst XL-GC-CONS-THRESHOLD-MIN (eval-when-compile (* 4 1024 1024))
  "The value for `gc-cons-threshold'.")
#+end_src

*** debug-p
:PROPERTIES:
:ID:       39197346-c420-4518-b8f8-8ea247d6decb
:END:

[[helpvar:void-debug-p][xl-debug]] is snatched from [[https://github.com/hlissner/doom-emacs][Doom's]] [[https://github.com/hlissner/doom-emacs/blob/develop/core/core.el][doom-debug-mode]]. The point of this variable is
to serve as an indicator of whether the current Emacs instance is run for
debugging. When Emacs is set up for debugging it prints out many messages about
what its doing via [[hfn:void-log][xl-log]].

#+begin_src emacs-lisp
(defvar xl-debug-p (or (getenv "DEBUG") init-file-debug)
  "When non-nil print debug messages.
The --debug-init flag and setting the DEBUG envar will enable this at startup.")
#+end_src

** package management
:PROPERTIES:
:ID:       1bb76e0a-c9a4-4024-be8f-942eaebb345f
:END:

This headline should be evaluated upon tangling.

*** straight :straight:
:PROPERTIES:
:ID:       2e251cc7-04de-43f8-a31f-1574a54ad576
:END:

[[straight][straight.el]] is a package manager that installs packages by cloning their git
repositories from online and building them from source. A consequence of this is
that you have the history of every installed emacs package locally. Another
consequence is that you can completely reproduce the state of your emacs on
another machine by installing the same packages with the same versions.

**** variables :straight:pacman:core:
:PROPERTIES:
:ID:       9dff9894-667c-4e74-9624-8aee533f8f70
:END:

We don't need to clone everything from the git repos. Setting the depth to one
conserves some disk space.

#+begin_src emacs-lisp
(setq straight-use-package-version 'straight)
(setq straight-use-package-by-default nil)
(setq straight-check-for-modifications nil)
(setq straight-recipes-emacsmirror-use-mirror t)
(setq straight-vc-git-default-clone-depth 1)
#+end_src

**** handle autoloads for me
:PROPERTIES:
:ID:       d3b052e4-fc7e-4b64-bd53-a6aa4b8abd16
:END:

To save startup time, we don't want to load packages unnecessarily. Many
packages have what I like to call (I just made this up :smirk-cat:) "entry-points", or
commands that are used to trigger the loading of the package. =straight=
optionally handles this for us.

#+begin_src emacs-lisp
(setq straight-disable-autoloads nil)
(setq straight-cache-autoloads t)
#+end_src

**** package integration
:PROPERTIES:
:ID:       db1f9042-5b6c-41a9-a69c-d05d0493fdb0
:END:

By "integration" this variable means that it disables =package.el='s
initialization. We don't need =straight= to do this for us because it is handled in
[[id][early-init]].

#+begin_src emacs-lisp
(setq straight-enable-package-integration nil)
#+end_src

**** load bootstrap file
:PROPERTIES:
:ID:       544f1bbe-3981-4d1b-8b24-3395b27890b2
:END:

#+begin_src emacs-lisp
(defun xl-load-straight-bootstrap-file (target-dir)
  "Load the boostrap file from TARGET-DIR."
  (defvar bootstrap-version)
  (let ((bootstrap-version 5)
	(bootstrap-file (expand-file-name "straight/repos/straight.el/bootstrap.el" target-dir)))
    (load bootstrap-file nil 'nomessage)))
#+end_src

**** install straight.el
:PROPERTIES:
:ID:       ab38beca-2f26-4718-ab73-e4e4409f1563
:END:

I got the inspiration of cloning straight's repo (as opposed to just using the
[[https://github.com/raxod502/straight.el#bootstrapping-straightel][bootstrap code]]) from [[https://github.com/kinnala/diy-emacs][diy-emacs]].

#+begin_src emacs-lisp
(defun xl-install-straight (recipe commit target-dir)
  "Install straight to TARGET-DIR."
  (let* ((repo (plist-get (cdr recipe) :repo))
	 (repo-dir (expand-file-name "straight/repos/" target-dir))
	 (github-link (format "https://github.com/%s.git" repo)))
    (make-directory repo-dir t)
    (shell-command (format "git -C %s clone %s" repo-dir github-link))
    (shell-command (format "git -C %s checkout %s" repo-dir commit))))
#+end_src

**** whether installed
:PROPERTIES:
:ID:       9216f0b9-93d5-43fe-aa96-3796674ab520
:END:

#+begin_src emacs-lisp
(defun xl-straight-installed-p (target-dir)
  "Return non-nil if straight is installed."
  (and (file-exists-p (expand-file-name "straight/" target-dir))
       (file-exists-p (expand-file-name "straight/repos/straight.el/bootstrap.el" target-dir))))
#+end_src

**** read recipes
:PROPERTIES:
:ID:       f7a3baa6-d876-40d3-84f5-74b1d9b4f432
:END:

One of the goals is to be able to completely reproduce my Emacs configuration.
To do this I store the recipes of all the package I install in [[helpvar:XL-RECIPE-FILE][XL-RECIPES-FILE]].
Upon startup I read this file and register all the recipes in it with =straight=.

#+begin_src emacs-lisp
(defun xl-read-recipes (recipe-file)
  "Read and return recipes from RECIPE-FILE."
  (with-temp-buffer
    (insert-file-contents-literally recipe-file)
    (let (forms form)
      (setq form (ignore-errors (read (current-buffer))))
      (while form
	(push form forms)
	(setq form (ignore-errors (read (current-buffer)))))
      (nreverse forms))))
#+end_src

**** versions alist
:PROPERTIES:
:ID:       3db31fa0-86e3-49e3-a13c-c3966bd7d6f7
:END:

#+begin_src emacs-lisp
(defun straight%versions-alist ()
  "Return an alist of (package . version)."
  (let ((versions-alist nil))
    (straight--map-repos
     (lambda (recipe)
       (straight--with-plist recipe
	   (package local-repo type)
	 (when (and local-repo (not (assoc local-repo versions-alist)))
	   (when-let ((commit (straight-vc-get-commit type local-repo)))
	     (push (cons local-repo commit) versions-alist))))))
    versions-alist))
#+end_src

**** generate load-path
:PROPERTIES:
:ID:       498862a1-8491-4ec1-95ad-f0bafd818ddc
:END:

Perhaps, in the future I could figure out preciesly how straight generates its
load paths and generate them without actually needing to call straight. The
advantage of doing it this way is that it is fool-proof.

#+name: generate-load-path
#+begin_src emacs-lisp
(defun xl-install-packages (recipe-file target-dir)
  "Install packages specified by RECIPE-FILE to TARGET-DIR.
Return a list of load-paths for the install packages."
  (pcase-let* ((recipes (xl-read-recipes recipe-file))
	       (regexp (rx-to-string `(seq ,(expand-file-name target-dir))))
	       (load-path load-path)
	       (`(,_ ,commit ,recipe) (assoc "straight" recipes)))
    (unless (xl-straight-installed-p target-dir)
      (xl-install-straight recipe commit target-dir))
    (setq straight-base-dir target-dir)
    (xl-load-straight-bootstrap-file target-dir)
    (pcase-dolist (`(,_ ,commit ,recipe) recipes)
      (straight-use-package recipe))
    (cl-remove-if-not (apply-partially #'string-match-p regexp) load-path)))
#+end_src

** set the load-path
:PROPERTIES:
:ID:       ea592f75-e8dd-4ee7-a44e-c2da9d76191b
:END:

I could just use the side-effect of [[helpfn:straight-use-package][straight-use-package]] to fill up the
[[helpvar:load-path][load-path]]. However, I eventually want to compile this step away in the style of
[[https://github.com/nilcons/emacs-use-package-fast][emacs-use-package-fast]].

#+begin_src emacs-lisp
(require 'cl-lib)
(cl-callf2 append (xl-install-packages XL-RECIPE-FILE XL-PACKAGES-DIR) load-path)
#+end_src

** load required packages
:PROPERTIES:
:ID:       b2d85ac5-7150-4a76-b5f3-067f8040977a
:END:

#+begin_src emacs-lisp
(require 'use-package)
(require 'loopy)
(require 'dash)
#+end_src

** library :library:
:PROPERTIES:
:ID:       296e48e0-5b0d-4b13-8d51-3c2b8c294026
:END:

This headline contains all the the helper functions and macros I defined for
customizing Emacs. The main thing that's done in an Emacs configuration is
configuring packages, both built-in packages and external packages. And in this
process, there are often packages that augment and aid in the configuration of
other packages. Additionally, if you care about startup time it's important to
make sure packages are only loaded when they need to be. The major purpose of
this library is to provide me the tools to configure these packages in a way
that is concise and efficient.

*** helpers :helper:
:PROPERTIES:
:ID:       638626ab-8451-4ae8-9838-6153915fd7f3
:END:

**** symbols :symbol:
:PROPERTIES:
:ID:       5539293f-bd15-49ce-915a-37b3aea6ffb3
:END:

***** convert to string
:PROPERTIES:
:ID:       60f22f98-8204-45ae-9943-f19cdfe60459
:END:

This function is for converting something to a string, no questions
asked. Similar to [[id:06bfc6f7-4c51-44e7-b32e-1434a602b55b][xl-symbol-intern]], I use it when I don't want to be bothered
with details and just want a string.

#+begin_src emacs-lisp
(defun xl-to-string (&rest args)
  "Return ARGS as a string."
  (declare (pure t) (side-effect-free t))
  (with-output-to-string (-each args #'princ)))
#+end_src

***** keyword name
:PROPERTIES:
:ID:       e853603a-851d-429f-9201-f2e93734dfaf
:END:

Calling [[helpfn:symbol-name][symbol-name]] on a keyword returns the keyword as a string. However,
sometimes we don't want the prepended colon on they keyword. This function is
for that occasion.

#+begin_src emacs-lisp
(defun xl-keyword-name (keyword)
  "Return the name of the KEYWORD without the prepended `:'."
  (declare (pure t) (side-effect-free t))
  (substring-no-properties (xl-to-string keyword) 1))
#+end_src

***** xl-symbol-intern
:PROPERTIES:
:ID:       06bfc6f7-4c51-44e7-b32e-1434a602b55b
:END:

This is a convenience function for quickly banging out a custom symbol. It's
advantage over just plain [[helpfn:intern][intern]] is that it will coerce its arguments to a
symbol. This is useful when writing macros where it is a common occurance to
have a mix of different objects (usually strings and symbols) that you want to
put together into one symbol. This function is meant to just do what I mean.

#+begin_src emacs-lisp
(defun xl-symbol-intern (&rest args)
  "Return ARGS as a symbol."
  (declare (pure t) (side-effect-free t))
  (intern (apply #'xl-to-string args)))
#+end_src

***** keyword intern
:PROPERTIES:
:ID:       0618b8d7-e0a4-4e3e-8d89-b7d0ebe43917
:END:

Sometimes I want to create a keyword by interning a string or a symbol. This
commands saves me having to add the colon at the beginning before interning.

#+begin_src emacs-lisp
(defun xl-keyword-intern (&rest args)
  "Return ARGS as a keyword."
  (declare (pure t) (side-effect-free t))
  (apply #'xl-symbol-intern ":" args))
#+end_src

***** intern format
:PROPERTIES:
:ID:       b371718f-2067-450c-8117-fb22f44be208
:END:

#+begin_src emacs-lisp
(defun xl-intern-format (format-string &rest args)
  "Same as `format` but return result as a symbol."
  (declare (pure t) (side-effect-free t))
  (intern (apply #'format format-string args)))
#+end_src

***** xl-emacs-hook-symbol-p
:PROPERTIES:
:ID:       7ae3dac1-058b-4b1b-a010-aeb5b121d3f6
:END:

As I mentioned, the convention for hook symbols is that they are suffixed with
=-hook=. This function checks for such variables.

#+begin_src emacs-lisp
(defun xl-emacs-hook-symbol-p (symbol)
  "Return true if symbol is a hook symbol."
  (declare (pure t) (side-effect-free t))
  (s-matches-p ".+-hook\\'" (symbol-name symbol)))
#+end_src

***** xl-emacs-hookify
:PROPERTIES:
:ID:       b308a172-6e99-491c-a382-7ee28e9fc1ae
:END:

#+begin_src emacs-lisp
(defun xl-emacs-hookify (symbol)
  "Return SYMBOL converted to hook.
If SYMBOL is already a hook symbol, return it unchanged."
  (declare (pure t) (side-effect-free t))
  (xl-symbol-intern symbol (if (xl-emacs-hook-symbol-p symbol) "" '-hook)))
#+end_src

***** xl-emacs-mode-symbol-p
:PROPERTIES:
:ID:       ec25e275-c36f-4cee-be04-1fdf8c974857
:END:

#+begin_src emacs-lisp
(defun xl-emacs-mode-symbol-p (symbol)
  "Return non-nil if symbol is a mode symbol."
  (declare (pure t) (side-effect-free t))
  (s-matches-p ".+-mode\\'" (symbol-name symbol)))
#+end_src

***** xl-emacs-modeify
:PROPERTIES:
:ID:       61fa29a7-9697-4171-8b6f-f4c0b487c02c
:END:

#+begin_src emacs-lisp
(defun xl-emacs-modeify (symbol)
  "Return SYMBOL converted to hook.
If SYMBOL is already a hook symbol, return it unchanged."
  (declare (pure t) (side-effect-free t))
  (if (xl-emacs-mode-symbol-p symbol)
      symbol
    (xl-symbol-intern symbol '-mode)))
#+end_src

***** xl-emacs-map-symbol-p
:PROPERTIES:
:ID:       b7ab2b84-ebea-46fe-8494-89a2aed2f6e8
:END:

#+begin_src emacs-lisp
(defun xl-emacs-map-symbol-p (obj)
  "Return non-nil if OBJ is an emacs map symbol."
  (and (symbolp obj)
       (s-suffix-p "-map" (symbol-name obj))))
#+end_src

***** xl-internal-symbol-p
:PROPERTIES:
:ID:       72aa71bd-186b-47b3-b30e-1bf5da6b41b1
:END:

To avoid.

#+begin_src emacs-lisp
(defun xl-internal-symbol-p (symbol)
  "Return non-nil if symbol is an internal XL symbol."
  (declare (pure t) (side-effect-free t))
  (s-matches-p "\\`xl-.+" (symbol-name symbol)))
#+end_src

***** TODO xl-interactive-function-p
:PROPERTIES:
:ID:       4994e720-e156-408b-b94c-19acbb684fe7
:END:

#+begin_src emacs-lisp
(defun xl-interactive-function-symbol-p (symbol)
  "Return non-nil if SYMBOL is a non-interactive function symbol."
  (s-match (rx (group (1+ (not white))) "/" (group (1+ (not white))))
	   (symbol-name symbol)))
#+end_src

***** TODO xl-extension-function-p
:PROPERTIES:
:ID:       4f86a625-12e1-4142-85b4-607602a8c8c2
:END:

#+begin_src emacs-lisp
(defun xl-extension-function-symbol-p (symbol)
  "Return non-nil if symbol is an extension function symbol."
  (s-match (rx (group (1+ (not white))) (1+ "%") (group (1+ (not white))))
	   (symbol-name symbol)))
#+end_src

**** quoting :quote:
:PROPERTIES:
:ID:       95a2271b-a21b-4fed-a6b8-1e76ca821ed4
:END:

This headline deals with utility functions for dealing it quotes. A quote is a
special form in lisp that is ued to indicate that a symbol or an expression
should not be evaluted. The quotes are so prevalent in lisp that they each have
a character that's used to abbreviate them as I will explain.

The purpose of this headline is to provide functions that are useful for macro
writing. What we deal with when writing macro is syntax itself.

***** single-quoted
:PROPERTIES:
:ID:       533945fc-c700-42ce-8b93-d6bd9e16d9c7
:END:

A single quote prevents the evaluation of a symbol so that lisp reads the symbol
as syntax instead of evaluating it for its value. I should not that the ='= is
just how emacs displays a quote for brevity. In reality something like ~'cat~ is
~(quote cat)~.

#+begin_src emacs-lisp
(defun xl-single-quoted-p (obj)
  "Return non-nil if OBJ is sharp-quoted."
  (declare (pure t) (side-effect-free t))
  (pcase obj
    (`(quote ,obj) t)
    (_ nil)))
#+end_src

***** sharp-quoted
:PROPERTIES:
:ID:       6ba0980e-4391-47ef-a555-4c1dc3132f3b
:END:

A sharp quote is visually represented as =#'=. The real lisp representation of
this is =(function)=. So a ~#'foo~ would be ~(function foo)~. =function= is the
same as =quote= except the former tells the compiler you're referring to the
function symbol.

#+begin_src emacs-lisp
(defun xl-sharp-quoted-p (obj)
  "Return non-nil if OBJ is sharp-quoted."
  (declare (pure t) (side-effect-free t))
  (pcase obj
    (`(function ,obj) t)
    (_ nil)))
#+end_src

***** backquoted
:PROPERTIES:
:ID:       2c7af958-3aa0-48d6-a852-fd5feae452a9
:END:

#+begin_src emacs-lisp
(defun xl-backquoted-p (obj)
  "Return non-nil if OBJ is backquoted."
  (declare (pure t) (side-effect-free t))
  (pcase obj
    (`(backquote ,obj) t)
    (_ nil)))
#+end_src

***** quoted
:PROPERTIES:
:ID:       d1b6c539-c8ca-4dc4-b76d-e2f9406b1c04
:END:

#+begin_src emacs-lisp
(defun xl-quoted-p (symbol)
  "Return non-nil if symbol is quoted."
  (declare (pure t) (side-effect-free t))
  (or (xl-single-quoted-p symbol)
      (xl-sharp-quoted-p symbol)
      (xl-backquoted-p symbol)))
#+end_src

***** unquote
:PROPERTIES:
:ID:       dbf97264-95e9-478b-aa44-edcbd3f39665
:END:

#+begin_src emacs-lisp
(defun xl-unquote (obj)
  "Return OBJ unquoted.
If object is already unquoted, return OBJ."
  (declare (pure t) (side-effect-free t))
  (pcase obj
    (`(,(or backquote quote function) ,obj) obj)
    (_ obj)))
#+end_src

**** macro keyword arguments obselete:
:PROPERTIES:
:ID:       dc7a63e6-041b-4855-b206-6d72ef732de1
:END:

Following past examples (such as that of), I initially opted for allowing
keyword arguments in the "function args" part of defun-like macros. This is fine
when there's only one keyword argument, but any more and it starts to get
crowded. It doesn't help that emacs functions tend towards longer names due to a
lack of namespaces. Therefore, I support keyword args in the function body.

#+begin_src emacs-lisp
(defun xl-keyword-macro-args (body)
  "Return list of (docstring KEYWORD-ARGS BODY)."
  (loopy (with (docstring (when (stringp (car body)) (pop body))))
	 (while (keywordp (car body)))
	 (append plist (list (pop body) (pop body)))
	 (finally-return (list docstring plist body))))
#+end_src

**** true-list-p
:PROPERTIES:
:ID:       43089182-316b-4191-a3f1-6f2d1b1b971e
:END:

Sometimes I want to know whether something is a list and not a cons
cell. Usually, this happens when I want to know whether I can loop over
something--you can loop over a list but not a cons cell.

#+begin_src emacs-lisp
(defun xl-true-list-p (obj)
  "Return non-nil if OBJ is a list and not a cons cell."
  (declare (pure t) (side-effect-free t))
  (and (listp obj) (not (-cons-pair-p obj))))
#+end_src

**** TODO detect emacs symbols 
:PROPERTIES:
:ID:       207ed522-51f3-45e7-91ba-8afb828d950b
:END:

These headline contains functions to detect particular Emacs symbols. Certain
Emacs symbols follow a convention. For example, most hooks end with the suffics
=-hook=. It may be useful--particularly in macros--to know what kind of symbol
we're dealing with. And, it may also be useful to be able to convert a normal
symbol (by which I mean one that doesn't follow the conventions) to one of these
particular kinds.

**** xl-true
:PROPERTIES:
:ID:       25dcd81e-11a1-42b1-87a3-1df8c5a56cf1
:END:

This is the opposite of [[helpfn:ignore][ignore]]. Like =ignore= it takes any number of
arguments. Unlike it, it always returns =t= instead of always returning =nil=.

#+begin_src emacs-lisp
(defun xl-true (&rest _)
  "Return t."
  t)
#+end_src

**** xl-false
:PROPERTIES:
:ID:       0d1349cc-8bd5-4830-9c3b-9b4f9ebe25d0
:END:

#+begin_src emacs-lisp
(defalias 'xl-false 'ignore)
#+end_src

**** eval a form in a string
:PROPERTIES:
:ID:       79cfc39a-0924-468b-9fbc-83388323a39b
:END:

Sometimes it is useful to evaluate a lisp form that's in a string. One example,
is when [[https://orgmode.org/manual/Evaluating-Code-Blocks.html#Evaluating-Code-Blocks][evaluating code in source blocks]]. In general, this comes up
whenever you have to evaluate code you've gotten from a buffer.

You may be wondering why I first wrapped the form in the string with a [[helpfn:progn][progn]]
form. The reason is that [[helpfn:read-from-string][read-from-string]] only takes reads one from from a
string at a time.

This function came from [[https://emacs.stackexchange.com/questions/19877/how-to-evaluate-elisp-code-contained-in-a-string][this stackexchange question]].

#+begin_src emacs-lisp
(defun xl-eval-from-string (string)
  "Eval from from string."
  (eval (car (read-from-string (format "(progn %s)" string)))))
#+end_src

**** wrapping forms
:PROPERTIES:
:ID:       48e48c0f-7bb3-45c9-b4af-2da0ce84b64e
:END:

When writing macros in lisp it is not uncommon to need to write a macro that can
nest a form within some number of other forms (for an example, see [[id][after!]]). This
macro makes this problem much easier.

The original idea for this macro came from [[https://gitlab.common-lisp.net/iterate/iterate/-/blob/master/iterate.lisp][iter's source code]].

#+begin_src emacs-lisp
(defun xl-wrap-form (wrappers form)
  "Wrap FORM with each wrapper in WRAPPERS.
WRAPPERS are a list of forms to wrap around FORM."
  (declare (pure t) (side-effect-free t))
  (setq wrappers (reverse wrappers))
  (if (consp wrappers)
      (xl-wrap-form (cdr wrappers)
                    (append (car wrappers)
                            (list form)))
    form))
#+end_src

**** dwim single
:PROPERTIES:
:ID:       13c4df8f-86f6-46e8-8507-60c08b96fb14
:END:

#+begin_src emacs-lisp
(defun xl-dwim-single (obj)
  "If OBJ is a list of one element return CAR of OBJ.
Otherwise, return OBJ."
  (declare (pure t) (side-effect-free t))
  (if (= (safe-length obj) 1) (car obj) obj))
#+end_src

**** parse body
:PROPERTIES:
:ID:       44f57f99-8290-48ad-8f5c-bdbecce9ab52
:END:

The purpose of this function is to parse a defun body. To be honest, this
function should not exist. Parsing the body of defun is something that should be
done by a pattern matching program, however in Emacs the most powerful
pattern-matching program, [[][pcase] doesn't have the features that would be
required to pattern match this. You'd need to add an ability to explicity
specify optional matches for pcase.

#+begin_src emacs-lisp
(defun xl-parse-defun-body (body)
  "Return a list of (docstring alist body)."
  (loopy (with (docstring (when (stringp (car body)) (pop body))))
	 (while (keywordp (car-safe (car body))))
	 (collect alist (pop body))
	 (finally-return (list docstring alist body))))
#+end_src

*** aliases :alias:
:PROPERTIES:
:ID:       bad5a570-2b94-4ada-88f0-de9f32fa9b7e
:END:

**** prefixed-core
:PROPERTIES:
:ID:       14b63dc9-1d95-4bd7-8b29-8b2b33bd1e69
:END:

This package defines numerous aliases to existing commands in an attempt to make
commands more discoverable and naming schemes more consistent. For example, it
aliases the function [[helpfn:set-frame-font][set-frame-font]] to [[helpfn:frame-set-font][frame-set-font]] because if you were
looking for function that involved the frame, the first thing you'd look for is
for functions namespaced =frame=.

#+begin_src emacs-lisp
(use-package prefixed-core :demand t)
#+end_src

**** custom aliases
:PROPERTIES:
:ID:       c32ede6e-05ae-4067-8505-ffe328295536
:END:

#+begin_src emacs-lisp
(defalias 'atomp 'atom)
(defalias 'buffer-next 'next-buffer)
(defalias 'buffer-previous 'previous-buffer)
(defalias 'char-backward 'backward-char)
(defalias 'char-forward 'forward-char)
(defalias 'add '+)
(defalias 'subtract '-)
(defalias 'multiply '*)
(defalias 'square-root 'sqrt)
(defalias 'hash-table-get 'hash-get)
(defalias 'buffer-create-file-buffer 'create-file-buffer)
(defalias 'find-file-get-create 'find-file-noselect)
#+end_src

*** use-package :usepackage:
:PROPERTIES:
:ID:       e85cfde1-285a-4782-817d-8c9e9fadb48c
:END:

[[https://github.com/jwiegley/use-package][use-package]] provides a uniform syntax for cross-configuring different
packages and features. It is widely used among the emacs community. In this
headline I build upon it and adapt it to my needs.

**** init use-package
:PROPERTIES:
:ID:       8879bd2b-5c7b-43d2-b922-7bb7cd6fea48
:END:

Finally, we get to use =use-package= to configure itself! :smile: By default,
=use-package= provides its own messages and error handling. This can make the
macro expansion of a =use-package= form crowded and much more difficult to
read. Setting [[helpvar:use-package-expand-minimally][use-package-expand-minimally]] tells =use-package=.

By default =use-package= loads a package immediately. Setting
[[helpvar:use-package-always-defer][use-package-always-defer]] tells =use-package= not to load it unless I explicitly
request it (for example, with the =:demand= keyword).

#+begin_src emacs-lisp
(use-package use-package
  :init
  (setq use-package-expand-minimally t)
  (cl-callf2 cl-remove-if (lambda (it) (eq (car it) :config)) use-package-defaults)
  (setq use-package-always-defer t))

(defalias 'use-package! 'use-package)
#+end_src

**** use-package helpers :helper:
:PROPERTIES:
:ID:       d02722ba-9546-42f9-b143-385f05618320
:END:

***** inserting keywords
:PROPERTIES:
:ID:       86f9fa28-6842-4580-994a-24f5d4608ad4
:END:

=use-package= has a built-in way of inserting keywords.

****** functional =use-package= keyword insertion
:PROPERTIES:
:ID:       4968a708-05f2-4a3b-8395-850a3c119fd2
:END:

This is an implementation for inserting something into a list before or after a
particular thing in the list. It is implemented in generally and without
side-effects. That way, it's easily testable.

#+begin_src emacs-lisp
(defun use-package%insert-keyword (where place key list)
  "Insert KEY at PLACE in PLIST.
If WHERE is before, KEY is inserted before place. If WHERE is `after' it is
inserted after PLACE."
  (--splice (eq place it)
	    (funcall (if (eq where 'before) #'identity #'reverse)
		     (list key it))
	    list))
#+end_src

****** dwim insert
:PROPERTIES:
:ID:       54fc11db-534a-4b59-836c-3165cf48b61d
:END:

I insert most =use-package= keywords in the same place. I don't want to have to
specify it all the time. Additionally, I don't want to have to keep repeating
the idiom =(setq use-package-keywords...use-package-keywords)= all the time
either.

#+begin_src emacs-lisp
(defun use-package%dwim-insert (key &optional where place)
  "Convenience wrapper around `use-package%insert-keyword'.
This is the same as `use-package%insert-keyword' except WHERE and PLACE to
`before' and `:hook'."
  (let ((where (or where 'before))
	(place (or place :hook)))
    (setq use-package-keywords
	  (use-package%insert-keyword where place key use-package-keywords))))
#+end_src

***** normalize cons
:PROPERTIES:
:ID:       d5beb18f-b18c-407b-9840-bda400ef52b4
:END:

=use-package= uses this funky-looking cons cell syntax to mean.

#+begin_src emacs-lisp
(defun use-package%normalize-cons (cons-pair)
  "Normalize."
  (-table-flat #'cons
	       (-list (car cons-pair))
	       (-list (cdr cons-pair))))
#+end_src

***** generate normalizer :usepackage:core:emacs:config:helper:
:PROPERTIES:
:ID:       f287aa5b-51ed-40da-bbc1-9a40586a1f83
:END:

I only use this function and [[id:495d3d70-f19f-420d-86ef-d75c49a77b66][its counterpart]] once so maybe putting this in
functions is rather overkill. But I like doing things right. And who knows?
Might be useful later. :shrug:

#+begin_src emacs-lisp
(defun use-package%normalize (key)
  "Return an appropriate normalize symbol for key."
  (xl-symbol-intern 'use-package-normalize/ key))
#+end_src

***** generate a handler :usepackage:core:emacs:config:helper:
:PROPERTIES:
:ID:       495d3d70-f19f-420d-86ef-d75c49a77b66
:END:

#+begin_src emacs-lisp
(defun use-package%handler (key)
  "Return an appropriate handler symbol for key."
  (xl-symbol-intern 'use-package-handler/ key))
#+end_src

***** override keyword :usepackage:core:emacs:config:helper:
:PROPERTIES:
:ID:       aff6cbbe-7657-4287-9632-31dab7310c63
:END:

I want to override some existing =use-package= keywords. Use package keywords
are defined by three things: the existence of the keyword in
[[helpvar:use-package-keywords][use-package-keywords]], the existence of a [[https://github.com/jwiegley/use-package#third-step-create-a-handler][handler]], and the existence of a
[[https://github.com/jwiegley/use-package#second-step-create-a-normalizer][normalizer]]. To overwrite an existing keyword all you have to do is
override the corresponding normalizer and handler. The purpose of this function
is to provide an easy way to do this.

#+begin_src emacs-lisp
(defun use-package%override (old new)
  "Overrides OLD with NEW.
OLD is an existing use-package keyword. NEW is the keyword to override OLD with."
  (advice-add (use-package%normalize old) :override (use-package%normalize new))
  (advice-add (use-package%handler old) :override (use-package%handler new)))
#+end_src

***** create autoloads
:PROPERTIES:
:ID:       ee0dc9c0-1bb3-4309-a61d-5b1c7f4c6ddf
:END:

Perhaps the most code saved with =use-package= is in it's generation of autoload
forms.

#+begin_src emacs-lisp
(defun use-package%autoload (package fn)
  "Return a form that autoloads FN from PACKAGE."
  `(unless (fboundp ',fn)
     (autoload #',fn ,(symbol-name package) nil t nil)))
#+end_src

**** use-package keywords :helper:
:PROPERTIES:
:ID:       0b0c51a6-1b10-4bfd-bb0b-35cecd44217f
:END:

***** DOC silence
:PROPERTIES:
:ID:       c69b021f-c1eb-4f51-8de3-234c4660a0ba
:END:

Many packages print some output to the messages buffer. And, while it may be
useful to receieve messages, often they can be telling you what you already know.

#+begin_src emacs-lisp
(use-package%dwim-insert :silence)

(defun use-package-normalize/:silence (key _ fns)
  "Normalize."
  (iter (for fn fns)
	(cl-assert (symbolp fn) nil "%s hello %s" key fn)
	(collect fn)))

(defun use-package-handler/:silence (name _ fns rest state)
  "Generate forms that silence output of FNS.
FNS is a list of function symbols."
  `(,@(iter (for fn fns)
	    (collect (use-package%autoload fn name))
	    (collect `(xl-gadvice-shut-up #',fn)))
    ,@(use-package-process-keywords name rest state)))
#+end_src

***** DOC gc-pause :performance:
:PROPERTIES:
:ID:       70dba953-1a83-4de8-9a63-43e20c50fe5a
:END:

The keyword pauses emacs gargbage collection (e.g increases the
[[helpvar:gc-cons-threshold][gc-cons-threshold]] to [[helpvar:most-positive-fixnum][most-positive-fixnum]]) for the duration of functions that
it's passed in. It should be used on particularly computationally expensive
functions that a package provides.

#+begin_src emacs-lisp
(use-package%dwim-insert :gc-pause)

(defalias 'use-package-normalize/:gc-pause 'use-package-normalize/:silence)

(defun use-package-handler/:gc-pause (name _ fns rest state)
  "Generate forms that inhibit `gc-cons-threshold' for the duration of FNS."
  `(,@(iter (for fn fns)
	    (collect (use-package%autoload name fn))
	    (collect `(xl-gadvice-pause-garbage-collection #',fn)))
    ,@(use-package-process-keywords name rest state)))
#+end_src

***** DOC ignore
:PROPERTIES:
:ID:       eeeaf89c-78e6-453d-bf3b-27091cc11bca
:END:

Sometimes I want to ignore certain functions.

#+begin_src emacs-lisp
(use-package%dwim-insert :ignore)

(defalias 'use-package-normalize/:ignore 'use-package-normalize/:silence)

(defun use-package-handler/:ignore (name _ fns rest state)
  "Generate forms that cause FNS to do nothing and return nil."
  `(,@(iter (for fn fns)
	    (collect (use-package%autoload name fn))
	    (collect `(xl-gadvice-ignore #',fn)))
    ,@(use-package-process-keywords name rest state)))
#+end_src

***** DOC always yes
:PROPERTIES:
:ID:       f2d89960-ed41-4a72-847f-e150db56330b
:END:

There are a number of functions in Emacs that prompt.

#+begin_src emacs-lisp
(use-package%dwim-insert :assume-yes)

(defalias 'use-package-normalize/:assume-yes 'use-package-normalize/:silence)

(defun use-package-handler/:assume-yes (name _ fns rest state)
  "Ensure that FNS always assume yes for confirmation."
  `(,@(iter (for fn fns)
	    (collect (use-package%autoload name fn))
	    (collect `(xl-gadvice-assume-yes #',fn)))
    ,@(use-package-process-keywords name rest state)))
#+end_src

***** os
:PROPERTIES:
:ID:       9d78d90a-0309-44c6-be96-82bd6608546a
:END:

This keyword provides an concise and declarative way of using [[id:a3ea434a-3f70-4137-a525-5be4bc63c3a2][with-os!]].

#+begin_src emacs-lisp
(use-package%dwim-insert :os)

(defun use-package-normalize/:os (_ _ args)
  (cl-assert (member (car args) '(mac linux windows)))
  (car args))

(defun use-package-handler/:os (name _ os rest state)
  "Wrap body form with `with-os!' macro."
  `((with-os! ,os ,@(use-package-process-keywords name rest state))))
#+end_src

***** hook
:PROPERTIES:
:ID:       02e42811-3b97-44f1-ad0c-d59787173ffb
:END:

Here I override the default hook keyword with my own which uses =xl-hook-add=
instead of =add-hook=.

#+begin_src emacs-lisp
(use-package%dwim-insert :xl-hook)
(use-package%override :hook :xl-hook)

(defun use-package-normalize/:xl-hook (name _ args)
  "Make sure that."
  (loopy (list elt args)
	 (cond ((symbolp elt)
		(collect (cons (xl-emacs-hookify elt) (xl-emacs-modeify name))))
	       ((-cons-pair-p elt)
		(expr (hooks . mode) elt)
		(subloop (list hook (-list hooks))
			 (collect (cons (xl-emacs-hookify hook) mode))))
	       (t
		(do (error "%s requires %s" key elt))))))

(defun use-package-handler/:xl-hook (name _ alist rest state)
  "Use `xl-hook-add' to add HOOK to FN for each (HOOK . FN) in HOOK-ALIST."
  `(,@(loopy (list (hook . fn) alist)
	     (collect `(xl-hook-add ',hook ',fn))
	     (collect (use-package%autoload name fn)))
    ,@(use-package-process-keywords name rest state)))
#+end_src

***** before-call :defer:performance:
:PROPERTIES:
:ID:       55e66d22-b75d-4e77-9f99-dca1afbe1094
:END:

Packages don't live in an isolated enviroment. Often one package depends on one
or more packages. Sometimes, I add customizations to a package using certain
libraries and then I need to load them when that package is loaded. The purpose
of this keyword is to load a package when a certain function is called.

#+begin_src emacs-lisp
(use-package%dwim-insert :before-call)

(defun use-package-normalize/:before-call (name key args)
  "Ensure ARGS is a list of symbols or list."
  (iter (for elt args)
	(cond ((symbolp elt) (collect (cons name elt)))
	      ((-cons-pair-p elt) (collect elt))
	      (t (error "%s requires either symbols or cons cells." key elt)))
	(finally-do (-map #'use-package%normalize-cons loopy-result))))

(defun use-package-handler/:before-call (name key alist rest state)
  "Generate forms that load PACKAGE before FN is called."
  `(,@(iter (for (package . fn) alist)
	    (collect (use-package%autoload package fn))
	    (collect `(xl-load-before-call ',package #',fn)))
    ,@(use-package-process-keywords name rest state)))
#+end_src

***** after-call :defer:performance:
:PROPERTIES:
:ID:       2c7dd1a8-c0ee-42cd-b76f-8a72c94be848
:END:

The.

#+begin_src emacs-lisp
(use-package%dwim-insert :after-call)

(defalias 'use-package-normalize/:after-call #'use-package-normalize/:before-call)

(defun use-package-handler/:after-call (name _ alist rest state)
  "Generate form that loads package after fn is called."
  `(,@(iter (for (package . fn) alist)
	    (collect (use-package%autoload name fn))
	    (collect `(xl-load-after-call ',package #',fn)))
    ,@(use-package-process-keywords name rest state)))
#+end_src

***** set
:PROPERTIES:
:ID:       9948a4ae-f80a-4b13-b97a-0895481021a6
:END:

I should give credit. I got this idea from the leaf macro.

#+begin_src emacs-lisp
(use-package%dwim-insert :set)

(defun use-package-normalize/:set (_ _ args)
  "Raise an error if."
  (cl-assert (-all-p #'listp args) nil "Should all be lists.")
  args)

(defun use-package-handler/:set (name _ values rest state)
  "Generate forms that set var to value."
  `(,@(loopy (list (var . val) values)
	     (expr setter (if (listp var) 'setf 'set!))
	     (collect `(,setter ,var ,val)))
    ,@(use-package-process-keywords name rest state)))
#+end_src

***** alias
:PROPERTIES:
:ID:       9fe0d171-55b4-4022-82ec-abfb5e776cae
:END:

Sometimes I want to alias certain.

#+begin_src emacs-lisp
(use-package%dwim-insert :alias)

(defalias 'use-package-normalize/:alias 'use-package-normalize/:set)

(defun use-package-handler/:alias (name _ aliases rest state)
  "Generate aliases forms for ALIASES."
  `(,@(loopy (list (sym . def) aliases)
	     (collect (use-package%autoload name def))
	     (collect `(defalias ',sym #',def)))
    ,@(use-package-process-keywords name rest state)))
#+end_src

***** advice :advice:
:PROPERTIES:
:ID:       1a0d6ff0-0dcd-4374-b52c-79bf617b3a2b
:END:

A keyword specifically designed for =xl= advices, or advices of the form
=xl-<name>-advice=. For convenience, it is assumed to use =around= advice.

#+begin_src emacs-lisp
(use-package%dwim-insert :advice)

(defun use-package-normalize/:advice (_ _ advices)
  "Ensure that ADVICES is a list of advice arguments.
ADVICES should be of the form (WHERE SYMBOL ADVICE PROPS EXPIRE-FN) where PROPS
and EXPIRE-FN are optional."
  (iter (each elt advices)
	(progn
	  (pcase elt
	    (`(,(and (pred keywordp) key) (,fn . ,advice))
	     (collect (list key fn advice)))
	    (`(,fn . ,advice)
	     (collect (list :around fn advice)))
	    (_
	     (error "wrong args"))))))

(defun use-package-handler/:advice (name _ advices rest state)
  "Generate forms that add advice."
  `(,@(loopy (list (where fn advice) advices)
	     (expr where (if (keywordp where) where (xl-keyword-intern where)))
	     (collect `(xl-advice-add #',fn ,where #',advice)))
    ,@(use-package-process-keywords name rest state)))
#+end_src

***** gadvice :gadvice:
:PROPERTIES:
:ID:       0646d4c8-47e7-45cc-a14a-6326a2b76fdd
:END:

This provides a shortcut for generic advices.

#+begin_src emacs-lisp
(use-package%dwim-insert :gadvice)

(defun use-package-normalize/:gadvice (_ _ advices)
  "Ensure that ADVICES is a list of advice arguments.
ADVICES should be of the form (WHERE SYMBOL ADVICE PROPS EXPIRE-FN) where PROPS
and EXPIRE-FN are optional."
  (loopy (with (normalized (use-package-normalize/:advice _ _ advices)))
	 (each (_ fn advice) normalized)
	 (expr gadvice (xl-intern-format "xl-gadvice-%s" advice))
	 (collect (cons fn gadvice))))

(defun use-package-handler/:gadvice (name _ gadvices rest state)
  `(,@(loopy (each (fn . gadvice) gadvices)
	     (collect `(,gadvice #',fn)))
    ,@(use-package-process-keywords name rest state)))
#+end_src

***** initial state :evil:
:PROPERTIES:
:ID:       e923e94e-9051-4be8-8dda-6566601ba865
:END:

I create this work to allow for easier cross configuration of states between
packages.

#+begin_src emacs-lisp
(use-package%dwim-insert :initial-state)

(defun use-package-normalize/:initial-state (name _ states)
  "Require series of symbols or cons of the form (MODE . STATE)."
  (loopy (list elt states)
	 (cond ((symbolp elt)
		(collect (cons (xl-emacs-modeify name) elt)))
	       ((consp elt)
		(expr (mode . state) elt)
		(collect (cons mode state)))
	       (t
		(do (error "Invalid argument: %s" states))))))

(defun use-package-handler/:initial-state (name _ states rest state)
  "Generate forms to set the initial evil state of certain modes."
  `(,@(loopy (list (mode . state) states)
	     (collect forms `(evil-set-initial-state ',mode ',state))
	     (finally-return `((after! (evil ,name) ,@forms))))
    ,@(use-package-process-keywords name rest state)))
#+end_src

***** advice for disable :advice:selectrum:
:PROPERTIES:
:ID:       1e39a4d2-8d4a-4413-a86e-3f92547cff14
:END:

For most functions, sorting their candidates is good. But for some, it doesn't
make sense. This is advice specifically designed to disable selectrum sorting.

#+begin_src emacs-lisp
(defun selectrum%disable-sorting (fn)
  "Disable sorting for FN."
  (let ((advice (xl-symbol-intern fn '@no-selectrum-sorting)))
    (defalias advice #'selectrum%disable-selectrum-sorting-advice)
    ;; (xl-gadvice-log advice)
    (advice-add fn :around advice)))

(defun selectrum%disable-selectrum-sorting-advice (orig-fn &rest args)
  (if (bound-and-true-p selectrum-mode)
      (let (selectrum-should-sort-p) (apply orig-fn args))
    (apply orig-fn args)))
#+end_src

***** use-package keyword for disabling sorting :selectrum:completion:
:PROPERTIES:
:ID:       a647122b-f39f-4140-8c5f-a3e14bfe37f3
:END:

#+begin_src emacs-lisp
(use-package%dwim-insert :no-sort)

(defun use-package-handler/:no-sort (name _ fns rest state)
  "Don't sort the functions with selectrum."
  `(,@(loopy (each fn fns)
	     (collect `(selectrum%disable-sorting #',fn)))
    ,@(use-package-process-keywords name rest state)))

(defalias 'use-package-normalize/:no-sort 'use-package-normalize/:gc-pause)
#+end_src

***** idle :defer:performance:
:PROPERTIES:
:ID:       78814410-c190-4f05-a319-4e6d13a9ea4b
:END:

#+begin_src emacs-lisp
(use-package%dwim-insert :idle)

(defun use-package-normalize/:idle (_ _ args)
  (cl-assert (-all-p #'symbolp args))
  (loopy (each arg args)
	 (collect (cons 10 arg))))

(defun use-package-handler/:idle (package _ args rest state)
  `(,(loopy (each (seconds . fn) args)
	    (collect forms `(run-with-idle-timer 10 t #',fn))
	    (finally-return `(after! ,package ,@forms)))
    ,@(use-package-process-keywords package rest state)))
#+end_src

*** features :feature:
:PROPERTIES:
:ID:       67e54261-0b00-4daa-bbe9-a0f2fbbc1d9b
:END:

These are packages that I use to make writing lisp code more convenient. Emacs
Lisp is a full-featured, turing-complete language. However, for some data
structures like hash-tables and alists it is missing consistently named
functions for performing operations on these data structures. This is improving
slowly with the introduction of libraries like =seq.el= and =map.el= but still
leaves much to be desired. This sounds like a complaint, but it actually
highlights the advantage of the extensibility of Emacs.

**** shut-up
:PROPERTIES:
:ID:       71681f9f-2760-4cee-95a0-4aeb71191a42
:END:

This package provides a macro named =shut-up= that as its name suggests,
silences output of any forms within it :speak-no-evil:. Emacs itself and many
emacs packages spew messages. While I can see how in certain circumstances there
messages can be useful, most of the time they are superfluous.

#+begin_src emacs-lisp
(use-package shut-up :demand t)
#+end_src

**** mmt 
:PROPERTIES:
:ID:       a4377985-fe0e-4980-b839-08c334bde76c
:END:

=mmt= is a library of tools for writing macros. Specifically, it provides the
quintessential =once-only= and =with-gensyms= macros which are used to prevent
variable leaking.

#+begin_src emacs-lisp
(use-package mmt)
#+end_src

**** dash 
:PROPERTIES:
:ID:       7885c48d-0ead-4d77-8de1-e9faec58b583
:END:

Dash is rich list manipulation library. Many of the functions it have already
been found in some form or another in emacs in features such as =cl-lib= and
=seq= and =subr=, but dash has some very convenient functions and macros over
emacs (such as =-let)=. Moreover, a lot of work has been put into making it's
functions efficient; some are even more efficient than built-in cl
functions. Additionally, it's already used as a dependency of very many packages
so I'll likely end up loading it anyway.

#+begin_src emacs-lisp
(use-package dash :demand t)
#+end_src

**** subr-x 
:PROPERTIES:
:ID:       ee3ad1b5-920a-4337-9874-79e066ed53fe
:END:

#+begin_src emacs-lisp
(use-package subr-x :demand t)
#+end_src

**** ht 
:PROPERTIES:
:ID:       56bb0ff4-6ad1-44b7-a9a4-54abf48ed253
:END:

=ht= is a package that tries to provide a consistently named API for dealing with
hash-tables.

#+begin_src emacs-lisp
(use-package ht)
#+end_src

**** dash-functional 
:PROPERTIES:
:ID:       704fc35f-0ad0-4eb3-9eb5-d8335465dbd8
:END:

=dash-functional= provides "function combinators". These are functions that take
one or more functions as arguments and return a function. One example of this is
emacs's [[helpfn:apply-partially][apply-partially]]. These functions can help.

#+begin_src emacs-lisp
(use-package dash-functional :demand t)
#+end_src

**** s 
:PROPERTIES:
:ID:       b96acb97-3963-4713-a03b-6294c65903fd
:END:

=s= is an api for strings inspired by [[id:704fc35f-0ad0-4eb3-9eb5-d8335465dbd8][dash]]. It has many useful string functions
that are not built-in to Emacs. Notably, it is functional.

#+begin_src emacs-lisp
(use-package s :demand t)
#+end_src

**** f 
:PROPERTIES:
:ID:       f44da560-dc3f-4635-926e-eec4fd6d159d
:END:

#+begin_src emacs-lisp
(use-package f :demand t)
#+end_src

**** anaphora 
:PROPERTIES:
:ID:       1c47bd8a-15f1-4b1c-9574-23547d27d968
:END:

It's common to want to refer to the thing you're operating on in lisp and in
many other languages. In lisp this often requires assigning the variable a name.
But if you're only.

#+begin_src emacs-lisp
(use-package anaphora :demand t)
#+end_src

**** a 
:PROPERTIES:
:ID:       32110690-9d0a-4e3d-a1d8-7695b42aeb30
:END:

=a= is an association list library.

#+begin_src emacs-lisp
(use-package a :demand t)
#+end_src

**** loopy 
:PROPERTIES:
:ID:       1c30099a-86b4-41f9-8390-e9e3c20b0257
:END:

=loopy= is an alternative to =cl-loop= that preserves lisp structure. It is akin
to [[https://common-lisp.net/project/iterate/][Common Lisp's iter]]. dash's functions and macros are good for most
cases. But they are not as good in my opinion when you're dealing with a complex
loop that involves accumulating several variables or atypical control-flow (as
in, break statements or return statements). This is where =loopy= comes into
play.

***** loopy
:PROPERTIES:
:ID:       da17f1ea-7b0d-4d8c-a068-792ed58c6a79
:END:

#+begin_src emacs-lisp
(use-package loopy
  :demand t
  :init
  (add-to-list 'loopy-default-flags '-split)
  (loopy-defalias 'fret 'finally-return)
  (loopy-defalias 'ret 'return))
#+end_src

***** iter
:PROPERTIES:
:ID:       cf3f024a-8bec-4f5a-bd63-38b09dc23ca5
:END:

I thought I'd be using this macro exclusively and that I'd never use =loopy= at
all. However, =loopy= has the distinct advantage that it has more freedom to
name its clauses without clobbering them with existing Emacs functions. So I'd
say I use =loopy= when the loop doesn't need.

For the same drawback as I've mentioned, =loopy-iter= can't use the =list=
clause because it would get confused with it and the built-in Emacs function
[[helpfn:list][list]]. For that reason we need to use one of lists aliases.

#+begin_src emacs-lisp
(use-package loopy-iter
  :demand t
  :init
  (callf2 cl-adjoin '+lax-names loopy-default-flags)
  (loopy-defalias 'for 'list)
  (loopy-defalias 'each 'list)
  :alias
  (iter . loopy-iter)
  (iterate . loopy-iter))
#+end_src

***** dash destructuring
:PROPERTIES:
:ID:       87615a1d-2790-44c4-ac95-90a36ff9c496
:END:

#+begin_src emacs-lisp
(use-package loopy-dash
  :demand t
  :init
  (callf2 cl-adjoin '+dash loopy-default-flags))
#+end_src

**** noflet
:PROPERTIES:
:ID:       27f06ae0-ed4d-45ca-b451-fa05a47b8fe0
:END:

This package provides an alternative to the built-in =cl-flet= called
=noflet=. The [[][]] is that.

#+begin_src emacs-lisp
(use-package noflet :demand t)
#+end_src

**** dbc
:PROPERTIES:
:ID:       b3351a74-b2d0-42b8-9895-b6baad0adb0b
:END:

=dbc= stands for "display-buffer-control". This package provides an interface
for working with [[helpfn:display-buffer-alist][display-buffer-alist]]. In a nutshell, =display-buffer-alist= is
a Emacs's built in way of allowing the user to customize how windows are opened.

#+begin_src emacs-lisp
(use-package dbc
  :demand t
  :config
  (--each '((display-buffer-in-side-window . ((side . bottom) (window-height . 0.5)))
	    (display-buffer-in-side-window . ((side . top) (window-height . 0.4)))
	    (display-buffer-in-side-window . ((side . left) (window-width 0.4)))
	    (display-buffer-in-side-window . ((side . right) (window-width 0.4))))
    (dbc-add-ruleset (xl-to-string (alist-get 'side (cdr it))) it)))
#+end_src

**** rule :usepackage:library:core:popup:
:PROPERTIES:
:ID:       30ee0415-dccf-4742-9c31-bd33b900ab81
:END:

This keyword integrates with [[id:b3351a74-b2d0-42b8-9895-b6baad0adb0b][dbc]] (display buffer control). What it does is.

#+begin_src emacs-lisp
(use-package%dwim-insert :rule)

(defun use-package-normalize/:rule (_ _ args)
  "Ensure ARGS is a list of lists."
  (cl-assert (-all-p #'xl-true-list-p args))
  args)

(defun use-package-handler/:rule (name _ rules rest state)
  "Generate popup rule for each."
  `(,@(loopy (list rule rules)
	     (collect `(dbc-add-rule ,@rule)))
    ,@(use-package-process-keywords name rest state)))
#+end_src

**** TODO log4e
:PROPERTIES:
:ID:       8360e875-61a6-46f8-a401-2a98c9e517fa
:END:

#+begin_src emacs-lisp
(use-package log4e
  :demand t
  :alias (xl/popup-log-buffer . xl--log-open-log)
  :init
  (defalias 'xl-log 'xl--log-info))

(log4e:deflogger "xl" "%t [%l] %m" "%H:%M:%S")
(xl--log-enable-logging)
#+end_src

**** ts

#+begin_src emacs-lisp
(use-package ts)
#+end_src

**** list-utils
:PROPERTIES:
:ID:       f87d570a-4b06-42ea-acaa-a0bedba0e623
:END:

#+begin_src emacs-lisp
(use-package list-utils)
#+end_src

**** map
:PROPERTIES:
:ID:       129b620e-62ab-40ca-ba8f-a5f7f64d6651
:END:

#+begin_src emacs-lisp
(use-package map :demand t)
#+end_src

*** custom macros
:PROPERTIES:
:ID:       40a33da1-6d4b-4395-adfb-a4cdba7ec28c
:END:

**** defmacro!
:PROPERTIES:
:ID:       9b476d3f-b7a3-4657-9059-ed59b414337f
:END:

When you start writing many macros you many notice that you often need to create
names for functions and variables. Typically, you create these symbols via
something like ~(intern (format "some-name-%s"))~. But doing this all time time
and often multiple times in one macro quickly becomes tedious. This macro is
designed to deal with this problem.

#+begin_src emacs-lisp
(defmacro defmacro! (name args &rest body)
  (declare (indent defun))
  `(defmacro ,name ,args ,@(mapcar #'def body)))
#+end_src

**** generate font-lock
:PROPERTIES:
:ID:       0353d5ad-d937-4e7d-8f33-30624b1905de
:END:

The font lock patters that I use are fairly regular.

#+begin_src emacs-lisp
(defun xl-gen-defun-font-lock (name)
  "Return the form to add to font lock for macro with name."
  `((,(format "(\\(%s!\\)[[:space:]]+\\([-[:word:]]+\\)[[:space:]]+(\\([-[:word:]]+\\)" name)
     (1 font-lock-keyword-face)
     (2 font-lock-function-name-face)
     (3 font-lock-variable-name-face))))
#+end_src

**** defunmacro!
:PROPERTIES:
:ID:       41585612-f351-4c73-82c2-73e7e2e59f50
:END:

This macro is for defining =defun-like= macros.

#+begin_src emacs-lisp
(defmacro defunmacro! (name args &rest body)
  "Define a macro for defining function names."
  (-let (((args plist) (-split-at )))
    `(progn
       ;; (defhook! add-<name>-font-lock-keywords (emacs-lisp-mode-hook :expire t)
       ;; 	 "Add font lock keywords for <name>."
       ;; 	 (font-lock-add-keywords 'emacs-lisp-mode (xl-defun-form-font-lock ,name)))
       (defmacro! ,name (name args &rest body)
	 (declare (indent defun))
	 (let-alist ,<$alist>
	   ,@body)))))
#+end_src

**** defhook!
:PROPERTIES:
:ID:       8ea918ba-e25f-4296-a83d-dbb05c4f9130
:END:

#+begin_src emacs-lisp
(defunmacro! defhook! (name hooks &rest body)
  "Define a hook that follows XL naming conventions."
  (loopy (with ((docstring alist body) (xl-parse-defun-body body))
	       (args (or .args '(&rest _)))
	       (base-hook (xl-intern-format "xl--%s-hook" name)))
	 (for hook hooks)
	 (expr hook (xl-hook-gen-name symbol name))
	 (collect `(defalias ',hook ,base-hook))
	 (collect `(add-hook ',hook ',hook ,(or .append .depth) ,local))
	 (collect `(xl-log-function ',hook))
	 (finally-return `(progn (defun ,base-hook ,args ,docstring ,@body)
				 ,@loopy-result))))
#+end_src

**** defadvice!
:PROPERTIES:
:ID:       6dd44e4c-0f11-4a45-9ad0-9b5ac35d4e58
:END:

#+begin_src emacs-lisp
(defunmacro! defadvice! (name args &rest body)
  "Define an advice that follows XL naming conventions."
  (loopy (with (orig-fn (xl-intern-format "xl--%s-advice" name)))
	 (for fn functions)
	 (expr advice (xl-advice-gen-symbol fn name))
	 (collect `(defalias ',advice ',orig-fn))
	 (collect `(advice-add #',fn ,where #',advice ,.props))
	 (collect `(xl-log-function #',advice))
	 (finally-return `((defun ,orig-fn ,.args ,docstring ,@.body)
			   ,@loopy-result))))
#+end_src

**** defhooksym!
:PROPERTIES:
:ID:       687c424f-967b-4950-98dc-2ee51532135a
:END:

#+begin_src emacs-lisp
(defmacro defhooksym! (name args &rest body)
  "Define a hook."
  (declare (indent defun))
  `(progn (defvar ,name nil ,docstring)
	  (defadvice! ,name ,args
	    "Run"
	    ,@body)))
#+end_src

**** before-load-hook
:PROPERTIES:
:ID:       296c2ea1-204c-4140-9e0c-e9037768b02e
:END:

#+begin_src emacs-lisp
(defhooksym! xl-before-load-hook ()
  (:before require)
  (run-hook 'xl-before-load-hook))
#+end_src

**** after-load-hook
:PROPERTIES:
:ID:       1cbc237b-b2f5-4a7d-a929-85887f8f76d1
:END:

#+begin_src emacs-lisp
(defhooksym! xl-before-load-hook (&rest _)
  (:after provide)
  (run-hook 'xl-before-load-hook))
#+end_src

**** defafter!
:PROPERTIES:
:ID:       892a40f9-7023-4cdc-a73c-c03d79037fca
:END:

#+begin_src emacs-lisp
(defmacro defafter! (name features &rest body)
  "Load feature after."
  (declare (indent defun))
  `(progn
     (defhook! ,name (feature)
       ,docstring
       (:hook xl-after-load-feature-hook)
       (when ,feature ,@body))))
#+end_src

**** defbefore!
:PROPERTIES:
:ID:       b58e4e3b-f141-4bbc-a898-3aef9f6813f4
:END:

#+begin_src emacs-lisp
(defmacro defbefore! (name args &rest body)
  "Load feature before."
  (declare (indent defun))
  `(progn
     (defhook! ,name (feature)
       ,docstring
       (:hook xl-before-load-feature-hook)
       (when ,feature ,@body))))
#+end_src

**** eval-after-load! :defer:
:PROPERTIES:
:ID:       8d831084-539b-4072-a86a-b55afb09bf02
:END:

=eval-after-load= is a macro that evaluates a lisp form after a file or feature
has been loaded. It's syntax is a bit terse because you need to quote the
feature as well as the form to be evaluated.

Also, if an =eval-after-load= block contains an error and it is triggered by a
feature, the error will happening. I think it might be that because the form was
not successfully evaluated =eval-after-load= does not realize it should stop
loading it. To remedy this I wrap the block with [[helpfn:condition-case][condition-case]].

#+begin_src emacs-lisp
(defmacro eval-after-load! (feature &rest body)
  "A wrapper around `eval-after-load!' with error catching."
  (declare (indent defun))
  `(eval-after-load ',feature
     '(condition-case error
          (progn ,@body)
        (error
         (message "Error in `eval-after-load': %S" error)))))
#+end_src

**** after! :defer:
:PROPERTIES:
:ID:       e209d256-86e0-4e30-a7d5-78a583729b42
:END:

=after!= is yet another wrapper around that can accept multiple features or
even a specification of features using =and= or =or=.

The reason that we check for the feature is to prevent [[hvar:eval-after-load][eval-after-load]] from
polluting the [[hvar:after-load-list][after-load-list]]. =eval-after-load= adds an entry to
=after-load-list= whether or not it has been loaded.

We intentionally avoid with-eval-after-load to prevent eager macro expansion
from pulling (or failing to pull) in autoloaded macros/features.

#+begin_src emacs-lisp
(defmacro after! (features &rest body)
  "Wrapper around `with-eval-after-load'."
  (declare (indent defun) (debug t))
  (cond ((eq 'or (car-safe features))
	 (loopy (list feature (cdr features))
		(collect form `(after! ,feature ,@body))
		(finally-return `(progn ,@forms))))
        ((eq 'and (car-safe features))
	 (loopy (with ((first . rest) (cdr features))
		      (forms `(after! ,first ,@body)))
		(list feature (reverse rest))
		(expr forms `(after! ,feature ,@(list forms)))
		(finally-return forms)))
        ((listp features)
         `(after! (and ,@features) ,@body))
        ((symbolp features)
         `(if (featurep ',features)
              (progn ,@body)
            (eval-after-load! ,features ,@body)))
        (t (error "Invalid argument."))))
#+end_src

**** config :defer:performance:usepackage:
:PROPERTIES:
:ID:       fa0947a2-7f0c-447e-9b16-03edb2648ad6
:END:

This keyword is meant to overwrite the built-in =:config= keyword. It does the
same thing, except it uses =after!= instead of =with-eval-after-load=.

#+begin_src emacs-lisp
(use-package%dwim-insert :xl-config)
(use-package%override :config :xl-config)

(defun use-package-normalize/:xl-config (_ _ args)
  args)

(defun use-package-handler/:xl-config (name _ forms rest state)
  "Wrap FORMS in an `after!' block."
  `((after! ,name ,@forms)
    ,@(use-package-process-keywords name rest state)))
#+end_src

**** with-temp-advice!
:PROPERTIES:
:ID:       5fb1f2e9-53d2-4830-b6b2-abef3477002d
:END:

https://emacs.stackexchange.com/questions/54500/how-to-add-a-locally-override-the-message-function

#+begin_src emacs-lisp
(defmacro with-temp-advice! (advices &rest body)
  "Evaluate BODY with ADVICES enabled."
  (declare (indent defun))
  (loopy (each (symbol where advice) advices)
	 (collect before `(advice-add #',symbol ,where #',advice))
	 (collect after `(advice-remove #',symbol #',advice))
	 (finally-return `(unwind-protect (progn ,@before ,@body) ,@after))))
#+end_src

**** with-os!
:PROPERTIES:
:ID:       a3ea434a-3f70-4137-a525-5be4bc63c3a2
:END:

Emacs is for the most part operating system agnostic. Packages written in elisp
should work across operating systems. Nevertheless, there are a handful of
settings that should favors particular operating systems over others.

#+begin_src emacs-lisp
(defmacro with-os! (os &rest body)
  "If OS is current system's operating system, execute body.
OS can be either `mac', `linux' or `windows' (unquoted)."
  (declare (indent defun))
  (when (funcall (cond ((eq :not (car-safe os)) (-not #'member))
                       (t #'member))
                 (pcase system-type
                   (`darwin 'mac)
                   (`gnu/linux 'linux)
                   (`(cygwin windows-nt ms-dos) 'windows)
                   (_ nil))
                 (-list os))
    `(progn ,@body)))
#+end_src

**** set!

One "gotcha" in Emacs is the existence of custom variables. Unlike typical
variables custom variables sometimes rely on certain code being executed when
they're initialized or when their values are changed. If you just set the
variable normally with [[helpfn:setq][setq]] you'd change it's value but you wouldn't be running
it's corresponding code so the change you think would happen, might not happen
at all.

Rather than keeping track of which variables have custom setters and which do
not, I opt to just use this macro.

For this reason I use =set!= as a replacement for =setq=.

[[https://opensource.com/article/20/3/variables-emacs][This article]] provides a brilliant synopsis of emacs variables.

Note that I may depreciate this in favor of setf.

#+begin_src emacs-lisp
(defmacro set! (&rest args)
  "Set"
  (pcase (length args)
    ((pred (= 1))
     (alet (car (xl-anaphoric-symbols args))
       `(set! ,(xl-anaphoric-true-symbol it)
	      ,(--tree-map (if (xl-anaphoric-symbol-p it) (xl-anaphoric-true-symbol it) it)
			   (car args)))))
    ((and (pred cl-evenp) (pred > 0))
     `(progn
	,@(loopy (cons (sym val . _) args #'cddr)
		 (expr setter `(or (get ',sym 'custom-set) 'set))
		 (collect `(funcall ,setter ',sym ,val)))))
    (_
     (error "Invalid arguments."))))
#+end_src

**** set-default!
:PROPERTIES:
:ID:       bc6b7560-fb71-4fc7-a53b-98f92c657d92
:END:

=set-default= is used for.

#+begin_src emacs-lisp
(defmacro set-default! (sym val)
  `(funcall (or (get ',sym 'custom-set-default) 'set-default) ',sym ,val))
#+end_src

**** fn!
:PROPERTIES:
:ID:       0ebd39d6-0f09-4a66-a6fc-5c259cab150d
:END:

This is a macro for writing anaphoric lambdas. It is based on [[https://github.com/troyp/fn.el][fn]], the main
difference being that in a few special cases you can specify a named anaphoric
variable. Also, I don't support the alternate =fn:= syntax.

#+begin_src emacs-lisp
(defmacro fn! (&rest body)
  "Expand into an anaphoric macro with body BODY."
  (let* ((argsym (make-symbol "ARGS"))
	 (symbolic-placeholders (-uniq (xl-anaphoric-symbols body)))
	 (number-fn (lambda (it) (s-matches-p "<[[:digit:]]>" (symbol-name it))))
	 (numbers-p (-all-p number-fn symbolic-placeholders)))
    (alet (if numbers-p
	      (-sort (lambda (it other) (string-lessp (symbol-name it) (symbol-name other)))
		     symbolic-placeholders)
	    symbolic-placeholders)
      `(lambda (&rest ,argsym)
	 (-let [,it ,argsym] ,@body)))))
#+end_src

**** defun! :extension:
:PROPERTIES:
:ID:       2e345fe9-4c03-4c81-bedf-6f40ea0b755c
:END:

=defun!= is meant to be a wrapper of and replacement for =defun=. I want a
general macro that I can use for building other "defun-like" macros such as
=defhook!= and =defadvice!=. More generally, there are patterns that are
repeated very often.

***** parser alist
:PROPERTIES:
:ID:       fa0773f5-d6be-4c9f-966f-7e8c2e68e40e
:END:

#+begin_src emacs-lisp
(defvar defun-macro%handler-alist nil)
#+end_src

***** process clauses
:PROPERTIES:
:ID:       ca8193b2-54dd-4637-90bb-670e0b5ad8f8
:END:

#+begin_src emacs-lisp
(defun defun-macro%process-clauses (alist state)
  "Return the form generated by ALIST."
  (-let* ((((name . args)) alist)
	  (fn (or (alist-get name defun-macro%handler-alist) #'ignore))
	  (rest (cdr alist)))
    (funcall fn name args rest state)))
#+end_src

***** defun!
:PROPERTIES:
:ID:       3ad5b063-3bb4-4a90-b875-f154a13dd7a6
:END:

#+begin_src emacs-lisp
(defmacro defun! (name args &rest body)
  "Extensible macro builder that is a variant of `defun'."
  (declare (indent defun) (doc-string 3))
  (let* ((docstring (when (stringp (car body)) (pop body)))
	 (alist (loopy (while (keywordp (ignore-errors (caar body)))) (collect (pop body))))
	 (state (a-list 'name name 'args args 'docstring docstring 'body body)))
    (macroexp-progn (defun-macro%process-clauses alist state))))
#+end_src

***** parsers
:PROPERTIES:
:ID:       3c3233ab-1cf2-47d5-bbad-d7e71bbc13aa
:END:

****** parse-hook
:PROPERTIES:
:ID:       f7c0897d-79da-4e73-8ba7-ac5bdedacbfb
:END:

#+begin_src emacs-lisp
(add-to-list 'defun-macro%handler-alist '(:hook . defun-macro%handle-hook))

(defun defun-macro%handle-hook (_ args rest state)
  "Generate code to define an xl hook."
  (let-alist state
    (loopy (with (orig-name (xl-intern-format "xl--%s-hook" .name))
		 ((hooks plist) (-split-with (-not #'keywordp) args))
		 ((&plist :append :depth :local) plist))
	   (for symbol hooks)
	   (expr hook (xl-symbol-intern symbol '& .name))
	   (collect `(defalias ',hook ',orig-name))
	   (collect `(add-hook ',symbol ',hook ,(or append depth) ,local))
	   (collect `(xl-log-function ',hook))
	   (finally-return `((defun ,orig-name ,.args ,.docstring ,@.body)
			     ,@loopy-result)))))
#+end_src

****** parse advice
:PROPERTIES:
:ID:       fbff4b81-3a11-42df-a61f-42e6c5771734
:END:

#+begin_src emacs-lisp
(iter (for type '(:override :around :before :after :after-while))
      (add-to-list 'defun-macro%handler-alist (cons type 'defun-macro%handle-advice)))

(defun defun-macro%handle-advice (where args rest state)
  (let-alist state
    (loopy (with (orig-advice (xl-intern-format "xl--%s-advice" .name))
		 ((functions plist) (-split-with (-not #'keywordp) args))
		 (props (plist-get :props plist)))
	   (for fn functions)
	   (expr advice (xl-advice-gen-symbol fn .name))
	   (collect `(defalias ',advice ',orig-advice))
	   (collect `(advice-add #',fn ,where #',advice))
	   (collect `(xl-log-function #',advice))
	   (finally-return `((defun ,orig-advice ,.args ,.docstring ,@.body)
			     ,@loopy-result
			     ,@(defun-macro%process-clauses rest state))))))
#+end_src

****** parse generic advice
:PROPERTIES:
:ID:       73f153c5-b005-41c1-bc35-3aa47b4339f1
:END:

#+begin_src emacs-lisp
(add-to-list 'defun-macro%handler-alist '(:gadvice . defun-macro%handle-gadvice))

(cl-defun defun-macro%handle-gadvice (_ bool rest state)
  (let-alist state
    (let ((generic-advice-fn (xl-intern-format "xl-gadvice-%s" .name))
	  (advice-fn (xl-intern-format "xl-gadvice--%s-advice" .name)))
      (when bool
	`((defun ,generic-advice-fn (fn) (advice-add fn :around #',advice-fn))
	  (defun ,advice-fn ,.args ,.docstring ,@.body)
	  ,@(defun-macro%process-clauses rest state))))))
#+end_src

****** parse =defafter!= :defer:
:PROPERTIES:
:ID:       76e34252-c93f-4de2-b13c-2e188cd4a476
:END:

#+begin_src emacs-lisp
(add-to-list 'defun-macro%handler-alist '(:features . defun-macro%handle-features))

(defun defun-macro%handle-features (_ features rest state)
  "Generate code to run function after features."
  (let-alist state
    (let ((after-fn (gensym (format "xl--after-%s-" .name))))
      `((after! ,features
	  (cl-defun ,after-fn ,.args ,.docstring ,@.body)
	  (funcall #',after-fn))
	,@(defun-macro%process-clauses rest state)))))
#+end_src

***** extensions
:PROPERTIES:
:ID:       1d8a1e3b-6f65-432a-9340-e1afe797c0ca
:END:

****** defgadvice!
:PROPERTIES:
:ID:       141da0b0-f721-4576-921b-7d800291267a
:END:

#+begin_src emacs-lisp
(defmacro defgadvice! (name args docstring &rest body)
  (declare (indent defun) (doc-string 3))
  `(defun! ,name ,args ,docstring (:gadvice t) ,@body))
#+end_src

****** defafter! :defer:
:PROPERTIES:
:ID:       b6179567-c840-4dfa-891e-3e27384dfdb9
:END:

#+begin_src emacs-lisp
(defmacro defafter! (name args &rest body)
  (declare (indent defun) (doc-string 3))
  (let ((docstring (when (stringp (car body)) (pop body))))
    `(defun! ,name () ,@(when docstring (list docstring))
       (:features ,@args)
       ,@body)))
#+end_src

*** anaphora :anaphora:
:PROPERTIES:
:ID:       9938b1e1-6c6e-4a45-a85e-1a7f2d0bf6df
:END:

Anaphora refers to the ability to refer to. I have decided it is best to use
=<>= to denote the symbol referred to by anaphoric macros because it is easy to
type (assuming parentheses completion), because such a symbol uncommon in lisp.
A key advantage to this is that there is a consistent "syntax" for anaphoric
variables as opposed to using =it=. A consequence of this is that you have more
flexibility to name variables. Additionally, I like that it looks like a slot or
placeholder.

https://en.wikipedia.org/wiki/Anaphoric_macro

**** anaphoric symbol regexp :anaphora:core:library:emacs:config:
:PROPERTIES:
:ID:       40c97bd5-dab1-44df-86f7-90274d5a8ea0
:END:

#+begin_src emacs-lisp
(defconst XL-ANAPHORIC-SYMBOL-REGEXP
  (eval-when-compile (rx "<" (group (zero-or-more (not (any white ">" "<")))) ">"))
  "Regular expression that matches an anaphoric symbol.")
#+end_src

**** anaphoric symbol :anaphora:core:library:
:PROPERTIES:
:ID:       db8169ba-1630-42fe-9ab7-e29c110a18c3
:END:

#+begin_src emacs-lisp
(defun xl-anaphoric-symbol-p (obj)
  "Return non-nil if OBJ is an anaphoric symbol."
  (and (symbolp obj)
       (string-match-p XL-ANAPHORIC-SYMBOL-REGEXP (symbol-name obj))))
#+end_src

**** true anaphora name :anaphora:
:PROPERTIES:
:ID:       2833cd75-9c85-4c0e-9523-4489d387150a
:END:

#+begin_src emacs-lisp
(defun xl-anaphoric-true-symbol (symbol)
  "Return the symbol that corresponds to the anaphoric symbol."
  (save-match-data
    (string-match XL-ANAPHORIC-SYMBOL-REGEXP (symbol-name symbol))
    (intern (match-string 1 (symbol-name symbol)))))
#+end_src

**** take symbol and return anaphoric symbol :anaphora:
:PROPERTIES:
:ID:       4b89588e-f3c3-49d3-8851-fdd214cee563
:END:

#+begin_src emacs-lisp
(defun xl-anaphoric-symbol (symbol)
  "Return anaphoric form of symbol."
  (xl-symbol-intern '< symbol '>))
#+end_src

**** body symbols :anaphora:
:PROPERTIES:
:ID:       2bae458e-404a-48e7-b57e-ce7f543f6e6d
:END:

#+begin_src emacs-lisp
(defun xl-anaphoric-symbols (body)
  "Return all the anaphoric symbols in body."
  (->> (-flatten body)
       (-filter #'xl-anaphoric-symbol-p)
       (-uniq)))
#+end_src

**** all anaphoric symbols in obj :anaphora:
:PROPERTIES:
:ID:       e0c0eb8c-52b3-4411-ab0b-06255490dacf
:END:

#+begin_src emacs-lisp
(defun xl-anaphoric-symbols-in-obj (obj)
  "Return a list of anaphoric symbols in OBJ."
  (s-match-strings-all XL-ANAPHORIC-SYMBOL-REGEXP (xl-to-string obj)))
#+end_src

*** generate a logging function
:PROPERTIES:
:ID:       08fe76f4-fd35-45fd-9fbe-1bd21c7c5233
:END:

#+begin_src emacs-lisp
(defun xl-log-function (fn)
  "Log a function."
  (let ((name (xl-advice-gen-symbol fn 'log)))
    (pcase fn
      ((pred xl-advice-symbol-p)
       (let ((symbol (xl-advice-orig-symbol fn))
	     (function (xl-advice-orig-function fn)))
	 (fset name `(lambda (&rest _) (xl-log "@ %s -> %s" ',symbol ',function)))
	 (advice-add fn :after name)))
      ((pred xl-hook-symbol-p)
       (let ((symbol (xl-hook-orig-symbol fn))
	     (function (xl-hook-orig-function fn)))
	 (fset name `(lambda (&rest _) (xl-log "& %s -> %s" ',symbol ',function)))
	 (advice-add fn :after name)))
      (_
       nil))))
#+end_src

*** advice :advice:
:PROPERTIES:
:ID:       e498fc7d-03f1-4a69-9869-28c1b499fe1f
:END:

**** advice regexp
:PROPERTIES:
:ID:       22a4ff2c-27b7-4938-802f-5b669caa3f12
:END:

#+begin_src emacs-lisp
(defconst XL-ADVICE-REGEXP "\\([^[:space:]]+\\)@\\([^[:space:]]+\\)"
  "A regular expression that defines naming convention for advices.")
#+end_src

**** remove XL advice
:PROPERTIES:
:ID:       3d13ea95-44aa-4261-8480-5ae9701d533d
:END:

Since we can get the advisee from the advise name, or remove advice only needs
one argument--the advice to remove.

#+begin_src emacs-lisp
(defun xl-advice-remove (advices)
  "Remove ADVICES from the functions they advise.
ADVICES is an advice or a list of advices."
  (iter (each advice (-list advices))
	(advice-remove (xl-advice-orig-symbol advice) advice)))
#+end_src

**** adding an advice
:PROPERTIES:
:ID:       14e23074-10ea-41cc-88e5-bac600658b20
:END:

#+begin_src emacs-lisp
(defun xl-advice-add (symbols where functions &optional props)
  "Add ADVICES to FUNCTIONS.
WHERE, DEPTH and LOCAL are the same as in `advice-add'."
  (iter (each symbol (-list symbols))
	(subloop (each function (-list functions))
		 (expr advice (xl-symbol-intern symbol '@ function))
		 (fset advice function)
		 (advice-add symbol where advice props)
		 (collect advice))))
#+end_src

**** advice-fn-p
:PROPERTIES:
:ID:       0ee2c179-39e9-4faa-8952-9440cfa46bca
:END:

#+begin_src emacs-lisp
(defun xl-advice-symbol-p (fn)
  "Return non-nil when FN is an advice."
  (s-matches-p XL-ADVICE-REGEXP (symbol-name fn)))
#+end_src

**** original fn
:PROPERTIES:
:ID:       eb5e771f-243b-4645-8be7-59fe2dcf1978
:END:

#+begin_src emacs-lisp
(defun xl-advice-orig-symbol (advice)
  "Return the function ADVICE is advised to.
ADVICE is an advice function that follows XL naming conventions."
  (intern (nth 1 (s-match XL-ADVICE-REGEXP (symbol-name advice)))))
#+end_src

**** original advice
:PROPERTIES:
:ID:       49f49994-637a-4e26-b680-3535463ee8bf
:END:

#+begin_src emacs-lisp
(defun xl-advice-orig-function (advice)
  "Return the function that ADVICE aliases.
ADVICE is an advice function that follows XL naming conventions."
  (intern (nth 2 (s-match XL-ADVICE-REGEXP (symbol-name advice)))))
#+end_src

**** gen symbol
:PROPERTIES:
:ID:       54e52ec5-c20f-48a3-abd7-13a695a45e75
:END:

#+begin_src emacs-lisp
(defun xl-advice-gen-symbol (symbol name)
  (xl-symbol-intern symbol '@ name))
#+end_src

**** generic advices
:PROPERTIES:
:ID:       ba195f61-9b1c-4b51-835c-d1351f4d6301
:END:

***** pause garbarge collection :advice:performance:
:PROPERTIES:
:ID:       41e763bd-215f-4176-95c1-f41261864671
:END:

Sometimes you come across a function that is computationally expensive. An
example is [[helpfn:helm-system-packages][helm-system-packages]], function that has to make a list of all system
packages which can contain several thousand items.

#+begin_src emacs-lisp
(defgadvice! pause-garbage-collection (orig-fn &rest args)
  "An around advice that pauses `gc-cons-threshold'."
  (let ((gc-cons-threshold most-positive-fixnum))
    (apply orig-fn args)))
#+end_src

***** catch errors
:PROPERTIES:
:ID:       3ac98fde-fe86-4221-abc7-d8bdfee4a58b
:END:

One important note here. I first wrote [[helpfn:xl-report-error-advice][xl-report-error-advice]] as an around
advice that should be added to functions. The problem here is that sometimes I
advise compiled functions; and when I do, the variable =orig-fn= is bound to a
compiled function instead of a symbol. This is why this function has to
pre-emptively insert FN. A similar situation occurs with [[][generic expiring
advice]].

#+begin_src emacs-lisp
(defgadvice! catch-error (orig-fn &rest args)
  "Catch and log any error."
  (condition-case error
      (apply orig-fn args)
    (error
     (xl-log "Failed calling %s because %s" orig-fn (error-message-string error)))))
#+end_src

***** log
:PROPERTIES:
:ID:       25ea174f-af84-49e3-ad13-c797ef4ee6b2
:END:

#+begin_src emacs-lisp
(defgadvice! log (fn &rest args)
  (prog1 (apply fn args)
    (cond ((not (symbolp fn))
	   (xl-log "function is not a symbol: %S" fn))
	  ((xl-hook-symbol-p fn)
	   (xl-log "& %s -> %s" (xl-hook-orig-symbol fn) (xl-hook-action fn)))
	  ((xl-advice-symbol-p fn)
	   (xl-log "@ %s -> %s" (xl-advice-orig-function fn) (xl-advice-orig-function fn)))
	  (t
	   (xl-log "%s called" fn)))))
#+end_src

***** silence :gadvice:advice:library:core:
:PROPERTIES:
:ID:       7eddba70-8597-4af7-bc93-6ebdcc06ee6c
:END:

Many packages output to the messages buffer. Often, I either find these messages
unecessary or, as an experienced user, I get it already. In these cases I prefer
to silence the said messages.

#+begin_src emacs-lisp
(defgadvice! shut-up (orig-fn &rest args)
  "Silence output of FN."
  (shut-up (apply orig-fn args)))
#+end_src

***** assume yes in prompts :setting:
:PROPERTIES:
:ID:       82960e31-b0c5-4b79-8ac4-508629bd63a4
:END:

Once in a while I come across a function that a [[helpfn:y-or-n-p][y-or-n-p]] prompt for things I
don't want to be prompted for. Or, in other words, for me the cost of the extra
second I spend typing =y= or =n= is not worth the benefit ([[helpfn:ert-delete-all-tests][ert-delete-all-tests]]
is an example).

#+begin_src emacs-lisp
(defgadvice! assume-yes (orig-fn &rest args)
  "An advice that makes `y-or-n-p' return t without prompt."
  (noflet ((y-or-n-p (prompt) t))
    (apply orig-fn args)))
#+end_src

***** log
:PROPERTIES:
:ID:       843d4ca9-ea52-46ea-9d77-bfd9e7222669
:END:

Sometimes I want to use =xl-log= instead of =message=.

#+begin_src emacs-lisp
(defgadvice! use-xl-log (orig-fn &rest args)
  (noflet ((message (&rest message-args) (apply #'xl-log message-args)))
    (apply orig-fn args)))
#+end_src

***** log advices and hooks
:PROPERTIES:
:ID:       8c34086d-67b8-4b7d-a52c-24c4090a73c9
:END:

Log when an advice or hook is being called.

#+begin_src emacs-lisp
(defun! log-advices (orig-fn &rest args)
  "Log ORIG-FN."
  (:around xl-hook-add xl-advice-add)
  (iter (with (symbols (apply orig-fn args)))
	(each symbol symbols)
	(xl-log-function symbol)
	(when (xl-hook-symbol-p symbol)
	  (xl-gadvice-catch-error symbol))
	(finally-return symbols)))
#+end_src

***** loading on call
:PROPERTIES:
:ID:       fa6583aa-5e7c-4212-be8a-b90b4c08aa31
:END:

Instead of loading all features on startup, we want to load features only when
we need them--just in time. And by "just in time" I mean at the last possible
moment or in practice just before a function that uses this feature is called.
While I could use =defadvice!= for defining these advices, doing this would
quickly become repetative because it's something that is done so often in
package configuration. The function =before-call= and =after-call= provide a fast
and convenient way to do this.

****** load-on-call
:PROPERTIES:
:ID:       324e707b-2f44-4168-a846-037f5401dedb
:END:

This is the internal function which I use to build the others. It loads a
package before or after (you specify) a particular function is called. To do
this it adds an =XL= advice that loads the feature to the function.

#+begin_src emacs-lisp
(defun xl-load-on-call (package where fn)
  "Load PACKAGE before or after FN is called."
  (alet (xl-intern-format "%s@load-%s-%s-call" fn package (xl-keyword-name where))
    (fset it `(lambda (&rest _)
                (xl-log "load %s" ',package)
                (require ',package)))
    (advice-add fn where it)
    (xl-gadvice-expire it)))
#+end_src

****** load before call
:PROPERTIES:
:ID:       cc0e92bc-cd6d-4994-82ea-eb065fc3ad89
:END:

For convenience, I provide [[helpfn:xl-load-before-call][xl-load-before-call]] and [[helpfn:xl-load-after-call][xl-load-after-call]]. It's nice
not to have to specify the advice keyword.

#+begin_src emacs-lisp
(defun xl-load-before-call (package fn)
  "Load PACKAGE before FN is called."
  (xl-load-on-call package :before fn))
#+end_src

****** load after call
:PROPERTIES:
:ID:       b0b294d0-15ac-42d9-9e4c-fd9da8a95206
:END:

#+begin_src emacs-lisp
(defun xl-load-after-call (package fn)
  "Load PACKAGE after FN is called."
  (xl-load-on-call package :after fn))
#+end_src

***** ignore output
:PROPERTIES:
:ID:       5053afcc-7a44-44d4-80b6-f42c3ea87926
:END:

#+begin_src emacs-lisp
(defgadvice! ignore (&rest _)
  "Advice to ignore a function.")
#+end_src

***** expiration
:PROPERTIES:
:ID:       b531dc79-73d0-43eb-a600-b3075315acf0
:END:

#+begin_src emacs-lisp
(defun xl-gadvice-expire (fn)
  "Cause FN to remove itself from any advice or hook."
  (let ((name (xl-advice-gen-symbol fn 'expire)))
    (pcase fn
      ((pred xl-advice-symbol-p)
       (fset name `(lambda (&rest _) (xl-advice-remove ',fn)))
       (advice-add fn :after name))
      ((pred xl-hook-symbol-p)
       (fset name `(lambda (&rest _) (xl-hook-remove ',fn)))
       (advice-add fn :after name))
      (_
       nil))))
#+end_src

*** hook :hook:
:PROPERTIES:
:ID:       8715c910-76df-41b7-873d-9b1a6a22350f
:END:

**** hook regexp
:PROPERTIES:
:ID:       5093d6ce-741d-4d11-8ac7-15c02aa45b3b
:END:

#+begin_src emacs-lisp
(defconst XL-HOOK-REGEXP "\\`\\(.+\\)&\\(.+\\)\\'"
  "Regular expression used to match `xl-' defined hooks.")
#+end_src

**** add hook
:PROPERTIES:
:ID:       e8d69a71-bab4-4e75-b8f8-33426200a0df
:END:

#+begin_src emacs-lisp
(defun xl-hook-add (symbols functions &optional depth local)
  "Alias FUNCTIONS to follow XL naming convention and add them to SYMBOLS."
  (iter (each symbol (-list symbols))
	(subloop (each function (-list functions))
		 (expr hook (xl-symbol-intern symbol '& function))
		 (fset hook function)
		 (add-hook symbol hook depth local)
		 (collect hook))))
#+end_src

**** remove hook
:PROPERTIES:
:ID:       e8ec61e0-a819-452c-8fb2-bf3023684b53
:END:

#+begin_src emacs-lisp
(defun xl-hook-remove (&rest hooks)
  "Remove HOOKS from their correponding symbols.
HOOKS is a list of hook functions that follow the XL naming convention."
  (iter (each hook hooks)
	(remove-hook (xl-hook-orig-symbol hook) hook)))
#+end_src

**** hook function
:PROPERTIES:
:ID:       d5ed128c-32a0-4387-a1e5-b4536ed86c95
:END:

#+begin_src emacs-lisp
(defun xl-hook-symbol-p (symbol)
  "Return non-nil if SYMBOL is defined with XL naming conventions."
  (s-match XL-HOOK-REGEXP (symbol-name symbol)))
#+end_src

**** original hook variable
:PROPERTIES:
:ID:       8788ec0c-2ab2-4fb3-b383-55d6ee533e8d
:END:

#+begin_src emacs-lisp
(defun xl-hook-orig-symbol (hook)
  "Return hook variable for HOOK.
HOOK is a hook function defined with XL naming conventions."
  (intern (nth 1 (xl-hook-symbol-p hook))))
#+end_src

**** original hook function
:PROPERTIES:
:ID:       640d7e5d-d3a7-43be-94df-0fb9c02201d9
:END:

#+begin_src emacs-lisp
(defun xl-hook-orig-function (hook)
  "Return the hook function for HOOK.
HOOK is a hook function that follows XL naming conventions."
  (intern (nth 2 (xl-hook-symbol-p hook))))
#+end_src

**** generate hook name
:PROPERTIES:
:ID:       dda7e704-4aa2-48fe-8cde-427d340d23aa
:END:

#+begin_src emacs-lisp
(defun xl-hook-gen-name (fn name)
  "Generate a hook name."
  (xl-symbol-intern fn '& name))
#+end_src

*** idle-require
:PROPERTIES:
:ID:       751b309f-aafc-4d11-ae0c-4d423713b52d
:END:

**** idle-require :defer:
:PROPERTIES:
:ID:       0d619336-e852-4c6a-89a8-38ccbb71a077
:END:

Idle require is a tool for loading autoload functions, files or features during
idle time. The way to use this is to idle-require many small packages that
individually don't take too much time. This helps ensure that in emacs loading
of big packages like org-mode is snappy.

When emacs goes idle for [[helpvar:idle-require-idle-delay][idle-require-idle-delay]] seconds, the features will
start loading. [[helpvar:idle-require-load-break][idle-require-load-break]] is the break between features idle
require loads.

=idle-require= messages us to tell us when a package is being idle required and
when it has finished idle-requiring packages. I don't want to see the message
unless I'm debugging.

Since we're evaluating a good amount of lisp expressions, we should boost
garbage collection during this time.

#+begin_src emacs-lisp
(use-package idle-require
  :demand t
  ;; :xl-use-xl-log idle-require-mode idle-require-load-next
  :gc-pause idle-require-load-next
  :set
  (idle-require-load-break . 2)
  (idle-require-idle-delay . 10))
#+end_src

**** idle-require :defer:performance:
:PROPERTIES:
:ID:       916f88bd-10e1-4030-a1d9-e42baf095492
:END:

This keyword integrates with [[0d619336-e852-4c6a-89a8-38ccbb71a077][idle-require]]. It can accept a boolean.

#+begin_src emacs-lisp
(use-package%dwim-insert :idle-require)

(defun use-package-normalize/:idle-require (package _ args)
  "Ensure each elements in ARGS is a symbol.
If an element is t, convert it to PACKAGE."
  (loopy (list symbol args)
	 (unless (symbolp symbol) (do (error "This key doesn't have this.")))
	 (collect (if (eq t symbol) package symbol))))

(defun use-package-handler/:idle-require (name _ features rest state)
  "Generate forms that `idle-require' FEATURES."
  `(,@(loopy (list feature features)
	     (collect `(idle-require ',feature nil t)))
    ,@(use-package-process-keywords name rest state)))
#+end_src

*** create additional hooks
:PROPERTIES:
:ID:       a88d6a5b-5b72-446d-a1ba-0ee153c26e0d
:END:

**** DOC loading theme :theme:
:PROPERTIES:
:ID:       b4773208-5e96-46d2-90d0-1731f6581f1b
:END:

Sometimes there are things that need tidying up after loading a theme. For
example, if I'm using evil I need to update the cursor color.

#+begin_src emacs-lisp
(defvar xl-after-load-theme-hook nil
  "Hook run after the theme is loaded with `load-theme'.")

(defadvice! run-after-load-theme-hook (:after load-theme)
  "Set up `xl-load-theme-hook' to run after `load-theme' is called."
  (run-hooks 'xl-after-load-theme-hook))
#+end_src

** keybinding :bind:
:PROPERTIES:
:ID:       b627fcf8-2f72-41a6-9ebe-08ff6c29fb54
:END:

The goal is to efficiently setup the bindings we need to use Emacs. It's
important to remember that not matter how powerful the commands you have, if you
don't invest the time into binding them to useful keys you'll be very
inefficient, having to press =M-x= between any non built-in command. Its
important to bind them and to do it in an organized way so you can always find
the bindings you need when you need it.

*** leaders
:PROPERTIES:
:ID:       1e4dac95-9c16-41db-9f99-63a250b447c2
:END:

The way I organize my keys is via leader keys. The leader will be the root of a
keybinding tree. And once you know the leader, you can "discover" the other
bindings as you need to. You can see the concept of the leader used in Emacs
distributions such as [[https://github.com/syl20bnr/spacemacs][Spacemacs]] and [[https://github.com/hlissner/doom-emacs][Doom Emacs]].

**** evil leaders :evil:
:PROPERTIES:
:ID:       47c4c3c5-3859-46a4-a4ef-3d27c552eec0
:END:

These leaders are specifically for evil mode states (not including insert and
Emacs). I choose the space (=SPC=) key for evil leaders because it is one of if
not the easiest key to press because of its central placement on the keyboard
and its sheer size--at least on the [[https://en.wikipedia.org/wiki/QWERTY][qwerty]] keyboard that I use. The choice
of =SPC m= for the major mode specific keys is simply for the pnemonic =m= which
stands for "major mode". The short major mode prefix key =,= is for cases when I
want to shorten a key binding. Although obviously not as easy to remember as
=m=, it provides me with one shorter keypress in certain situations.

#+begin_src emacs-lisp
(defconst XL-EVIL-LEADER-KEY "SPC"
  "The evil leader prefix key.")

(defconst XL-EVIL-LOCALLEADER-KEY "SPC m"
  "The localleader prefix key for major-mode specific commands.")

(defconst XL-EVIL-LOCALLEADER-SHORT-KEY ","
  "A shorter alternative `xl-localleader-key'.")
#+end_src

**** emacs leaders
:PROPERTIES:
:ID:       f3299c73-837e-46f9-a29e-9932c4570858
:END:

These leaders are for evil insert and emacs states as well as vanilla
Emacs. Note that evil Emacs state is different from vanilla Emacs. One of the
goals with these bindings is to set up keybindings in the case that I disable
evil mode or in the case that I want to use my bindings in insert or Emacs
state--or even vanilla Emacs. The choice behind the bindings is the same as
[[id:][before]], except I just prepended the =Meta= (a.k.a. the =Alt= key) to everything.

#+begin_src emacs-lisp
(defconst XL-EMACS-LEADER-KEY "M-SPC"
  "The leader prefix key used for Insert and Emacs states.")

(defconst XL-EMACS-LOCALLEADER-KEY "M-SPC m"
  "The localleader prefix key for major-mode specific commands.")

(defconst XL-EMACS-LOCALLEADER-SHORT-KEY "M-,"
  "A short non-normal  `xl-localleader-key'.")
#+end_src

*** prefix commands
:PROPERTIES:
:ID:       2cf36d16-eafc-46d8-8b19-e1eb02d39c0d
:END:

A quote from [[https://github.com/hlissner/doom-emacs/blob/develop/core/core-keybinds.el#L182][Doom Emacs]]:

We use a prefix commands instead of general's :prefix/:non-normal-prefix
properties because general is incredibly slow binding keys en mass with them in
conjunction with :states -- an effective doubling of Doom's startup time!

#+begin_src emacs-lisp
(defvar xl-leader-map (make-sparse-keymap))

(define-prefix-command 'xl/leader 'xl-leader-map)
#+end_src

*** bind! :extension:
:PROPERTIES:
:ID:       b6f3d4bc-b4e3-4e0d-a8db-4654f8dfe5ca
:END:

This headline is concerned with the definition of =bind!=, a general purpose
mapping macro similar to [[https://github.com/hlissner/doom-emacs/blob/develop/core/core-keybinds.el][doom's map macro]], [[https://github.com/justbur/emacs-bind-map][bind-map]], and [[https://github.com/priyadarshan/bind-key][bind]] used in
use-package (of these though it is most similar to doom's macro). The purpose is
to provide a versatile, non-repetative, and extensible syntax that does what I
mean. Overall I want to abstract the act of keybinding and to not concern myself
with the automatable (not a word probably) details of binding keys.

**** evil key to states :evil:
:PROPERTIES:
:ID:       672841ed-1c4b-4351-ac68-e7107cc0bea2
:END:

I want to specify evil states via keywords just like Doom Emacs's =map!=
macro. So, for example =:nm= in front of a binding would mean the binding should
be bound in =normal= and =motion= state. The reason for doing this is that (1)
it is more concise than naming the actual states and (2) it allows us to specify
bindings of different states in the same form as opposed to [[helpfn:evil-define-key*][evil-define-key*]].

#+begin_src emacs-lisp
(defun xl-bind%evil-keyword-to-states (evil-keyword)
  "Return list of evil states specified by EVIL-KEYWORD.
EVIL-KEYWORD is a keyword whose letters correspond to the first letters of evil
states (e.g. :i \"i\" would correspond to \"insert\" state).
If any letter in EVIL-KEYWORD does not correspond to an evil state, return nil."
  (loopy (with (evil-states '(normal visual emacs insert operator motion)))
	 (seq char (seq-uniq (xl-keyword-name evil-keyword)))
	 (expr state (--first (->> (symbol-name it)
				   (seq-first)
				   (char-equal char))
			      evil-states))
	 (unless state (return nil))
	 (collect state)))
#+end_src

**** deferring keymaps
:PROPERTIES:
:ID:       76200d2b-839d-4111-863a-08021e18c7e4
:END:

As it stands =define-key= and friends raise an error if the keymap you specified
has not been defined. We want the =bind!= macro to do what we mean: if a key's
keymap is not defined, then bind the key when it is.

***** deferred binding forms
:PROPERTIES:
:ID:       e03e1a47-41d1-4dd8-9f1a-8151de76da2a
:END:

To do this, the first step is creating a variable that will store the binding
forms that need to be evaluated when a keymap is loaded.

#+begin_src emacs-lisp
(defvar xl-bind%deferred-bindings nil
  "Alist of deferred bindings.
Each element is of the form (KEYMAP . BINDING-FORMS).
KEYMAP is a keymap that has not yet been bound. BINDING-FORMS are the forms to
be evaluated when KEYMAP is bound.")
#+end_src

***** updating deferred bindings
:PROPERTIES:
:ID:       fa345a49-e002-4efd-ba68-5f533d42aebb
:END:

This hook will traverse the alist of deferred bindings, checking to see whether
a keymap in the alist is bound. If it is we evaluate its corresponding forms.

#+begin_src emacs-lisp
(defun xl-bind%update-deferred-bindings (deferred-bindings)
  "Evaluate bindings whose keymap now exist.
Return any keymaps whose keymaps still don't exist."
  (iter (each (elt &as keymap . forms) deferred-bindings)
	(cond ((boundp keymap)
	       (xl-log "bind %s keys" keymap)
	       (funcall `(lambda () (progn ,@forms))))
	      (t
	       (collect elt)))))
#+end_src

***** hook for deferred bindings
:PROPERTIES:
:ID:       a95d82f1-9614-4ec5-a2e5-a2f29f514e2b
:END:

We also need to add a hook to [[helpfn:after-load-functions][after-load-functions]]. The hook
=after-load-functions= is abnormal because it does not end in =-hook=. It is run
after any file is loaded. We put use this hook so we can be sure to catch any
new keymaps.

#+begin_src emacs-lisp
(defhook! eval-deferred-bindings (after-load-functions)
  "Evaluate deferred bindings whose keymap is now bound."
  (cl-callf xl-bind%update-deferred-bindings xl-bind%deferred-bindings))
#+end_src

***** with-deferred-keymap!
:PROPERTIES:
:ID:       ddb17e5c-74e8-445e-b659-cf94f4831a46
:END:

The final touch is to create a macro that evaluates its body only if a specified
keymap is already bound. If the keymap is not bound then it simply updates
[[helpvar:xl-bind%deferred-bindings][xl-bind:deferred-bindings]]. I wrap every individual binding with this form.

#+begin_src emacs-lisp
(defmacro with-deferred-map! (map &rest forms)
  "Defer the evaluation of FORMS until MAP is loaded.
If MAP is already loaded, evaluate forms immediately."
  (declare (indent defun))
  (pcase map
    ((or (pred boundp) 'local-map 'global-map)
     `(progn ,@forms))
    (_
     `(cl-callf a-update xl-bind%deferred-bindings ',map #'append ',forms))))
#+end_src

**** read a clause
:PROPERTIES:
:ID:       255730df-5715-4808-8a7d-6c37bd1333e5
:END:

#+begin_src emacs-lisp
(defun xl-bind%read-clause (clauses)
  "Return CLAUSES."
  (loopy (with (clauses (--splice (listp (car it)) (xl-bind%read-clause it) clauses)))
	 (list clause clauses)
	 (cond ((or (xl-bind%binding-p clause)
		    (xl-bind%binding-p (-butlast clause)))
		(collect bindings clause))
	       (t
		(append common-args clause)))
	 (finally-return (-map (-partial #'append common-args) bindings))))
#+end_src

**** whether is a binding
:PROPERTIES:
:ID:       743e3fdb-fb0c-44ba-a5e9-7282b20cfdcc
:END:

#+begin_src emacs-lisp
(defun xl-bind%binding-p (clause)
  "Return non-nil if CLAUSE contains a keybinding."
  (pcase (-take-last 2 clause)
    (`(,(or (pred stringp) (pred vectorp) (pred symbolp)) ,(pred xl-quoted-p)) t)
    (_ nil)))
#+end_src

**** normalization
:PROPERTIES:
:ID:       56abc5a3-bcf7-4943-a941-939e16d46dea
:END:

The purpose of normalization is to make the clauses homogenous and into a form
that is easily.

***** fix the keybinding
:PROPERTIES:
:ID:       0202c1a2-75a3-45ac-a226-8b6b906d96ac
:END:

This means that the keybinding should always be last.

#+begin_src emacs-lisp
(defun xl-bind%normalize-keybinding (clause)
  "Return clause with proper keybinding."
  (append (-drop-last 2 clause)
	  (-interleave '(:key :def) (-take-last 2 clause))))
#+end_src

***** fix the evil state :evil:
:PROPERTIES:
:ID:       1a8f4cf8-1013-4e0c-8fd1-21b69c2e6b8b
:END:

#+begin_src emacs-lisp
(defun xl-bind%normalize-evil-state (clause)
  "Return clause with proper evil-state."
  (pcase (-take-last 5 clause)
    (`(,(and (pred keywordp) ekey) :key ,_ :def ,_) t
     `(,@(-drop-last 5 clause) :states ,(xl-bind%evil-keyword-to-states ekey)
       ,@(-take-last 4 clause)))
    (_ clause)))
#+end_src

***** flatten plist values
:PROPERTIES:
:ID:       6be10885-4bbe-47e2-bd47-0c14f51b9065
:END:

Remember, that the goal of normalization is to end up with a list of plists with.

#+begin_src emacs-lisp
(defun xl-bind%flatten-plist-values (plist)
  "Expand clause."
  (loopy (cons (key val . rest) plist #'cddr)
	 (cond ((or (atom val) (xl-quoted-p val))
		(append new (list key val)))
	       ((= 1 (length val))
		(append new (list key (car val))))
	       (t
		(expr tails (xl-bind%flatten-plist-values `(,key ,(cdr val) ,@rest)))
		(subloop (list tail tails)
			 (collect flattened (append new tail)))
		(append new (list key (car val)))))
	 (finally-return (cons new flattened))))
#+end_src

***** make clause into proper plist
:PROPERTIES:
:ID:       e836329e-c2b9-4978-a3d7-9ba32c160f04
:END:

#+begin_src emacs-lisp
(defun xl-bind%make-proper-plist (list)
  "Ensure every key in LIST has only one value."
  (loopy (with (list `(,@list :done)))
	 (while list)
	 (expr elt (pop list))
	 (expr next (car list))
	 (cond ((keywordp elt)
		(expr key elt))
	       (t
		(collect values elt)))
	 (when (keywordp next)
	   (append plist (list key (xl-dwim-single values)))
	   (expr values nil))
	 (finally-return plist)))
#+end_src

***** merge multiple plist values
:PROPERTIES:
:ID:       d50cb073-54c0-4b96-8df1-2ae195ac4651
:END:

#+begin_src emacs-lisp
(defun xl-bind%merge-duplicate-plist-keys (plist)
  "Merge duplicate keys in PLIST."
  (iter (conses (key val . _) plist #'cddr)
	(cond ((assoc key alist)
	       (expr var (alist-get key alist))
	       (set var (append (symbol-value var) (list val))))
	      (t
	       (expr var (gensym (symbol-name key)))
	       (set var (list val))
	       (collect alist (cons key var))))
	(fret (loopy (list (key . var) alist)
		     (append (list key (xl-dwim-single (symbol-value var))))))))
#+end_src

***** normalize the list
:PROPERTIES:
:ID:       377bcdf9-3798-4dff-83e5-13f3a59e112e
:END:

#+begin_src emacs-lisp
(defun xl-bind%normalize-plist (plist)
  "Return the list normalized."
  (loopy (while plist)
	 (expr key (pop plist))
	 (expr values (loopy (while (and plist (not (keywordp (car plist)))))
			     (collect (pop plist))))
	 (expr alist (a-update alist key #'append (list values)))
	 (finally-return alist)))
#+end_src

***** ensure-keymap
:PROPERTIES:
:ID:       1fb99451-7b0e-4bef-b980-7f4e038dd38d
:END:

#+begin_src emacs-lisp
(defun xl-bind%ensure-keymap (token)
  (if (not (plist-get token :map))
      `(:map global-map ,@token)
    token))
#+end_src

***** apply-prefix
:PROPERTIES:
:ID:       5c1aa062-8660-453b-ba8e-04610bec043a
:END:

#+begin_src emacs-lisp
(defun xl-bind%apply-prefix (token)
  (-let [(&plist :prefix :key) token]
    (if (and prefix key (stringp key))
	`(:key ,(concat prefix "\s" key) ,@token)
      token)))
#+end_src

***** convert lists
:PROPERTIES:
:ID:       74298919-c3f2-4e7e-8377-bd8a87def771
:END:

#+begin_src emacs-lisp
(defun xl-bind%process-prefix (plist)
  (loopy (cons (key val . _) plist #'cddr)
	 (cond ((and (eq key :prefix) (listp val))
		(append (list key (s-join "\s" val))))
	       (t
		(append (list key val))))))
#+end_src

**** converting tokens to forms
:PROPERTIES:
:ID:       aade9ecc-ee16-407d-a451-03da731daeb2
:END:

This section is about actually converting define key clauses that have already
been parsed and processed into lisp forms that actually correspond to
bindings. The design of this step follows a =use-package=.

***** convert logic
:PROPERTIES:
:ID:       9c779428-a8b5-4e2c-b3d3-c369f7f161b0
:END:

What list of converters should be used to edit the token depends on the token
itself. Some converters imply not using others. Some should only be used in
certain circumstances.

#+begin_src emacs-lisp
(defvar xl-bind%converters
  '((evil-which-key which-key)
    which-key
    defer-map
    kbd
    (evil-bind bind)
    bind))
#+end_src

***** decide on which converters to use
:PROPERTIES:
:ID:       09ad63c3-c438-47d2-9e4e-789bc0a4b488
:END:

Code that is split into appropriate parts is easier to read and write.

#+begin_src emacs-lisp
(defun xl-bind%converters (token)
  "Return a list of converters for TOKEN."
  (loopy (with (converters xl-bind%converters))
	 (list (name . exclude) (-map #'-list converters))
	 (expr convert-fn (xl-symbol-intern 'xl-bind%convert- name))
	 (expr pred (xl-symbol-intern 'xl-bind%predicate- name))
	 (when (and (funcall pred token) (not (member name excluded)))
	   (collect fns convert-fn)
	   (append excluded exclude))
	 (finally-return fns)))
#+end_src

***** convert token to forms
:PROPERTIES:
:ID:       10116109-b7a6-4e6e-94b2-6b41d4fc9f1f
:END:

#+begin_src emacs-lisp
(defun xl-bind%convert-token-to-forms (token converters)
  "Convert TOKEN to a list of forms."
  (-let [(converter . rest) converters]
    (funcall (or converter #'ignore) token rest)))
#+end_src

***** binding-forms
:PROPERTIES:
:ID:       31d4d497-afac-4ccf-a426-afa8f159e242
:END:

#+begin_src emacs-lisp
(defun xl-bind%binding-forms (tokens)
  "Convert BIND-TOKENS to binding forms.
Return a list of forms that binds keys specified by BIND-TOKENS."
  (loopy (list token tokens)
	 (expr converters (xl-bind%converters token))
	 (expr forms (xl-bind%convert-token-to-forms token converters))
	 (append forms)))
#+end_src

***** converting to forms
:PROPERTIES:
:ID:       7fd1a756-b8aa-41e4-8dae-7a0dfdd1e17b
:END:

****** which-key
:PROPERTIES:
:ID:       076b2b4d-7c12-4ebd-8f84-1d649487ae72
:END:

#+begin_src emacs-lisp
(defun xl-bind%predicate-which-key (token)
  "Return non-nil if TOKEN has a which-key."
  (--all-p (plist-get token it) '(:key :map :wk :prefix)))

(defun xl-bind%convert-which-key (token converters)
  "Add needed which-key form."
  (-let* (((&plist :key :map :wk :prefix) token))
    `((after! which-key
	(which-key-add-keymap-based-replacements ,map ,prefix ,wk))
      ,@(xl-bind%convert-token-to-forms token converters))))
#+end_src

****** evil which-key :evil:
:PROPERTIES:
:ID:       290cceaf-30b1-48d0-a688-b7db49728f01
:END:

The way evil works is that for an existing map (such as =org-mode-map=), it
creates an evil variant for each state. And this is the keymap that actually has
priority over original keymap when the given state is enabled. You can access
this keymap via the function [[helpfn:evil-get-auxiliary-keymap][evil-get-auxiliary-keymap]].

#+begin_src emacs-lisp
(defun xl-bind%predicate-evil-which-key (token)
  (and (xl-bind%predicate-which-key token)
       (xl-bind%predicate-evil-bind token)))

(defun xl-bind%convert-evil-which-key (token converters)
  "Return which key forms for an evil token."
  (loopy (with ((&plist :states :map :prefix :key :wk) token)
	       (rest (xl-bind%convert-token-to-forms token converters)))
	 (list state states)
	 (expr keymap `(evil-get-auxiliary-keymap ,map ',state))
	 (collect forms `(which-key-add-keymap-based-replacements ,keymap ,prefix ,wk))
	 (finally-return `((after! which-key ,@forms) ,@rest))))
#+end_src

****** evil-bind :evil:
:PROPERTIES:
:ID:       7d69d323-2eeb-4d90-88c8-cfde7f7768d3
:END:

#+begin_src emacs-lisp
(defun xl-bind%predicate-evil-bind (token)
  "Return non-nil if TOKEN."
  (and (xl-bind%predicate-bind token)
       (plist-get token :states)
       t))

(cl-defun xl-bind%convert-evil-bind (token converters)
  "Return evil binding form for TOKEN."
  (-let [(&plist :states :map :key :def) token]
    `((after! evil (evil-define-key* ',states ,map ,key ,def))
      ,@(xl-bind%convert-token-to-forms token converters))))
#+end_src

****** bind
:PROPERTIES:
:ID:       be633966-63b6-40ef-a5fe-79444218caf2
:END:

#+begin_src emacs-lisp
(defun xl-bind%predicate-bind (token)
  (-all-p (-partial #'plist-get token) '(:map :key :def)))

(defun xl-bind%convert-bind (token converters)
  "Add binding form for token."
  (-let [(&plist :prefix :map :key :def :states) token]
    `((define-key ,map ,key ,def)
      ,@(xl-bind%convert-token-to-forms token converters))))
#+end_src

****** defer binding
:PROPERTIES:
:ID:       f8892022-1921-44de-b157-7182bbcba31c
:END:

#+begin_src emacs-lisp
(defun xl-bind%predicate-defer-map (token)
  (xl-bind%predicate-bind token))

(defun xl-bind%convert-defer-map (token converters)
  `((with-deferred-map! ,(plist-get token :map)
      ,@(xl-bind%convert-token-to-forms token converters))))
#+end_src

****** kbd
:PROPERTIES:
:ID:       cdf12c08-799d-4cbc-be73-88ca77efc16f
:END:

This is the final step. The purpose of the binding tokens is to conveniently
provide the data needed about each binding so that we can write our own custom
function to generate binding forms. Obviously, this is very customizable.

#+begin_src emacs-lisp
(defun xl-bind%predicate-kbd (token)
  (and (plist-get token :kbd) (not (vectorp (plist-get token :key))) t))

(defun xl-bind%convert-kbd (token converters)
  (-let [(&plist :kbd :key) token]
    (-> (if kbd (map-insert token :key `(kbd ,key)) token)
	(xl-bind%convert-token-to-forms converters))))
#+end_src

***** localleader :evil:
:PROPERTIES:
:ID:       e83756c1-2472-4b69-8a9e-4a9328af32a7
:END:

This is a wrapper macro around =bind!= that applies. Eventually, I want to
implement this macro as a =:localleader= keyword, so I can use just one macro,
=bind!= for everything. But this was easier to implement quickly.

#+begin_src emacs-lisp
(defmacro bind-localleader! (&rest clause)
  "Apply localleader to bindings."
  `(bind!
     ((:prefix ,XL-EMACS-LOCALLEADER-KEY ,XL-EMACS-LOCALLEADER-SHORT-KEY)
      ,@clause)
     ((:prefix ,XL-EMACS-LOCALLEADER-KEY ,XL-EMACS-LOCALLEADER-SHORT-KEY)
      (:states insert emacs)
      ,@clause)
     ((:prefix ,XL-EVIL-LOCALLEADER-KEY ,XL-EVIL-LOCALLEADER-SHORT-KEY)
      (:states normal visual motion)
      ,@clause)))
#+end_src

**** bind!
:PROPERTIES:
:ID:       0ce28150-7971-466f-b9b7-3cf33c496393
:END:

Finally, our main macro is here.

#+begin_src emacs-lisp
(defmacro bind! (&rest clauses)
  "Define bindings based on CLAUSES."
  (declare (indent defun))
  `(progn
     ,@(->> (xl-bind%read-clause (cons '(:kbd t) clauses))
	    (-map #'xl-bind%normalize-keybinding)
	    (-map #'xl-bind%normalize-evil-state)
	    (-map #'xl-bind%make-proper-plist)
	    (-mapcat #'xl-bind%flatten-plist-values)
	    (-map #'xl-bind%merge-duplicate-plist-keys)
	    (-map #'xl-bind%process-prefix)
	    (-map #'xl-bind%apply-prefix)
	    (-mapcat #'xl-bind%flatten-plist-values)
	    (-map #'xl-bind%ensure-keymap)
	    (xl-bind%binding-forms))))
#+end_src

*** ensuring high keymap precedence
:PROPERTIES:
:ID:       e06bcfa0-63e9-429e-8ff7-4263cbd4f9b1
:END:

In Emacs, there's a [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Searching-Keymaps.html][hierarchy of keymaps]] that consulted when determining which
keymap takes precedence. The steps I take in this headline are also in [[https://github.com/noctuid/evil-guide#preventing-certain-keys-from-being-overridden][noctuid's
evil-guide]].

**** minor mode
:PROPERTIES:
:ID:       9863dc90-fc8c-422c-918f-3d75d52e8a14
:END:

Creating a minor mode to hold the leader map allows us to toggle our leader
bindings on or off.

Enabling =override-mode= needs to be the first thing we do in
=emacs-startup-hook=, or at least it needs to be before modes that set
keybindings like evil. Otherwise, your bindings might not take effect
immediately. This is why I set the advice dept to =-100=.

#+begin_src emacs-lisp
(defvar xl-override-mode-map (make-sparse-keymap))

(define-minor-mode xl-override-mode
  "Global minor mode for higher precedence evil keybindings."
  :keymap xl-override-mode-map
  :global t)

(xl-hook-add 'emacs-startup-hook #'xl-override-mode -100)
#+end_src

**** take precedence over Emacs bindings
:PROPERTIES:
:ID:       9248fb7f-1901-4beb-8b3a-faded48cdddc
:END:

Looking at the [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Searching-Keymaps.html][Emacs keymap hierarchy]], emulation mode maps is pretty up
there. The [[helpvar:emulation-mode-map-alists][emulation-mode-map-alists]] takes an ali.

#+begin_src emacs-lisp
(push '((xl-override-mode . xl-override-mode-map)) emulation-mode-map-alists)
#+end_src

**** make an overriding map
:PROPERTIES:
:ID:       f52fbd32-58a0-4b60-a382-b29112f5d972
:END:

The whole point of the leader bindings is that they be available everywhere and
at all times. Accordingly, we want to ensure our leaders and all their child
bindings take precedence over other Emacs bindings. To do this I create a keymap
that will override all other keymaps, aptly named =XL-OVERRIDE-MAP=.

#+begin_src emacs-lisp
(define-key xl-override-mode-map (kbd XL-EMACS-LEADER-KEY) #'xl/leader)
#+end_src

**** registering override map with evil :evil:
:PROPERTIES:
:ID:       23b55b9c-ea38-485a-b986-ac62d60a6f75
:END:

To ensure that =xl-override-mode-map= takes priority over evil states, we need
to make it an intercept map for all evil states. In evil, intercept maps are
maps that take priority (intercept) evil bindings when they have a different
binding for the same key (this is opposed to =overriding-maps=, which completely
override an evil keymap).

#+begin_src emacs-lisp
(defhook! make-intercept-map (evil-mode-hook)
  "Register `xl-override-map' as an intercept map."
  (iter (each state '(normal motion visual insert emacs))
	(evil-make-intercept-map xl-override-mode-map state t)))
#+end_src

**** binding the leader keys to the prefix map :evil:
:PROPERTIES:
:ID:       d710cbf7-66c5-4934-a2d4-998fdb6f7731
:END:

These keys need to be bound before =evil-mode-hook=, specifically right after
evil is loaded. Otherwise, the bindings won't take effect immediately in buffers
that have already been created by emacs (such as =*scratch*= and
=*Messages*=). Instead, they will only work after you switch states once.

#+begin_src emacs-lisp
(bind!
 (:map xl-override-mode-map)
 (:ie XL-EMACS-LEADER-KEY 'xl/leader)
 (:mnv XL-EVIL-LEADER-KEY 'xl/leader))
#+end_src

*** execute extended command
:PROPERTIES:
:ID:       f17a6b64-f9df-4801-9728-235f6bbb9b4d
:END:

One of the most common--if not the most common--command you use in Emacs is
[[helpfn:execute-extended-command][execute-extended-command]]. This command let's you search any other command and
upon pressing enter, then you execute the command. The fact that this command is
invoked so frequently suggests it should have one of the shortest, easiest to
press bindings. I chose to give it =SPC SPC= and =;=. =SPC SPC= is short and
quick to type as well as consistent with other =SPC= bindings. While =;= is
super fast to press as well and even faster than =SPC SPC=.

#+begin_src emacs-lisp
(bind!
  (:map xl-leader-map "SPC" #'execute-extended-command)
  (:n ";" #'execute-extended-command)
  ("A-x" #'execute-extended-command)
  ("M-x" #'execute-extended-command))
#+end_src

*** space bindings
:PROPERTIES:
:ID:       90c3de63-f4f4-438b-8221-a4aedc7a1968
:END:

**** generic app
:PROPERTIES:
:ID:       68945ce0-82fb-4844-b53b-422c328558af
:END:

#+begin_src emacs-lisp
(bind!
  (:prefix "a" :wk "app")
  (:map xl-leader-map)
  ("c" #'org-capture)
  ((:prefix "o" :wk "arg")
   ("a" #'org-agenda)
   ("l" #'org-store-link)
   ("i" #'org-clock-in-last)
   ("o" #'org-clock-out)
   ("c" #'org-capture))
  ("l" #'xl--log-open-log)
  ("e" #'eshell)
  ("E" #'xl/open-emacs-instance)
  ("d" #'deer)
  ("r" #'ranger))
#+end_src

**** help
:PROPERTIES:
:ID:       f28081e3-451c-4005-80cc-bffeafe0051c
:END:

#+begin_src emacs-lisp
(bind!
  (:map xl-leader-map)
  (:prefix "h" :wk "help")
  ("i" #'info)
  ("m" #'describe-mode)
  ("f" #'describe-function)
  ("v" #'describe-variable)
  ("c" #'describe-char)
  ("k" #'describe-key)
  ("a" #'apropos)
  ("w" #'woman))
#+end_src

**** toggling
:PROPERTIES:
:ID:       b962fa01-d63f-47a9-bf69-b2f82c8b1e61
:END:

I have kind of a loose definition of "toggle" in this headline.

#+begin_src emacs-lisp
(bind!
  (:prefix "t" :wk "toggle")
  (:map xl-leader-map)
  ("r" #'read-only-mode)
  ("t" #'load-theme)
  ("c" #'caps-lock-mode)
  ("d" #'toggle-debug-on-error)
  ("F" #'xl/set-font-face)
  ("f" #'xl/set-font-size))
#+end_src

**** buffer
:PROPERTIES:
:ID:       5fd53168-3eee-4ed4-8213-28efba5d0200
:END:

#+begin_src emacs-lisp
(bind!
  (:prefix "b" :wk "buffer")
  (:map xl-leader-map)
  ("w" #'save-buffer)
  ((:prefix "k" :wk "kill")
   ("c" #'kill-current-buffer)
   ("o" #'xl/kill-other-buffers))
  ("n" #'next-buffer)
  ("p" #'previous-buffer)
  ("d" #'display-buffer)
  ("b" #'consult-buffer))
#+end_src

**** file
:PROPERTIES:
:ID:       3857a17c-1a14-4163-a23b-8811a2dad111
:END:

#+begin_src emacs-lisp
(bind!
  (:prefix "f" :wk "file")
  (:map xl-leader-map)
  ("s" #'save-buffer)
  ("f" #'find-file)
  ("i" #'xl/switch-to-init-file)
  ("r" #'xl/switch-to-readme))
#+end_src

**** code
:PROPERTIES:
:ID:       d6229bf2-9d8d-4f97-bb95-b07ef409e33f
:END:

#+begin_src emacs-lisp
(bind!
  (:prefix "c" :wk "code")
  (:map xl-leader-map)
  ("l" #'lispyville-comment-or-uncomment)
  ("c" #'lispyville-comment-or-uncomment))
#+end_src

**** eval
:PROPERTIES:
:ID:       3947b258-fc46-4fc9-8350-3fd25a69d749
:END:

#+begin_src emacs-lisp
(bind!
  (:prefix "e" :wk "eval")
  (:map xl-leader-map)
  ("e" #'eval-expression))

(bind-localleader!
 (:prefix "e" :wk "eval")
 (:map emacs-lisp-mode-map)
 ("d" #'eval-defun)
 ("e" #'eval-expression)
 ("l" #'eval-last-sexp)
 ("p" #'eval-print-last-sexp))
#+end_src

**** search

#+begin_src emacs-lisp
(bind!
  (:prefix "s" :wk "search")
  (:map xl-leader-map)
  ((:prefix "w" :wk "web")
   ("d" #'engine/search-duckduckgo)
   ("q" #'engine/search-qwant)
   ("a" #'engine/search-amazon)
   ("w" #'engine/search-wikipedia))
  ("s" #'consult-line)
  ("l" #'consult-line)
  ("h" #'consult-outline)
  ("o" #'consult-outline))
#+end_src

**** version control
:PROPERTIES:
:ID:       31234afc-a11d-42a8-88af-e0647d44c1b1
:END:

#+begin_src emacs-lisp
(bind!
  (:prefix "v" :wk "version control")
  (:map xl-leader-map)
  ((:prefix "g" :wk "git-gutter+")
   ("u" #'git-gutter+-unstage-whole-buffer)
   ("n" #'git-gutter+-next-hunk)
   ("p" #'git-gutter+-previous-hunk)
   ("s" #'git-gutter+-stage-hunks)
   ("c" #'git-gutter+-commit))
  ("s" #'magit-status))
#+end_src

**** packages
:PROPERTIES:
:ID:       0ec9aee0-8f9a-4700-8928-abff758357e1
:END:

#+begin_src emacs-lisp
(bind!
  (:prefix "p" :wk "packages")
  (:map xl-leader-map)
  ("i" #'straight-use-package)
  ("u" #'straight-pull-package)
  ("r" #'straight-rebuild-package)
  ("h" #'straight-visit-package-website)
  ("d" #'visit-package-directory))
#+end_src

**** quit
:PROPERTIES:
:ID:       ae435361-79e7-41c8-b490-8ec0f8d23a59
:END:

There's many ways to quit Emacs. Sometimes I'd like to save all the buffers I
had been working on. Sometimes, when I'm testing something and I mess up
[[helpvar:kill-emacs-hook][kill-emacs-hook]] I want Emacs to just quit even if it means ignoring that hook.
Most of the time, I know what I'm doing when I quit Emacs, so I don't want a
prompt asking me if I'm sure.

#+begin_src emacs-lisp
(bind!
  (:prefix "q" :wk "quit")
  (:map xl-leader-map)
  ("q" #'save-buffers-kill-emacs)
  ("s" #'xl/quit-emacs-no-prompt)
  ("Q" #'evil-save-and-quit)     
  ("x" #'xl/kill-emacs-no-hook)
  ("e" #'xl/kill-emacs-processes)
  ("b" #'xl/kill-emacs-brutally))
#+end_src

* DOC org :org:
:PROPERTIES:
:ID:       090ce452-80bc-4565-a591-2e3e4d30d718
:END:

** increase line spacing
:PROPERTIES:
:ID:       25614f23-f337-4092-8d3d-5c5d75efe90c
:END:

Inspired by [[https://www.reddit.com/r/emacsporn/comments/kjwdd3/adding_some_whitespace_to_let_the_text_breathe/][this reddit post]] (which was in turn inspired by [[https://github.com/rougier/nano-emacs][nano emacs]]), I
decided to increase [[helpvar:line-spacing][line-spacing]] for org-mode.

#+begin_src emacs-lisp
(defhook! increase-line-spacing (org-mode-hook)
  "Set `line-spacing' to 0.2."
  (setq-local line-spacing 0.2))
#+end_src

** =org-capture= still deletes other windows :capture:popup:
:PROPERTIES:
:ID:       018fc5a8-666f-4233-af33-0a562c729712
:END:

When you bring up the =org-capture= popup, other opened windows are deleted,
which I find unnecessary and disorienting. This code suppresses this behavior.

#+begin_src emacs-lisp
(defafter! suppress-the-deletion-of-windows (org-capture)
  "Don't let the `org-capture' popup delete other windows."
  (xl-gadvice-suppress-delete-windows #'org-capture))
#+end_src

** TODO add a todo-keyword for adding a doc :doc:todo:
:PROPERTIES:
:ID:       6bd0e450-19a4-4ef5-9938-5d8eea3615bd
:END:

This keyword means I need to add documentation to a headline.

#+begin_src emacs-lisp
(defafter! add-doc-keyword (org)
  (add-to-list 'org-todo-keywords '(sequence "DOC" "|")))
#+end_src

** TODO add bug to use-package keywords :todo:debug:
:PROPERTIES:
:ID:       083e2975-eea0-4ebb-a903-f681194aae74
:END:

#+begin_src emacs-lisp
(defafter! add-bug-keyword (org)
  (add-to-list 'org-todo-keywords '(sequence "BUG" "|")))
#+end_src

** TODO org-version
:PROPERTIES:
:ID:       0b2cfe2b-a75c-48ea-9470-19c92521e2cf
:END:

#+begin_src emacs-lisp
(advice-add #'org-version :override (-const "10"))
#+end_src

** commands :command:
:PROPERTIES:
:ID:       6f3aa588-6d08-4c5f-af74-f03891abc020
:END:

*** next-line
:PROPERTIES:
:ID:       3566b78b-56f8-4628-ad77-ae040f82eaaf
:END:

#+begin_src emacs-lisp
(defun org/dwim-next-line (&optional backward)
  "Go to the start of the next heading.
If DIR is a negative integer, go the opposite direction: the start of the
  previous heading."
  (interactive)
  (outline-next-visible-heading (if backward -1 1))
  (when (org-at-heading-p)
    (org%heading-goto-start)))
#+end_src

*** show branch
:PROPERTIES:
:ID:       d95fab52-7d8f-439f-9221-188490f4ad5f
:END:

This shows all headlines that make up the branch of the current headine and
their children. This is the typical behavior you would expect in any outlining
program.

As it stands =org-mode= will keep the parents of a headline you jump to akwardly
hidden.

#+begin_src emacs-lisp
(defun org%show-branch ()
  "Reveal the current org branch.
Show all of the current headine's parents and their children. This includes this
headline."
  (save-excursion
    (loopy (before-do (org-back-to-heading t)
		      (outline-show-children))
	   (while (org-up-heading-safe))
	   (do (outline-show-children)))))
#+end_src

*** show branch after jumping to point
:PROPERTIES:
:ID:       251e5df0-0a7d-4bf9-8fd9-69991d89a074
:END:

Note that I use points to store the heading points and go back to them inreverse
order. This is important because org does not unfold headlines properly if you
start from an invisible subheading.

Notably, I do not try to conserve the return value of =xl/goto-line= or
=xl/jump-to-headline= because these functions are and should only be used for
their side-effects.

#+begin_src emacs-lisp
(defadvice! show-current-branch-in-org-mode (:after xl/goto-line org/goto-headline)
  "Properly unfold nearby headlines and reveal current headline."
  (when (eq major-mode 'org-mode)
    (org%show-branch)))
#+end_src

*** tangle asynchronously :tangle:
:PROPERTIES:
:ID:       9fcff539-5c1c-4ec8-8aa7-ac8fb82d3392
:END:

Tangling is extremely slow using [[helpfn:org-babel-tangle][org-babel-tangle]]. With a large org file like mine there's
a significant lag and Emacs is blocked while it is tangling.

#+begin_src emacs-lisp
(defun xl/tangle-config-async ()
  "Tangle the readme file asynchronously."
  (interactive)
  (let ((input (expand-file-name "init.org" "~/.tangld/src/emacs/"))
	(output (expand-file-name "init.el" "~/.config/emacs/")))
    (async-start
     `(lambda ()
	(require 'org)
	(require 'ob-tangle)
	(require 'rx)
	(setq org-confirm-babel-evaluate nil)
	(let ((gc-cons-threshold most-positive-fixnum)
	      (org-confirm-babel-evaluate nil))
	  (mkdir "~/.config/emacs/" t)
	  (org-babel-tangle-file ,input ,output)))
     `(lambda (result)
	(message (if result "Successfully tangled %s" "Failed to tangle %s") ,output)))))
#+end_src

*** previous-line
:PROPERTIES:
:ID:       682ec141-fb93-4b55-9c3d-d40aacada205
:END:

#+begin_src emacs-lisp
(defun org/dwim-previous-line (&optional forward)
  (interactive)
  (funcall #'org/dwim-next-line (not forward)))
#+end_src

*** heading below
:PROPERTIES:
:ID: b059a431-e29c-4f2c-ab5e-8d2d02636405
:END:

#+begin_src emacs-lisp
(defun org/insert-heading-below (&optional above)
  "Insert heading below."
  (interactive)
  (let* ((on-heading-p (ignore-errors (org-back-to-heading)))
         (newlines org%newlines-between-headings)
         (level (or (org-current-level) 1))
         (heading (concat (make-string level ?*) "\s")))
    (cond ((not on-heading-p)
           (insert heading))
          (above
           (goto-char (line-beginning-position))
           (insert heading)
           (save-excursion (insert newlines)))
          (t ; below
           (org-end-of-subtree)
           (insert (concat newlines heading))))
    ;; From `org-insert-heading'
    (pcase (get-char-property-and-overlay (point) 'invisible)
      (`(outline . ,o)
       (move-overlay o (overlay-start o) (line-end-position 0)))
      (_ nil))
    (run-hooks 'org-insert-heading-hook)))
#+end_src

*** heading above
:PROPERTIES:
:ID:       545a9192-b312-4667-b4f0-000ddb47b4a1
:END:

#+begin_src emacs-lisp
(defun org/insert-heading-above (&optional below)
  "Insert a heading above the current heading."
  (interactive)
  (funcall #'org/insert-heading-below (not below)))
#+end_src

*** subheading
:PROPERTIES:
:ID:       38cc6c74-4b2c-4aa8-b672-86bb7f4fcd7d
:END:

#+begin_src emacs-lisp
(defun org/insert-subheading ()
  "Insert subheading below current heading."
  (interactive)
  (org/insert-heading-below)
  (org-demote))
#+end_src

*** dwim insert source block
:PROPERTIES:
:ID:       0025e89d-23a9-42bf-87bb-a4f6d8fbe5a3
:END:

#+begin_src emacs-lisp
(defun org/dwim-edit-source-block ()
  "Edit close source block from point."
  (interactive)
  (unless (org-in-src-block-p)
    (org-next-block 1))
  (org-edit-src-code))
#+end_src

*** elisp block
:PROPERTIES:
:ID:       e03149e3-500f-45d6-a4c1-b2f69947b4d5
:END:

#+begin_src emacs-lisp
(defun org/dwim-insert-elisp-block ()
  "Insert elisp block."
  (interactive)
  (save-excursion
    (unless (org-at-heading-p)
      (org-back-to-heading))
    (org-end-of-subtree)
    (goto-char (line-end-position))
    (insert (concat "\n\n"
                    "#+begin_src emacs-lisp"
                    "\n"
                    "#+end_src"))
    (forward-line -1)))
#+end_src

*** eval
:PROPERTIES:
:ID:       1a7d5dde-ab85-4159-b3c7-9da093a30de0
:END:

#+begin_src emacs-lisp
(defun org/dwim-eval-block ()
  "Eval block contents."
  (interactive)
  (unless (org-at-heading-p)
    (user-error "Not in source block"))
  (save-window-excursion
    (org-babel-execute-subtree)))
#+end_src

*** jump to line
:PROPERTIES:
:ID:       47480f9a-2e82-435a-a098-6a1a9a11c2f0
:END:

A simplified version of [[helpfn:consult-line][consult-line]] that only works in org mode. Thing
is, although consult line looks prettier I find it less useful to see fontified
headlines and would rather view the entire path.

#+begin_src emacs-lisp
(defun xl/goto-org-heading ()
  "Jump to an org heading."
  (interactive)
  (let ((selectrum-should-sort-p nil)
        (org-outline-path-complete-in-steps)
        (org-goto-interface 'outline-path-completion)
	(org-goto-max-level 10))
    (org-goto))
  (when (eq major-mode 'org-mode) (org%show-branch)))
#+end_src

*** org choose tags
:PROPERTIES:
:ID:       b8b0c3a2-2cdc-424f-9cd6-ef3ad3d1512c
:END:

#+begin_src emacs-lisp
(defun org/choose-tags ()
  "Select tags to add to headline."
  (interactive)
  (let* ((current (org-get-tags (point)))
         (selected (->> (org-get-buffer-tags)
                        (completing-read-multiple "Select org tag(s): "))))
    (alet (-distinct (append (-difference current selected)
                             (-difference selected current)))
      (org-set-tags it))))
#+end_src

*** return
:PROPERTIES:
:ID:       8314f2e0-da63-4f2f-ad89-b97987ca5843
:END:

#+begin_src emacs-lisp
(defun org/dwim-return ()
  "Do what I mean."
  (interactive)
  (cond ((org-at-heading-p)
         (org/insert-heading-below))
        (t
         (call-interactively #'org-return))))
#+end_src

** important files and directories
:PROPERTIES:
:ID:       97a3bb5a-f485-45d0-a7f4-4bdd3963a16b
:END:

For now, I define these variables after org mode. These are important files and
directories that I need to reference multiple times.

#+begin_src emacs-lisp
(defconst XL-ORG-DIR (f-full "~/Documents/org/")
  "Directory where org files are kept.")

(defconst XL-CAPTURE-FILE (concat XL-ORG-DIR "capture.org")
  "Org file where capture template captures should go.")

(defconst XL-CODE-FILE (concat XL-ORG-DIR "capture.org")
  "Org file where code snippets should go.")

(defconst XL-TEST-FILE (concat XL-ORG-DIR "test.org")
  "Org file tests should go.")
#+end_src

** bind :bind:
:PROPERTIES:
:ID:       66e694fb-c8db-47a9-869d-101ee34aa6bd
:END:

*** org mode local bindings
:PROPERTIES:
:ID:       a950d732-b0d2-46b9-82ce-1b9a474e7d76
:END:

#+begin_src emacs-lisp
(bind-localleader!
 (:map org-mode-map)
 ((:prefix "i")
  ("b" #'org/dwim-insert-elisp-block)
  ("k" #'org/insert-heading-above)
  ("j" #'org/insert-heading-below))
 ("p" #'org-set-property)
 ("o" #'outorg-edit-as-org)
 ("w" #'widen)
 ("n" #'org-narrow-to-subtree)
 ("k" #'org-cut-subtree)
 ("c" #'org-copy-subtree)
 ("r" #'org-refile)
 ("j" #'org/avy-goto-headline)
 ("E" #'org-babel-execute-subtree)
 ("d" #'org/dwim-edit-description)
 ("H" #'(lambda () (interactive) (org-up-heading-safe)))
 ("h" #'org-promote-subtree)
 ("l" #'org-demote-subtree)
 ("e" #'org/dwim-edit-source-block)
 ("," #'org/dwim-edit-source-block))
#+end_src

*** generic org bindings
:PROPERTIES:
:ID:       583bd7ac-64e0-48ea-bd75-5b6a20f2deae
:END:

Org mode just does not lend itself to typical evil bindings. These bindings are
much more useful considering the specific structure of org mode documents.

#+begin_src emacs-lisp
(bind!
  (:map org-mode-map)
  (:states normal)
  ("j" #'org-next-visible-heading)
  ("k" #'org-previous-visible-heading)
  ("E" #'org/dwim-eval-block)
  ("e" #'org/dwim-eval-block)
  ("b" #'org/dwim-insert-elisp-block)
  ("o" #'org/insert-heading-below)
  ("O" #'org/insert-heading-above)
  ("h" #'org-up-heading-safe)
  ("l" #'org-do-demote)
  ("H" #'org-promote-subtree)
  ("S" #'org-demote-subtree)
  (">" #'org-shiftmetaright)
  ("<" #'org-shiftmetaleft)
  ("t" #'org-set-tags-command)
  ("c" #'org-capture)
  ("s" #'org/dwim-edit-source-block)
  ("R" #'org-refile)
  ("r" #'org/refile-to-current-file)
  ("T" #'org-todo)
  ("D" #'org-cut-subtree)
  ("Y" #'org-copy-subtree)
  ("K" #'org-metaup)
  ("J" #'org-metadown))
#+end_src

*** bindings
:PROPERTIES:
:ID:       3f4144ee-a780-478e-a1ad-47591f181ff3
:END:

#+begin_src emacs-lisp
(bind! ([remap org-cycle] #'outline-toggle-children))
#+end_src

*** goto start of heading
:PROPERTIES:
:ID:       0431e49f-ef6b-4edb-854c-6427479e5ee2
:END:

#+begin_src emacs-lisp
(defun org%heading-goto-start ()
  "Go to the end of headline."
  (save-match-data
    (beginning-of-line)
    (when (looking-at (rx (1+ "*")))
      (goto-char (1- (match-end 0))))))
#+end_src

** do the right thing after jumping to headline
:PROPERTIES:
:ID:       2ca61454-a0ca-47b3-8622-91d7969653da
:END:

When I search for a headline with [[helpfn:void/goto-line][xl/goto-line]] or [[helpfn:void/goto-headline][xl/goto-headline]] or even their
counsel equivalents, the proper headlines aren't automatically revealed.

[[screenshot:][This]] is what headline structure looks after using counsel/ivy's [[helpfn:swiper][swiper]] to find
the word =xl/goto-line= in my emacs. You can see that only the headline that has
the target word is revealed but it's parents are (akwardly) hidden. I never want
headlines to be unfolded like this.

** inserting
:PROPERTIES:
:ID:       9ff51c40-5b4a-4861-834f-df1ddb0fc709
:END:

In my eyes, many Org functions are unnecessarily complicated and long. Often they
need to perform a simple task (like inserting a heading) but lose their
fundamental purpose in their inclusion of numerous obscure and opinionated
options. For this reason I wrote my own insert heading functions.

** newlines between headings
:PROPERTIES:
:ID:       995ac71b-8428-4eec-83ac-1ba50383f600
:END:

#+begin_src emacs-lisp
(defvar org%newlines-between-headings "\n\n"
  "Number of newlines between headings.")
#+end_src

** DOC switch :popup:
:PROPERTIES:
:ID:       120e0129-8cc8-4010-b628-7b7a80c1efd4
:END:

#+begin_src emacs-lisp
(defun! use-pop-to-buffer (_ buf &optional norecord)
  "Use `pop-to-buffer' instead of `switch-to-buffer' to open buffer.'"
  (:around org-switch-to-buffer-other-window)
  (pop-to-buffer buf nil norecord))
#+end_src

** DOC another :popup:
:PROPERTIES:
:ID:       fcba7e55-600c-45e2-a224-91a9af6a9ff2
:END:

#+begin_src emacs-lisp
(defun! use-switch-to-buffer-instead (orig-fn &rest args)
  (:around org-src-switch-to-buffer)
  (with-temp-advice! ((pop-to-buffer-same-window :override switch-to-buffer))
    (apply orig-fn args)))
#+end_src

** suppress deleting-windows :popup:
:PROPERTIES:
:ID:       9a991acc-a24c-4b28-bafa-876a7f973b90
:END:

Org has a nasty tendency of deleting windows. This advice needs to be added to
various functions in org mode.

#+begin_src emacs-lisp
(defgadvice! suppress-delete-windows (orig-fn &rest args)
  "Inhibit the deletion of windows."
  (with-temp-advice! ((delete-window :override ignore)
		      (delete-other-windows :override ignore))
    (apply orig-fn args)))
#+end_src

** org
:PROPERTIES:
:ID:       b0aa3f0b-876a-4527-b8ba-4fdac5e7ebe8
:END:

#+begin_src emacs-lisp
(use-package org
  :gadvice
  (org-add-log-note . suppress-delete-windows)
  (org-fast-tag-selection . suppress-delete-windows)
  (org-fast-todo-selection . suppress-delete-windows)
  :set
  (org-directory                      . (concat "~/Documents/org/"))
  (org-default-notes-file             . (concat org-directory "notes.org"))
  (org-fontify-emphasized-text        . t)
  (org-hide-emphasis-markers          . t)
  (org-pretty-entities                . t)
  (org-fontify-whole-heading-line     . t)
  (org-fontify-done-headline          . t)
  (org-fontify-quote-and-verse-blocks . t)
  (org-adapt-indentation              . nil)
  (org-cycle-separator-lines          . 2)
  (outline-blank-line                 . t)
  (org-enforce-todo-dependencies      . t)
  (org-use-fast-tag-selection         . nil)
  (org-tags-column                    . 0)
  (org-log-done                       . 'time))
#+end_src

** tangld
:PROPERTIES:
:ID:       03016895-7b3a-4809-a72d-ae635c3f0d01
:END:

=tangled= is currently in its early development stages--meaning it is not
working yet.

#+begin_src emacs-lisp
(use-package tangld)
#+end_src

** org-annotate-code
:PROPERTIES:
:ID:       a8c5199d-1f4d-44a5-b6f1-2f8f264b181d
:END:

This package lets you annotate files in a separate org file.

#+begin_src emacs-lisp
(use-package org-annotate-code
  :set (org-annotate-code-org-file . (concat XL-ORG-DIR "annotations.org")))
#+end_src

** org-archive
:PROPERTIES:
:ID:       e53743e9-79ec-42b9-9a4e-5aa87fe936ac
:END:

#+begin_src emacs-lisp
(use-package org-archive
  :set
  (org-archive-location . (concat org-directory "archive.org::")))
#+end_src

** org-super-links
:PROPERTIES:
:ID:       f3eed884-408f-44cb-becc-17c1431060c5
:END:

#+begin_src emacs-lisp
(use-package org-superlinks
  :commands org-super-links-link
  :set
  (org-super-links-backlink-prefix      . nil)
  (org-super-links-related-into-drawer  . "LINKS")
  (org-super-links-backlink-into-drawer . "LINKS"))
#+end_src

** org-todo-keywords
:PROPERTIES:
:ID:       aaa98680-d9b4-4726-b3ba-a50b3442e8e8
:END:

I like the terms "issue" and "closed" because they are more general than the
corresponding "todo" and "done". "Issue" simply implies a problem that needs to
be fixed. When I use =todo= I feel obligated to write what I have to do and
often I don't know that. Who knows? It could even be that nothing needs to be
done.

#+begin_src emacs-lisp
(setq org-todo-keywords
      '((sequence "TODO" "NEXT" "|" "DONE" "CANCELLED")))
#+end_src

** org-ml
:PROPERTIES:
:ID:       7f3ec0ad-45f8-4100-970e-773cfb9a625b
:END:

#+begin_src emacs-lisp
(use-package org-ml)
#+end_src

** org-journal
:PROPERTIES:
:ID:       c3056303-5fa1-49f9-ae2d-294942e25f54
:END:

=org-journal= is a package that provides functions to maintain a simple
diary/journal using =org-mode=.

#+begin_src emacs-lisp
(use-package org-journal
  :commands org-journal-new-entry
  :set
  (org-journal-file-type . 'yearly)
  (org-journal-find-file . 'find-file)
  (org-journal-dir       . (concat org-directory "journal/")))
#+end_src

** org-src
:PROPERTIES:
:ID:       e00378a1-adcf-4e83-8533-b6b442b5f362
:END:

#+begin_src emacs-lisp
(use-package org-src
  :idle-require t
  :rule ("bottom" "org source" :newname "\\*Org Src")
  :set
  (org-src-window-setup                        . 'plain)
  (org-src-ask-before-returning-to-edit-buffer . nil)
  (org-edit-src-persistent-message             . nil)
  (org-src-preserve-indentation                . t)
  (org-confirm-babel-evaluate                  . nil)
  (org-src-tab-acts-natively                   . t)
  (org-src-fontify-natively                    . t))
#+end_src

*** bindings in source block
:PROPERTIES:
:ID:       df270638-f6a7-4f0e-abe7-dd0c4e7df7ce
:END:

Note that you should have bindings that are different for entering and exiting
source blocks.

#+begin_src emacs-lisp
;; (defhook! enable-org-exit-src-bindings (org-src-mode-hook)
;;   ;; "," (list :def #'org-edit-src-exit  :wk "exit source block")
;;   ;; "a" (list :def #'org-edit-src-abort :wk "abort source block")
;;   ;; "c" (list :def #'org-edit-src-exit  :wk "exit source block")
;;   )
#+end_src

** set default header arguments
:PROPERTIES:
:ID:       6151eadc-434b-427f-9e01-9003b3ffab05
:END:

#+begin_src emacs-lisp
(defafter! set-the-default-header-args (org-src)
  ""
  (setq org-babel-default-header-args
	'((:session . "none")
	  (:results . "silent")
	  (:exports . "code")
	  (:mkdirp  . "yes")
	  (:cache   .  "no")
	  (:noweb   .  "no")
	  (:hlines  .  "no")
	  (:tangle  .  "no"))))
#+end_src

** org-capture
:PROPERTIES:
:ID:       c9d34e33-f2bc-4351-a654-64e91f4814b1
:END:

=org-capture= is a feature that allows you to quickly save a thought that popped
into your head while keeing disctractions to a minimum.

*** org-capture
:PROPERTIES:
:ID:       8fc5d248-ff21-45e4-a48b-57cecd57b7a3
:END:

My capture templates use =ts= and =org-ml= so I make sure to load those library
before org-capture is loaded.

#+begin_src emacs-lisp
(use-package org-capture
  :idle-require t
  :initial-state insert
  :before-call
  (ts     . org-capture)
  (org-ml . org-capture)
  :rule ("bottom" "capture" :newname "\\`CAPTURE-.+"))
#+end_src

*** TODO remove capture headerline
:PROPERTIES:
:ID:       dacaf33d-3914-49e4-a1d0-e6bb41b1a44e
:END:

By default org capture templates display a header line. This was the answer to [[https://emacs.stackexchange.com/questions/53648/eliminate-org-capture-message][my
question]]. I need to disable =org-capture's= header-line.

#+begin_src emacs-lisp
(defhook! disable-header-line (org-capture-mode-hook)
  "Turn of the header line message."
  ;; (:feature org)
  (setq-local header-line-format nil))
#+end_src

*** doct
:PROPERTIES:
:ID:       fa37f618-b58c-449b-a216-9d2f80ed12c6
:END:

[[https://github.com/progfolio/doct][doct]] is a package designed to ease writing and understanding capture templates
by allowing you to write them in a declarative style (see [[helpfn:doct][doct docstring]]).
In org mode, capture templates are [[info:org#Capture templates][represented as plain lists]]. This makes
it easy to forget what a certain element meant or to accidentally omit a capture
template element as you're writing it.

#+begin_src emacs-lisp
(use-package doct
  :before-call org-capture)
#+end_src

*** register org capture files
:PROPERTIES:
:ID:       c3c072c9-71b1-44c1-b472-5dc129a19963
:END:

#+begin_src emacs-lisp
(defafter! register-capture-file (org-capture)
  "Add the file I use for capturing to `org-agenda-files'."
  (callf2 cl-adjoin XL-CAPTURE-FILE org-agenda-files :test #'string=))
#+end_src

*** DOC completing-read org-capture :bind:
:PROPERTIES:
:ID:       ad2cc056-edda-490a-8cf9-10b370a21dc0
:END:

Org provides it's own default interface for capturing. To be consistent with how
we complete everything else--via [[helpfn:][completing-read]], I create a function which
let's me choose the template via completing-read.

#+begin_src emacs-lisp
(defun org-capture/choose-template ()
  (interactive)
  (require 'org-capture)
  (let* ((read-string (loopy (list (first second . _) (org-capture%template-list))
			     (collect (format "%s %s" first second))))
	 (selection (completing-read "Capture template: " read-string nil :require-match))
	 (key (car (split-string selection "\s" t))))
    (org-capture nil key)))

(bind! ([remap org-capture] #'org-capture/choose-template))
#+end_src

*** capture templates :helper:
:PROPERTIES:
:ID:       c4fdb186-3509-42f1-9c3e-8bf80a5e6b47
:END:

#+begin_src emacs-lisp
(defun org-capture%template-list ()
  "Return a list of capture templates."
  (thread-first org-capture-templates
    (org-capture-upgrade-templates)
    (org-contextualize-keys org-capture-templates-contexts)))
#+end_src

*** capture templates
:PROPERTIES:
:ID:       a2a3f682-322a-450f-91bf-169d90f040c0
:END:

**** todo
:PROPERTIES:
:ID:       ef103d28-b746-42ba-ac1a-0462a19f03cd
:END:

***** todo capture template string
:PROPERTIES:
:ID:       a58f1de7-2049-4195-abfb-daad93a6ff2a
:END:

Instead of passing in the string I use =org-ml= to print the string.

#+begin_src emacs-lisp
(defun org-capture%todo-template ()
  "Return capture template for an todo."
  (->> (org-ml-build-headline! :title-text "%?")
       (org-ml-headline-set-node-property "ID" (org-id-new))
       (org-ml-set-property :todo-keyword "TODO")
       (org-ml-to-trimmed-string)))
#+end_src

***** todo
:PROPERTIES:
:ID:       2682910c-9620-4cbf-ab71-371ed29e25a1
:END:

#+begin_src emacs-lisp
(defafter! add-todo-capture-template (org-capture doct)
  (alet (doct '(("todo"
		 :keys "t"
		 :template org-capture%todo-template
		 :file XL-CAPTURE-FILE
		 :prepend t
		 :empty-lines 1)))
    (add-to-list 'org-capture-templates (car it))))
#+end_src

** org-clock
:PROPERTIES:
:ID:       d378471c-89df-48c9-a755-b79880f27308
:END:

=org-clock= is a built-in package that provides time logging functions for
tracking the time you spend on a particular task.

#+begin_src emacs-lisp
(use-package org-clock
  :idle-require t
  :commands org-clock-in org-clock-goto
  :hook (kill-emacs-hook . org-clock-save)
  :set
  (org-clock-persist      . 'history)
  (org-clock-persist-file . (concat XL-CACHE-DIR "org-clock-save.el"))
  (org-clock-in-resume    . t)
  :config
  (org-clock-persistence-insinuate))
#+end_src

** org-ql
:PROPERTIES:
:ID:       f2b2f464-f9f0-4ba4-9808-4bf5cb75aaf8
:END:

This package provides an org query language for looking up org headline.

#+begin_src emacs-lisp
(use-package org-ql)
#+end_src

** calfw
:PROPERTIES:
:ID:       4b317202-0f4c-40e9-b708-484cd995c9b8
:END:

This package displays a calendar.

#+begin_src emacs-lisp
(use-package calfw)
#+end_src

** org-agenda
:PROPERTIES:
:ID:       72fba07e-df2e-420a-8ddd-40b9e27bf28f
:END:

*** org-agenda :popup:
:PROPERTIES:
:ID:       efa9d237-b055-4bfb-a1f9-86d964b5f007
:END:
:LINKS:
[[info:org#Weekly/daily agenda][info:org#Weekly/daily agenda]]
:END:

#+begin_src emacs-lisp
(use-package org-agenda
  :idle-require t
  :rule ("top" "org agenda" :newname "\\*Org Agenda\\*")
  :before-call (org-ql . org-agenda)
  :gc-pause org-agenda-list
  :gadvice (org-agenda-get-restriction-and-command . suppress-delete-windows)
  :set
  (org-agenda-include-diary . t)
  (org-agenda-text-search-extra-files . '(agenda-archives))
  (org-agenda-skip-unavailable-files  . t)
  (org-agenda-files                   . (list XL-CAPTURE-FILE))
  (org-agenda-warning-days . 10)
  (org-agenda-start-on-weekday        . 0)
  (org-agenda-timegrid-use-ampm       . nil)
  (org-agenda-time-leading-zero       . t)
  (org-agenda-dim-blocked-tasks       . t)
  (org-agenda-inhibit-startup         . t))
#+end_src

*** respect display-buffer :popup:
:PROPERTIES:
:ID:       50933d82-1208-481d-8dc7-42630f3f3b41
:END:

=org= functions are known to try to configure buffer displays themselves. This
forces agenda view to rely on [[helpvar:display-buffer-alist][display-buffer-alist]] for it's display.

#+begin_src emacs-lisp
(defun! use-display-buffer (abuf filter-alist)
  "Use `display-buffer' to display the agenda buffer.
Unlike `org-agenda-prepare-window', this function does not store the window configuration."
  :override org-agenda-prepare-window
  (display-buffer abuf)
  (setq org-agenda-tag-filter (cdr (assq 'tag filter-alist)))
  (setq org-agenda-category-filter (cdr (assq 'cat filter-alist)))
  (setq org-agenda-effort-filter (cdr (assq 'effort filter-alist)))
  (setq org-agenda-regexp-filter (cdr (assq 're filter-alist)))

  (unless (equal (current-buffer) abuf)
    (pop-to-buffer-same-window abuf)))
#+end_src

*** filter candidates in agenda command :org:lang:
:PROPERTIES:
:ID:       377ded57-7431-4929-8be9-e04f8f172c38
:END:
:LINKS:
https://emacs.stackexchange.com/questions/53028/how-to-show-only-time-grid-without-todo-items-in-org-agenda
https://emacs.stackexchange.com/questions/15309/is-there-a-way-to-show-an-agenda-with-just-a-time-grid
:END:

The goal is to achieve, an agenda with only items in the time grid. There was a
[[https://emacs.stackexchange.com/questions/15309/is-there-a-way-to-show-an-agenda-with-just-a-time-grid][question]] asked about this. This is theoretically possible by creating a
skip function that skips all items that aren't in the time frame of the grid.
Ideally, what we'd want is to use =org-ql=.

Fortunately, there's a function =org-= that takes a =POM= (point or marker)
which is perfect for getting the agenda.

#+begin_src emacs-lisp
(defun! org-agenda%skip-if-not-today ()
  (let* ((time (org-entry-get (point) "DEADLINE"))
	 (dtime (when time (ts-parse-org time)))
	 (now (ts-now)))
    (if (and dtime
	     (= (ts-day dtime) (ts-day now))
	     (= (ts-year dtime) (ts-year now))
	     (= (ts-month-num dtime) (ts-month-num now)))
	nil
      (org-entry-end-position))))
#+end_src

*** org-agenda-custom-commands :org:lang:
:PROPERTIES:
:ID:       b7023041-df49-4750-8b27-91b7175bd1ee
:END:
:LINKS:
https://llazarek.github.io/2018/09/improving-the-agenda-part-2-custom-views.html
https://blog.aaronbieber.com/2016/09/24/an-agenda-for-life-with-org-mode.html
https://orgmode.org/worg/org-tutorials/org-custom-agenda-commands.html
https://github.com/remyhonig/org-query
[[info:org#Filtering/limiting agenda items][info:org#Filtering/limiting agenda items]]
https://github.com/alphapapa/org-ql
:END:

The default org agenda display is pretty crude, particularly with several items.
To customize the default agenda view you can checkout
[[helpfvar:org-agenda-custom-commands][org-agenda-custom-commands]]. For sections of the agenda I suggest using
[[helpfn:org-ql-block][org-ql-block]]. It makes things easier and is likely much faster than the default
Emacs. In the future I want to divide these sections into their own function (or
variables?) so that I can easily piece together different agenda views.

#+begin_src emacs-lisp
(setq org-agenda-custom-commands
      '(("c" "My custom agenda"
         ((agenda ""
	   ((org-agenda-span 'day)
	    (org-agenda-overriding-header "")
	    (org-agenda-skip-function #'org-agenda%skip-if-not-today)))
	  (org-ql-block '(and (todo "TODO") (deadline))
	   ((org-ql-block-header "Most Pressing Todos")
	    (org-agenda-sorting-strategy '(deadline-down priority-up))
	    (org-agenda-max-entries 5)))
	  (org-ql-block '(and (todo "TODO") (tags "emacs") (deadline))
	   ((org-ql-block-header "Emacs Tasks")
	    (org-agenda-sorting-strategy '(deadline-down))
	    (org-agenda-max-entries 5)))))))
#+end_src

*** call custom agenda directly :command:org:agenda:
:PROPERTIES:
:ID:       bb813af0-118a-49ff-ae69-4d4995dadcac
:END:

I don't like the org mode agenda dispatcher--or any of org-mode's interfaces to
be exact. Therefore, I define a function I can use instead.

#+begin_src emacs-lisp
(defun xl/org-agenda ()
  (interactive)
  (org-agenda nil "c"))
#+end_src

** org refile :refile:
:PROPERTIES:
:ID:       9999ac00-f663-43ff-a708-3d7c90d3dc21
:END:

*** DOC org-refile
:PROPERTIES:
:ID:       6dfc0415-2945-4259-a782-b569fcb397ea
:END:

=org-refile= is a built-in package that.

#+begin_src emacs-lisp
(use-package org-refile
  :idle-require t
  :set
  (org-refile-use-outline-path            . 'file)
  (org-refile-allow-creating-parent-nodes . t)
  (org-reverse-note-order                 . t)
  (org-outline-path-complete-in-steps     . nil))
#+end_src

*** TODO allow refiling to any org file in Emacs dir :org:refile:xl:command:
:PROPERTIES:
:ID:       712d53c5-f4db-4968-b78f-0ab407b33814
:END:

#+begin_src emacs-lisp
(defun org/refile-to-emacs-config ()
  "Refile to any file in my emacs config."
  (interactive)
  (let ((org-refile-targets))
    (callf2 cl-adjoin (cons (xl-tangle-files) (cons :level 0)) org-refile-targets)
    (call-interactively #'org-refile)))
#+end_src

*** TODO refile in current buffer :command:org:refile:
:PROPERTIES:
:ID:       c24b2065-4533-4e43-80a9-c1b2c891ead8
:END:

#+begin_src emacs-lisp
(defun org/refile-to-current-file (arg &optional file)
  "Refile heading at point to some other heading in current file."
  (interactive "P")
  (let ((org-refile-targets `((,(buffer-file-name) :maxlevel . 10)))
	(org-refile-use-outline-path t)
	(selectrum-should-sort nil)
        (org-refile-keep arg)
        current-prefix-arg)
    (call-interactively #'org-refile)))
#+end_src

** org-goto
:PROPERTIES:
:ID:       900250ad-ed09-4000-ab1c-be9f4d461951
:END:

#+begin_src emacs-lisp
(use-package org-goto
  :gadvice (org-goto-location . suppress-delete-windows))
#+end_src

** ox
:PROPERTIES:
:ID:       5f8eac7d-cc1f-4bba-bd65-77ead98c8e0c
:END:

This package stands for "org-export".

#+begin_src emacs-lisp
(use-package ox
  :gadvice (org-export--dispatch-ui . suppress-delete-windows))
#+end_src

** org-id
:PROPERTIES:
:ID:       95f2a096-2cf4-4634-aa32-13f00b31ea19
:END:

=org-id= is a built-in package that creates that provides tools for creating and
storing universally unique IDs. This is primarily used to disguish and
referenance org headlines.

#+begin_src emacs-lisp
(use-package org-id
  :idle-require t
  :hook (org-insert-heading-hook . org-id-get-create)
  :set
  (org-id-locations-file-relative . t)
  (org-id-link-to-org-use-id      . 'create-if-interactive-and-no-custom-id)
  (org-id-locations-file          . (concat XL-CACHE-DIR "org-id-locations"))
  (org-id-files                   . (list (f-full "~/README.org"))))
#+end_src

** asthetic :asthetic:
:PROPERTIES:
:ID:       f17ad3f4-3f21-49e2-a078-37304aad5138
:END:

*** org-superstar
:PROPERTIES:
:ID:       c4428756-a804-47e8-9586-f63b82dd1561
:END:

#+begin_src emacs-lisp
(use-package org-superstar
  :hook org-mode-hook
  :set
  (org-superstar-leading-bullet     . ?\s)
  (org-superstar-special-todo-items . t))
#+end_src

*** org-fancy-priorities
:PROPERTIES:
:ID:       c4ff4407-774c-4028-bb9d-01412fdfc8d2
:END:

#+begin_src emacs-lisp
(use-package org-fancy-priorities
  :hook org-mode-hook)
#+end_src

*** org-pretty-tags
:PROPERTIES:
:ID:       7f024968-89ea-4e24-90a9-63771d8342b3
:END:

#+begin_src emacs-lisp
(use-package org-pretty-tags
  :hook org-mode-hook)
#+end_src

*** org-babel-hide-markers-mode
:PROPERTIES:
:ID:       a7b3c769-985d-4ed1-90ec-f4923275ecd6
:END:

#+begin_src emacs-lisp
(use-package org-babel-hide-markers-mode)
#+end_src

*** org-link-minor-mode
:PROPERTIES:
:ID:       25b93a1f-b105-47aa-9647-5015d23a4ac3
:END:

This is a minor mode for displaying links in non-org buffers.

#+begin_src emacs-lisp
(use-package org-link-minor-mode
  :hook outshine-mode-hook)
#+end_src

** org-toc
:PROPERTIES:
:ID:       aca910e9-364f-4631-a7eb-d7d6275b6472
:END:

This package creates a table of contents for your org file at the first headline
with the tag =:TOC:= on it. As you might have guessed [[helpvar:toc-org-max-depth][toc-org-max-depth]] is the
maximum dept at which toc will make the table of contents.

#+begin_src emacs-lisp
(use-package toc-org
  :hook org-mode-hook
  :set
  (toc-org-max-depth . 2))
#+end_src

** org-babel
:PROPERTIES:
:ID:       bac221d6-ab49-425f-8f89-d2bf741d3b3d
:END:

As I've mentioned, org-babel is increadibly slow. So slow that I don't think
even increasing the gc-cons-threshold will help enough. But here goes nothing.

#+begin_src emacs-lisp
(use-package ob-tangle
  :gc-pause org-babel-tangle)
#+end_src

* completion :completion:
:PROPERTIES:
:ID:       192b8e36-eb69-4439-bc6f-b97cb336ea2a
:END:

** marginalia
:PROPERTIES:
:ID:       0ce9957b-8805-4b2b-b5cb-52dc425a3dee
:END:

Marginalia adds descriptions to various commands.

#+begin_src emacs-lisp
(use-package marginalia
  :hook emacs-startup-hook
  :set
  (marginalia-annotators . '(marginalia-annotators-heavy marginalia-annotators-light nil)))
#+end_src

** orderless
:PROPERTIES:
:ID:       9702810e-2013-4c41-ba12-0b55de6ceb38
:END:

#+begin_src emacs-lisp
(use-package orderless
  :commands orderless-filter orderless-highlight-matches
  :set
  (selectrum-refine-candidates-function    . #'orderless-filter)
  (selectrum-highlight-candidates-function . #'orderless-highlight-matches))
#+end_src

** prescient :cache:
:PROPERTIES:
:ID:       4445c814-9899-4d54-affe-0cee38642690
:END:

This package.

#+begin_src emacs-lisp
(use-package prescient
  :idle prescient--save
  :set
  (prescient-save-file . (concat XL-CACHE-DIR "prescient-save-file"))
  :config
  (prescient-persist-mode))
#+end_src

** selectrum :selectrum:
:PROPERTIES:
:ID:       f8a9cdba-a4a9-42aa-a505-e88ad0b4114d
:END:

Selectrum is another completion framework. It distinguishes itself from the rest
by striving to work with the built-in emacs [[helpfn:completing-read][completing-read]] instead of replacing
it like [[https://github.com/emacs-helm/helm][helm]] and [[https://github.com/emacs-helm/helm][ivy]] do. It promises to work with the existing Emacs framework
instead of replacing it as does Ivy and Helm. :recycle:

*** selectrum-prescient :cache:
:PROPERTIES:
:ID:       70668ed8-9c83-42d2-8dce-d8f7de923569
:END:

The variable names can get really long, no? :joy: Maybe it's better to have sort
of a =:nameless-set= keyword that implies a namespace the same as a package. :bulb:

#+begin_src emacs-lisp
(use-package selectrum-prescient
  :hook selectrum-mode-hook
  :set
  (selectrum-preprocess-candidates-function . #'selectrum-prescient--preprocess))
#+end_src

*** lettered candidate index :selectrum:
:PROPERTIES:
:ID:       aae96baa-4acb-43cd-9d1d-0106abc762fd
:END:

When the variable [[helpvar:selectrum-show-indices][selectrum-show-indices]] is set to this function, selectrum
displays letters starting at =a= to [[helpvar:selectrum-num-candidates-displayed][selectrum-num-candidates-displayed]] times
down the alphabet. Fun fact, I actually contributed this feature to selectrum. :confetti-ball:

#+begin_src emacs-lisp
(defun selectrum%show-letter-index-fn (i)
  "Return letter corresponding to index."
  (format "%c " (+ 97 (% (1- i) selectrum-num-candidates-displayed))))
#+end_src

*** stop selectrum filtering and highlight
:PROPERTIES:
:ID:       a6720cdc-9d51-463b-9ffe-f9341c6bd967
:END:

#+begin_src emacs-lisp
(defun! inhibit-filtering-and-highlighting (orig-fn &rest args)
  "Don't let `selectrum-prescient' filter or highlight. "
  (:around selectrum-prescient-mode)
  (let ((selectrum-refine-candidates-function selectrum-refine-candidates-function)
	(selectrum-highlight-candidates-function selectrum-highlight-candidates-function))
    (apply orig-fn args)))
#+end_src

*** bindings :bind:
:PROPERTIES:
:ID:       97dccbf9-4ffd-4191-87e6-813bc99c3df7
:END:

#+begin_src emacs-lisp
(bind!
  (:map selectrum-minibuffer-map)
  (:ie "C-o" #'selectrum-submit-exact-input)
  (:ie "TAB" #'selectrum-next-candidate)
  (:ie "C-k" #'selectrum-previous-candidate)
  (:ie "C-j" #'selectrum-next-candidate)
  (:ie "C-;" #'selectrum-insert-current-candidate)
  (:ie "C-l" #'selectrum/mark-candidate)
  (:ie [backtab] #'selectrum-previous-candidate))
#+end_src

*** show indicators :interface:completion:
:PROPERTIES:
:ID:       d0d61c43-88cd-49ed-bd1a-515405c2fa94
:END:

I want to select candidates efficiently. For me this means not having to press
=C-j= multiple times to reach a candidate that's lower in the list (imagine the
number of indices displayed is 15 and the candidate I want is the 14th one). To
address this I create this function. It displays letters next to the candidates.

#+begin_src emacs-lisp
(defun selectrum%select-candidate-by-letter ()
  "Choose selectrum candidate by letter."
  (interactive)
  (let ((selectrum-show-indices #'selectrum%show-letter-index-fn))
    (selectrum--update)
    (alet (read-key)
      (unless (= it 27)
	(selectrum-select-current-candidate (- (1+ it) 97))))))

(bind!
  (:map selectrum-minibuffer-map)
  (:ie "," #'selectrum%select-candidate-by-letter))
#+end_src

*** consult-selectrum
:PROPERTIES:
:ID:       1620151c-77c9-4fe3-a1df-e9041ceca29d
:END:

If I don't include this, I get an.

#+begin_src emacs-lisp
(use-package consult-selectrum
  :after (consult)
  :demand t)
#+end_src

*** selectrum
:PROPERTIES:
:ID:       6e670980-7794-4505-a285-184416a5b377
:END:

In contrast, any command defined via completing-read should work consistently with
selectrum and its provided features.

Because helm and ivy replace the existing framework, it means that whenever you
want a command be capable of using all of helm or ivy's features, you need to
define it their way. Otherwise, there's no guarantee their features will work at
least any features besides the basic choosing of a single candidate. That's a
big reason why there are helm and ivy packages (there's 216 helm packages and 42
ivy packages in [[helpfn:straight-use-package][straight-use-package]] completion): many of those packages are just ivy and
helm wrappers around existing commands.

#+begin_src emacs-lisp
(use-package selectrum
  :hook emacs-startup-hook
  :set
  (selectrum-max-window-height        . 15)
  (selectrum-num-candidates-displayed . 15)
  (selectrum-fix-vertical-window-height . 15)
  (selectrum-fix-minibuffer-height    . t)
  (selectrum-should-sort-p            . t)
  (selectrum-count-style              . 'matches))
#+end_src

** company
:PROPERTIES:
:ID:       5579b8d8-9778-4b2d-a56f-ec43754a8d18
:END:

*** company
:PROPERTIES:
:ID:       5e5393d9-9f58-45be-9ecc-1bc9f0316379
:END:

#+begin_src emacs-lisp
(use-package company
  :hook prog-mode-hook
  :set
  (company-tooltip-align-annotations . t)
  (company-minimum-prefix-length     . 1)
  (company-minimum-prefix-length     . 1)
  (company-dabbrev-downcase          . nil)
  (company-require-match             . 'never)
  (company-tooltip-limit             . 14)
  (company-show-numbers              . t)
  (company-idle-delay                . 0.15)
  (company-frontends                 . '(company-pseudo-tooltip-frontend)))
#+end_src

*** bindings
:PROPERTIES:
:ID:       ba170d95-7d86-4827-af6b-dc5fd4c1b7e5
:END:

#+begin_src emacs-lisp
(bind!
  (:map company-active-map)
  ([tab]     #'company-select-next)
  ([backtab] #'company-select-previous)
  ("C-k"     #'company-select-previous)
  ("C-j"     #'company-select-next))
#+end_src

*** determining which modes are active
:PROPERTIES:
:ID:       b8603ca5-9a24-4684-a75b-e0c3845bfff0
:END:

[[https://stackoverflow.com/questions/1511737/how-do-you-list-the-active-minor-modes-in-emacs][listing active minor modes]]

#+begin_src emacs-lisp
(defun xl-active-minor-modes ()
  "Return active minor modes in current buffer."
  (-select (-andfn #'boundp #'symbol-value) minor-mode-list))
#+end_src

*** backends-alist
:PROPERTIES:
:ID:       dac0a998-e1b1-424f-8c40-e1bc19843153
:END:

#+begin_src emacs-lisp
(defvar company:backend-alist
  '((text-mode :derived (company-dabbrev company-ispell))
    (prog-mode :derived ((:separate company-capf company-yasnippet))))
  "An alist modes to company backends.")
#+end_src

*** initialize backends
:PROPERTIES:
:ID:       4e82e869-b144-44aa-bc19-bb58b8c5ff2a
:END:

When the user

#+begin_src emacs-lisp
(defhook! setup-company-backends (company-mode-hook)
  "Set `company-backends' for the current buffer."
  (alet (company:backends-for-mode major-mode)
    (xl-log "set up %S backends: %S" major-mode it)
    (set (make-local-variable 'company-backends) it)))
#+end_src

*** get backends
:PROPERTIES:
:ID:       282a2c16-ae5f-4d81-acaa-8d60fb24e762
:END:

#+begin_src emacs-lisp
(cl-defun company:backends-for-mode (&optional (current-major-mode major-mode))
  "Return a list of company backends for major-mode."
  (loopy (with (active-minor-modes (xl-active-minor-modes)))
	 (list (mode type backends) company:backend-alist)
	 (expr derived-p (and (eq type :derived) (derived-mode-p mode)))
	 (expr mm-enabled-p (or (eq current-major-mode mode)
				(and (boundp mode) (symbol-value mode))))
	 (expr active-minor-mode-p (member mode active-minor-modes))
	 (cond ((and (eq type :only) (or mm-enabled-p active-minor-mode-p))
		(return backends))
	       ((or (or derived-p (and (eq type :exact) mm-enabled-p))
		    active-minor-mode-p)
		(append new-backends backends)))))
#+end_src

*** company-prescient
:PROPERTIES:
:ID:       be4bc19d-a25c-4e2d-9f12-5d2946bc9931
:END:

[[https://github.com/raxod502/prescient.el][company-prescient]] is the same as =prescient= but for =company= instead of =ivy=.

#+begin_src emacs-lisp
(use-package company-prescient
  :hook company-mode-hook)
#+end_src

*** close company on escape
:PROPERTIES:
:ID:       a880c155-b860-4880-840d-4a891b4668c4
:END:

#+begin_src emacs-lisp
(defhook! close-tooltip (xl-escape-hook)
  "Close company tooltip."
  (when (and (boundp 'company-mode) (eq company-mode t))
    (company-abort)
    t))
#+end_src

** bind completion at point :bind:
:PROPERTIES:
:ID:       3b301d8b-624f-440c-a645-dfec105d9859
:END:

#+begin_src emacs-lisp
(bind! (:ie "TAB" #'completion-at-point))
#+end_src

** yasnippet
:PROPERTIES:
:ID:       611fa6f5-d889-4399-a090-37aeb043cd13
:END:

*** yasnippet
:PROPERTIES:
:ID:       41958449-b3b1-4c5b-915a-7cef7c5aa41d
:END:

#+begin_src emacs-lisp
(use-package yasnippet
  :hook (prog-mode-hook . yas-minor-mode-on)
  :set
  (yas-snippet-dirs . (list (concat XL-CACHE-DIR "snippets/")))
  (yas-verbosity . (if xl-debug-p 3 0))
  (yas-indent-line . 'auto)
  (yas-prompt-functions . '(yas-completing-prompt yas-ido-prompt))
  (yas-use-menu . nil)
  (yas-triggers-in-field . t)
  :config
  (delq #'yas-dropdown-prompt yas-prompt-functions))
#+end_src

*** don't interfere with yasnippet bindings
:PROPERTIES:
:ID:       2c359813-e928-4a2b-982e-b722bf44fac7
:END:

#+begin_src emacs-lisp
(defafter! dont-interfere-with-yasnippet-bindings (smartparens yasnippet)
  "Don't interfere with yasnippet bindings."
  (advice-add #'yas-expand :before #'sp-remove-active-pair-overlay))
#+end_src

*** ensure yasnippet directories
:PROPERTIES:
:ID:       bf48e5dd-32ba-4141-a26c-a5e549e7d878
:END:

#+begin_src emacs-lisp
(defafter! ensure-yasnippet-dirs (yasnippet)
  "Ensure that yasnippet dirs exist."
  (iter (each elt yas-snippet-dirs)
	(expr dir (if (symbolp elt) (symbol-value elt) elt))
	(mkdir dir t)))
#+end_src

*** yasnippet-snippets
:PROPERTIES:
:ID:       57af5709-1597-4e3e-b895-77c17285f64d
:END:

#+begin_src emacs-lisp
(use-package yasnippet-snippets)
#+end_src

** consult
:PROPERTIES:
:ID:       921ce22e-59ae-4de1-bef0-66a20e320df5
:END:

=consult= is a package that's akin to =counsel=. It's a library of generally
useful functions which are written in such a way that they can be work across
all the completion frameworks.

#+begin_src emacs-lisp
(use-package consult
  :gc-pause consult-outline consult-line
  :set
  (consult-preview-key . nil)
  :config
  (bind! ([remap switch-to-buffer] #'consult-buffer)))
 #+end_src

* editing :edit:
:PROPERTIES:
:ID:       f10c1865-13ad-47c9-b9b2-ec6533af62f3
:END:

** TODO easymotion :evil:edit:navigation:
:PROPERTIES:
:ID:       f2736330-20ab-4ffd-b7d8-8ea74e619857
:header-args: :tangle no
:END:

=easymotion= is an Emacs package that allows you to move from one character to
another.

*** TODO evil-easymotion
:PROPERTIES:
:ID:       9be10754-3975-49d4-afa7-08a122161c19
:END:

#+begin_src emacs-lisp
(use-package evil-easymotion
  :set
  (evilem-keys . (number-sequence ?a ?z))
  (evilem-style . 'at))
#+end_src

*** convenience macro
:PROPERTIES:
:ID:       bf5a38d5-3ccf-42f0-90f6-910312994163
:END:

#+begin_src emacs-lisp
(defmacro evilem%defmotion! (name args &rest body)
  (declare (indent defun))
  `(defun! ,name ,args (:evilem t) ,@body))
#+end_src

*** custom motions
:PROPERTIES:
:ID:       a9b0a117-d409-4559-b60f-07dd8464b52a
:END:

The following motions are variants of existing motions which I find more useful.

**** dwim begin word
:PROPERTIES:
:ID:       80304718-0aa7-448c-9014-4e3a1c17d0e6
:END:

This is very similar to what =syntax-forward=, but it does not include the
newline.

#+begin_src emacs-lisp
(after! evil-easymotion
  (bind! (:n "w" #'evilem%forward-word-begin))

  (evilem%defmotion! forward-word-begin ()
    (:scope 'page)
    (:initial-point #'point-min)
    (alet (rx (or (seq bol (1+ white))
		  (seq (1+ white))
		  (seq bol (1+ punct))
		  (seq (1+ white) (1+ punct))
		  (seq (1+ punct)))
	      word)
      (save-match-data
	(when (re-search-forward it nil t nil)
	  (backward-char))))))
#+end_src

**** dwim begin WORD
:PROPERTIES:
:ID:       191343fb-0cfb-43e7-a14c-6c59551d1b7c
:END:

#+begin_src emacs-lisp
(after! evil-easymotion
  (bind! (:n "W" #'evilem%forward-word-begin))

  (evilem%defmotion! forward-WORD-begin ()
    (:scope 'page)
    (:initial-point #'point-min)
    (alet (rx (or (seq bol (1+ white))
		  (seq (1+ white))
		  (seq bol (1+ punct))
		  (seq (1+ white) (1+ punct)))
	      word)
      (save-match-data
	(when (re-search-forward it nil t nil)
	  (backward-char))))))
#+end_src

**** dwim end word
:PROPERTIES:
:ID:       9b970748-4462-413b-9966-c054bfb17352
:END:

#+begin_src emacs-lisp
(bind! (:n "e" #'evilem%forward-word-end))

(evilem%defmotion! forward-word-end ()
  (:scope 'page)
  (:initial-point #'point-min)
  (alet (rx (1+ alnum))
    (save-match-data
      (awhen (save-excursion (incf (point)) (re-search-forward it nil t nil))
	(setf (point) (1- (match-end 0)))))))
#+end_src

**** dwim end WORD
:PROPERTIES:
:ID:       46a63255-47e0-4b2d-bdda-96b393f53dd1
:END:

#+begin_src emacs-lisp
(bind! (:n "E" #'evilem%forward-WORD-end))

(evilem%defmotion! forward-WORD-end ()
  (:scope 'page)
  (:initial-point #'point-min)
  (alet (rx (1+ alnum))
    (save-match-data
      (awhen (save-excursion (incf (point)) (re-search-forward it nil t nil))
	(setf (point) (1- (match-end 0)))))))
#+end_src

**** org headline motion :org:
:PROPERTIES:
:ID:       d9ea0c1a-80b3-46ff-b319-6b89b90cb295
:END:

#+begin_src emacs-lisp
(evilem%defmotion! headline-start (org)
  (:scope 'page)
  (:initial-point #'point-min)
  (save-match-data (re-search-forward (rx bol (1+ "*") (1+ white)))))
#+end_src

*** TODO add evil easymotions :evil:bind:
:PROPERTIES:
:ID:       4696c5ad-3c95-43fc-8718-b579bf6a7242
:END:

#+begin_src emacs-lisp
(after! easymotion
  (evilem-make-motion my-evilem-motion-find-char #'evil-find-char :initial-point #'point-min :scope 'page))
#+end_src

** undo-tree
:PROPERTIES:
:ID:       35c9eb5f-6d6d-4011-89a2-38aa8b2211f7
:END:

#+begin_src emacs-lisp
(use-package undo-tree)
#+end_src

** DOC paragraph :write:
:PROPERTIES:
:ID:       aeb973cb-41ad-4891-94b2-d0ea5c1baa33
:END:

#+begin_src emacs-lisp
(use-package paragraph
  :set
  (sentence-end-double-space . nil))
#+end_src

** edit-indirect :interface:extension:
:PROPERTIES:
:ID:       786b11a6-561b-4793-9c6c-f7630aba3774
:END:

=edit-indirect= is a package that provides a means to edit text in an indirect
buffer. It's the same concept as org-src buffers but is not tied to org-mode.

*** edit-indirect
:PROPERTIES:
:ID:       d08adcae-ab17-41f1-94c9-1d9a8cb385d7
:END:

#+begin_src emacs-lisp
(use-package edit-indirect :commands edit-indirect)
#+end_src

*** editing org descriptions
:PROPERTIES:
:ID:       bdabe0b9-4116-423b-9fc0-049651bed58a
:END:

This headline contains customizations and extensions to =edit-indirect= so that I
can use it to edit org descriptions in the same way that we edit source blocks.

There are two cases when editing a description. There's the case of an existing
description and there's the case of a new one.

**** init

#+begin_src emacs-lisp
(use-package org-edit-paragraph
  :rule ("bottom" "org description" :newname "\\*Org Desc - .+")
  :xl-config
  (after! (evil evil-surround)
    (xl-hook-add 'org-edit-paragraph:mode-hook #'evil-surround-mode)))
#+end_src

**** description bounds
:PROPERTIES:
:ID:       74367212-cbd0-4871-94d5-24980e997bd7
:END:

#+begin_src emacs-lisp
(defun org-edit-paragraph:bounds ()
  "Return the bounds of description at headline.
If there is no existing description return nil."
  (interactive)
  (let* ((parse-tree (org-ml-parse-subtree-at (point)))
	 (elements '(headline section property-drawer src-block paragraph))
	 (nodes (->> (org-element-map parse-tree elements #'identity)
		     (-split-when (fn! (eq (org-element-type <elt>) 'headline)))
		     (car))))
    (aif (car (-split-when (fn! (not (eq (org-element-type <elt>) 'paragraph))) nodes))
	(cons (org-element-property :begin (-first-item it))
	      (org-element-property :end (-last-item it)))
      (-let* ((section (-first (fn! (eq (org-element-type <elt>) 'section)) nodes))
	      ((property-drawer others) (org-element-contents section)))
	(alet (org-element-property :end (if others property-drawer section))
	  (cons it it))))))
#+end_src

**** default post blanks
:PROPERTIES:
:ID:       117478bf-3759-4a00-b738-9b1aad99ed54
:END:

It is my preference to have one blank line after a description--or any org item
for that matter. I just find it much more readable and less cluttered.

#+begin_src emacs-lisp
(defvar org-edit-paragraph:default-post-blanks 1
  "Number of blank lines that should follow a description.")
#+end_src

**** hooks
:PROPERTIES:
:ID:       6ab3a2cc-17aa-4166-aa3f-8627afe40c1a
:END:

=edit-indirect= has hooks for whenever you want to do a quick thing.

***** goto last non-white
:PROPERTIES:
:ID:       f9afdc3d-ceea-4e9e-a986-9f6bb7e860f6
:END:

Most of the time I will want to add to the end of a description. Therefore, I
want the cursor to start at the last non-whitespace character of the
description.

#+begin_src emacs-lisp
(defun org-edit-paragraph:goto-last-non-white ()
  (goto-char (point-max))
  (skip-chars-backward "\n\s"))
#+end_src

***** add newlines in the beginning
:PROPERTIES:
:ID:       46917f50-8e0b-4c29-8f9b-1aab7e0e9550
:END:

In the case where there was no existing description, we need to add newlines to
the description buffer so that if we end up committing a change the description
will be placed properly in relation to what's below it. This hook is designed to
make sure this happens.

#+begin_src emacs-lisp
(defun org-edit-paragraph:add-newlines ()
  "Add newlines."
  (save-excursion
    (--dotimes (1+ org-edit-paragraph:default-post-blanks)
      (insert "\n"))))
#+end_src

***** maybe remove newline
:PROPERTIES:
:ID:       cfa12a0f-fd23-4684-bb10-b86b2e4e5c58
:END:

When you open a description buffer and close it again, you'd expect the source
buffer to stay the same--and you should expect this. Since we add newlines to
the description buffer when there's no existing description, we could
inadvertently edit the source buffer in this case. So this hook is to remove any
newlines added in the case that nothing was changed.

#+begin_src emacs-lisp
(defun org-edit-paragraph:maybe-remove-newline ()
  "Remove newline if that's all there is."
  (when (and (loopy (seq char (buffer-string)) (always (= 10 char)))
	     (= (1+ org-edit-paragraph:default-post-blanks) (length (buffer-string))))
    (erase-buffer)))
#+end_src

**** define a minor mode for editing descriptions
:PROPERTIES:
:ID:       8775acdc-0389-40af-a5f4-e74c78144944
:END:

The way I've set things up editing descriptions is it's own "thing". I'm going
to be adding hooks and maybe even binding keys with editing descriptions in mind.
Therefore, I think it's worthy to give it it's own mode.

#+begin_src emacs-lisp
(define-minor-mode org-edit-paragraph:mode
  "Mode for editing org descriptions.")
#+end_src

**** requirements for editing descriptions
:PROPERTIES:
:ID:       9a789e79-84b8-4415-b152-e11fca786587
:END:

The edit description function requires =org-ml= and =edit-indirect=. I don't
know if this is the best way to declare these dependencies. It certaintly is
efficient.

#+begin_src emacs-lisp
(xl-load-before-call 'org-ml #'org/dwim-edit-description)
(xl-load-before-call 'edit-indirect #'org/dwim-edit-description)
#+end_src

**** edit description
:PROPERTIES:
:ID:       3a7da5c8-f445-4592-b0c0-7fbff3be912e
:END:

It is uncough to edit the text of the buffer when we're not commit it--even
worse to have to edit it again afterwards if we don't end up committing
anything. No, instead we should work with the edit indirect buffer.

We need to make sure that we respect [[helpvar:edit-indirect-after-creation-hook][edit-indirect-after-creation-hook]] by doing
our description management stuff before anything is done in that hook. It may be
worth it to consider creating a hook specifically for org descriptions.

#+begin_src emacs-lisp
(defun org/dwim-edit-description ()
  (interactive)
  (-let* (((beg . end) (org-edit-paragraph:bounds))
	  (was-empty-p (= beg end)))
    (unless beg (user-error "No description at headline."))
    (let ((edit-indirect-after-creation-hook edit-indirect-after-creation-hook)
	  (headline (org-get-heading t t t t)))
      (when was-empty-p
	(add-hook 'edit-indirect-after-creation-hook #'org-edit-paragraph:add-newlines 0))
      (add-hook 'edit-indirect-after-creation-hook #'org-edit-paragraph:goto-last-non-white 0)
      (with-current-buffer (edit-indirect-region beg end)
	(rename-buffer (format "*Org Desc - %s*" headline) t)
	(org-edit-paragraph:mode 1)
	(add-hook 'edit-indirect-before-commit-hook
		  #'org-edit-paragraph:maybe-remove-newline nil t)
	(select-window (display-buffer (buffer-name)))))))
#+end_src

**** evil support
:PROPERTIES:
:ID:       f270092b-19ca-40ba-87aa-77b3d314c9a6
:END:

When I open a buffer for editing a description it is very likely that I'll end
up appending more commentary to the existing description. I think it will save
me more time making that common case easier than the cost for the few situations
where I don't do this.

#+begin_src emacs-lisp
(after! evil
  (xl-hook-add 'org-edit-paragraph:mode-hook #'evil-insert-state))
#+end_src

**** custom hooks
:PROPERTIES:
:ID:       240acf8a-621e-4e44-9c11-250b70a0e3dc
:END:

#+begin_src emacs-lisp
(dolist (mode (list #'auto-capitalize-mode
		    #'aggressive-fill-paragraph-mode
		    #'org-link-minor-mode))
  (xl-hook-add 'org-edit-paragraph:mode-hook mode))
#+end_src

*** bindings inside edit-indirect
:PROPERTIES:
:ID: 42992d1e-5d65-4570-ba96-02b3be31b97b
:END:

I want quick, convenient bindings I can use to abort or commit (which is
=edit-indirect= lingo for writing the contents of the buffer back into its source
file, see [[helpfn:edit-indirect-commit][edit-indirect-commit]].

#+begin_src emacs-lisp
(bind-localleader!
 (:map edit-indirect-mode-map)
 ("," #'edit-indirect-commit)
 ("c" #'edit-indirect-commit)
 ("a" #'edit-indirect-abort))
#+end_src

** separedit :interface:
:PROPERTIES:
:ID:       07021099-6cea-4016-929b-d9310ea305f8
:END:

#+begin_src emacs-lisp
(use-package separedit :commands separedit)
#+end_src

** writing :write:
:PROPERTIES:
:ID:       ec6f755f-5bce-4bff-a603-d4725e097cc5
:END:

*** auto-capitalize :write:
:PROPERTIES:
:ID:       4ddfacc1-a25e-466e-ab6b-2a5ec306f3be
:END:

[[https://github.com/emacsmirror/auto-capitalize][auto-capitalize]] automatically capitalizes the first word of a sentence for me.
It will also upcase any word I add to [[helpvar:auto-capitalize-words][auto-capitalize-words]].

#+begin_src emacs-lisp
(use-package auto-capitalize
  :hook text-mode-hook
  :set
  (auto-capitalize-words . '("I" "English" "Emacs")))
#+end_src

*** plural :write:
:PROPERTIES:
:ID:       bf2ed9b7-144c-4d4b-92ae-74c93dfc6db5
:END:

This package determines whether a noun is plural and provides a function to
convert a singular noun to a plural one. For example ~(plural-pluralize
"goose")~ returns ~"geese"~.

My intended use for this package is to help automate prompts, docstrings or the
like that concern N number of things, where N could be 1 or more things.

#+begin_src emacs-lisp
(use-package plural
  :commands plural-make-plural
  :xl-config
  (push '("\\`is\\'" . "are") plural-knowledge)
  (push '("\\`thas\\'" . "those") plural-knowledge)
  (push '("\\`this\\'" . "these") plural-knowledge))
#+end_src

*** spell-number :write:spell:
:PROPERTIES:
:ID:       8bf270a6-6003-4430-bb03-0b665d5a162f
:END:

#+begin_src emacs-lisp
(use-package spell-number
  :set
  (spelln-language          . 'english-us)
  (spelln-country           . 'united-states)
  (spelln-period-character  . ?,)
  (spelln-decimal-character . ?.))
#+end_src

** backups and saving :backup:
:PROPERTIES:
:ID:       edcf4a17-5554-4985-8210-322a5fa3dc99
:END:

*** set undo-tree :evil:
:PROPERTIES:
:ID:       e54f42d0-f146-4816-8226-8798d0746533
:END:

#+begin_src emacs-lisp
(defafter! set-evil-undo-system (evil)
  (setq evil-undo-system 'undo-tree))
#+end_src

*** super-save :edit:
:PROPERTIES:
:ID:       684e788c-6db9-4e6e-826b-d4871c0a3f90
:END:

The default auto-saving feature in emacs saves after a certain number of
characters are typed (see [[helpvar:auto-save-interval][auto-save-interval]]). The problem is that if you're in
the middle of typing and you've just hit the number of characters that trigger a
save, you could experience a lag, particularly if you are dealing with a large
file being saved. Instead of doing this, [[https://github.com/bbatsov/super-save][super-save]] saves buffers during idle
time and after certain commands like [[helpfn:switch-to-buffer][switch-to-buffer]] (see [[helpvar:super-save-triggers][super-save-triggers]]).
Note that this is the same strategy employed by [[id:c550f82a-9608-47e6-972b-eca460015e3c][idle-require]] to load packages.
Saving files like this reduces the likelihood of user delays.

#+begin_src emacs-lisp
(use-package super-save
  :before-call find-file
  :set
  (super-save-auto-save-when-idle . t)
  (super-save-idle-duration       . 5))
#+end_src

**** vc-hook
:PROPERTIES:
:ID:       a8dcb1f6-05a0-46cb-95b5-1d0cd0ad4467
:END:

#+begin_src emacs-lisp
(use-package vc-hooks
  :set
  (vc-follow-symlinks . t)
  (vc-follow-link     . t))
#+end_src

*** version control :vc:
:PROPERTIES:
:ID:       3020da29-778d-4e34-8f9d-286b398df995
:END:

**** quit :git:
:PROPERTIES:
:ID:       8014eb34-416a-4c79-b21a-7960f77da75e
:END:

#+begin_src emacs-lisp
(defun magit/quit ()
  "Clean up magit buffers after quitting `magit-status'."
  (interactive)
  (let ((buffers (magit-mode-get-buffers)))
    (magit-restore-window-configuration)
    (mapc #'kill-buffer buffers)))
#+end_src

**** git-auto-commit-mode :git:
:PROPERTIES:
:ID:       00a518e9-56ae-4c0b-b2cd-518fb4c5d201
:END:

To avoid losing information. You should commit often in git--like every 10
seconds or so. Obviously doing this manually on the command line (or even on
[[id:d6088ed3-417a-44e8-822b-ce4743f497d0][magit]]) every time is a pain. This package commits your changes every time
you save your file--which for me is all the time because I use [[id:bd455e73-4035-49b9-bbdf-3d59d4906c97][super-save]].

***** git-auto-commit-mode
:PROPERTIES:
:ID:       8a46cee4-624c-4440-8b99-c6b34d356a6b
:END:

#+begin_src emacs-lisp
(use-package git-auto-commit-mode
  :commands git-auto-commit-mode
  :set
  (gac-automatically-push-p   . nil)
  (gac-ask-for-summary-p      . nil)
  (gac-default-message        . #'gac%commit-message)
  (gac-commit-additional-flag . "-S")
  (gac-silent-message-p       . t))
#+end_src

***** commit message
:PROPERTIES:
:ID:       3f0297a0-5929-4217-a109-545a2a010473
:END:

Committing often as I recommend will inevitably result with commits that are
many bits and pieces of a change. The idea is to then squash together all
related commits for the "polished" result. With this function I create "smart"
commit messages that take advantage of the org headline structure. This makes it
easy to go back and group commits which are related. Note that this function
fails when you have a change that spans across multiple headlines (such as the
replacement of a name throughout a document). This is something I plan to
address later.

#+begin_src emacs-lisp
(defun gac%commit-message (file)
  "Return the commit message for changes to FILE."
  (format "Update %s" (f-base file)))
#+end_src

**** magit :git:
:PROPERTIES:
:ID:       820ce76e-53e4-4be8-9cad-3bf35efeefd7
:END:

#+begin_src emacs-lisp
(use-package magit
  :idle-require f s with-editor git-commit package eieio lv transient
  :gc-pause magit-status magit-commit
  :rule ("bottom" "magit" :newname "magit: ")
  :hook (magit-popup-mode-hook . hide-mode-line-hook)
  :set
  (magit-completing-read-function . #'completing-read)
  (magit-diff-refine-hunk . t)
  (magit-auto-revert-mode . t))
#+end_src

**** git-commit :git:
:PROPERTIES:
:ID:       2edbbef6-dec3-4af7-a445-8a2c7b1c0397
:END:

#+begin_src emacs-lisp
(use-package git-commit
  :initial-state insert)
#+end_src

**** git-gutter+ :git:
:PROPERTIES:
:ID:       77fb81e3-29c0-4eb3-a1ff-e1bdbfa41bf2
:END:

=git-gutter= indicates which parts of a file has been modified.

#+begin_src emacs-lisp
(use-package git-gutter+
  :alias (git-commit-mode-font-lock-keywords . ignore))
#+end_src

**** evil-magit :evil:bind:git:
:PROPERTIES:
:ID:       a86e7a69-4e0a-41fd-aca7-66e514332e7f
:END:

#+begin_src emacs-lisp
(use-package evil-magit
  :silence evil-magit-init
  :before-call magit-status
  :xl-config
  (evil-magit-init)
  :set
  (evil-magit-state . 'normal))
#+end_src

** debug :debug:
:PROPERTIES:
:ID:       bd3e1752-c3d7-41cd-90e9-7b5a69716aa7
:END:

*** ert
:PROPERTIES:
:ID:       5fbf293e-84ae-4f47-bdcd-850ff552465a
:END:

#+begin_src emacs-lisp
(use-package ert
  :rule ("bottom" "ert" :newname "\\*ert\\*")
  :assume-yes ert-delete-all-tests)
#+end_src

*** ert-expectations
:PROPERTIES:
:ID:       3062b8a4-4261-49fc-9bdb-895ba75bbd19
:END:

#+begin_src emacs-lisp
(use-package ert-expectations)

(autoload 'expect "ert-expectations" nil nil 'macro)
(autoload 'expectations "ert-expectations" nil nil 'macro)
#+end_src

*** el-mock
:PROPERTIES:
:ID:       46df66b0-5820-4550-aa99-c913d3022fe1
:END:

#+begin_src emacs-lisp
(use-package el-mock)
#+end_src

*** assess
:PROPERTIES:
:ID:       cea20fcd-0c75-42dc-be7f-e9eda7b932b1
:END:

=assess= is similar to =ert-expectations=. It is a wrapper around the built in
[[][ert-deftest] that provides a cleaner syntax for writing tests.

#+begin_src emacs-lisp
(use-package assess)
#+end_src

*** bug-hunter
:PROPERTIES:
:ID:       30196ef6-7b34-4a6c-b084-8e613010abd4
:END:

=bug-hunter= is a package that automates [[https://en.wikipedia.org/wiki/Bisection_(software_engineering)][code-bisection]], the process of trying
parts of your code at a time until you find out where the bug is. You can find
the culprit of a problem by [[][code bisection].

#+begin_src emacs-lisp
(use-package bug-hunter)
#+end_src

*** ppp
:PROPERTIES:
:ID:       82dbb88a-4bce-4ca3-90fe-38cfbea7abc6
:END:

This is a pretty printer.

Sometimes you want to see what an object looks like represented as text so you
know what you're dealing with. For example, I've wanted to see what a straight
recipe looks like. The problem is by default [[][]] prints something on one
line. And to avoid long lines, emacs truncates the output so you can't even see
the whole thing.

#+begin_src emacs-lisp
(use-package ppp)
#+end_src

** expand-region :region:
:PROPERTIES:
:ID:       b76eb685-37eb-4c58-8712-6b23f2e33d3f
:END:

*** expand region bindings :keybind:edit:emacs:config:
:PROPERTIES:
:ID: 417c9c53-a776-4779-9afc-1eaa35a145c6
:END:

#+begin_src emacs-lisp
(bind!
  (:v "V" #'er/contract-region)
  (:v "v" #'er/expand-region))
#+end_src

*** quit expand region :advice:edit:emacs:config:
:PROPERTIES:
:ID:       639824e1-0dcf-46bc-98b4-c70b9c7cb2a6
:END:

#+begin_src emacs-lisp
(defadvice! quit-expand-region (:before evil-escape)
  "Properly abort an expand-region region."
  (when (memq last-command '(er/expand-region er/contract-region))
    (er/contract-region 0)))
#+end_src

*** expand region :edit:emacs:config:
:PROPERTIES:
:ID:       41a1cebc-8da8-4e5c-8258-2ce440f1af50
:END:

#+begin_src emacs-lisp
(use-package expand-region
  :commands er/expand-region er/contract-region er/mark-symbol)
#+end_src

*** expand-region :edit:emacs:config:desc:
:PROPERTIES:
:ID:       7e873fba-33ea-4720-ad79-bd8d557cc4b3
:END:

[[https://github.com/magnars/expand-region.el][expand-region]] allows me to toggle a key ("v" in my case) to select progressively
larger text objects. It's saves me keystrokes.

** DOC smartparens :parens:
:PROPERTIES:
:ID:       1c370582-6d30-44fb-a421-47885b99d110
:END:

*** DOC disable =smartparens-navigate-skip-match=
:PROPERTIES:
:ID:       512a1623-d5ec-4af4-8fc3-471f4fe3dcde
:END:

#+begin_src emacs-lisp
(defhook! disable-smartparens-navigate-skip-match (after-change-major-mode-hook)
  "Disable smartparents skip match feature."
  (setq sp-navigate-skip-match nil)
  (setq sp-navigate-consider-sgml-tags nil))
#+end_src

*** DOC config
:PROPERTIES:
:ID:       46cc632f-b577-456e-b47d-0c166a5d5663
:END:

#+begin_src emacs-lisp
(defhook! init-smartparens-config (smartparens-mode-hook)
  (require 'smartparens-config)
  (sp-local-pair 'minibuffer-inactive-mode "'" nil :actions nil))
#+end_src

*** DOC smartparens
:PROPERTIES:
:ID:       e26f4c55-9585-4544-bed6-9733d50823e7
:END:

#+begin_src emacs-lisp
(use-package smartparens
  :before-call evil-expression evil-ex
  :hook ((prog-mode eshell-mode ielm-mode) . smartparens-strict-mode)
  :set
  (sp-cancel-autoskip-on-backward-movement . nil)
  (sp-highlight-wrap-tag-overlay           . nil)
  (sp-highlight-pair-overlay               . nil)
  (sp-highlight-wrap-overlay               . nil)
  (sp-show-pair-from-inside                . t)
  (sp-show-pair-delay                      . 0.1)
  (sp-max-pair-length                      . 4)
  (sp-max-prefix-length                    . 50)
  (sp-escape-quotes-after-insert           . nil))
#+end_src

*** DOC autopairing :parens:edit:
:PROPERTIES:
:ID:       5173d780-c2ce-4e78-b1cc-0f4ffa2fde7d
:END:

#+begin_src emacs-lisp
(defhook! enable-smartparens-maybe (minibuffer-setup-hook)
  "Enable `smartparens-mode' in the minibuffer."
  (when (memq this-command '(eval-expression evil-ex))
    (smartparens-mode 1)))
#+end_src

*** DOC change one-off issue :evil:parens:
:PROPERTIES:
:ID:       284dabf8-d1a1-4d92-866c-7ebbb6885174
:END:

#+begin_src emacs-lisp
(defafter! fix-on-off-issue (evil smartparens)
  (setq sp-show-pair-from-inside t)
  (setq sp-cancel-autoskip-on-backward-movement nil)
  (setq sp-pair-overlay-keymap (make-sparse-keymap)))
#+end_src

*** DOC skipping org markup :parens:org:lisp:
:PROPERTIES:
:ID:       0c9747a6-c98a-478d-967a-d8efcf900f65
:END:

#+begin_src emacs-lisp
(defun sp%org-skip-markup (ms mb me)
  (save-excursion
    (and (progn
           (goto-char mb)
           (save-match-data (looking-back "\\sw\\|\\s_\\|\\s.")))
         (progn
           (goto-char me)
           (save-match-data (looking-at "\\sw\\|\\s_\\|\\s."))))))
#+end_src

*** DOC skip markup :parens:org:lisp:
:PROPERTIES:
:ID:       48681dfd-5d1d-4a90-bf33-e6915c87588b
:END:

#+begin_src emacs-lisp
(defun sp%skip-markup (ms mb me)
  (cond ((equal ms "'")
	 (or (sp--org-skip-markup ms mb me)
	     (not (sp-point-in-string-or-comment))))
	(t (not (sp-point-in-string-or-comment)))))
#+end_src

*** DOC disable lisp pairs in emacs-lisp-mode :parens:lisp:quote:elisp:webcode:
:PROPERTIES:
:ID:       ead6257f-42fd-4265-8006-094f23215a13
:END:
:LINKS:
https://github.com/Fuco1/smartparens/issues/286
:END:

In lisp, ='= and =`= are used for quoting. We don't want smartparens
auto-pairing them.

#+begin_src emacs-lisp
(defafter! disable-lisp-pairs (smartparens)
  "Disable auto-pairing for text used in quoting."
  (sp-local-pair sp-lisp-modes "'" nil :actions nil)
  (sp-local-pair sp-lisp-modes "`" "'" :when '(sp-in-string-p sp-in-comment-p))
  (sp-local-pair sp-lisp-modes "`" nil :skip-match #'sp%skip-markup))
#+end_src

*** DOC disable lisp pairs in minibuffer :minibuffer:parens:
:PROPERTIES:
:ID:       0cba1d65-d5f2-462b-aa91-c6b5fa8818d7
:END:

"You're likely writing lisp in the minibuffer, therefore, disable these quote
pairs, which lisps doesn't use for strings." - Doom Emacs

#+begin_src emacs-lisp
(defafter! disable-lisp-pairs (smartparens)
  "Disable auto-pairing for text used in minibuffer."
  (sp-local-pair 'minibuffer-inactive-mode "'" nil :actions nil)
  (sp-local-pair 'minibuffer-inactive-mode "`" nil :actions nil))
#+end_src

*** DOC disable overlays :evil:smartparens:parens:edit:
:PROPERTIES:
:ID:       c0088dca-9e3b-412f-ade9-d67199b0c8ca
:END:

#+begin_src emacs-lisp
(defafter! disable-smartparens-overlays (smartparens)
  (setq sp-highlight-pair-overlay nil)
  (setq sp-highlight-wrap-overlay nil)
  (setq sp-highlight-wrap-tag-overlay nil))
#+end_src

** indentation :indent:
:PROPERTIES:
:ID:       02ddb747-2a7c-4616-b6ff-a67018d79059
:END:

*** aggressive-fill-paragraph
:PROPERTIES:
:ID:       8bdaccca-a046-44c5-a41d-c0380d6fca83
:END:

Emacs is very minimal by default. Most reading this will likely be used to.

#+begin_src emacs-lisp
(use-package aggressive-fill-paragraph)
#+end_src

*** aggressive-indent
:PROPERTIES:
:ID: f1b9a36e-26e4-4305-99ae-cbcf6a90013d
:END:

[[https://github.com/Malabarba/aggressive-indent-mode][aggressive-indent]] indents portions of the text your working on as your typing
it. It's pretty smart and very convenient.

#+begin_src emacs-lisp
(use-package aggressive-indent
  :hook emacs-lisp-mode-hook)
#+end_src

** lisp
:PROPERTIES:
:ID:       d214f09b-4f68-411f-8a01-d9df69217e2b
:END:

*** lispyville :parens:
:PROPERTIES:
:ID:       120baacb-4835-4e96-a7cb-e8bb7496d7be
:END:

[[https://github.com/noctuid/lispyville][lispyville]] helps vim commands work better with lisp by providing
commands (like [[helpfn:lispyville-delete][lispyville-delete]]) which preserve parentheses.

**** lispyville
:PROPERTIES:
:ID:       fad4cb7c-ff1e-485d-99d1-f55384c26402
:END:

#+begin_src emacs-lisp
(use-package lispyville :hook emacs-lisp-mode-hook)
#+end_src

**** remappings :bind:
:PROPERTIES:
:ID:       f14083fc-13d1-41c6-9fca-eb686a1d50a3
:END:

#+begin_src emacs-lisp
(bind!
  (:map lispyville-mode-map)
  ([remap evil-yank]                 #'lispyville-yank)
  ([remap evil-delete]               #'lispyville-delete)
  ([remap evil-change]               #'lispyville-change)
  ([remap evil-yank-line]            #'lispyville-yank-line)
  ([remap evil-delete-line]          #'lispyville-delete-line)
  ([remap evil-change-line]          #'lispyville-change-line)
  ([remap evil-delete-char]          #'lispyville-delete-char-or-splice)
  ([remap evil-delete-backward-char] #'lispyville-delete-char-or-splice-backwards)
  ([remap evil-substitute]           #'lispyville-substitute)
  ([remap evil-change-whole-line]    #'lispyville-change-whole-line)
  ([remap evil-join]                 #'lispyville-join))
#+end_src

**** inner text objects :bind:
:PROPERTIES:
:ID:       f9f82ebe-5749-452f-ba49-269e60526b04
:END:

#+begin_src emacs-lisp
(bind!
 (:map evil-inner-text-objects-map)
 ("a" #'lispyville-inner-atom)
 ("l" #'lispyville-inner-list)
 ("x" #'lispyville-inner-sexp)
 ("c" #'lispyville-inner-comment)
 ("s" #'lispyville-inner-string))
#+end_src

**** outer text objects :bind:
:PROPERTIES:
:ID:       9dda9a1b-c76f-4537-9554-45ad3c77977a
:END:

#+begin_src emacs-lisp
(bind!
  (:map evil-outer-text-objects-map)
  ("a" #'lispyville-a-atom)
  ("l" #'lispyville-a-list)
  ("x" #'lispyville-a-sexp)
  ("c" #'lispyville-a-comment)
  ("s" #'lispyville-a-string))
#+end_src

**** slurp/barf :bind:
:PROPERTIES:
:ID:       7b7b0288-745d-49cd-98e0-5d6a1ba6ce82
:END:

#+begin_src emacs-lisp
(bind!
  (:map lispyville-mode-map)
  (:n ">" #'lispyville-slurp)
  (:n "<" #'lispyville-barf))
#+end_src

**** DOC escape :bind:
:PROPERTIES:
:ID:       53a208ee-4389-4edd-ad46-02cd811f8d81
:END:

=lispyville= binds escape to [[helpfn:lipyville-normal-state][lispyville-normal-state]]. So for =xl-escape-hook=
to still happen on escape, I need to add [[helpfn:evil:escape-a][evil:escape-a]] as advice to
=lispyville-normal-state=.

Sometimes =evil-normal-state= enters visual state.

#+begin_src emacs-lisp
(bind!
  (:map lispyville-mode-map)
  (:ei [escape] #'lispyville-normal-state))
#+end_src

**** additional :bind:
:PROPERTIES:
:ID:       ffe6833e-1ba2-402d-9b1a-5232168bd468
:END:

#+begin_src emacs-lisp
(bind!
  (:map lispyville-mode-map)
  (:ei "SPC" #'lispy-space)
  (:ei ";"   #'lispy-comment)
  (:nv "M-j" #'lispyville-drag-forward)
  (:nv "M-k" #'lispyville-drag-backward)
  (:nv "M-R" #'lispyville-raise-list)
  (:nv "M-v" #'lispy-convolute-sexp))
#+end_src

** rainbow-delimiters :parens:asthetic:
:PROPERTIES:
:ID:       5b58bb1c-5d3c-4f04-b4fb-c55f1588839e
:END:

[[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]] colors parentheses different colors based on level. This is a
great idea! It makes it really easy to see which parentheses go together.

#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :hook prog-mode-hook reb-mode-hook
  :set
  (rainbow-delimiters-max-face-count . 9))
#+end_src

** paren :parens:emacs:asthetic:
:PROPERTIES:
:ID:       c4d415da-a408-4e59-ac6a-c5ab17e2e32d
:END:

#+begin_src emacs-lisp
(use-package paren
  :hook (prog-mode . show-paren-mode)
  :set
  (show-paren-delay . 0))
#+end_src

** lispyville :parens:lisp:navigation:
:PROPERTIES:
:ID:       1045f310-70d7-4a69-b5f2-414947971b0f
:END:

*** lispyville
:PROPERTIES:
:ID:       fad4cb7c-ff1e-485d-99d1-f55384c26402
:END:

#+begin_src emacs-lisp
(use-package lispyville :hook emacs-lisp-mode-hook)
#+end_src

*** remappings :bind:
:PROPERTIES:
:ID:       411cb6e1-311a-458a-a241-d9b9aef45d25
:END:

#+begin_src emacs-lisp
(bind!
  (:map lispyville-mode-map)
  ([remap evil-yank]                 #'lispyville-yank)
  ([remap evil-delete]               #'lispyville-delete)
  ([remap evil-change]               #'lispyville-change)
  ([remap evil-yank-line]            #'lispyville-yank-line)
  ([remap evil-delete-line]          #'lispyville-delete-line)
  ([remap evil-change-line]          #'lispyville-change-line)
  ([remap evil-delete-char]          #'lispyville-delete-char-or-splice)
  ([remap evil-delete-backward-char] #'lispyville-delete-char-or-splice-backwards)
  ([remap evil-substitute]           #'lispyville-substitute)
  ([remap evil-change-whole-line]    #'lispyville-change-whole-line)
  ([remap evil-join]                 #'lispyville-join))
#+end_src

*** inner text objects :bind:
:PROPERTIES:
:ID:       f9f82ebe-5749-452f-ba49-269e60526b04
:END:

#+begin_src emacs-lisp
(bind!
  (:map evil-inner-text-objects-map)
  ("a" #'lispyville-inner-atom)
  ("l" #'lispyville-inner-list)
  ("x" #'lispyville-inner-sexp)
  ("c" #'lispyville-inner-comment)
  ("s" #'lispyville-inner-string))
#+end_src

*** outer text objects :bind:
:PROPERTIES:
:ID:       9dda9a1b-c76f-4537-9554-45ad3c77977a
:END:

#+begin_src emacs-lisp
(bind!
  (:map evil-outer-text-objects-map)
  ("a" #'lispyville-a-atom)
  ("l" #'lispyville-a-list)
  ("x" #'lispyville-a-sexp)
  ("c" #'lispyville-a-comment)
  ("s" #'lispyville-a-string))
#+end_src

*** slurp/barf :bind:
:PROPERTIES:
:ID:       2b70a90f-6d5a-437e-99e9-e72224d64079
:END:

#+begin_src emacs-lisp
(bind!
  (:map lispyville-mode-map)
  (:n ">" #'lispyville-slurp)
  (:n "<" #'lispyville-barf))
#+end_src

*** escape :bind:
:PROPERTIES:
:ID:       6469110b-e5bf-4276-a9de-a5c1e1eb2385
:END:

=lispyville= binds escape to [[helpfn:lipyville-normal-state][lispyville-normal-state]]. So for =xl-escape-hook=
to still happen on escape, I need to add [[helpfn:evil:escape-a][evil:escape-a]] as advice to
=lispyville-normal-state=.

Sometimes =evil-normal-state= enters visual state.

#+begin_src emacs-lisp
(bind!
  (:map lispyville-mode-map)
  ([escape] #'lispyville-normal-state))
#+end_src

*** additional :bind:
:PROPERTIES:
:ID:       af8b96f7-183a-4f87-a985-7f7328e6feb7
:END:

#+begin_src emacs-lisp
(bind!
  (:map lispyville-mode-map)
  (:ei "SPC" #'lispy-space)
  (:ei ";"   #'lispy-comment)
  (:nv "M-j" #'lispyville-drag-forward)
  (:nv "M-k" #'lispyville-drag-backward)
  (:nv "M-R" #'lispyville-raise-list)
  (:nv "M-v" #'lispy-convolute-sexp))
#+end_src

** modal editing :modal:
:PROPERTIES:
:ID:       51826df5-8e16-4f4b-9814-cdcc6d5b7e7a
:END:

*** TODO multistate :disabled:
:PROPERTIES:
:ID:       3af402ee-9fe4-4d2e-b859-22e3b6e8a324
:END:

#+begin_src emacs-lisp
(use-package multistate)
#+end_src

*** TODO meow :meow:disabled:
:PROPERTIES:
:ID:       47c5cad9-2ba3-40ee-a872-0d90ba438601
:END:

**** bindings :bind:
:PROPERTIES:
:ID:       c90a8647-0199-4cbe-bfb4-6487de53f380
:END:

#+begin_src emacs-lisp
;; (bind! ())
#+end_src

*** evil :evil:
:PROPERTIES:
:ID:       5baaae49-7785-4b3e-99b9-7ad50e90ec43
:END:

**** evil :modal:evil:edit:
:PROPERTIES:
:ID:       9639633f-ec3d-4499-9615-db0dcc9650c9
:END:

[[https://github.com/emacs-evil/evil][evil]] is an extensible vi layer for Emacs. It emulates the main features of Vim,
and provides facilities for writing custom extensions. Also see our page on
[[emacswiki:Evil][EmacsWiki]]. See a brief [[https://bytebucket.org/lyro/evil/raw/default/doc/evil.pdf][manual]]. See the [[https://github.com/noctuid/evil-guide][evil-guide]] by noctuid.

***** evil :edit:evil:
:PROPERTIES:
:ID:       e472e5d3-2760-420b-bbe1-2eb043368f67
:END:

#+begin_src emacs-lisp
(use-package evil :demand t)
#+end_src

***** evil-core :edit:evil:
:PROPERTIES:
:ID:       9aa26d2c-d15a-4f36-a024-3ca9ce568385
:END:

#+begin_src emacs-lisp
(use-package evil-core
  :hook (emacs-startup-hook . evil-mode))
#+end_src

***** evil-vars :edit:evil:
:PROPERTIES:
:ID:       af3a9791-76ac-4fd5-96fe-d361cef3b5b3
:END:

#+begin_src emacs-lisp
(use-package evil-vars
  :set
  (evil-want-visual-char-semi-exclusive . t)
  (evil-ex-search-vim-style-regexp      . t)
  (evil-respect-visual-line-mode        . t)
  (evil-insert-skip-empty-lines         . t)
  (evil-want-C-w-in-emacs-state         . nil)
  (evil-ex-substitute-global            . t)
  (evil-ex-visual-char-range            . t)
  (evil-move-beyond-eol                 . nil)
  (evil-move-cursor-back                . nil)
  (evil-indent-convert-tabs             . t)
  (evil-symbol-word-search              . t)
  (evil-mode-line-format                . nil)
  (evil-echo-state                      . nil)
  (evil-magic                           . t))
#+end_src

***** custom :edit:evil:
:PROPERTIES:
:ID:       f7ece898-25e2-4b2c-94f3-e832a687114c
:END:

#+begin_src emacs-lisp
(set-default! evil-want-C-u-scroll t)
#+end_src

***** make normal state default :evil:edit:
:PROPERTIES:
:ID:       4940ad40-35a2-43ca-a005-da708aa44313
:END:

#+begin_src emacs-lisp
(defhook! make-normal-state-default (evil-mode-hook)
  "Make normal state the default state."
  (set! (append evil-emacs-state-modes evil-motion-state-modes <evil-normal-state-modes>))
  (setq evil-emacs-state-modes nil)
  (setq evil-motion-state-modes nil))
#+end_src

***** replace normal with motion :evil:edit:
:PROPERTIES:
:ID:       69dc135f-0c4a-49ad-9801-ee45dc3ff20f
:END:

#+begin_src emacs-lisp
(defun! replace-motion-with-normal (orig-fn &rest args)
  "Advice for `evil-make-overriding-map' that inhibits motion state."
  (:around evil-make-overriding-map)
  (-let (((keymap state copy) args))
    (funcall orig-fn keymap (if (eq state 'motion) 'normal state) copy)))
#+end_src

***** normal state everywhere :evil:edit:
:PROPERTIES:
:ID:       e6126bd7-94b8-4ce0-b547-0536b59437ea
:END:

In his excellent [[https://github.com/noctuid/evil-guide][evil-guide]], =noctuid= pointed out that [[https://github.com/noctuid/evil-guide#global-keybindings-and-evil-states][motion state is a
useless state]]. The code in this headline essentially just says =NO= to motion
state and disables it everywhere in favor of normal state.

#+begin_src emacs-lisp
(defun! replace-motion-with-normal (orig-fn &rest args) 
  ""
  (:around evil-set-initial-state)
  (-let (((mode state) args))
    (funcall orig-fn mode (if (eq state 'motion) 'normal state))))

(xl-advice-add #'evil-motion-state :override #'evil-normal-state)
#+end_src

***** cursors :cursor:
:PROPERTIES:
:ID: a5f558fb-221c-4b33-a7cd-29308ef74b0d
:END:

It's nice to have cursors change colors (and sometimes shape) depending on the
current evil state. It makes it easy to tell which state you're in. I define
some colors here. Evil has a cursor variable for each state. The cursor variable
for insert state, for example, is [[helpvar:evil-insert-state-cursor][evil-insert-state-cursor]]. Its value is of the
form: ~((CURSOR-SHAPE . CURSOR-WIDTH) COLOR)~.

****** colors and shapes :evil:cursor:asthetic:
:PROPERTIES:
:ID: 3f3cd5c9-1f6d-4c3b-b73f-82c9ee00395e
:END:

Changing the cursor shape and color depending on the state is a convenient and
asthetically pleasing way of determining which state you're in. Some add some
modeline indicator for this but I find that the cursor suffices.

#+begin_src emacs-lisp
(defhook! setup-cursor (evil-mode-hook)
  "Initialize the default cursor shape and size."
  (setq evil-insert-state-cursor   '((bar . 3)   "chartreuse3"))
  (setq evil-emacs-state-cursor    '((bar . 3)   "SkyBlue2"))
  (setq evil-normal-state-cursor   '( box        "DarkGoldenrod2"))
  (setq evil-visual-state-cursor   '((hollow)    "dark gray"))
  (setq evil-operator-state-cursor '((hbar . 10) "hot pink"))
  (setq evil-replace-state-cursor  '( box        "chocolate"))
  (setq evil-motion-state-cursor   '( box        "plum3")))
#+end_src

****** updating cursors :evil:cursor:asthetic:
:PROPERTIES:
:ID: ea4da6d4-4a2c-42cf-b397-cea1555781ce
:END:

After a theme is loaded, the cursor color won't automatically update. Therefore,
I add a hook in [[helpvar:xl-after-load-theme-hook][xl-after-load-theme-hook]]. Now after a new theme is loaded, the
cursor color will update.

#+begin_src emacs-lisp
(defhook! refresh-evil-cursor (xl-after-load-theme-hook)
  "Enable cursor refreshing after theme change."
  (when (bound-and-true-p evil-mode)
    (evil-refresh-cursor)))
#+end_src

***** insert state in minibuffer :minibuffer:evil:
:PROPERTIES:
:ID: a23137c5-62a0-4e77-9e51-6a7372dac703
:END:

Before I just used ~(evil-change-state evil-previous-state)~ to revert the
state back to what it last was. But this fails with ~evil-force-normal-state~
which is what I'm currently using to exit the minibuffer because then the
last state is normal state if the minibuffer is aborted. Using a
=evil:state-before-minibuffer= ensures that the state will be reverted to
the correct one.

#+begin_src emacs-lisp
(defhook! preserve-prior-evil-state (minibuffer-setup-hook)
  "Save state before entering the minibuffer and enter insert state."
  (when (bound-and-true-p evil-mode)
    (setq evil:state-before-minibuffer evil-state)
    (evil-insert-state)))

(defhook! restore-prior-evil-state (minibuffer-exit-hook)
  "Restore state after minibuffer."
  (when (bound-and-true-p evil-mode)
    (evil-change-state evil:state-before-minibuffer)
    (setq evil:state-before-minibuffer nil)))
#+end_src

***** escape :evil:
:PROPERTIES:
:ID: ea9378de-e5c5-482c-b53b-743a81e3bc8e
:END:

We want escape to be a "quit everything" keybinding.

#+begin_src emacs-lisp
(bind! (:ei [escape] #'evil-force-normal-state))

(defadvice! exit-everything (:after evil-force-normal-state lispyville-normal-state)
  "Exits out of whatever is happening after escape."
  (cond ((minibuffer-window-active-p (minibuffer-window))
         (abort-recursive-edit))
        ((run-hook-with-args-until-success 'xl-escape-hook))
        ((or defining-kbd-macro executing-kbd-macro) nil)
        (t (keyboard-quit))))
#+end_src

***** text objects :evil:textobj:
:PROPERTIES:
:ID:       0edef735-cec9-4015-bfd5-cf36e816cbc3
:END:

To edit text efficiently Vim has the concept of [[https://blog.carbonfive.com/2011/10/17/vim-text-objects-the-definitive-guide/][text objects]]. Text objects are
structures that are seen in text. For example, a set of words followed by a
period is a sentence. A words between two closing parentheses is a sexp.

****** general delimiter text object
:PROPERTIES:
:ID:       0066093b-7991-4193-8ce2-ef9f17af211a
:END:

I discovered this the =form= text object from using [[https://github.com/luxbock/evil-cleverparens][evil-cleverparens]] in the past.
The package =evil-cleverparens= was too slow for my taste; noctuid's [[https://github.com/sp3ctum/evil-lispy][evil-lispy]] is
much faster and gave me the functionality that I needed most from
=evil-cleverparens=: deleting and copying text with parentheses intelligently.
However, many of the ideas of =evil-cleverparens= were excellent. One particular
idea was to have a general =form= text object. Instead of specifying the
particular surrounding bounds when doing an evil operator command you just use a
single key for them. It's kind of like a =Do-What-I-Mean= surround operator. This
is suprisingly useful because it takes significant time to specify whether you
want =[]= or ={=}= or =()= or =""=. The main drawback you cannot distinguish between
surround characters at multiple levels--it just takes the closest one. In
practice, this is rarely an issue.

****** inner :textobj:
:PROPERTIES:
:ID:       dc06e55b-ce4d-4921-b478-ae7b7927df82
:END:

#+begin_src emacs-lisp
(after! evil
  (evil-define-text-object evil:textobj-inner-form (count &rest _)
    "Inner sexp object."
    (-if-let ((beg . end)
	      (->> (list (lispy--bounds-list) (lispy--bounds-string))
		   (-non-nil)
		   (--sort (< (- (cdr it) (car it)) (- (cdr other) (car other))))
		   (car)))
	(evil-range (1+ beg) (1- end) 'inclusive :expanded t)
      (error "No surrounding form found."))))
#+end_src

****** outer :textobj:
:PROPERTIES:
:ID:       6068a56f-d162-4da2-801f-6f72357fdd62
:END:

#+begin_src emacs-lisp
(after! evil
  (evil-define-text-object evil:textobj-outer-form (count &rest _)
    "Smartparens inner sexp object."
    (-if-let ((beg . end)
              (->> (list (lispy--bounds-list) (lispy--bounds-string))
                   (-non-nil)
                   (--sort (< (- (cdr it) (car it)) (- (cdr other) (car other))))
                   (car)))
        (evil-range beg end 'inclusive :expanded t)
      (error "No surrounding form found."))))
#+end_src

****** bindings :textobj:
:PROPERTIES:
:ID:       4bf10f8e-2ae6-44b1-9087-5d1e2af028f1
:END:

#+begin_src emacs-lisp
(bind!
  (:map evil-inner-text-objects-map "f" #'evil:textobj-inner-form)
  (:map evil-outer-text-objects-map "f" #'evil:textobj-outer-form))
#+end_src

****** fix vim/evil around =""= :textobj:
:PROPERTIES:
:ID:       b91726b4-7e7e-442a-9858-df5d51c751c8
:END:

=Vim= and =Evil= both have the interesting (inconsistent?) behavior that doing an
outer text object operator on a comment grabs some whitespace on the left side.
Try doing =va"= to ~(progn "hello world")~ and you'll see that =\s"hello world"= is
selected instead of just "hello world".

Why not just go to the end of the ="= like any other around operator?

#+begin_src emacs-lisp
(after! evil
  (evil-define-text-object evil:textobj-a-string (count &rest _)
    "An outer comment text object as defined by `lispy--bounds-string'."
    (-if-let ((beg . end) (lispy--bounds-string))
        (evil-range beg end 'exclusive :expanded t)
      (error "Not inside a comment.")))

  (bind!
    (:map evil-outer-text-objects-map)
    ("\"" #'evil:textobj-a-string)))
#+end_src

**** evil-visualstar :evil:edit:
:PROPERTIES:
:ID:       ae15f6a4-59a5-49ca-9add-1b90d393b09c
:END:

[[https://github.com/bling/evil-visualstar][evil-visualstar]]

#+begin_src emacs-lisp
(use-package evil-visualstar)

(bind! (:map evil-visual-state-map)
  ("#" #'evil-visualstar/begin-search-backward)
  ("*" #'evil-visualstar/begin-search-forward))
#+end_src

**** evil-lion :evil:bind:
:PROPERTIES:
:ID:       95d248be-601e-4dbd-b318-febcd0e49d71
:END:

=evil-lion= provides a very useful way of aligning text.

#+begin_src emacs-lisp
(use-package evil-lion
  :commands evil-lion-right evil-lion-left)

(bind!
  (:prefix "g")
  (:nv "l" #'evil-lion-left)
  (:nv "L" #'evil-lion-right))
#+end_src

**** evil-surround :evil:edit:
:PROPERTIES:
:ID:       9ab88644-3c33-463c-8f24-3b048209e082
:END:

#+begin_src emacs-lisp
(use-package evil-surround
  :hook prog-mode-hook text-mode-hook)
#+end_src

**** evil-goggles :evil:
:PROPERTIES:
:ID:       30d19955-dabf-472f-a485-22114e1eaaa4
:END:

#+begin_src emacs-lisp
(use-package evil-goggles)
#+end_src

**** evil-god-state :evil:
:PROPERTIES:
:ID:       4374e82c-bac1-4c9e-9ab9-70799140f5a7
:END:

#+begin_src emacs-lisp
#+end_src

* settings :setting:
:PROPERTIES:
:ID:       5e3d46da-33c5-4388-8111-85436d2a46d1
:END:

** maybe run server at startup :startup:
:PROPERTIES:
:ID:       a35d4b90-ac83-462d-83d7-5c86e79dfdc3
:END:

#+begin_src emacs-lisp
(defhook! run-server-maybe (emacs-startup-hook)
  "Run emacs as a server if it's not running already."
  (require 'server)
  (unless (server-running-p) (server-start)))
#+end_src

** recenter cursor :cursor:
:PROPERTIES:
:ID:       dda57b64-b645-4eda-be54-9dda4af35404
:END:

#+begin_src emacs-lisp
(defadvice! recenter-on-load (:after-while save-place-find-file-hook)
  "Recenter on cursor when loading a saved place."
  (when buffer-file-name (ignore-errors (recenter))))
#+end_src

** minibuffer :minibuffer:performance:
:PROPERTIES:
:ID:       8c02fc83-5e7e-4115-9768-020abcf82541
:END:

[[helpvar:minibuffer-setup-hook][minibuffer-setup-hook]] and [[helpvar:minibuffer-exit-hook][minibuffer-exit-hook]] are the hooks run just before
entering and exiting the minibuffer (respectively). In the minibuffer I'll be
primarily doing searches for variables and functions. There are alot of
variables and functions so this can certainly get computationally expensive. To
keep things snappy I increase boost the [[helpvar:gc-cons-threshold][gc-cons-threshold]] just before I enter
the minibuffer, and restore it to it's original value a few seconds after it's closed.

It would take me forever to guess the name =minibuffer-setup-hook= from the
variable [[helpvar:minibuffer-exit-hook][minibuffer-exit-hook]]. If I knew the name =minibuffer-exit-hook= but did not
know what the hook to enter the minibuffer was, I'd probably
=minibuffer-enter-hook= because [[https://www.wordhippo.com/what-is/the-opposite-of/exit.html]["enter" is one of the main antonyms of "exit"]].
It'd take me forever to guess =startup=. Note that the only tricky thing about
this example.

At first I thought of =entry= but after more thought I realized
hook variables use action verbs in their names not nouns. So the =exit= in
=minibuffer-exit-hook= is actually the verb =exit= not the noun.

#+begin_src emacs-lisp
(defhook! boost-garbage-collection (minibuffer-setup-hook)
  "Boost garbage collection settings to `XL-GC-CONS-THRESHOLD-MAX'."
  (setq gc-cons-threshold XL-GC-CONS-THRESHOLD-MAX))

(defhook! defer-garbage-collection (minibuffer-exit-hook :append t)
  "Reset garbage collection settings to `xl-gc-cons-threshold' after delay."
  (setq gc-cons-threshold XL-GC-CONS-THRESHOLD))
#+end_src

** disable terminal initialization :setting:core:
:PROPERTIES:
:ID:       540c1c5a-cd31-45cf-afaf-b8e48a76e68e
:END:

According to Doom Emacs, when running emacs in terminal tty is *tremendously* slow.

#+begin_src emacs-lisp
(unless (display-graphic-p)
  (xl-advice-add #'tty-run-terminal-initialization :override #'ignore)
  (defhook! init-tty (window-setup-hook)
    (advice-remove #'tty-run-terminal-initialization #'ignore)
    (tty-run-terminal-initialization (selected-frame) nil t)))
#+end_src

** server :cache:
:PROPERTIES:
:ID:       3a1120f5-2809-42d6-938c-3916483033e0
:END:

#+begin_src emacs-lisp
(use-package server
  :set
  (server-auth-dir . (concat XL-CACHE-DIR "server/")))
#+end_src

** prevent emacs from killing certain buffers
:PROPERTIES:
:ID:       ae935cf5-7322-499c-96d7-20209d9b6641
:END:

I never want the =*scratch*= and =*Messages*= buffer to be killed. I owe this idea
to [[https://github.com/rememberYou/.emacs.d][rememberYou's Emacs]].

#+begin_src emacs-lisp
(defhook! lock-certain-buffers (after-init-hook)
  "Prevent certain buffers from being killed."
  (iter (each buffer (list "*scratch*" "*Messages*"))
	(with-current-buffer buffer (emacs-lock-mode 'kill))))
#+end_src

** startup :startup:
:PROPERTIES:
:ID:       fff8691b-a0c8-4e99-aa9a-bf1288cd810a
:END:

#+begin_src emacs-lisp
(defun startup%initial-buffer-choice ()
  "Return the initial buffer to be displayed.
This function is meant to be used as the value of `initial-buffer-choice'."
  (alet (if xl-debug-p "*xl-log*" "*scratch*")
    (get-buffer-create it)))
#+end_src

** log the init time :log:
:PROPERTIES:
:ID:       36e2113f-a28f-4ef2-bb90-141f82291c91
:END:

I find it convenient to be able to view the init time in the =*xl-log*=
buffer. Speed is important to me and I want to know how fast my Emacs is at
initializing. :race-car:

I'm not sure why, but [[helpfn:emacs-init-time][emacs-init-time]] is not completely accurate in some
circumstances. The one I'm referring to now is with general prefix bindings.

#+begin_src emacs-lisp
(defhook! log-init-time (emacs-startup-hook)
  "Log the init time."
  (xl-log "emacs-init-time: %s" (emacs-init-time)))
#+end_src

** utf-8 text encoding
:PROPERTIES:
:ID:       26344072-c145-40bd-9ade-8c7f2eef54c8
:END:

#+begin_src emacs-lisp
(setq-default locale-coding-system 'utf-8)
(setq-default buffer-file-coding-system 'utf-8)

(set-language-environment 'utf-8)
(setq-default locale-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
(setq-default default-file-name-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)

(setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))

;; (with-os! (:not windows)
;;   (setq selection-coding-system 'utf-8))

(when (fboundp 'set-charset-priority)
  (set-charset-priority 'unicode))
#+end_src

** use yes or no
:PROPERTIES:
:ID:       82a84315-2018-42e0-bd1a-74af7b722593
:END:

Essentially, I am telling all Emacs functions that prompt the user for a =yes=
or =no= to instead allow me to type =y= or =p=. [[helpfn:yes-or-no-p][yes-or-no-p]] is defined in c
source code.

#+begin_src emacs-lisp
(xl-advice-add #'yes-or-no-p :override #'y-or-n-p)
#+end_src

** recursive minibuffers :minibuffer:
:PROPERTIES:
:ID:       7eb20f6d-75b4-4eec-8878-e7232c1a153d
:END:

This means that you can use the minibuffer while in the minibuffer. One
situation where I use this feature is in the command [[helpfn:eval-expression][eval-expression]]. As I'm
typing an expression, I get completion from the minibuffer.

#+begin_src emacs-lisp
(set-default! enable-recursive-minibuffers t)
#+end_src

** clipboard
:PROPERTIES:
:ID:       6aa6d0ac-6cf8-4f82-a724-c56d69cc062b
:END:

#+begin_src emacs-lisp
(use-package clipboard
  :set
  (selection-coding-system . 'utf-8)
  (select-enable-clipboard . t)
  (select-enable-primary   . t)
  (x-select-request-type   . '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
#+end_src

** simple :popup:
:PROPERTIES:
:ID:       a1fa5195-9b6a-4842-bc5f-71305e603c55
:END:

#+begin_src emacs-lisp
(use-package simple
  :rule ("bottom" "messages" :newname "\\*Messages\\*")
  :set
  (delete-trailing-lines . nil)
  (blink-matching-paren  . t)
  (idle-update-delay     . 1))
#+end_src

** disable old themes first :theme:
:PROPERTIES:
:ID:       c2110d52-ce27-4f3a-b856-1e31200f597c
:END:

Sometimes we end up with remants of the faces of old themes when we load a new
one. For this reason, I make sure to disable any enabled themes before applying
a new theme.

#+begin_src emacs-lisp
(defun! disable-old-themes (orig-fn &rest args)
  "Disable old themes before loading new ones."
  (:around load-theme)
  (mapc #'disable-theme custom-enabled-themes)
  (apply orig-fn args))
#+end_src

** don't echo keystrokes
:PROPERTIES:
:ID:       b8856ebe-6208-4271-ad5a-d352fabec8bb
:END:

After you type a key, emacs echoes it into the echo area. I find this
unnecessary. Additionally, this will interfere with [[https://github.com/justbur/emacs-which-key][which-key]]. The keystroke
echoing in the mode line makes the which-key prompt disappear prematurely.

#+begin_src emacs-lisp
(setq-default echo-keystrokes 0)
#+end_src

** linux :os:
:PROPERTIES:
:ID:       6572e618-e5ef-445b-90d6-14dc2c24f1a4
:END:

#+begin_src emacs-lisp
(with-os! linux
  (setq-default x-underline-at-descent-line t)
  (setq-default x-gtk-use-system-tooltips nil))
#+end_src

** scroll faster :scroll:
:PROPERTIES:
:ID:       964a8b3e-37b4-4d6b-9298-3a1be3cfe6aa
:END:

"More performant rapid scrolling over unfontified regions. May cause brief
spells of inaccurate fontification immediately after scrolling."

#+begin_src emacs-lisp
(set! fast-but-imprecise-scrolling t)
#+end_src

** how to scroll :scroll:
:PROPERTIES:
:ID:       c91bcd0f-da83-44a3-9d9e-e1f55dcdb642
:END:

#+begin_src emacs-lisp
(setq-default hscroll-margin 2)
(setq-default hscroll-step 1)
(setq-default scroll-conservatively 1001)
(setq-default scroll-margin 0)
(setq-default scroll-preserve-screen-position t)
#+end_src

** disable cursor blinking :cursor:
:PROPERTIES:
:ID:       fe8a259b-12e6-4e58-a324-eab831283a86
:END:

By default the cursor blinks. The point is so that it is easier to find on the
screen. Usually, however, I have no trouble finding it so I disable it.

#+begin_src emacs-lisp
(use-package frame
  :config
  (blink-cursor-mode -1))
#+end_src

** cus-edit
:PROPERTIES:
:ID:       a844ddb6-245b-463c-963d-743c931698ae
:END:

Emacs automatically creates a [[helpvar:custom-file][custom-file]] for customizations done via the [[info:emacs#Easy
 Customization][customization interface]]. I am one of those who prefers to set them myself in my
config file as opposed to having this file. Therefore, I set it to [[;][null-device]].

#+begin_src emacs-lisp
(use-package cus-edit
  :set
  (custom-file            . null-device)
  (custom-theme-directory . (concat XL-LOCAL-DIR "themes/")))
#+end_src

** startup :startup:
:PROPERTIES:
:ID:       f9854e53-dd9d-4381-8e9c-8336736d4308
:END:

As it's name suggests, the built-in startup feature in Emacs.

If you just set [[helpvar:inhibit-startup-echo-area-message][inhibit-startup-echo-area-message]] to =t= the word =nil= is
messaged.  So it's best just to override the function entirely.

As per [[https://emacs.stackexchange.com/questions/18677/prevent-auto-save-list-directory-to-be-created][this stackoverflow question]], this prevents the =auto-save-directory= from
being created.

#+begin_src emacs-lisp
(use-package startup
  :ignore display-startup-echo-area-message startup-echo-area-message
  :set
  (auto-save-list-file-prefix  . nil)
  (inhibit-startup-buffer-menu . t)
  (inhibit-startup-message     . t)
  (inhibit-startup-screen      . t)
  (inhibit-default-init        . t)
  (inhibit-spash-screen        . t)
  (initial-scratch-message     . nil)
  (initial-buffer-choice       . #'startup%initial-buffer-choice)
  (initial-major-mode          . 'fundamental-mode))
#+end_src

** set the fill-column
:PROPERTIES:
:ID:       84d8e85a-a6a1-49cd-b46e-e5cd3f825438
:END:

Fill column refers to the column where line-wrapping will occur. The standard
value for this is =80= but historically that was because of the [[https://en.wikipedia.org/wiki/Punched_card][IBM punch
card]]. Now this is not the case so I don't think it's as much of a deal.

#+begin_src emacs-lisp
(setq-default fill-column 80)
#+end_src

** delete duplicates in history
:PROPERTIES:
:ID:       1c381491-c4fa-4b5e-99de-ec6bd33df77c
:END:

This variable tells savehist not to record duplicate entries in history. Note
this is not apart of savehist technically; it is a variable defined in C source
code.

#+begin_src emacs-lisp
(setq-default history-delete-duplicates t)
#+end_src

** don't create lockfiles
:PROPERTIES:
:ID:       ae464c90-d220-4db2-a3fd-fec36b9181e4
:END:

https://stackoverflow.com/questions/8246483/emacs-how-to-disable-files-creation

#+begin_src emacs-lisp
(set! create-lockfiles nil)
#+end_src

** disable bi-directional text
:PROPERTIES:
:ID:       6c12f14c-75c7-4b30-9bb4-ca6e8d3cae47
:END:

Disabling bidirectional text provides a small performance boost. Bidirectional
text is useful for languages that read right to left.

#+begin_src emacs-lisp
(set-default! bidi-display-reordering 'left-to-right)
(set-default! bidi-paragraph-direction 'left-to-right)
#+end_src

** stop beeping :sound:
:PROPERTIES:
:ID:       2a83cb3a-ca2e-4d9c-a296-340d33855614
:END:

#+begin_src emacs-lisp
(set-default! ring-bell-function #'ignore)
#+end_src

** resize pixelwise
:PROPERTIES:
:ID:       02daff3d-e532-4cfa-a217-81e27627e7a7
:END:

;; https://github.com/baskerville/bspwm/issues/551#issuecomment-574975395

#+begin_src emacs-lisp
(set-default! window-resize-pixelwise t)
(set-default! frame-resize-pixelwise t)
#+end_src

** files :setting:core:
:PROPERTIES:
:ID:       83549b5b-33e2-48b2-aeaf-cf4734ec4040
:END:

Watch out for [[][auto-save-file-name-transforms]] and [[][]]. If you don't
disable backups nor change these variables, Emacs will end up littering backup
files wherever you go. These are usually among the first things new Emacsers
will change.

#+begin_src emacs-lisp
(use-package files
  :set
  (auto-save-file-name-transforms . `((".*" ,(concat XL-CACHE-DIR "auto-save-list/") t)))
  (auto-save-interval                 . 300)
  (auto-save-default                  . nil)
  (auto-save-timeout                  . 30)
  (confirm-nonexistent-file-or-buffer . nil)
  (backup-by-copying-when-linked      . t)
  (backup-directory-alist             . (list (cons ".*" (concat XL-CACHE-DIR "backup/"))))
  (require-final-newline              . nil)
  (delete-old-versions                . t)
  (auto-mode-case-fold                . nil)
  (confirm-kill-emacs                 . #'y-or-n-p)
  (backup-by-copying                  . t)
  (make-backup-files                  . nil)
  (kept-old-versions                  . 2)
  (kept-new-versions                  . 2)
  (trash-directory                    . (expand-file-name "Trash" "~"))
  (version-control                    . nil))
#+end_src

** loaddefs :core:setting:
:PROPERTIES:
:ID:       5af4faf8-47e3-4db2-9d13-47fc828b8fca
:END:

By default Emacs disables certain commands that are deemed too confusing for new
users. Some such commands are the narrowing commands.

I, however, know what I'm doing. So I enable all commands.

#+begin_src emacs-lisp
(use-package loaddefs
  :set
  (disabled-command-function . nil))
#+end_src

** move to trash instead of deleting :backup:
:PROPERTIES:
:ID:       b6f33596-1b9c-45bf-bce5-ece5042782ac
:END:

By default Emacs actually deletes files. By setting this to =t=, you tell Emacs
to move a file to trash instead of actually deleting it. This is better because
if you accidentally delete a file or discover you can still just go get your
file from the trash.

#+begin_src emacs-lisp
(setq delete-by-moving-to-trash t)
#+end_src

** don't prompt me when loading theme :theme:
:PROPERTIES:
:ID:       eaa6531c-1188-41c7-a645-a82d9f482449
:END:

If you don't enable =custom-save-themes=, emacs asks you whether you're sure you
want to load a theme for security reasons. I prefer the convenience of not being
prompted.

Loading a theme qualifies as an intensive operation as all the faces on the
screen need to be redisplayed.

#+begin_src emacs-lisp
(use-package custom
  :gc-pause load-theme
  :set
  (custom-safe-themes . t))
#+end_src

* utility :utility:
:PROPERTIES:
:ID:       5f7b31a6-b99e-4ac8-a2be-2e0aaa4906d6
:END:

** DOC dmenu
:PROPERTIES:
:ID:       2b9348d3-eb71-4e55-abfb-b7b865bb81ac
:END:

=dmenu= is a package that mimicks [[][dmenu]. It allows me to choose an
executable to run.

#+begin_src emacs-lisp
(use-package dmenu
  :commands dmenu
  :set (dmenu-save-file . (concat XL-CACHE-DIR "dmenu-itmes")))
#+end_src

** TODO origami
:PROPERTIES:
:ID:       ac2cc043-331f-435b-b903-39681b84fefe
:END:

=origami= is, as its name suggests, a package that handles folding.

#+begin_src emacs-lisp
(use-package origami)
#+end_src

** TODO pdf-tools :pdf:exec:
:PROPERTIES:
:ID:       63343f9d-6b19-43de-8302-d1344d571949
:END:

*** pdf-tools
:PROPERTIES:
:ID:       e19d0200-5e41-4295-ae54-fa71bfeadb06
:END:

#+begin_src emacs-lisp
(use-package pdf-tools
  :magic ("%PDF" . pdf-view-mode)
  :init
  (push '("\\.[pP][dD][fF]\\'" . pdf-view-mode) auto-mode-alist))
#+end_src

*** epd-pdf-info-program :startup:
:PROPERTIES:
:ID:       25826061-a4a7-4f8a-8d3b-bdd5a80f70d0
:END:

#+begin_src emacs-lisp
(defun! build-pdf-into-program-maybe ()
  "Build the pdf-info program if it hasn't already been built."
  (:before pdf-view-mode)
  (unless (file-executable-p pdf-info-epdfinfo-program)
    (let ((wconf (current-window-configuration)))
      (pdf-tools-install)
      (message "Building epdfinfo, this will take a moment...")
      (with-current-buffer buffer
	(iter (each buffer buffer-list)
	      (when (eq major-mode 'pdf-view-mode) (fundamental-mode))))
      (while compilation-in-progress
        ;; Block until `pdf-tools-install' is done
        (redisplay)
        (sleep-for 1))
      ;; HACK If pdf-tools was loaded by you opening a pdf file, once
      ;;      `pdf-tools-install' completes, `pdf-view-mode' will throw an error
      ;;      because the compilation buffer is focused, not the pdf buffer.
      ;;      Therefore, it is imperative that the window config is restored.
      (when (file-executable-p pdf-info-epdfinfo-program)
        (set-window-configuration wconf)))))
#+end_src

*** bindings :bind:
:PROPERTIES:
:ID:       506c568c-0473-4db6-82b6-cc91174b0ce4
:END:

#+begin_src emacs-lisp
(bind!
  (:states normal)
  (:map pdf-view-mode-map)
  ("j" #'pdf-view-next-line-or-next-page)
  ("k" #'pdf-view-previous-line-or-previous-page)
  ("0" #'pdf-view-first-page)
  ("9" #'pdf-view-last-page)
  ("s" #'pdf-view-fit-width-to-window))
#+end_src

** ednc :notify:
:PROPERTIES:
:ID:       e72dfee2-3c80-4206-b2ea-d4a25fffc75c
:END:

This is a replacement for things like =dunst= except written completely en Emacs
lisp.

#+begin_src emacs-lisp
(use-package ednc)
#+end_src

** egg-timer :notify:
:PROPERTIES:
:ID:       a98d0f06-5b2a-449d-8719-bcc8d3d0a241
:END:

#+begin_src emacs-lisp
(use-package egg-timer)
#+end_src

** multimedia :multimedia:
:PROPERTIES:
:ID:       5675cbbc-beb1-4470-a1d2-08f253bb4535
:END:

*** webpage screenshot
:PROPERTIES:
:ID:       284482e6-f3a3-4850-9664-db83ebdd894e
:END:

*** screenshots :screenshot:
:PROPERTIES:
:ID:       26d59d00-72e3-4b8c-9845-e5d9627cd4aa
:END:
:LINKS:
https://www.reddit.com/r/emacs/comments/idz35e/emacs_27_can_take_svg_screenshots_of_itself/
:END:

This headline contains utilities for taking screenshots. As I see it,
screenshots are vital. I use maim to take screenshots because. I will note that
when I used [[][escr]] to take screenshots, those screenshots would not show
exwm windows. =escr= used [[][]]'s import.

**** screenshot name
:PROPERTIES:
:ID:       7210e8a8-7cbc-40ec-bd70-f8cfc6a32c56
:END:

The name for the screenshot.

***** screenshot dir
:PROPERTIES:
:ID:       54257850-47e7-4073-ab8b-c9c1adf4219e
:END:

#+begin_src emacs-lisp
(defvar xl-screenshot-dir "~/.tangld/multimedia/screenshots/")
(defun xl-screenshot-dir () xl-screenshot-dir)
#+end_src

***** xl-screenshot-path
:PROPERTIES:
:ID:       a6a75a8c-8d00-4f26-9df0-7f24af577e87
:END:

#+begin_src emacs-lisp
(defun xl-screenshot-path (name)
  "Return the full path where screenshot named NAME should go."
  (format "%s%s.png" (xl-screenshot-dir) name))
#+end_src

***** whether to prompt for screenshots
:PROPERTIES:
:ID:       1c280e62-2a1b-41f8-8ff9-039528652fcf
:END:

#+begin_src emacs-lisp
(defvar xl-prompt-for-screenshot-name-p t
  "If non-nil, prompt for screenshot name.")
#+end_src

***** name passed into prompt
:PROPERTIES:
:ID:       e8a21618-50f6-45ba-9a38-bff5c6d0a924
:END:

#+begin_src emacs-lisp
(defun xl-prompt-screenshot-name ()
  "Prompt for screenshot name."
  (when xl-prompt-for-screenshot-name-p
    (alet (read-string "Image Name: ")
      (unless (string-empty-p it)
	(xl-screenshot-path it)))))
#+end_src

***** default screenshot name
:PROPERTIES:
:ID:       58405f4f-e891-494e-afc7-a227415ec12b
:END:

#+begin_src emacs-lisp
(defun xl-default-screenshot-name ()
  "Return the default screenshot name."
  (alet (format-time-string "%Y-%m-%d-%H%M%S" (current-time))
    (xl-screenshot-path it)))
#+end_src

**** interactive screenshot functions
:PROPERTIES:
:ID:       27089aef-5937-4a7e-9af1-794fbeb835f2
:END:

When I first implemented these functions I prompted for the name first, but this
had the side-effect of displaying the prompt in the screenshot which is not what
I want. To avoid this, I decided to create the screenshot with the default name
and then prompt to rename the file afterwards.

***** toggle prompting for name
:PROPERTIES:
:ID:       5872ecd0-063b-4887-83c6-9a0a79988f47
:END:

#+begin_src emacs-lisp
(defun xl/prompt-screenshot-name-toggle ()
  "Toggle whether to prompt for screenshot name."
  (interactive)
  (setq xl-prompt-for-screenshot-name-p (not xl-prompt-for-screenshot-name-p)))
#+end_src

***** fullscreen
:PROPERTIES:
:ID:       5cb29bb2-459a-4c84-9bf8-df179d2d2e8e
:END:

At first I tried implementing this with [[helpfn:sleep-for][sleep-for]], but doing it that way makes
it so that you include the prompt in the screenshot like in [[file:multimedia/screenshots/screenshot-using-sleep-for.png][this screenshot]]. I
don't want to completely discount this way of doing it, because sometimes you do
want to take a screenshot of the prompt itself. Generally speaking though, it's
not what you want. It looks like we need an idle timer for screenshots because
otherwise you.

#+begin_src emacs-lisp
(defun xl/take-fullscreen-screenshot ()
  "Take a fullscreen screenshot."
  (interactive)
  (let* ((name (or (xl-prompt-screenshot-name) (xl-default-screenshot-name)))
	 (path (f-expand name (xl-screenshot-dir))))
    (alet `(lambda ()
	     (call-process "maim" nil nil nil "-u" ,path)
	     (when (file-exists-p ,path)
	       (message "screenshot successful!")))
      (run-with-timer 2 nil it))))
#+end_src

***** window
:PROPERTIES:
:ID:       1a8724bb-24be-43fd-a3f6-3a41f7380fe8
:END:

#+begin_src emacs-lisp
(defun xl/take-window-screenshot ()
  "Take a screenshot of the current Emacs window."
  (interactive)
  (-let* ((name (or (xl-prompt-screenshot-name) (xl-default-screenshot-name)))
	  (path (f-expand name (xl-screenshot-dir)))
	  ((x y w h) (window-pixel-edges))
	  (geometry (format "%dx%d+%d+%d" w h x y)))
    (sleep-for 1)
    (call-process "maim" nil nil nil "-u" "--geometry" geometry name)
    (when (file-exists-p path)
      (message "screenshot successful!"))))
#+end_src

*** elfeed :newfeed:
:PROPERTIES:
:ID:       45a52b98-9eba-45ab-9269-e8f930499e1c
:END:

=elfeed= is a newsfeed reader to Emacs. It's used over gnus because it is
generally faster and more "modern".

**** elfeed
:PROPERTIES:
:ID:       6aa4ece0-0b94-48b6-9a99-4b85cd1f7ccd
:END:

#+begin_src emacs-lisp
(use-package elfeed
  :rule ("right" "elfeed" :newname "\\*elfeed.+")
  :commands elfeed
  :set
  (elfeed-db-directory           . (concat XL-CACHE-DIR "elfeed"))
  (elfeed-search-title-max-width . 100))
#+end_src

**** elfeed-score
:PROPERTIES:
:ID:       20d1a501-4a52-43b8-b124-be1f62265b73
:END:

#+begin_src emacs-lisp
(use-package elfeed-score)
#+end_src

**** elfeed-org
:PROPERTIES:
:ID:       f646640b-6982-478f-bd1b-babd0ee00165
:END:

#+begin_src emacs-lisp
(use-package elfeed-org
  ;; :init
  ;; (defvar elfeed-org%public-newsfeed-file (xl-org-dir "newsfeeds.org")
  ;;   "Newsfeeds.")
  ;; :set
  ;; (rmh-elfeed-org-files . (list elfeed-org%public-newsfeed-file))
  )
#+end_src

**** newsfeeds
:PROPERTIES:
:ID:       6d64a62c-a3f7-449c-833d-0738c1e5f28a
:END:

These are my newsfeed for =elfeed-org=.

***** [[https://planet.emacslife.com/][planet emacslife]]
:PROPERTIES:
:ID:       c042350e-6c21-4c98-82b1-332ef808cba5
:END:

*** gif-screencast :exec:
:PROPERTIES:
:ID:       d8553132-c244-4319-bcc9-51905a296e34
:END:

#+begin_src emacs-lisp
(use-package gif-screencast
  :commands gif-screencast-start-or-stop
  :set 
  (gif-screencast-program . "scrot")
  (gif-screencast-args . '("--quality" "25" "--focused"))
  (gif-screencast-cropping-program . "mogrify")
  (gif-screencast-optimize-program . "gifsicle")
  (gif-screencast-capture-format . "png"))
#+end_src

*** videos :video:
:PROPERTIES:
:ID:       a8c1f6aa-25f6-47aa-a625-2c870f322a8c
:END:

*** emms :music:
:PROPERTIES:
:ID:       6f3eaa69-bbbb-458e-bcad-1c121a3174e9
:END:

[[https://www.gnu.org/software/emms/][emms]] is a very complete music player.

**** emms
:PROPERTIES:
:ID: 5d28b703-a87f-47ca-b320-785e7589fea6
:END:

#+begin_src emacs-lisp
(use-package emms
  :set
  (emms-source-file-directory-tree-function . 'emms-source-file-directory-tree-find)
  (emms-source-file-default-directory       . "~/Multimedia/music")
  (emms-playlist-buffer-name                . "*EMMS-PLAYLIST*")
  (emms-seek-seconds                        . 5)
  (emms-directory                           . (concat XL-CACHE-DIR "emms/"))
  (emms-player-list                         . '(emms-player-mpv)))
#+end_src

**** quitting
:PROPERTIES:
:ID: 545e6534-f289-4a89-838a-2a65ac74fe72
:END:

#+begin_src emacs-lisp
(after! emms
  (defhook! quit-emms (kill-emacs-hook)
    "Shut down EMMS."
    (when emms-player-playing-p (emms-pause))
    (emms-stop)))
#+end_src

** xr :regexp:
:PROPERTIES:
:ID: 75c56163-9ce1-4726-969a-350fcc56395f
:END:

This package is the inverse of =rx=. It takes a regular expression and returns the
=rx= representation.

#+begin_src emacs-lisp
(use-package xr :commands xr)
#+end_src

** man :exec:
:PROPERTIES:
:ID:       3982b034-90e1-4961-90d9-224e913c0b8c
:END:

#+begin_src emacs-lisp
(use-package man
  :rule ("left" "man" :newname "\\*man.+"))
#+end_src

** eping :exec:
:PROPERTIES:
:ID:       37004f10-66d5-4b5a-a9eb-31107464e5a5
:END:

#+begin_src emacs-lisp
(use-package eping)
#+end_src

** grugru :write:edit:
:PROPERTIES:
:ID:       9d96a611-355a-4b62-bb0e-18e9d4af92c9
:END:

#+begin_src emacs-lisp
(use-package grugru)
#+end_src

** fortune-cookie :exec:
:PROPERTIES:
:ID:       8105dadd-4d4a-4f57-a5f9-5cae1b14ef3a
:END:

#+begin_src emacs-lisp
(use-package fortune-cookie
  :commands fortune-cookie)
#+end_src

** figlet :exec:
:PROPERTIES:
:ID:       b5be9427-a814-4a91-92ab-ad393375ec41
:END:

#+begin_src emacs-lisp
(use-package figlet :commands figlet)
#+end_src

** system-packages :pacman:exec:
:PROPERTIES:
:ID:       74bd0e5a-f6b0-48eb-a91e-3932eae23516
:END:

=system-packages= provides an api for installing system packages. This api strives
to abstract package installation on different operating systems. Unfortunately,
it does not include an interactive function that uses [[helpfn:completing-read][completing-read]] to list
packages

*** init
:PROPERTIES:
:ID:       08bf0487-2a57-483d-8d22-8253ebda6d9d
:END:

#+begin_src emacs-lisp
(use-package system-packages
  :rule ("bottom" "system-packages" :newname "\\*system-packages")
  :set (system-packages-noconfirm . t))
#+end_src

*** use yay for arch
:PROPERTIES:
:ID:       2fc48e66-83f3-4e35-8b2c-ef9113cb9b45
:END:

If we're in arch and we have yay intalled, use that.

#+begin_src emacs-lisp
(after! system-packages
  (when (and (eq system-packages-package-manager 'pacman)
             (system-packages-package-installed-p "yay"))
    (alet (alist-get 'pacman system-packages-supported-package-managers)
      (push `(yay (default-sudo . nil)
                  ,@(-map (-lambda ((action . command))
			    (cons action (s-replace "pacman" "yay" command)))
                          (cdr it)))
            system-packages-supported-package-managers))
    (setq system-packages-package-manager 'yay)))
#+end_src

** fix elisp indentation :elisp:lang:
:PROPERTIES:
:ID:       834eff05-1b96-4295-a46c-d14f81b43ad6
:END:

A problem with elisp indentation is indents quoted lists the way functions
should be indented. It has been discussed in at least three stackoverflow
questions [[https://emacs.stackexchange.com/questions/10230/how-to-indent-keywords-aligned/10233#10233][here]], [[https://stackoverflow.com/questions/49222433/align-symbols-in-plist][here]] and [[https://stackoverflow.com/questions/22166895/customize-elisp-plist-indentation][here]]. In all these questions the solutions have not
been satisfactory. Some of them recommend using [[helpfn:common-lisp-indent-function][common-lisp-indent-function]] as
the value of [[helpvar:lisp-indent-function][lisp-indent-function]]. This works for indenting a quoted list
properly, but at the expense of changing the way that many other elisp forms are
indented. Common Lisp's indentation is different from Elisp's. Others recommend
using [[https://github.com/Fuco1/.emacs.d/blob/af82072196564fa57726bdbabf97f1d35c43b7f7/site-lisp/redef.el#L12-L94][Fuco1's lisp indent function hack]]. This also is not ideal. For one thing it
only works for quoted lists with keywords but not generic symbols. Another thing
is that the change should really be occurring in [[helpfn:calculate-lisp-indent][calculate-lisp-indent]].
~calculate-lisp-indent~ is a function that returns what the indentation should be
for the line at point. Since Fuco1 did not modify ~calculate-lisp-indent~ the
*wrong* indentation still returned by this function and the modified
~lisp-indent-function~ just cleans up the mess. Better is just fixing the source
of the problem. You can check out a more in-depth explanation looking at my
[[https://www.reddit.com/r/emacs/comments/d7x7x8/finally_fixing_indentation_of_quoted_lists/][reddit-post]] or looking at an answer I gave to [[https://emacs.stackexchange.com/questions/10230/how-to-indent-keywords-aligned][this question]].

#+begin_src emacs-lisp
(defun! properly-calculate-indent (&optional parse-start)
  "Add better indentation for quoted and backquoted lists. "
  (:override calculate-lisp-indent)
  (defvar calculate-lisp-indent-last-sexp)
  (save-excursion
    (beginning-of-line)
    (let ((indent-point (point))
          state
          ;; setting this to a number inhibits calling hook
          (desired-indent nil)
          (retry t)
          calculate-lisp-indent-last-sexp containing-sexp)
      (cond ((or (markerp parse-start) (integerp parse-start))
	     (goto-char parse-start))
            ((null parse-start) (beginning-of-defun))
            (t (setq state parse-start)))
      (unless state
        ;; Find outermost containing sexp
        (while (< (point) indent-point)
          (setq state (parse-partial-sexp (point) indent-point 0))))
      ;; Find innermost containing sexp
      (while (and retry
                  state
                  (> (elt state 0) 0))
        (setq retry nil)
        (setq calculate-lisp-indent-last-sexp (elt state 2))
        (setq containing-sexp (elt state 1))
        ;; Position following last unclosed open.
        (goto-char (1+ containing-sexp))
        ;; Is there a complete sexp since then?
        (if (and calculate-lisp-indent-last-sexp
                 (> calculate-lisp-indent-last-sexp (point)))
            ;; Yes, but is there a containing sexp after that?
            (let ((peek (parse-partial-sexp calculate-lisp-indent-last-sexp
                                            indent-point 0)))
	      (if (setq retry (car (cdr peek))) (setq state peek)))))
      (if retry
          nil
        ;; Innermost containing sexp found
        (goto-char (1+ containing-sexp))
        (if (not calculate-lisp-indent-last-sexp)
            ;; indent-point immediately follows open paren.
            ;; Don't call hook.
            (setq desired-indent (current-column))
          ;; Find the start of first element of containing sexp.
          (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
          (cond ((looking-at "\\s(")
                 ;; First element of containing sexp is a list.
                 ;; Indent under that list.
                 )
                ((> (save-excursion (forward-line 1) (point))
                    calculate-lisp-indent-last-sexp)
                 ;; This is the first line to start within the containing sexp.
                 ;; It's almost certainly a function call.
                 (if (or
		      (= (point) calculate-lisp-indent-last-sexp)

		      (when-let (after (char-after (1+ containing-sexp)))
                        (char-equal after ?:))

		      (when-let (point (char-before containing-sexp))
                        (char-equal point ?'))

		      (let ((quoted-p nil)
                            (point nil)
                            (positions (nreverse (butlast (elt state 9)))))
                        (while (and positions (not quoted-p))
                          (setq point (pop positions))
                          (setq quoted-p
                                (or
                                 (and (char-before point)
				      (char-equal (char-before point) ?'))
                                 (save-excursion
                                   (goto-char (1+ point))
                                   (looking-at-p "quote[\t\n\f\s]+(")))))
                        quoted-p))
                     ;; Containing sexp has nothing before this line
                     ;; except the first element.  Indent under that element.
                     nil
                   ;; Skip the first element, find start of second (the first
                   ;; argument of the function call) and indent under.
                   (progn (forward-sexp 1)
                          (parse-partial-sexp (point)
					      calculate-lisp-indent-last-sexp
					      0 t)))
                 (backward-prefix-chars))
                (t
                 ;; Indent beneath first sexp on same line as
                 ;; `calculate-lisp-indent-last-sexp'.  Again, it's
                 ;; almost certainly a function call.
                 (goto-char calculate-lisp-indent-last-sexp)
                 (beginning-of-line)
                 (parse-partial-sexp (point) calculate-lisp-indent-last-sexp
                                     0 t)
                 (backward-prefix-chars)))))
      ;; Point is at the point to indent under unless we are inside a string.
      ;; Call indentation hook except when overridden by lisp-indent-offset
      ;; or if the desired indentation has already been computed.
      (let ((normal-indent (current-column)))
        (cond ((elt state 3)
	       ;; Inside a string, don't change indentation.
	       nil)
	      ((and (integerp lisp-indent-offset) containing-sexp)
	       ;; Indent by constant offset
	       (goto-char containing-sexp)
	       (+ (current-column) lisp-indent-offset))
	      ;; in this case calculate-lisp-indent-last-sexp is not nil
	      (calculate-lisp-indent-last-sexp
	       (or
                ;; try to align the parameters of a known function
                (and lisp-indent-function
                     (not retry)
                     (funcall lisp-indent-function indent-point state))
                ;; If the function has no special alignment
                ;; or it does not apply to this argument,
                ;; try to align a constant-symbol under the last
                ;; preceding constant symbol, if there is such one of
                ;; the last 2 preceding symbols, in the previous
                ;; uncommented line.
                (and (save-excursion
		       (goto-char indent-point)
		       (skip-chars-forward " \t")
		       (looking-at ":"))
                     ;; The last sexp may not be at the indentation
                     ;; where it begins, so find that one, instead.
                     (save-excursion
		       (goto-char calculate-lisp-indent-last-sexp)
		       ;; Handle prefix characters and whitespace
		       ;; following an open paren.  (Bug#1012)
		       (backward-prefix-chars)
		       (while (not (or (looking-back "^[ \t]*\\|([ \t]+"
                                                     (line-beginning-position))
				       (and containing-sexp
                                            (>= (1+ containing-sexp) (point)))))
                         (forward-sexp -1)
                         (backward-prefix-chars))
		       (setq calculate-lisp-indent-last-sexp (point)))
                     (> calculate-lisp-indent-last-sexp
                        (save-excursion
                          (goto-char (1+ containing-sexp))
                          (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
                          (point)))
                     (let ((parse-sexp-ignore-comments t)
                           indent)
		       (goto-char calculate-lisp-indent-last-sexp)
		       (or (and (looking-at ":")
                                (setq indent (current-column)))
                           (and (< (line-beginning-position)
                                   (prog2 (backward-sexp) (point)))
                                (looking-at ":")
                                (setq indent (current-column))))
		       indent))
                ;; another symbols or constants not preceded by a constant
                ;; as defined above.
                normal-indent))
	      ;; in this case calculate-lisp-indent-last-sexp is nil
	      (desired-indent)
	      (t
	       normal-indent))))))
#+end_src

** eros :elisp:lang:
:PROPERTIES:
:ID:       76a70683-bd59-4ec4-9574-d307ccdc36cd
:END:

=eros= displays the result of evaluating elisp expressions as overlays.

#+begin_src emacs-lisp
(use-package eros
  :hook emacs-lisp-mode-hook
  :set (eros-eval-result-prefix . "⟹ ")
  :config (bind! ([remap eval-last-sexp] #'eros-eval-last-sexp)))
#+end_src

** macrostep :elisp:lang:keybind:prog:
:PROPERTIES:
:ID:       fefc5700-3bd7-4a89-ae7b-bf68368e8bc4
:END:

#+begin_src emacs-lisp
(use-package macrostep
  :commands macrostep-expand)

(bind-localleader!
 (:map emacs-lisp-mode-map)
 (:prefix "m" :wk "macrostep")
 ("e" #'macrostep-expand)
 ("c" #'macrostep-collapse)
 ("C" #'macrostep-collapse-all))
#+end_src

** savehist :cache:
:PROPERTIES:
:ID:       dd4b9da7-e54d-4d62-bb70-aa8f7f4a016f
:END:

=savehist= is a built-in feature for saving the minibuffer-history to a file--the
[[helpvar:savehist][savehist]] file. Additionally, it provides the ability to save additional
variables which may or may not be related to minibuffer history. You add the
ones you want to save to [[helpvar:savehist-additional-variables][savehist-additional-variables]].

*** savehist
:PROPERTIES:
:ID:       54183df6-b4f5-4b01-9ddb-4054ef0583b0
:END:

#+begin_src emacs-lisp
(use-package savehist
  :idle-require custom
  :hook emacs-startup-hook
  :set
  (savehist-save-minibuffer-history . t)
  (savehist-additional-variables    . '(kill-ring search-ring regexp-search-ring))
  (savehist-autosave-interval       . nil)
  (savehist-file                    . (concat XL-CACHE-DIR "savehist")))
#+end_src

*** unpropertize kill ring
:PROPERTIES:
:ID:       da2b6c31-d251-48aa-a6ed-8f01b9fa0b8d
:END:

#+begin_src emacs-lisp
(defhook! unpropertize-kill-ring (kill-emacs-hook :append t)
  "Remove text properties from `kill-ring'."
  (set! (-map-when #'stringp #'substring-no-properties <kill-ring>)))
#+end_src

** ellocate :search:
:PROPERTIES:
:ID:       e3590042-52fb-47ee-a5eb-a7860a3cdb17
:END:

=ellocate= is replacement for.

#+begin_src emacs-lisp
(use-package ellocate
  :commands ellocate
  :set
  (ellocate-scan-dirs . `(("~/" . ,(concat XL-CACHE-DIR "ellocate"))))
  (ellocate-gc-mem    . most-positive-fixnum))
#+end_src

** saveplace :cache:
:PROPERTIES:
:ID:       63b04114-bcb9-4a2e-ad45-be4db8d4a269
:END:

As its name suggests, =save-place= is a built-in package that stores the buffer
location you left off at in a particular buffer. When you visit that buffer
again, you are taken to the location you left off. This is very convenient.

#+begin_src emacs-lisp
(use-package saveplace
  :after-call after-find-file
  :xl-config
  (save-place-mode)
  :set
  (save-place-file . (concat XL-CACHE-DIR "saveplace"))
  (save-place-limit . nil))
#+end_src

** recentf :emacs:config:cache:
:PROPERTIES:
:ID:       5ab47c35-53bd-460f-ba41-6f3075bd1222
:END:

=recentf= is a built-in program that tracks the files you've opened recently
persistently. This is a great idea because these are the files you'll likely
revisit. In practice, I look at this list of files in addition to the buffers I
already have open using a [[id:f26bedb3-a172-4543-afd0-4c47f5872d15][completion-framework]]. Because of this I rarely
have to set out to look for a file with =dired=.

#+begin_src emacs-lisp
(use-package recentf
  :before-call find-file
  :idle-require easymenu tree-widget timer
  :idle recentf-save-list
  :hook (kill-emacs-hook . recentf-save-list)
  :advice (:before (recentf-save-list . recentf-cleanup))
  :silence recentf-mode recentf-cleanup recentf-save-list
  :set
  (recentf-max-menu-items    . 0)
  (recentf-max-saved-items   . 700)
  (recentf-save-file         . (concat XL-CACHE-DIR "recentf"))
  (recentf-auto-cleanup      . (* 60 10))
  (recentf-filename-handlers . '(file-truename abbreviate-file-name))
  :config
  (recentf-mode 1))
#+end_src

** all-the-icons-dired :icon:asthetic:
:PROPERTIES:
:ID:       8e2fe483-5da1-47c7-8d80-a8e68b21fa39
:END:

#+begin_src emacs-lisp
(use-package all-the-icons-dired
  :hook dired-mode-hook)
#+end_src

** dired :file:
:PROPERTIES:
:ID:       877b66c0-7952-4b37-839a-4a9aa5af164a
:END:

*** dired
:PROPERTIES:
:ID:       8a5f8bb6-dce2-4fac-b9c4-068e39f4cfcc
:END:

If you don't set [[helpvar:dired-recursive-deletes][dired-recursive-deletes]], emacs will prompt you every time you
try to delete a directory asking you whether you want to recursively delete its
contents. If you're actually permenently deleting it this is a good idea to
prevent accidental deletion, but I set [[helpvar:delete-by-moving-to-trash][delete-by-moving-to-trash]] to =t=. So
worst case I'll accidentally move a directory to the trash folder.

#+begin_src emacs-lisp
(use-package dired
  :set
  (dired-recursive-copies                      . 'always)
  (dired-recursive-deletes                     . 'always)
  (dired-hide-details-hide-symlink-targets     . nil)
  (dired-clean-confirm-killing-deleted-buffers . nil))
#+end_src

*** sort directories first
:PROPERTIES:
:ID:       8db5ffba-3f74-4146-96e0-03a46213e77d
:END:

#+begin_src emacs-lisp
(defhook! dired:sort-directories-first (dired-after-readin-hook)
  "List directories first in dired buffers."
  (save-excursion
    (let (buffer-read-only)
      (forward-line 2) ;; beyond dir. header
      (sort-regexp-fields t "^.*$" "[ ]*." (point) (point-max))))
  (and (featurep 'xemacs)
       (fboundp 'dired-insert-set-properties)
       (dired-insert-set-properties (point-min) (point-max)))
  (set-buffer-modified-p nil))
#+end_src

**** create non-existent directory
:PROPERTIES:
:ID:       d6151903-ab72-48d7-b9ef-fd13880d3dd2
:END:

#+begin_src emacs-lisp
(defun dired:create-non-existent-directory-h ()
  "Automatically create missing directories when creating new file."
  (let ((parent-directory (file-name-directory buffer-file-name)))
    (when (and (not (file-exists-p parent-directory))
               (y-or-n-p (format "Directory `%s' does not exist! Create it?" parent-directory)))
      (make-directory parent-directory t))))

(after! dired
  (add-to-list 'find-file-not-found-functions 'dired:create-non-existent-directory-h nil #'eq))
#+end_src

** ranger :file:
:PROPERTIES:
:ID:       1791aeb9-1146-43c8-85d6-149335eb9d8f
:END:

[[github:ralesi/ranger.el][ranger]] is a file browser built on top of dired that seeks to emulate [[github:ranger/ranger][a VIM
inspired file manager]] of also called =ranger=.

*** make sure that =;= uses =M-x=
:PROPERTIES:
:ID:       c63911ca-6d26-4d7c-be76-246639fb6c7a
:END:

#+begin_src emacs-lisp
(bind!
  (:map ranger-mode-map)
  (";" #'execute-extended-command)
  ("u" #'dired-unmark))
#+end_src

*** entry
:PROPERTIES:
:ID:       19047e0c-927d-46a6-babe-9c096f4fbcc7
:END:

#+begin_src emacs-lisp
(use-package ranger
  :commands deer ranger
  :silence ranger-window-check
  :set
  (ranger-override-dired-mode . t)
  (ranger-cleanup-eagerly     . t)
  (ranger-cleanup-on-disable  . t)
  (ranger-omit-regexp         . "^.DS_Store$")
  (ranger-excluded-extensions .'("mkv" "iso" "mp4"))
  (ranger-deer-show-details   . nil)
  (ranger-max-preview-size    . 10)
  (ranger-modify-header       . t)
  (ranger-hide-cursor         . t)
  (ranger-dont-show-binary    . t))
#+end_src

*** refresh contents
:PROPERTIES:
:ID:       cef37397-53aa-47e1-a519-ef56a311ae30
:END:

Ranger doesn't refresh the buffer after stuff like moving and pasting has
happend. It results in a very jarring display.

#+begin_src emacs-lisp
(defadvice! refresh-contents (:after ranger-paste dired-do-rename)
  "Refresh contents."
  (when (eq major-mode 'ranger-mode)
    (ranger-refresh)))
#+end_src

** info :popup:help:
:PROPERTIES:
:ID:       d49f83c4-ba8f-477e-beef-8156ed8b974b
:END:

This headline is for customizing info nodes.

#+begin_src emacs-lisp
(use-package info
  :rule ("top" "info" :newname "\\*info"))
#+end_src

** eshell :shell:
:PROPERTIES:
:ID:       58423f45-5f3d-4ba6-8f00-e21dfe3ec2ec
:END:

[[info:eshell#Top][eshell]] is a built-in shell written entirely in elisp. This means that it's as
portable and customizable as emacs itself. It can run elisp functions as
commands. There's a good article about it in [[https://masteringemacs.org/article/complete-guide-mastering-eshell][mastering-emacs]]. Other articles I
have like about eshell: [[https://ambrevar.xyz/emacs-eshell/][ambrevar's eshell post]], [[http://www.howardism.org/Technical/Emacs/eshell-fun.html][Howard Abram's Post]].

*** eshell
:PROPERTIES:
:ID:       b2b473c8-78d7-4f41-9be3-842b6c5acdbb
:END:

#+begin_src emacs-lisp
(use-package eshell
  :rule ("bottom" "eshell" :newname "\\*eshell\\*")
  :set
  (eshell-directory-name             . (concat XL-CACHE-DIR "eshell/"))
  (eshell-history-file-name          . (concat eshell-directory-name "history"))
  (eshell-banner-message             . "")
  (eshell-prefer-lisp-functions      . nil)
  (eshell-scroll-to-bottom-on-input  . 'all)
  (eshell-scroll-to-bottom-on-output . 'all)
  (eshell-buffer-shorthand           . t)
  (eshell-kill-processes-on-exit     . t)
  (eshell-hist-ignoredups            . t)
  (eshell-input-filter               . #'eshell-input-filter-initial-space)
  (eshell-glob-case-insensitive      . t)
  (eshell-error-if-no-glob           . t))
#+end_src

*** em-hist
:PROPERTIES:
:ID:       aaea54da-bd51-4a73-9dad-fe0b49d0f617
:END:

#+begin_src emacs-lisp
(use-package em-hist
  :idle-require t
  :set
  (eshell-history-file-name    . (concat eshell-directory-name "history"))
  (eshell-history-size         . 2000)
  (eshell-hist-ignoredups      . nil)
  (eshell-save-history-on-exit . t))
#+end_src

*** em-term
:PROPERTIES:
:ID:       d2afb853-15c3-4d3f-b8fa-a1075f84bbac
:END:

#+begin_src emacs-lisp
(use-package em-term
  :idle-require t)
#+end_src

*** populate eshell visual commands
:PROPERTIES:
:ID:       e46d897d-eca5-43be-83d1-05eab1184965
:END:

#+begin_src emacs-lisp
(defafter! populate-eshell-visual-commands (em-term)
  "Add common commands to `eshell-visual-commands'."
  (iter (each command '("tmux" "htop" "bash" "zsh" "fish" "vim" "nvim" "ncmpcpp"))
	(pushnew command eshell-visual-commands)))
#+end_src

*** em-alias
:PROPERTIES:
:ID:       694a8c17-8318-4222-b461-abfc1d8a78ea
:END:

#+begin_src emacs-lisp
(use-package em-alias
  :idle-require t)
#+end_src

*** eshell-z
:PROPERTIES:
:ID: 497798a0-7b62-4779-bf15-f67500528f03
:END:

#+begin_src emacs-lisp
(use-package eshell-z
  :commands eshell-z
  :set
  (eshell-z-freq-dir-hash-table-file-name . (expand-file-name "z" eshell-directory-name)))
#+end_src

*** eshell-up
:PROPERTIES:
:ID: 478219b9-1c6f-4907-b428-a2dfe0f45e5c
:END:

This is an Emacs package for quickly navigating to a specific parent directory
in ~eshell~ without having to repeatedly typing ~cd ..~.

#+begin_src emacs-lisp
(use-package eshell-up
  ;; :alias
  ;; (eshell/up . eshell-up)
  ;; (eshell/peek . eshell-up-peek)
  )
#+end_src


** shrink-path :file:
:PROPERTIES:
:ID:       7edc1484-1e21-45b7-8db6-904b1ef913a6
:END:

It's easy to underestimate how much of a difference having an asthetically
pleasing Emacs configuration can have. Ugliness really can take its toll.

** helpful :help:bind:interface:
:PROPERTIES:
:ID:       5340ddb3-92bc-42e5-bf0e-9f9650c41cd9
:END:

[[github:wilfred/helpful][helpful]] provides a complete replacement for the built-in Emacs help facility
which provides much more contextual information in a better format.

#+begin_src emacs-lisp
(use-package helpful
  :rule ("bottom" "help" :newname "\\*help.+"))

(bind!
 ([remap describe-function] #'helpful-callable)
 ([remap describe-command]  #'helpful-command)
 ([remap describe-variable] #'helpful-variable)
 ([remap describe-key]      #'helpful-key))
#+end_src

* window :window:
:PROPERTIES:
:ID:       bb6bc4a5-6567-4fa8-b984-7175bd9fad31
:END:

** zoom-window
:PROPERTIES:
:ID:       d506fde5-d1bc-4807-a1d0-a8ed5c33def2
:END:

This package provides a command that temporarily makes a window occupy full
screen. And then reverts the window configuration to what it was again
afterwards.

#+begin_src emacs-lisp
(use-package zoom-window
  :commands zoom-window)
#+end_src

** window
:PROPERTIES:
:ID:       af27cd7e-2096-4f6d-a749-63e4c38d136c
:END:

#+begin_src emacs-lisp
(use-package window
  :set
  (split-width-threshold . 160))
#+end_src

** commands
:PROPERTIES:
:ID:       5fd85e31-872c-4030-b9a8-c86d7bc2f440
:END:

*** window movement
:PROPERTIES:
:ID:       f0152373-3b3f-4cf1-abaf-d025c93c64d3
:END:

#+begin_src emacs-lisp
(bind!
  (:prefix "w" :wk "window")
  (:map xl-leader-map)
  ("h" #'windmove-left)
  ("j" #'windmove-down)
  ("k" #'windmove-up)
  ("l" #'windmove-right)
  ("o" #'ace-window)
  ("d" #'delete-window)
  ("D" #'delete-other-windows)
  ("v" #'split-window-horizontally)
  ("s" #'split-window-vertically)
  ("t" #'transpose-frame))
#+end_src

*** split-below-and-focus
:PROPERTIES:
:ID: d6a4a81f-007d-4b7e-97a3-e0bba3ff97a4
:END:

#+begin_src emacs-lisp
(defun xl/window-split-below-and-focus ()
  "Split window below and select the window created with the split."
  (interactive)
  (select-window (split-window-below)))
#+end_src

*** split-right-and-focus
:PROPERTIES:
:ID: 6cb60d94-723b-48e5-850a-3483e78f6647
:END:

#+begin_src emacs-lisp
(defun xl/window-split-right-and-focus ()
  "Split window right and select the window created with the split."
  (interactive)
  (select-window (split-window-right)))
#+end_src

*** window resizing :keybind:window:
:PROPERTIES:
:ID:       373e3cf8-68ea-4791-ae71-e0c73b2f218a
:END:

#+begin_src emacs-lisp
(bind!
  (:prefix "w")
  (:map xl-leader-map)
  ("M" #'maximize-window)
  ("m" #'minimize-window)
  ("b" #'window-balance)
  ("z" #'zoom-window-zoom))
#+end_src

** workspaces :workspace:
:PROPERTIES:
:ID:       f6e649d6-70f3-4103-9f12-dd9c91dd5ebe
:END:

*** desktop
:PROPERTIES:
:ID:       902a11fc-b9aa-4875-ba92-8d2561a12a50
:END:

=desktop= is a built-in emacs package for saving window configuration setup.

**** some settings
:PROPERTIES:
:ID:       e4c30275-db62-4e6d-890c-6199b0594fd8
:END:

#+begin_src emacs-lisp
(use-package desktop
  :set
  (desktop-save                 . t)
  (desktop-dirname              . XL-CACHE-DIR)
  (desktop-auto-save-timeout    . auto-save-timeout)
  (desktop-base-file-name       . "emacs.desktop")
  (desktop-base-lock-name       . "emacs.desktop.lock")
  (desktop-path                 . (list XL-CACHE-DIR))
  (desktop-missing-file-warning . nil))
#+end_src

**** allowing desktops to go in one directory
:PROPERTIES:
:ID:       22b0be3a-ef36-47d4-8684-602f3a8c8462
:END:

These functions are all based on the =desktop+= functions. The main thing it
does is provide a directory where desktop files can be placed. This should
really have been done by =desktop.el= but oh well.

***** base directory
:PROPERTIES:
:ID:       e1ce2616-2280-435d-85c4-8d71c30c6a75
:END:

#+begin_src emacs-lisp
(defvar desktop:base-dir (concat XL-CACHE-DIR "desktops/")
  "Directory where desktops should go.")
#+end_src

***** generate the base directory
:PROPERTIES:
:ID:       fa173f38-2888-465a-8de4-282233322363
:END:

#+begin_src emacs-lisp
(defun desktop:dirname (name)
  "Return the path where desktop named NAME should go."
  (require 'f)
  (f-join desktop:base-dir name))
#+end_src

***** ensure the base directory
:PROPERTIES:
:ID:       3662ceaa-aed9-4dbc-bea9-7e1878237c87
:END:

#+begin_src emacs-lisp
(defhook! ensure-desktop-directory (desktop-mode-hook)
  "Make `desktop:base-dir' if it does not exist."
  (mkdir desktop:base-dir t))
#+end_src

***** desktop names
:PROPERTIES:
:ID:       5286a22f-dc93-4e32-8a35-3bfbdfda8668
:END:

#+begin_src emacs-lisp
(defun desktop:list ()
  "Return a list of the names of all desktops."
  (-difference (directory-files desktop:base-dir)
	       (list ".." ".")))
#+end_src

***** create a desktop
:PROPERTIES:
:ID:       331367bb-a1eb-414f-89ef-386ba6fc1e60
:END:

#+begin_src emacs-lisp
(defun desktop:create-desktop (name)
  "Create a new desktop named NAME."
  (let ((desktop-dirname (desktop:dirname name)))
    (desktop-kill)
    (make-directory desktop-dirname 'parents)
    (desktop-save desktop-dirname)))
#+end_src

***** load an existing desktop
:PROPERTIES:
:ID:       691dd9bf-b207-4885-9f7c-b8791d972dc1
:END:

#+begin_src emacs-lisp
(defun desktop:load-desktop (name)
  (desktop-change-dir (desktop:dirname name)))
#+end_src

**** create desktop in new tab
:PROPERTIES:
:ID:       4bbb0f3a-bc51-4552-b91f-8404ab19cdd8
:END:

This is an integration with desktop and tab mode.

#+begin_src emacs-lisp
(defun desktop/create-desktop-in-new-tab (name)
  "Create desktop named NAME in new tab.
The tab's new name is the same as the desktop name."
  (interactive
   (list (completing-read "Create desktop:" (desktop:list))))
  (tab-bar-new-tab)
  (tab-bar-rename-tab name)
  (desktop:create-desktop name))
#+end_src

**** load desktop in a new tab
:PROPERTIES:
:ID:       391c0817-bb2f-4334-b320-f039ab23cfb7
:END:

#+begin_src emacs-lisp
(defun desktop/load-desktop-in-new-tab (name)
  "Create desktop named NAME in new tab.
The tab's new name is the same as the desktop name."
  (interactive
   (list (completing-read "Load desktop: " (desktop:list))))
  (tab-bar-new-tab)
  (tab-bar-rename-tab name)
  (desktop:load-desktop name))
#+end_src

**** desktop restore functions
:PROPERTIES:
:ID:       0f82a1dc-d28e-4875-a622-e6116c0d3843
:END:

***** helpful-buffers
:PROPERTIES:
:ID:       f7d3a8ce-7115-47d6-b0ac-2d078741a49a
:END:

#+begin_src emacs-lisp
(defun desktop:restore-helpful-buffer ()
  "Restore helpful buffer.")
#+end_src

*** workgroups2
:PROPERTIES:
:ID:       b5452102-a8fb-409f-8c36-35d404b5a5a6
:END:

There is a need to save buffers and window configurations in their own groups.
Often we'll have a group of buffers we've setup to work on a project or task and
suddenly, in the middle of that task we'll want to work on another task. It's
inconvenient to get rid of the window configuration we've set up just to have to
come back to it and set it up again. This is what workspaces, also called
workgroups, are for. You can save the window configuration you're using and
switch to a new one.

Workgroup provides a. One notable advantage of workgroups is that it does not
use emacs's built-in serialization of window configs. Usually, it is better to
use something that's built-in. However, emacs's serialization has the drawback
that it's not a lisp object; implying that it is not.

**** workspaces :workgroup:keybind:
:PROPERTIES:
:ID:       ba627c58-6008-42a2-abc2-7136f77d44d5
:END:

#+begin_src emacs-lisp
(bind!
  (:map xl-leader-map)
  (:prefix "r" :wk "workspace")
  ("c" #'wg-create-workgroup)
  ("b" #'wg-switch-to-workgroup)
  ("a" #'wg-associate-visible-buffers-with-workgroup)
  ("b" #'wg-dissociate-buffer-from-workgroup)
  ((:prefix "o" :wk "reload")
   ("w" #'wg-open-workgroup)
   ("s" #'wg-open-session))
  ((:prefix "s" :wk "save")
   ("s" #'wg-save-session)
   ("c" #'wg-save-wconfig)))
#+end_src

**** workgroups2
:PROPERTIES:
:ID:       890c8e5b-524d-44b6-b90e-c830436b9da8
:END:

#+begin_src emacs-lisp
(use-package workgroups2
  :commands wg-switch-workgroup
  :ignore wg-change-modeline
  :silence wg-create-workgroup wg-switch-workgroup
  :set
  (wg-emacs-exit-save-behavior           . 'save)
  (wg-workgroups-mode-exit-save-behavior . 'save)
  (wg-flag-modified                      . nil)
  (wg-mode-line-display-on               . nil)
  (wg-load-last-workgroup                . nil)
  (wg-open-this-wg                       . nil)
  (wg-control-frames                     . nil)
  (wg-session-load-on-start              . nil)
  (wg-flag-modified                      . nil)
  (wg-session-file                       . (concat XL-CACHE-DIR "wg-session")))
#+end_src

*** tab-bar-mode
:PROPERTIES:
:ID:       0a72fe9a-1948-4022-a300-18a4881da382
:END:

**** settings
:PROPERTIES:
:ID:       bb63f5b2-cc45-454b-a032-be248f801636
:END:

#+begin_src emacs-lisp
(use-package tab-bar-mode
  :hook (tab-bar-mode-hook . tab-bar-history-mode)
  :set
  (tab-bar-new-tab-choice . "*scratch*")
  (tab-bar-history-limit  . 25)
  (tab-bar-tab-hints      . nil)
  (tab-bar-show           . nil))
#+end_src

**** dont actually display the tabs
:PROPERTIES:
:ID:       e4cee146-f6ac-47f1-9e98-f209ae9f9bec
:END:

I want the tabs to exist as a concept, but (ironically) I don't actually want
them displayed.

#+begin_src emacs-lisp
(defadvice! inhibit-tab-display (:after tab-bar-mode make-frame)
  "Inhibit the display of tags in tab-bar-mode."
  (iter (for frame (frame-list))
	(set-frame-parameter frame 'tab-bar-lines 0)))
#+end_src

** exwm :exwm:
:PROPERTIES:
:ID:       ff30cdb0-5c9a-454d-9a6c-dbc8e3fa7cfe
:END:

[[https://github.com/ch11ng/exwm][EXWM]] (Emacs X-Window Manager) is a full-featured window manager in Emacs.  There
are benefits and drawbacks to making emacs your window manager. One benefit is
that you get a super consistent window management experience. One drawback is
that if Emacs hangs or crashes you need to restart your computer.

*** exwm
:PROPERTIES:
:ID:       7b83cab0-d599-46c4-b20c-19ff33345ae3
:END:

#+begin_src emacs-lisp
(use-package exwm
  :os linux
  :before-call browse-url)
#+end_src

*** trigger exwm on =browse-url= :advice:
:PROPERTIES:
:ID:       581b8529-00a0-4935-9363-60dba9dbe5f4
:END:

=exwm= provides an option [[helpvar:exwm-replace][exwm-replace]] to deal with the case of an existing
window manager when exwm is initializing itself. There are three
ways. You could replace it with exwm without asking, ask whether to
replace it, or abort the initialization of exwm.

#+begin_src emacs-lisp
(defadvice! init-exwm-maybe (:before browse-url)
  "Try to initialize exwm.
If it's not possible, abort initialization gracefully."
  (require 'exwm)
  ;; Try to enable exwm.
  (let ((exwm-replace nil))
    (if (ignore-errors (exwm-init))
	;; Enable the clipboard.
	(progn (require 'exwm-systemtray)
	       (exwm-systemtray-enable))
      (xl-log "Another window manager is present (or something went wrong)."))))
#+end_src

*** exwm-evil-firefox :browser:
:PROPERTIES:
:ID:       e5463b7a-9727-43b1-aa20-831a3617308f
:END:

This package lets you use exwm to control firefox and give it evil bindings. You
can tell exwm to send "fake" keys to firefox corresponding to the key you've
pressed. The only thing I find missing here is a way to quickly select links in
an. One caveat is that mouse clicks only work in insert mode.

#+begin_src emacs-lisp
(use-package exwm-firefox-evil
  :hook (exwm-manage-finished-hook . exwm-firefox-evil-activate-if-firefox)
  :before-call browse-url-firefox)
#+end_src

*** exwm-float
:PROPERTIES:
:ID:       aa59c567-56b6-4ef7-b63c-cb8172e38965
:END:

This package provides a minor mode for configuring floating windows. I still
need to figure out the proper way to lazy load it.

Interestingly, Emacs offers two different ways of managing windows like a window
manager. One is to use windows and the other is to use frames. The advantage of
the frame approach is that it's easy to have a "gap" setup.

#+begin_src emacs-lisp
(use-package exwm-float
  :set
  (exwm-float-modify-amount . '(:move-slow 20 :move-fast 100 :resize 50))
  (exwm-float-border        . '(:stationary ("navy" . 1) :moving ("maroon" . 2)))
  :config
  (exwm-float-setup)
  (exwm-input-set-key (kbd "C-c M-f") #'exwm-float-mode))
#+end_src

*** exwm-outer-gaps
:PROPERTIES:
:ID:       6bf91f2b-a41b-43f9-bb22-4c01b27d1f07
:END:

This package provides exwm with outer gaps.

#+begin_src emacs-lisp
(use-package exwm-outer-gaps)
(straight-use-package '(exwm-outer-gaps :host github :type git :repo "lucasgruss/exwm-outer-gaps"))
#+end_src

*** TODO org capture from an exwm buffer :exwm:org:capture:
:PROPERTIES:
:ID:       5428bdc1-c075-4387-b3ab-080d372c478f
:END:

A common dream among many Org users is to integrate [[info:org#Capture][org-capture]] into their browser.
Indeed, the browser by nature would be a place you'd want to capture from a lot.
However, since graphical browsers are not in emacs the main way to do this was
via a hacky and difficult to set up [[https://orgmode.org/worg/org-contrib/org-protocol.html][org-protocol]].

https://www.reddit.com/r/emacs/comments/f6zzux/capturing_website_url_with_orgcapture_and_exwm/

**** exwm title
:PROPERTIES:
:ID:       ce78d409-e635-4d94-b20e-38c2034ab5e8
:END:

#+begin_src emacs-lisp
(defun exwm%title-info (title)
  "Return the webpage and the program."
  (-let [(_ webpage program) (s-match "\\([^z-a]+\\) - \\([^z-a]+\\)\\'" title)]
    (list webpage program)))
#+end_src

**** simulate keys
:PROPERTIES:
:ID:       b2688daa-eda9-480c-9d4b-2e054bcb633f
:END:

This is an improvement to the raw code provided [[https://www.reddit.com/r/emacs/comments/f6zzux/capturing_website_url_with_orgcapture_and_exwm/][on reddit]]. Using this make
simulating keys require *much* less boilerplate.

#+begin_src emacs-lisp
(defun exwm%simulate-keys (keys &optional buffer msecs)
  "Simulate keys in current buffer."
  (iter (with (fid (exwm--buffer->id (or buffer (current-buffer)))))
	(each key keys)
	(exwm-input::fake-key-to-id key fid)
	(sleep-for 0 (or msecs 300))))
#+end_src

*** appropriate name for exwm buffers
:PROPERTIES:
:ID:       3e32ba6d-dfb3-4bae-b3d8-21b6e38bfe51
:END:

By default each exwm buffer is named =*EXWM*=. We want them to have
a more descriptive name.

#+begin_src emacs-lisp
(defhook! rename-buffer-to-title (exwm-update-title-hook)
  "Rename buffer to title."
  (exwm-workspace-rename-buffer exwm-title))
#+end_src

*** char mode
:PROPERTIES:
:ID:       80dbac77-5b8c-4ef7-8d37-561f646af250
:END:

=EXWM= has two modes, =line-mode= and =char-mode=. It's best for Emacs and Next to
start with =char-mode= because they both have keys that are important for their
use (like =M-x=) which conflict with Emacs (the instance that's managing the
windows).

*** list of applications
:PROPERTIES:
:ID:       d1bf0601-a995-48f7-ab80-86755ba9269a
:END:

#+begin_src emacs-lisp
(defvar exwm:char-mode-apps (list "emacs" "next" "nyxt" "qutebrowser")
  "List of applications to exwm should start in char-mode.")
#+end_src

*** to start in char mode
:PROPERTIES:
:ID:       cb9da3f1-3cbb-4a16-b5ae-b1e122a3a3fd
:END:

#+begin_src emacs-lisp
(defhook! start-in-char-mode (exwm-manage-finish-hook)
  "Start a program in char-mode if it's in `exwm:char-mode-apps'."
  (when (--any-p (string-prefix-p it exwm-instance-name) exwm:char-mode-apps)
    (exwm-input-release-keyboard (exwm--buffer->id (window-buffer)))))
#+end_src

*** exwm-edit :edit:
:PROPERTIES:
:ID:       39361fa6-0df0-416e-aed6-2f8cb3bf9fb9
:END:

The dream is to do all text editing in Emacs. This package is a big step towards
achieving that dream. =exwm-edit= allows the user to edit text fields in
external packages with an emacs buffer. It acts a lot like =org-edit-src-code=:
it copies any text in the text field to a buffer, you edit the buffer, then
press a binding to insert the buffer text into the text field. It goes without
saying that when the text is in an emacs buffer, you can use the full-force of
Emacs's text editing capabilities on it.

Concerning the loading of exwm-edit. Ideally, I should load it after
certain applications where I'd use it need to be loaded.

#+begin_src emacs-lisp
(use-package exwm-edit
  :commands exwm-edit
  :init
  (after! exwm
    (funcall (get 'exwm-input-global-keys 'custom-set)
	     'exwm-input-global-keys
	     `((,(kbd "C-'") . exwm-edit)))))
#+end_src

*** TODO keybindings
:PROPERTIES:
:ID:       8f8e7106-be2e-4c4f-8e4b-d236f805725b
:END:

#+begin_src emacs-lisp
(after! exwm
  (funcall (get 'exwm-input-global-keys 'custom-set)
           'exwm-input-global-keys
           `((,(kbd "s-R") . exwm-reset)
             (,(kbd "s-x") . exwm-input-toggle-keyboard)
             (,(kbd "s-h") . windmove-left)
             (,(kbd "s-j") . windmove-down)
             (,(kbd "s-k") . windmove-up)
             (,(kbd "s-l") . windmove-right)
             (,(kbd "s-t") . transpose-frame)
             (,(kbd "s-D") . kill-this-buffer)
             (,(kbd "s-b") . switch-to-buffer)
             (,(kbd "s-f") . find-file)
             (,(kbd "s-O") . exwm-layout-toggle-fullscreen)
             (,(kbd "s-p") . previous-buffer)
             (,(kbd "s-n") . next-buffer)
             (,(kbd "s-q") . xl/open-qutebrowser)
             (,(kbd "s-e") . xl/open-emacs-instance))))
#+end_src

* miscellaneous :miscellany:
:PROPERTIES:
:ID:       09686c53-e830-4366-b251-7505cff70e3f
:END:

** buffer management
:PROPERTIES:
:ID:       689c4fc9-6afd-432e-82be-2ed06050b2c7
:END:

** TODO key-chord :bind:
:PROPERTIES:
:ID:       20d6d9c1-50a1-4699-a67c-e6f04d3b5576
:END:

Sometimes we don’t have access to a convenient escape key--I mean that caps-lock
is not bound to escape. Or, perhaps, we might find it faster or preferable to
press jk really quickly to invoke escape.

This is better than evil escape as it only binds in insert.

#+begin_src emacs-lisp
(use-package key-chord
  :silence key-chord-mode
  :before-call evil-insert-state evil-emacs-state)
#+end_src

** TODO key-chord :bind:evil:
:PROPERTIES:
:ID:       65bb49db-7df4-4503-977d-b1285c7a48f3
:END:

#+begin_src emacs-lisp
(defafter! use-j-k-as-escape (key-chord evil)
  (key-chord-define evil-insert-state-map "jk" #'evil-force-normal-state)
  (key-chord-define evil-insert-state-map "kj" #'evil-force-normal-state)
  (key-chord-define evil-emacs-state-map "jk" #'evil-force-normal-state)
  (key-chord-define evil-emacs-state-map "kj" #'evil-force-normal-state)
  (after! lispyville
    (key-chord-define evil-emacs-state-map "jk" #'lispyville-normal-state)
    (key-chord-define evil-emacs-state-map "kj" #'lispyville-normal-state)
    (key-chord-define evil-insert-state-map "jk" #'lispyville-normal-state)
    (key-chord-define evil-insert-state-map "kj" #'lispyville-normal-state)))
#+end_src

** nameless :elisp:prog:
:PROPERTIES:
:ID:       695aeb73-89d3-47f8-bee8-2721111dd2bf
:END:

=nameless= is a package that truncates namespace prefixes that you specify
in. Shortening aliases allows for more concise, easier to read, and less
redundant code.

#+begin_src emacs-lisp
(use-package nameless
  :hook emacs-lisp-mode-hook
  :set (nameless-private-prefix . t))
#+end_src

** avy :navigation:interface:
:PROPERTIES:
:ID:       78064d92-2dde-4067-8a10-208ca6e88852
:END:

#+begin_src emacs-lisp
(use-package avy
  :set
  (avy-style . 'pre)
  (avy-keys . (number-sequence ?a ?z)))
#+end_src

** TODO zone :amusement:
:PROPERTIES:
:ID:       fe176959-3134-4b18-8abb-a962347b8df0
:END:

#+begin_src emacs-lisp
(use-package zone)
#+end_src

** zoom-frm :text:interface:
:PROPERTIES:
:ID:       15b8577e-3f98-420a-81a5-c7b91292aca3
:END:

This package increases or decreases the font of the current frame. It differs
from [[helpfn:text-scale-increase][text-scale-increase]] and [[helpfn:text-scale-decrease][text-scale-decrease]] in that it applies this
"zooming" to the whole frame instead of the current buffer.

#+begin_src emacs-lisp
(use-package zoom-frm
  :set
  (frame-zoom-font-difference . 0.5)
  (zoom-frame/buffer          . 'buffer))
#+end_src


** tramp :cache:
:PROPERTIES:
:ID:       a3ccfafa-dc88-4aac-bbe9-fc4ae0f00997
:END:

#+begin_src emacs-lisp
(use-package tramp
  :set
  (tramp-backup-directory-alist . backup-directory-alist)
  (tramp-persistency-file-name  . (concat XL-CACHE-DIR "tramp-persistency.el"))
  (tramp-auto-save-directory    . (concat XL-CACHE-DIR "tramp-auto-save/")))
#+end_src

** restart-emacs
:PROPERTIES:
:ID:       7412bc2f-0db1-44e9-8ea7-0dc595a04fca
:END:

#+begin_src emacs-lisp
(use-package restart-emacs
  :commands restart-emacs)
#+end_src

** elisp-demos :interface:elisp:
:PROPERTIES:
:ID:       2c419004-a7c1-4de5-bada-8420505cea90
:END:

This package has a good idea--namely it provides a systematic way to add
function/macro demos to documentation. Still, I have a few problems with this
package. For one thing, it adds the examples along with the ugly "begin/end_src"
lines. I'd rather have something like the comment arrow ~;=>~. Also, I'd like to
integrate it with writing tests. Wouldn't it be great if I could write tests for
a function and simultaneously add those tests as examples for how to use the
function?

#+begin_src emacs-lisp
(use-package elisp-demos
  :advice (:after (helpful-update . elisp-demos-advice-helpful-update)))
#+end_src

** bookmarks
:PROPERTIES:
:ID:       a4514b36-6e08-4a66-a595-cd40fc9acc0b
:END:

#+begin_src emacs-lisp
(use-package bookmark
  :set
  (bookmark-default-file . (concat XL-CACHE-DIR "bookmarks")))
#+end_src

** nsm
:PROPERTIES:
:ID:       0ca7fc66-5312-4c69-a87d-7607292c7a2a
:END:

#+begin_src emacs-lisp
(use-package nsm
  :set
  (nsm-settings-file . (concat XL-CACHE-DIR "network-settings.data")))
#+end_src

** mouse :mouse:
:PROPERTIES:
:ID:       d0d6de11-50fa-4ae2-ad4b-69712f3e2c54
:END:

#+begin_src emacs-lisp
(use-package mouse
  :set
  (mouse-yank-at-point . t))
#+end_src

** ansi-color
:PROPERTIES:
:ID:       5feaab76-e5c1-450c-94a6-8fdfb95ddb94
:END:

#+begin_src emacs-lisp
(use-package ansi-color
  :set
  (ansi-color-for-comint-mode . t))
#+end_src

** gv
:PROPERTIES:
:ID:       84cc5883-a303-453e-af91-644d4544e3f9
:END:

=gv= is what contains the code for the =setf= macro.
https://emacs.stackexchange.com/questions/59314/how-can-i-make-setf-work-with-plist-get

#+begin_src emacs-lisp
(use-package gv
  :xl-config
  (gv-define-simple-setter plist-get plist-put))
#+end_src

** image mode
:PROPERTIES:
:ID:       32e2118a-c92b-4e8d-b2db-048428462783
:END:

Non-nil means animated images loop forever, rather than playing once.

#+begin_src emacs-lisp
(use-package image-mode
  :set
  (image-animate-loop . t))
#+end_src

** uniquify :buffer:
:PROPERTIES:
:ID:       9ba2726b-3fef-4e9b-9387-a80ab09bdb7d
:END:

#+begin_src emacs-lisp
(use-package uniquify
  :set
  (uniquify-buffer-name-style . 'forward))
#+end_src

** compile
:PROPERTIES:
:ID:       913aa4f2-e42b-4b74-a2d4-e87b1738a5bd
:END:

#+begin_src emacs-lisp
(use-package compile
  :set
  (compilation-ask-about-save . nil)
  (compilation-scroll-output  . 'first-error)
  (compilation-always-kill    . t))
#+end_src

** bytecomp
:PROPERTIES:
:ID:       6b375bfb-a8c3-473c-8dbd-530e692a15ab
:END:

#+begin_src emacs-lisp
(use-package bytecomp
  :set
  (byte-compile-warnings . '(not free-vars unresolved noruntime lexical make-local))
  (byte-compile-verbose  . xl-debug-p))
#+end_src

** url :cache:
:PROPERTIES:
:ID:       d4c0b77e-7c6c-4ab3-bf20-fb0d335eb771
:END:

#+begin_src emacs-lisp
(use-package url
  :set
  (url-cache-directory         . (concat XL-CACHE-DIR "url/cache/"))
  (url-configuration-directory . (concat XL-CACHE-DIR "url/configuration/")))
#+end_src

** ffap
:PROPERTIES:
:ID:       acdd6407-c7db-40d7-9a7f-3a189d3c40eb
:END:

Don't ping things that look like domain names.

#+begin_src emacs-lisp
(use-package ffap
  :set
  (ffap-machine-p-known . 'reject))
#+end_src

** passwords and security :security:
:PROPERTIES:
:ID:       7ca7587e-d94b-408b-8656-c6a09d6ee8b6
:END:

I build my =mbsyncrc= and my =msmtprc= via tangling.

*** pass
:PROPERTIES:
:ID:       6f3268a1-4606-435d-9bf4-05d1c54c28a9
:END:

#+begin_src emacs-lisp
(use-package pass)
#+end_src

*** password-store
:PROPERTIES:
:ID:       3c57590c-1507-4369-b615-795965d4b182
:END:

#+begin_src emacs-lisp
(use-package password-store)
#+end_src

*** email accounts :email:
:PROPERTIES:
:ID:       3a3c6778-dc5d-45cf-87d1-1c6aacbbae46
:END:

Whatever emails I may use, I'll be adding their password in my password store so
why not use this as a way to get email information?

#+begin_src emacs-lisp
(defun password-store%email-accounts ()
  "Return a list of email accounts."
  (->> (expand-file-name "email/" (password-store-dir))
       (directory-files)
       (cddr)
       (mapcar (fn! (s-chop-suffix ".gpg" <>)))))
#+end_src

*** epa :gpg:
:PROPERTIES:
:ID:       ad3f6134-4fa6-492e-93a6-b94235ecad3d
:END:
:LINKS:
https://vxlabs.com/2021/03/21/gnupg-pinentry-via-the-emacs-minibuffer/
:END:

Setting these variables in coordination with [[id:58a65d49-cd9f-4b5d-86d7-d43209424cf3][my gpg-agent config]] lets me enter my
gpg passphrase via emacs.

#+begin_src emacs-lisp
(use-package epa-config
  :set
  (epg-gpg-program   . "gpg2")
  (epg-pinentry-mode . 'loopback))
#+end_src

** chess :amusement:
:PROPERTIES:
:ID:       1197be6f-a2ff-4cf1-8b78-02ebceb43317
:END:

#+begin_src emacs-lisp
(use-package chess)
#+end_src

** gcmh :performance:core:
:PROPERTIES:
:ID:       86653a5a-f273-4ce4-b89b-f288d5d46d44
:END:

=gcmh= does three things. It reduces garbage collection by setting, it adds a
hook telling Emacs to gargbage collect during idle time, and it tells Emacs
to garbage collect more frequently when it's idle.

Note that I add gcmh mode hook at the end so that all the other hook commands
are done before setting the =gc-cons-threshold= back to a normal value.

#+begin_src emacs-lisp
(use-package gcmh
  :hook emacs-startup-hook
  :set
  (gcmh-idle-delay          . 5)
  (gcmh-verbose             . xl-debug-p)
  (gcmh-high-cons-threshold . XL-GC-CONS-THRESHOLD)
  (gcmh-low-cons-threshold  . XL-GC-CONS-THRESHOLD-MIN))
#+end_src

** readme org file
:PROPERTIES:
:ID:       ceb0caee-f950-4ab5-a6e9-aad436334469
:END:

#+begin_src emacs-lisp
(defun xl/switch-to-readme ()
  "Switch to README."
  (interactive)
  (find-file (f-full "~/README.org")))
#+end_src

** hideshow :prog:
:PROPERTIES:
:ID:       2222cf6a-5274-4a33-ae74-357676fbd61d
:END:

#+begin_src emacs-lisp
(use-package hideshow
  :hook (prog-mode-hook . hs-minor-mode))
#+end_src

** commands :command:
:PROPERTIES:
:ID:       d4d49eb7-8fb3-414e-ad13-6ee353ee3466
:END:

*** elisp init file
:PROPERTIES:
:ID:       74ad3337-4a36-4524-87c1-6b46b2dc24dd
:END:

#+begin_src emacs-lisp
(defun xl/switch-to-init-file ()
  "Switch to init file."
  (interactive)
  (find-file user-init-file))
#+end_src

*** emacs directory
:PROPERTIES:
:ID:       7ea118cb-4eb6-4ffb-9d82-6ae65ff7a961
:END:

#+begin_src emacs-lisp
(defun xl/open-dired-at-emacs-dir ()
  "Switch to a dired buffer at emacs directory."
  (interactive)
  (dired user-emacs-directory))
#+end_src

*** setting font size
:PROPERTIES:
:ID:       b138b662-4087-4199-abe5-ecacb22dfb2a
:END:

#+begin_src emacs-lisp
(defun xl/set-font-size ()
  "Set the font size interactively.
Inhibit accidentally setting font size too high or too low."
  (interactive)
  (let* ((old-size (/ (face-attribute 'default :height) 10))
         (prompt "The font size is currently %d. What do you want to change it to? ")
         (new-size (string-to-number (read-string (format prompt old-size)))))
    (cond ((> new-size XL-FONT-MAX-SIZE)
	   ;; (message "That font size is too large. It should be below %d." XL-FONT-MAX-SIZE)
	   (call-interactively #'xl/set-font-size))
	  ((< new-size XL-FONT-MIN-SIZE)
	   ;; (message "That font size is too small. It should be above %d." XL-FONT-MIN-SIZE)
	   (call-interactively #'xl/set-font-size))
	  (t
	   (xl-set-font-size new-size)
	   (message "Font set from %d to %d." old-size new-size)))))
#+end_src

*** kill Emacs processes
:PROPERTIES:
:ID:       811f6b55-6f54-4854-9098-8754359b4f85
:END:

#+begin_src emacs-lisp
(defun xl/kill-emacs-processes ()
  "Kill all emacs processes."
  (interactive)
  (loopy (with (count 1) (process "emacs"))
	 (while (ignore-errors (kill-process process)))
	 (expr process (format "emacs<%d>" count))
	 (do (incf count))
	 (finally (message "killed %d processes" count))))
#+end_src

*** font-face
:PROPERTIES:
:ID:       1bf8b603-ba11-422f-80d2-53dd8483fdbb
:END:

There is also no interactive function for setting the font face.

I will note that I use [[helpfn:xl-list-fonts][x-list-fonts]] intentionally, because it gives you options.

#+begin_src emacs-lisp
(defun xl/set-font-face ()
  "Apply an existing xfont to all graphical frames."
  (interactive)
  (alet (completing-read "Choose font: " (x-list-fonts "*"))
    (set-frame-font it nil t)))
#+end_src

*** open Emacs instance
:PROPERTIES:
:ID:       287537bc-f1a7-4c04-bbb6-c372df540e04
:END:

#+begin_src emacs-lisp
(defun xl/open-emacs-instance ()
  "Open a new emacs instance in debug-mode."
  (interactive)
  (cond ((eq system-type 'darwin)
         (start-process-shell-command
          "emacs"
          nil "open -n /Applications/Emacs.app --args --debug-init"))
        ((eq system-type 'gnu/linux)
         (start-process "emacs" nil "emacs" "--debug-init"))))
#+end_src

* email :email:
:PROPERTIES:
:ID:       816e5dc0-92b6-4197-97fc-8129902a812f
:END:

** sendmail
:PROPERTIES:
:ID:       85ce3bf2-6903-4cc9-8963-173aea0ffd02
:END:

#+begin_src emacs-lisp
(use-package sendmail
  :set
  (sendmail-program . (executable-find "msmtp"))
  (send-mail-function . #'smtpmail-send-it))
#+end_src

** message
:PROPERTIES:
:ID:       73682358-6c32-40d7-b193-2aa2ceea270c
:END:

#+begin_src emacs-lisp
(use-package message
  :set
  (message-sendmail-f-is-evil . t)
  (message-sendmail-extra-arguments . '("--read-envelope-from"))
  (message-send-mail-function . #'message-send-mail-with-sendmail))
#+end_src

** TODO notmuch
:PROPERTIES:
:ID:       f286edb9-4586-43e0-b208-dd1dd0e9f459
:END:

I've configured =mu4e= extensively. But ultimately, I've decided to use notmuch
as my main email. The two annoyances of =mu4e= were simply too much.

One of the advantages of.

*** notmuch :exec:
:PROPERTIES:
:ID:       5bfe2c00-5574-4f9a-8f69-a373a089e59c
:END:

#+begin_src emacs-lisp
(use-package notmuch)
#+end_src

*** change the order of the email
:PROPERTIES:
:ID:       bac8d73c-5afd-43a0-a615-8ec4bee280a3
:END:

By default notmuch puts the oldest emails at the top which is rather
unconventional for email clients considering that the newer emails are among the
most important.

#+begin_src emacs-lisp
(defafter! sort-newest-first (notmuch)
  "Tell notmuch to sort by."
  (set! notmuch-search-oldest-first nil))
#+end_src

** TODO gnus
:PROPERTIES:
:ID:       c7131b43-cfac-4c0f-8395-0c4b8e9d4078
:END:

*** gnus
:PROPERTIES:
:ID:       9f0829c3-c123-4d14-9b6d-23aaddf8728b
:END:

#+begin_src emacs-lisp
(use-package gnus)
#+end_src

** mu4e :mu4e:
:PROPERTIES:
:ID:       905ba1b5-bafc-4855-b772-fa750c294327
:END:

=mu4e= is the most popular Emacs email client--and for good reason. It's fast,
tag-based, and has great documentation. One annoying quirk for me is that unlike
all other Emacs packages it does not come uncoupled from the external program it
uses. What this means is that you need to tell Emacs where the mu4e =.el= files
are :pouting-cat:. It also means it's more difficult to incorporate it with the
contribution workflow that [[https://github.com/raxod502/straight.el][straight.el]] encourages. I haven't figured out
how to automate this across multiple OSes.

This is annoying, but minor. =mu4e= itself is a great package.

*** TODO maildir
:PROPERTIES:
:ID:       49debca7-6ae7-40e4-9bd0-73c3bba40539
:END:

#+begin_src emacs-lisp
(defun xl-mail-dir (&rest others)
  (apply #'concat (f-full "~/.mail") others))

(defalias 'mu4e%mail-dir 'xl-mail-dir)
#+end_src

*** BUG list email accounts
:PROPERTIES:
:ID:       0b7dcf44-b245-4ca8-9407-3d3c043e1d96
:END:

I'm storing all my email account passwords using =pass=. I can use the encrypted
files in my pass directory to determine what my email accounts are and, in turn,
how to automate this.

#+begin_src emacs-lisp
(defalias 'mu4e%mail-accounts 'password-store%email-accounts)
#+end_src

*** mu4e
:PROPERTIES:
:ID:       9dccb5e4-5d8e-4da6-99ae-9f8ed3bd8a5d
:END:

#+begin_src emacs-lisp
(use-package mu4e :commands mu4e)
#+end_src

*** mu4e-vars
:PROPERTIES:
:ID:       25cf40b9-901b-40f4-800f-3fa577ee22c3
:END:

=mu4e-var= contains many miscellaneous variables. Some highlights.

#+begin_src emacs-lisp
(use-package mu4e-vars
  :set
  (mu4e-completing-read-function . #'completing-read)
  (mu4e-get-mail-command         . "mbsync -a")
  (mu4e-update-interval          . nil)
  (mu4e-context-policy           . nil)
  (mu4e-use-fancy-chars          . (display-graphic-p))
  (mu4e-org-support              . t)
  (mu4e-index-cleanup            . t)
  (mu4e-split-view               . 'vertical)
  (mu4e-index-lazy-check         . nil)
  (mu4e-hide-index-messages      . t)
  (mu4e-confirm-quit             . nil))
#+end_src

**** mu4e
:PROPERTIES:
:ID: 565eff90-8626-4ec8-a576-4ff3dfb307ae
:END:

#+begin_src emacs-lisp
(setq mu4e-html2text-command
      (if (executable-find "w3m") "w3m -dump -T text/html" #'mu4e-shr2text))
#+end_src

*** mu4e-views
:PROPERTIES:
:ID:       5ebeddaa-94ae-4acc-9659-5aae8cb4a2f0
:END:

#+begin_src emacs-lisp
(use-package mu4e-view
  :set
  (mu4e-view-show-images     . t)
  (mu4e-view-image-max-width . 800)
  (mu4e-view-show-addresses  . t)
  (mu4e-date-format          . "%c"))
#+end_src

*** mu4e-compose
:PROPERTIES:
:ID:       cd07286d-2a94-4953-99bf-8e06b3edcf15
:END:

#+begin_src emacs-lisp
(use-package mu4e-compose
  :set
  (mu4e-compose-context-policy . nil))
#+end_src

*** mu4e-drafts
:PROPERTIES:
:ID:       5de3eca7-968b-4228-a1d9-ca872f18f58b
:END:

#+begin_src emacs-lisp
(use-package mu4e-drafts
  :set
  (mu4e-compose-signature-auto-include . t)
  (mu4e-compose-format-flowed          . t))
#+end_src

*** mu4e-headers
:PROPERTIES:
:ID:       8bc93633-f3a0-494d-ae61-c05f6490cd87
:END:

These are custom icons used to spice up the =mu4e= display.

#+begin_src emacs-lisp
(use-package mu4e-headers
  :set
  (mu4e-headers-auto-update    . t))
#+end_src

*** mu4e-org
:PROPERTIES:
:ID:       eaa1577b-bcb9-4f6e-9927-8c6d8042dda2
:END:

Mu4e's org integration lets you write emails in org mode and convert it to html
before sending--very interesting indeed :grinning:. I have yet to explore this feature but
it is definitely on my list of things to try out.

#+begin_src emacs-lisp
(use-package mu4e-org
  :hook (mu4e-compose-mode-hook . org-mu4e-compose-org-mode)
  :set
  (mu4e-org-link-query-in-headers-mode . nil)
  (mu4e-org-convert-to-html            . t))
#+end_src

*** set the mu4e icons
:PROPERTIES:
:ID:       fddb7d53-6d72-4ad1-9d75-b65db20d8692
:END:

I don't want to do this immediately to avoid extra function calls on startup.
Also, if I for some reason decide not to use the dashboard icons I don't want to
pay the icon loading costs at startup.

#+begin_src emacs-lisp
(defafter! set-mu4e-marks (mu4e-headers)
  "Set the mu4e marks."
  (setq mu4e-headers-draft-mark     (cons "D" (all-the-icons-faicon "pencil")))
  (setq mu4e-headers-flagged-mark   (cons "F" (all-the-icons-faicon "flag")))
  (setq mu4e-headers-new-mark       (cons "N" (all-the-icons-material "fiber_new")))
  (setq mu4e-headers-passed-mark    (cons "P" (all-the-icons-faicon "arrow-right")))
  (setq mu4e-headers-seen-mark      (cons "S" (all-the-icons-faicon "eye")))
  (setq mu4e-headers-attach-mark    (cons "a" (all-the-icons-material "attach_file")))
  (setq mu4e-headers-replied-mark   (cons "R" (all-the-icons-faicon "reply")))
  (setq mu4e-headers-unread-mark    (cons "u" (all-the-icons-faicon "eye-slash")))
  (setq mu4e-headers-encrypted-mark (cons "x" (all-the-icons-octicon "lock")))
  (setq mu4e-headers-signed-mark    (cons "s" (all-the-icons-faicon "certificate")))
  (setq mu4e-headers-trash-mark     (cons "T" (all-the-icons-faicon "trash"))))
#+end_src

*** DOC hook
:PROPERTIES:
:ID:       fcdbaa17-20c6-4322-baed-27df5a0ad9a2
:END:

Only render to html once. If the first send fails for whatever reason,
org-mu4e would do so each time you try again.

#+begin_src emacs-lisp
(defhook! org-mu4e-render-html-only-once (message-send-hook)
  (setq-local org-mu4e-convert-to-html nil))
#+end_src

*** TODO initializing mu4e
:PROPERTIES:
:ID:       93cffd11-a812-4cda-b7dd-a06f70367afe
:END:

This headline attempts to automate the initialization of mu4e. The goal is for
me to do as little as possible by (by which I mean nothing :joy:) to get a
working mu4e setup. In other words, after I initialize my dotfiles and install
all my system packages, I want mu4e to /just work/. There should be no prompts
asking me to run anything or do anything at all.

The idea is to do preliminary things before the main entry point--the function
[[helpfn:mu4e][mu4e]]--is called.

**** TODO mu4e database location
:PROPERTIES:
:ID:       fe8f10c1-3035-4a97-9657-98236f50d0a8
:END:

This is the place where the mu4e database is stored. The existence of this
database is used to determine whether we'll run =mu init= or not.

#+begin_src emacs-lisp
(defvar mu4e%mu-database-path (expand-file-name "~/.cache/mu/xapian")
  "Path where mu database should go.")
#+end_src

**** TODO init mu4e database
:PROPERTIES:
:ID:       4d107050-db05-4d7e-ae44-4bf356a44fd0
:END:

The first time you run =mu= it needs to [initialize it's database]. This is done
with the command =mu init --maildir=~/Maildir=.

#+begin_src emacs-lisp
(defafter! init-database-maybe (mu4e)
  "Initialize the mu4e database if it does not exist."
  (iter (initially (unless (file-exists-p mu4e%mu-database-path) (return)))
	(each account (mu4e%mail-accounts))
	(call-process-shell-command (format "mu init --my-address=%s" account))))
#+end_src

**** TODO ensuring email directories
:PROPERTIES:
:ID:       704b7049-fac5-4fa7-b710-1bbfe50cea5f
:END:

Make sure mail directories exist. =mbsync= will fail if they don't.

#+begin_src emacs-lisp
(defadvice! ensure-mail-dirs (:before mu4e)
  "Create mail directories if they don't exist."
  (iter (with (dirs (mapcar #'mu4e%mail-dir (mu4e%mail-accounts))))
	(each dir dirs)
	(mkdir dir t)))
#+end_src

*** TODO contexts
:PROPERTIES:
:ID:       0e580010-d5b2-4708-a7dc-c586908409b5
:END:

[[info:mu4e#What are contexts][Contexts]]. This headline attempts to automate context creation. Context are
probably the hardest part of setting up =mu4e= for elisp. [[https://jherrlin.github.io/posts/emacs-mu4e/][this article]]. If you
don't make contexts, =mu4e= will be confused and think that.

**** mu4e%generate-context
:PROPERTIES:
:ID:       cdbfbf97-47a9-4769-8d62-e7ea974f4bd1
:END:

#+begin_src emacs-lisp
(defun mu4e-context%generate-context (mail-address)
  "Generate a simple context for MAIL-ADDRESS."
  (let ((entry (format "email/%s" mail-address))
	(folder (format "/%s" mail-address)))
    (make-mu4e-context
     :name mail-address
     :enter-func nil
     :leave-func nil
     :match-func nil
     :vars `((user-mail-address     . ,mail-address)
	     (smtpmail-smtp-server  . ,(password-store-get-field entry "server"))
	     (smtpmail-smtp-service . ,(password-store-get-field entry "port"))
	     (mu4e-drafts-folder    . ,(concat folder "/drafts"))
	     (mu4e-trash-folder     . ,(concat folder "/trash"))
	     (mu4e-sent-folder      . ,(concat folder "/sent"))))))
#+end_src

**** init contexts
:PROPERTIES:
:ID:       e74512a7-1d1f-4241-b245-5863e7730398
:END:

If you don't specify contexts =mu4e= will think that the mail directory itself
is a context and will keep prompting you about creating mu4e directories (e.g.).

#+begin_src emacs-lisp
(defafter! define-contexts (mu4e)
  "Define contexts for each email account and initialize the first.
Information for contexts are."
  (iter (with (accounts (password-store%email-accounts)))
	(each mail-account accounts)
	(add-to-list 'mu4e-contexts (mu4e-context%generate-context mail-account))
	(finally-do (mu4e-context-switch nil (car accounts)))))
#+end_src

* appearance :appearance:
:PROPERTIES:
:ID:       ebcad8f8-06d6-4c25-8ca6-c7f2190dca65
:END:

** TODO customize org-block-begin-line face :theme:face:org:
:PROPERTIES:
:ID:       b2aa074f-8991-4a26-9b14-33f49164fc2e
:END:
:LINK:
https://www.emacswiki.org/emacs/CustomizingFaces
https://emacs.stackexchange.com/questions/19924/whats-the-difference-between-set-face-background-and-custom-set-faces
https://emacs.stackexchange.com/questions/52324/prevent-org-source-block-face-from-bleeding-out-in-fold
:END:

When a theme has and you fold these headings, the headings bleed out of the
folded blocks. Eventually, I want to conditionally hide the headline colors when
a headline is folded. But that's a bit complicated. It's easier to do away with
the colors for now.

#+begin_src emacs-lisp
(defhook! remove-org-block-line-background (xl-after-load-theme-hook)
  "Remove org block delimiter color.
Set the background of the faces `org-block-begin-line' and `org-block-end-line'
to the default face background."
  (set-face-background 'org-block-begin-line (face-attribute 'default :background))
  (set-face-background 'org-block-end-line (face-attribute 'default :background)))
#+end_src

** mini-frame
:PROPERTIES:
:ID:       1e93b22f-e918-4a6e-9753-9e7657cbfcab
:END:

This package opens the minibuffer in a new frame. Using the default minibuffer
creates a disturbance in the your window configuration when it pops up. The
advantage that this offers over the minibuffer is that.

Note that by default, [[helpvar:mini-frame-resize][mini-frame-resize]] is set to =t=. The problem I have with
this is that when I first call a minibuffer completion command the candidates
are not immediately visible. They are only visible when I type
something. Setting it to =nil= makes the frame start at the size you specified.

#+begin_src emacs-lisp
(use-package! mini-frame
  ;; :hook emacs-startup-hook
  :set
  (mini-frame-resize . nil)
  (mini-frame-show-parameters . '((top . 10)
				  (width . 0.95)
				  (left . 0.5)
				  (height . 15))))
#+end_src

** highlight-quoted :elisp:lang:prog:
:PROPERTIES:
:ID:       d0973dce-693b-45ca-88e3-27da1bb217f7
:END:

[[https://github.com/Fanael/highlight-quoted][highlight-quoted]] highlights quotes, backticks and.

#+begin_src emacs-lisp
(use-package highlight-quoted
  :hook emacs-lisp-mode-hook)
#+end_src

** transient :interface:
:PROPERTIES:
:ID:       1805bd2d-b190-47b6-9c7c-2a200f9cf6a1
:END:

#+begin_src emacs-lisp
(use-package transient
  :set
  (transient-default-level . 5)
  (transient-levels-file . (concat XL-CACHE-DIR "transient/levels"))
  (transient-values-file . (concat XL-CACHE-DIR "transient/values"))
  (transient-history-file . (concat XL-CACHE-DIR "transient/history")))
#+end_src

** emojify :icon:appearance:
:PROPERTIES:
:ID:       d3e15439-f690-4ced-b701-0882fb911a5c
:END:

This is a package that displays emojis! :D A major focus of my config is having
the ability to express myself well--in ways that is simply impossible with mere
documentation. This includes using emojis. Also, using emojis makes
documentation *much* more fun. :joy-cat:

#+begin_src emacs-lisp
(use-package emojify
  :hook org-mode-hook
  :set
  (emojify-emojis-dir . (concat XL-CACHE-DIR "emojis/")))
#+end_src

** which-key :interface:
:PROPERTIES:
:ID:       2ad092a3-ff63-49cd-91b9-380c91dbe9f5
:END:

Emacs is full of so many keybindings, that it can be difficult to keep track of
them. Especially when you're starting out, but even when you're an Emacs-pro,
it's easy to forget what a particular functionality is bound to. Typically,
you'll remember the first few key strokes but struggle with the rest. To address
this [[github:][which-key]] displays key binding sequences in the minibuffer as your typing
them. By doing this you can "discover" the commands as you go along.

*** init
:PROPERTIES:
:ID:       c4aedc23-0be3-46fe-b046-32b5f0738c6b
:END:

#+begin_src emacs-lisp
(use-package which-key
  :hook emacs-startup-hook
  :set
  (which-key-sort-uppercase-first . nil)
  (which-key-max-display-columns  . nil)
  (which-key-add-column-padding   . 1)
  (which-key-min-display-lines    . 6)
  (which-key-side-window-slot     . -10)
  (which-key-sort-order           . #'which-key-prefix-then-key-order)
  (which-key-popup-type           . 'minibuffer)
  (which-key-idle-delay           . 0.8))
#+end_src

*** set line spacing :asthetic:
:PROPERTIES:
:ID:       6abb35f4-c648-4bed-b59a-5a0636857fd8
:END:

#+begin_src emacs-lisp
(defhook! set-line-spacing (which-key-init-buffer-hook)
  (setq line-spacing 3))
#+end_src

** font :font:
:PROPERTIES:
:ID:       d600fe06-7a61-43e1-93ea-4e193c69c9f3
:END:

Setting the font correctly and well is crucial for your efficiency while using
emacs. A well choosen font can make things very readable.

Also, sometimes I have font "mania" where I keep toggling different fonts so see
what I feel like using at the moment. Therefore, I need an easy way to toggle.

*** font size
:PROPERTIES:
:ID:       3efd0698-a8d3-4fc0-b22b-7f0589de4661
:END:

It's very suprising to me Emacs doesn't provide a function for interactively
setting the font size.

Make sure to appropriately update [[helpvar:default-frame-alist][default-frame-alist]] when changing font size.
Otherwise, you might find (as I did) that switching themes might reset your font
size to its default value.

#+begin_src emacs-lisp
(defun xl-set-font-size (size)
  "Set the font size for the current frame."
  (let ((fs (font-spec :name (frame-parameter nil 'font))))
    (font-put fs :size size)
    (set-frame-font fs nil t)
    (let ((new-font (frame-parameter nil 'font))
          (current-default (assq 'font default-frame-alist)))
      (setf (alist-get 'font default-frame-alist) new-font))))
#+end_src

*** font max and min size
:PROPERTIES:
:ID:       309c572a-6aaa-4986-a79d-4774110e6ead
:END:

I have had the experience where I've accidentally set Emacs font so large or so
small that I've had to restart Emacs because even though I know how to undo it,
I could not read anything. Here I declare font size bounds I should never go
outside of.

#+begin_src emacs-lisp
(defconst XL-FONT-MAX-SIZE 30
  "Maximum font size.
The font size that `xl/set-font-size' should never go above.")

(defconst XL-FONT-MIN-SIZE 11
  "Minimum font size.
The font size that `xl/set-font-size' should never go below.")
#+end_src

** hide-mode-line :modeline:asthetic:
:PROPERTIES:
:ID:       e8f53422-9d24-4119-9b0f-9b6d1e10c1b0
:END:

#+begin_src emacs-lisp
(use-package hide-mode-line
  :commands hide-mode-line-mode)
#+end_src

** themes
:PROPERTIES:
:ID:       376581c7-0b45-40c7-a10c-38fde7f9c7a4
:END:

*** modus themes :asthetic:theme:
:PROPERTIES:
:ID:       b825b4a0-13e4-483e-b793-c0fcd6223897
:END:

#+begin_src emacs-lisp
(use-package modus-themes
  :set
  (modus-themes-syntax . 'green-strings)
  (modus-themes-slanted-constructs . t)
  (modus-themes-bold-constructs . nil)
  (modus-themes-region . 'no-extend)
  (modus-themes-org-blocks . t)
  (modus-themes-no-mixed-fonts . t))
#+end_src

** dashboard :dashboard:startup:appearance:
:PROPERTIES:
:ID: 20926522-b78b-4bca-b70e-9ef4213c4344
:END:

[[https://github.com/emacs-dashboard/emacs-dashboard][dashboard]] is an extensible emacs startup screen. I love the idea of =dashboard=:
having an extensible, fast, nice-looking dashboard when starting emacs is
nice. It's not only nice asthetically, it's also strategic too. First, you can
use it as a launching point to get to your tasks quicker. And second, it doesn't
require any expensive modes. I've often been starting out with the scratch
buffer and I've wanted to have the scratch buffer start off with
=emacs-lisp-mode=, but I don't want it to trigger =company=, =yasnippet=, etc. on
startup. If I start my emacs with =dashboard= I can avoid this.

*** load page-break-lines
:PROPERTIES:
:ID:       b8fc0ee8-7e61-41df-b243-500b686bf2fd
:END:

#+begin_src emacs-lisp
(use-package page-break-lines :demand t)
#+end_src

*** random logo :dashboard:startup:asthetic:
:PROPERTIES:
:ID:       80e5fa17-d18a-4ec0-af8d-728d77843c69
:END:

=dashboard= provides three text pictures which are referred to by number and two
images which referred to by the symbols =official= and =logo=.

#+begin_src emacs-lisp
(defun dashboard%random-logo ()
  "Display a random logo."
  (seq-random-elt
   (append '(1 2 3) (if (display-graphic-p) '(official logo)))))
#+end_src

*** require :dashboard:asthetic:
:PROPERTIES:
:ID:       73d00f99-4b70-44d1-8359-01bd2c94b330
:END:

#+begin_src emacs-lisp
(use-package dashboard
  :demand t
  :hook (window-setup-hook . dashboard-insert-startupify-lists)
  :set
  (dashboard-items . nil)
  (dashboard-startup-banner . (dashboard%random-logo))
  (dashboard-center-content . t)
  (initial-buffer-choice . #'startup%initial-buffer-choice))
#+end_src

*** open dashboard at startup :dashboard:startup:asthetic:
:PROPERTIES:
:ID:       1bcc371e-61fa-480e-bdae-4a999d3b10c9
:END:

When I'm using the dashboard.

#+begin_src emacs-lisp
(defun! open-dashboard-instead (&rest _)
  (:around startup%initial-buffer-choice)
  (get-buffer-create "*dashboard*"))
#+end_src
:END:

[[helpvar:xl-init-time][xl-init-time]] is more accurate than dashboard's init time measure. So I use it
instead.

#+begin_src emacs-lisp :tangle no
(defadvice! show-package-load-time (:before dashboard-insert-startupify-lists)
  (setq dashboard-init-info
        (format "%d packages loaded in %.2f seconds"
                (cond ((featurep 'straight)
		       (hash-table-size straight--profile-cache))
                      ((featurep 'package)
		       (length package-activated-list))
                      (t
		       0))
                (string-to-number (emacs-init-time)))))
#+end_src

** mini-modeline :modeline:
:PROPERTIES:
:ID:       2e18b51f-e9c5-4cd5-857c-a14f0c1aaf1c
:END:

*** setup
:PROPERTIES:
:ID:       d9acb47b-089f-4b18-8fdd-94ffefb2ef86
:END:

These variables do stuff with displaying lines and separators to make the
modeline more visible. I do that myself with =window-divider= so I don't need
this.

#+begin_src emacs-lisp
(use-package mini-modeline
  :demand t
  :hook (emacs-startup-hook . mini-modeline-mode)
  :set
  (mini-modeline-enhance-visual . nil)
  (mini-modeline-display-gui-line . nil))
#+end_src

*** default face
:PROPERTIES:
:ID:       1aab03cd-83b2-4d3a-bf3b-71f52dc6158d
:END:

If you don't set this, mini-modeline's background color won't
update with the theme. This is probably what the default value of this
variable should be anyway.

#+begin_src emacs-lisp
(use-package mini-modeline
  :set
  (mini-modeline-face-attr . '(:inherit default)))
#+end_src

*** left format
:PROPERTIES:
:ID:       a7d11a8b-e792-43e5-9992-10df562e17ea
:END:

#+begin_src emacs-lisp
(defafter! set-modeline-format (mini-modeline)
  (setq mini-modeline-l-format
	'("%e" mode-line-buffer-identification)))
#+end_src

*** right format
:PROPERTIES:
:ID:       fd79e9cb-40d7-4320-9b1d-248da4330bca
:END:

#+begin_src emacs-lisp
(defafter! set-the-right-modeline (mini-modeline)
  (setq mini-modeline-r-format
	'("%e" (:eval (format-time-string "%a %m/%d %T")))))
#+end_src

** window divider :window:
:PROPERTIES:
:ID:       2cdd6e24-5153-4585-8f1f-206b33445359
:END:

Emacs can add border to windows using a mode called [[helpfn:window-divider-mode][window-divider-mode]].
Often in emacs you have multiple windows displaying different buffers on the
screen. By default the border between these windows is very thin, so it can be
hard to distinguish windows sometimes. The point of adding borders to windows is
to distinguish them easily from one another.

Window dividers are useful in general so I don't get confused about when one
window ends and another begins (see [[helpfn:window-divider-mode][window-divider-mode]]). When using [[I like emacs][exwm]] it
makes emacs feel like a window manager with gaps.

*** window divider :window:asthetic:
:PROPERTIES:
:ID:       c3e2fda8-89c8-4f3b-951a-113e936d6206
:END:

#+begin_src emacs-lisp
(use-package window-divider
  :hook (window-setup-hook . window-divider-mode)
  :set
  (window-divider-default-bottom-width . 7)
  (window-divider-default-right-width  . 7)
  (window-divider-default-places       . t))
#+end_src

*** window divider face :window:asthetic:
:PROPERTIES:
:ID:       61157149-dcce-40a9-8bfa-76a6af24838a
:END:

#+begin_src emacs-lisp
(defhook! set-window-divider-face (load-theme)
  (set-face-foreground 'window-divider "black"))
#+end_src

*** update on theme change :theme:asthetic:window:
:PROPERTIES:
:ID:       ceff91e5-8172-4b26-81de-681c0864bc4b
:END:

#+begin_src emacs-lisp
(defhook! update-window-divider (xl-after-load-theme-hook)
  "Ensure window divider persists after theme change."
  (unless (bound-and-true-p window-divider-mode)
    (window-divider-mode 1)))
#+end_src

*** TODO increase gap size :asthetic:window:
:PROPERTIES:
:ID:       867fad5c-b4d4-4cba-929e-0dc23f007c5b
:END:

Somtimes I might want to adjust this.

#+begin_src emacs-lisp
(defun frame/adjust-window-divider-size (amount)
  "Adjust the gap size of window-divider by AMOUNT."
  (cl-incf window-divider-default-bottom-width amount)
  (cl-incf window-divider-default-right-width amount))
#+end_src

*** increase :command:asthetic:
:PROPERTIES:
:ID:       ebd6b013-6213-42a1-9e95-fefc7e7da991
:END:

#+begin_src emacs-lisp
(defun frame/increment-window-divider-size ()
  "Increase window divider size."
  (interactive)
  (frame:adjust-window-divider-size 1))
#+end_src

*** decrease :command:asthetic:
:PROPERTIES:
:ID:       6b1eb1cd-1cfd-4b82-a413-cb61fa13e0a4
:END:

#+begin_src emacs-lisp
(defun frame/decrement-window-divider-size ()
  "Decrease window divider size."
  (interactive)
  (frame:adjust-window-divider-size -1))
#+end_src

** emojis :asthetic:icon:
:PROPERTIES:
:ID:       d3e15439-f690-4ced-b701-0882fb911a5c
:END:

This is a package that displays emojis! :D A major focus of my config is having
the ability to express myself well--in ways that is simply impossible with mere
documentation. This includes using emojis. Also, using emojis makes
documentation *much* more fun. :joy-cat:

#+begin_src emacs-lisp
(use-package emojify
  :hook org-mode-hook
  ;; :on-install (emojify-in)
  :set
  (emojify-emojis-dir . (concat XL-CACHE-DIR "emojis/")))
#+end_src

