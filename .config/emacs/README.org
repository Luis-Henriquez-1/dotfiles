
* Core
:PROPERTIES:
:ID:       d68434bf-be6a-471f-ab65-e151f4f1c111
:END:

** Init
:PROPERTIES:
:ID: 9022457f-609b-4d1c-b972-ceca19300cd3
:END:

*** gc cons threshold
:PROPERTIES:
:ID: 27ad0de3-620d-48f3-aa32-dfdd0324a979
:END:

A big contributor to long startup times is the garbage collector. When
performing a large number of calculations, it can make a big difference to
increase the [[helpvar:gc-cons-threshold][gc-cons-threshold]], or the /number of bytes of consing between
garbage collections/. If garbage collection is done too often between
calculations it will affect the time they take. Besides, the default value is
usually too low for modern machines.

**** gc cons threshold
:PROPERTIES:
:ID: e15d257f-1b0f-421e-8b34-076b1d20e493
:END:

#+begin_src emacs-lisp
(defconst VOID:GC-CONS-THRESHOLD-MAX (eval-when-compile (* 256 1024 1024))
  "The upper limit for `gc-cons-threshold'.
When VOID is performing computationally intensive operations,
`gc-cons-threshold' is set to this value.")

(defconst VOID:GC-CONS-THRESHOLD (eval-when-compile (* 16 1024 1024))
  "The default value for `gc-cons-threshold'.
If you experience freezing, decrease this. If you experience stuttering,
increase this.")

(defconst VOID:GC-CONS-PERCENTAGE-MAX 0.6
  "The upper limit for `gc-cons-percentage'.
When VOID is performing computationally intensive operations,
`gc-cons-percentage' is set to this value.")

(defconst VOID:GC-CONS-PERCENTAGE 0.1
  "The default value for `gc-cons-percentage'.")
#+end_src

**** boost gc threshold
:PROPERTIES:
:ID: eac7cfbb-6576-4506-8118-5bfda151654b
:END:

#+begin_src emacs-lisp
(setq gc-cons-threshold VOID:GC-CONS-THRESHOLD-MAX
      gc-cons-percentage VOID:GC-CONS-PERCENTAGE-MAX)
#+end_src

**** Restore GC after delay
:PROPERTIES:
:ID: d49bef67-0a1e-4026-838c-217b0d6ecad5
:END:

Restore gc cons threshold (after a 7 second delay). I got this from [[https://github.com/hlissner/doom-emacs/blob/develop/core/core.el#L283][doom]]. We
don't do it immediately because packages are still being lazy loaded at this
time.

#+begin_src emacs-lisp
(defun void:restore-gc-cons-threshold ()
  "Restore `gc-cons-threshold' to `VOID:GC-CONS-PERCENTAGE' after 7 idle seconds."
  (void:log "Restoring...gc-cons-threshold: %d -> %d | gc-cons-percentage %.2f -> %.2f"
            gc-cons-threshold
            VOID:GC-CONS-THRESHOLD
            gc-cons-percentage
            VOID:GC-CONS-PERCENTAGE)
  (setq gc-cons-threshold VOID:GC-CONS-THRESHOLD)
  (setq gc-cons-percentage VOID:GC-CONS-PERCENTAGE))

(run-with-idle-timer 7 nil #'void:restore-gc-cons-threshold)
#+end_src

*** message logging
:PROPERTIES:
:ID:       4d4f4b4a-4fc3-47fe-bed7-acc8e8103933
:END:

**** debug-p                                                               :eac:
:PROPERTIES:
:ID: b9e28d90-cdbe-412f-8ed8-1b8b97c1ab07
:END:

[[helpvar:void-debug-p][void:debug]] is snatched from [[https://github.com/hlissner/doom-emacs][Doom's]] [[https://github.com/hlissner/doom-emacs/blob/develop/core/core.el][doom-debug-mode]]. The point of this variable
is to serve as an indicator of whether the current Void instance is run for
debugging. When Void is set up for debugging it prints out many messages about
what its doing via [[hfn:void-log][void:log]].

#+begin_src emacs-lisp
(defvar void:debug-p (or (getenv "DEBUG") init-file-debug)
  "When non-nil print debug messages.
The --debug-init flag and setting the DEBUG envar will enable this at startup.")
#+end_src

**** logging                                                               :eac:
:PROPERTIES:
:ID: 84ded5f7-382e-4f59-af9e-ccb157ef5c42
:END:

The purpose of ~void:log~ is to distinguish regular messages from messages that
pertain specifically to Void, and to help debug Void functionality. When Void is
=void:debug= is non-nil, void:specific messages are logged in the =*messages*=
buffer.

#+begin_src emacs-lisp
(defun void:log (format-string &rest args)
  "Log to *Messages* if `void:debug-p' is on.
Does not interrupt the minibuffer if it is in use, but still log to *Messages*.
Accept the same arguments as `message'."
  (when void:debug-p
    (let ((inhibit-message (active-minibuffer-window)))
      (when void:debug-p
        (apply #'message (concat (propertize "VOID " 'face 'font-lock-comment-face)
                                 format-string)
               args)))))
#+end_src

*** default coding system
:PROPERTIES:
:ID:       4c55a0d4-dbd7-4405-b944-3b68d8a069f2
:END:

#+begin_src emacs-lisp
(defconst VOID:DEFAULT-CODING-SYSTEM 'utf-8
  "Default text encoding.")
#+end_src

*** macros
:PROPERTIES:
:ID: 71870763-2888-453e-842e-98804813350b
:END:

Because of how I organize my init file. These are macros that I need to define
before package installation, because I will use them during package
installation.

**** defadvice!
:PROPERTIES:
:ID:       cc161eaf-a8fb-4e24-853f-a76a49c28dcf
:END:

#+begin_src emacs-lisp
(defmacro defadvice! (name args &rest body)
  "Add advice."
  (let* ((docstring (when (stringp (car body)) (pop body)))
         (key (pop body))
         (advices (pop body)))
    (unless (listp advices) (setq advices (list advices)))
    `(prog1 (defun ,name ,args ,docstring ,@body)
       ,@(mapcar (lambda (advice) `(advice-add #',advice ,key #',name))
                 advices))))
#+end_src

**** defhook!
:PROPERTIES:
:ID:       fb33eef6-d84e-4384-9241-73cde5e0e0d0
:END:

#+begin_src emacs-lisp
(defmacro defhook! (name args &rest body)
  "Define a hook function."
  (let* ((docstring (when (stringp (car body)) (pop body)))
         (key (pop body))
         (hooks (pop body))
         (append (eq key :append))
         (local (eq key :local)))
    (unless (listp hooks) (setq hooks (list hooks)))
    `(prog1 (defun ,name ,args ,docstring ,@body)
       ,@(mapcar (lambda (hook) `(add-hook ',hook #',name ,append ,local))
                 hooks))))
#+end_src

**** with-os!
:PROPERTIES:
:ID: 1a645745-11ce-4cfb-8c5f-63470f0a61c3
:END:

Emacs is for the most part operating system agnostic. Packages written in elisp
should work across operating systems. Nevertheless, there are a handful of
settings that should favors particular operating systems over others.

#+begin_src emacs-lisp
(defmacro with-os! (os &rest body)
  "If OS is current system's operating system, execute body.
OS can be either `mac', `linux' or `windows'(unquoted)."
  (declare (indent defun))
  (setq os (if (listp os) os (list os)))
  (when (funcall (cond ((eq :not (car-safe os)) (lambda (a b) (not (member a b))))
                       (t #'member))
                 (cond ((eq system-type 'darwin) 'mac)
                       ((eq system-type 'gnu/linux) 'linux)
                       ((member system-type '(cygwin windows-nt ms-dos)) 'windows)
                       (t nil))
                 os)
    `(progn ,@body)))
#+end_src

**** after!
:PROPERTIES:
:ID: b31cd42d-cc57-492d-afae-d7d5e353e931
:END:

The reason that we check for the feature is to prevent [[hvar:eval-after-load][eval-after-load]] from polluting the
[[hvar:after-load-list][after-load-list]]. =eval-after-load= adds an entry to =after-load-list= whether or not it has
been loaded.

We intentionally avoid with-eval-after-load to prevent eager macro expansion
from pulling (or failing to pull) in autoloaded macros/features.

#+begin_src emacs-lisp
(defmacro after-feature! (feature &rest body)
  "Execute BODY after FEATURES are loaded."
  (declare (indent defun) (debug t))
  `(,(if (and (bound-and-true-p byte-compile-current-file)
              (not (require feature nil 'noerror)))
         #'with-no-warnings
       #'progn)
    (if (featurep ',feature)
        (progn ,@body)
      (eval-after-load ',feature '(progn ,@body)))))

(defmacro after! (features &rest body)
  (declare (indent defun) (debug t))
  `(,@(if (cdr-safe features)
          `(after! ,@(cdr features))
        '(progn))
    (after-feature! ,(or (car-safe features) features)
      ,@body)))
#+end_src

**** ignore!
:PROPERTIES:
:ID: 0597956f-d40c-4c2b-9adf-5ece8c5b38de
:END:

#+begin_src emacs-lisp
(defmacro ignore! (&rest _)
  "Do nothing and return nil."
  nil)

(defalias 'disable! 'ignore!)
#+end_src

*** directories                                                            :eac:
:PROPERTIES:
:ID: 93cc2db1-44c7-45ec-af98-5a4eb7145f61
:END:

There are a handful of files and directory that are necessary to doom. I try to
keep the number of files to a minimum because I think that more files means more
stuff to manage, and more potential errors. That's partly the reason why I use
one large org file.

**** core directories and files
:PROPERTIES:
:ID: ad18ebcb-803a-4fd6-adcb-c71cf54f3432
:END:

***** top level
:PROPERTIES:
:ID: 48bf884a-de27-45f8-a5b1-94567815942d
:END:

These are important files and directories that I end up referring to often in my
code. Well, not so much =VOID:README-FILE= and =VOID:TODO-FILE= but the others are
referenced alot.

#+begin_src emacs-lisp
(defconst VOID:EMACS-DIR (file-truename user-emacs-directory)
  "Path to `user-emacs-directory'.")

(defconst VOID:INIT-FILE (concat VOID:EMACS-DIR "init.el")
  "Path to the elisp file that bootstraps Void startup.")

(defconst VOID:README-FILE (concat VOID:EMACS-DIR "README.org")
  "Path to the Org file that when that Void.")

(defconst VOID:ORG-DIR (expand-file-name "~/Documents/org/")
  "Path where Void's org files go.")

(defconst VOID:SCREENSHOT-DIR (concat VOID:EMACS-DIR "screenshots/")
  "Path where any screenshots I take with Void go.")

(defconst VOID:TEST-FILE (concat VOID:EMACS-DIR "test.org")
  "Path to the file that contains all of Void's tests.")

(defconst VOID:TODO-FILE (concat VOID:ORG-DIR "emacs.org")
  "Path where all of Void's emacs related todos go.")
#+end_src

***** hidden
:PROPERTIES:
:ID: d46d573b-1d17-4d0b-9b49-9049dbb6f7c1
:END:

#+begin_src emacs-lisp
(defconst VOID:LOCAL-DIR (concat VOID:EMACS-DIR ".local/")
  "Path to the directory for local Emacs files.
Files that need to exist, but I don't typically want to see go here.")

(defconst VOID:DATA-DIR (concat VOID:LOCAL-DIR "data/")
  "Path to the directory where Void data files are stored.")

(defconst VOID:PACKAGES-DIR (concat VOID:LOCAL-DIR "packages/")
  "Path to the directory where packages are stored.")
#+end_src

**** ensure directories exist                                              :ewc:
:PROPERTIES:
:ID: 56e80dda-5d0e-4c7c-a225-00d0028d4995
:END:

I create the directories that don't exist. But I assume they already exist if
Void is compiled.

#+begin_src emacs-lisp
(dolist (dir (list VOID:LOCAL-DIR VOID:DATA-DIR VOID:ORG-DIR))
  (make-directory dir t))
#+end_src

**** system directories
:PROPERTIES:
:ID:       f3bdd353-b0ff-48fd-a2f2-295ccfa139ab
:END:

#+begin_src emacs-lisp
(defconst VOID:DOWNLOAD-DIR (expand-file-name "~/Downloads/")
  "Directory where downloads should go.")

(defconst VOID:VIDEO-DIR (expand-file-name "~/Videos/")
  "Directory where videos should go.")

(defconst VOID:MUSIC-DIR (expand-file-name "~/music/")
  "Directory where music should go.")
#+end_src

*** defined in c source code
:PROPERTIES:
:ID:       873e6820-52f0-4b70-9992-ccb1610eb266
:END:

**** default settings
:PROPERTIES:
:ID: 8d578668-9b0b-4117-bf93-f556e970527b
:END:

#+begin_src emacs-lisp
(setq-default fringe-indicator-alist
              (delq (assq 'continuation fringe-indicator-alist)
                    fringe-indicator-alist))
(setq-default highlight-nonselected-windows nil)
(setq-default indicate-buffer-boundaries nil)
(setq-default inhibit-compacting-font-caches t)
(setq-default max-mini-window-height 0.3)
(setq-default mode-line-default-help-echo nil)
(setq-default mouse-yank-at-point t)
(setq-default resize-mini-windows 'grow-only)
(setq-default show-help-function nil)
(setq-default use-dialog-box nil)
(setq-default visible-cursor t)
(setq-default x-stretch-cursor nil)
(setq-default ring-bell-function #'ignore)
(setq-default visible-bell nil)
(setq-default window-resize-pixelwise t)
(setq-default frame-resize-pixelwise t)
#+end_src

**** compilation
:PROPERTIES:
:ID: 65c83b28-9bee-48fe-856a-f9c38f28c817
:END:

#+begin_src emacs-lisp
;; Non-nil means load prefers the newest version of a file.
(setq-default load-prefer-newer t)
#+end_src

**** all
:PROPERTIES:
:ID:       276d0193-5a46-4034-b145-f235178678d6
:END:

#+begin_src emacs-lisp
;; File name in which to write a list of all auto save file names.
(setq auto-save-list-file-name (concat VOID:DATA-DIR "autosave"))
;; Directory of score files for games which come with GNU Emacs.
(setq shared-game-score-directory (concat VOID:DATA-DIR "shared-game-score/"))

(setq-default cursor-in-non-selected-windows nil)

(setq highlight-nonselected-windows nil)

;; When non-nil, accelerate scrolling operations.
(setq fast-but-imprecise-scrolling t)

(setq-default frame-inhibit-implied-resize t)

;; Non-nil means use lockfiles to avoid editing collisions.
(setq-default create-lockfiles nil)
;; Non-nil says by default do auto-saving of every file-visiting buffer.
(setq-default history-length 500)
;; Specifies whether to use the system's trash can.
(setq-default delete-by-moving-to-trash t)

;; Disabling bidirectional text provides a small performance boost. Bidirectional
;; text is useful for languages that read right to left.
(setq-default bidi-display-reordering 'left-to-right)
(setq-default bidi-paragraph-direction 'left-to-right)

;; Non-nil means echo keystrokes after this many seconds. A value of zero means
;; don't echo at all.
(setq-default echo-keystrokes 0)

;; Template for displaying mode line for current buffer.
(setq-default mode-line-format nil)

(setq-default locale-coding-system VOID:DEFAULT-CODING-SYSTEM)
(setq-default buffer-file-coding-system VOID:DEFAULT-CODING-SYSTEM)
#+end_src

**** scrolling
:PROPERTIES:
:ID: 21e56e37-5ff8-40d8-9f27-c3a3ab37dfb8
:END:

#+begin_src emacs-lisp
(setq-default hscroll-margin 2)
(setq-default hscroll-step 1)
(setq-default scroll-conservatively 1001)
(setq-default scroll-margin 0)
(setq-default scroll-preserve-screen-position t)
#+end_src

***** spacing
:PROPERTIES:
:ID: 8b3f38f9-b789-43e3-b2c5-5152a67d2803
:END:

#+begin_src emacs-lisp
(setq-default fill-column 80)
(setq-default sentence-end-double-space nil)
(setq-default tab-width 4)
#+end_src

***** line wrapping
:PROPERTIES:
:ID: e1564e28-d2ab-4649-b18b-24c27b897256
:END:

#+begin_src emacs-lisp
(setq-default word-wrap t)
(setq-default indicate-empty-lines nil)
(setq-default indent-tabs-mode nil)
(setq-default truncate-lines t)
(setq-default truncate-partial-width-windows 50)
#+end_src

***** other
:PROPERTIES:
:ID: cd0aa7ad-97bc-48ec-9a09-8af56cbf6157
:END:

#+begin_src emacs-lisp
;; Non-nil means reorder bidirectional text for display in the visual order.
;; Disabling this gives Emacs a tiny performance boost.
(setq-default bidi-display-reordering nil)
(setq-default cursor-in-non-selected-windows nil)
(setq-default display-line-numbers-width 3)
(setq-default enable-recursive-minibuffers t)
(setq-default frame-inhibit-implied-resize t)
#+end_src

**** printing
:PROPERTIES:
:ID: 2dfce297-0f01-4576-ae5d-bb5856591ecb
:END:

When eval and replacing expressions, I want the printed result to express all
newlines in strings as =\n= as opposed to an actual newline. In fact, in general I
want any character to be expressed in =backslash + number or character= form. It
makes the strings more readable and easier to deal with.

Furthermore, I'd like printed lisp expressions to express quoted forms the way I
write them, with a ='= as opposed to the literal =(quote ...)=.

There comes a point when output is too long, or too nested to be usable. It's ok
to abbreviate it at this point.

#+begin_src emacs-lisp
(setq-default print-escape-newlines t)
(setq-default print-escape-multibyte t)
(setq-default print-escape-control-characters t)
(setq-default print-escape-nonascii t)
(setq-default print-length nil)
(setq-default print-level nil)
(setq-default print-quoted t)
(setq-default print-escape-newlines t)
#+end_src

*** UTF-8 for everything
:PROPERTIES:
:ID: dd0fc702-67a7-404c-849e-22804663308d
:END:

I set =utf-8= as the default encoding for everything except the clipboard on
windows. Window clipboard encoding could be wider than =utf-8=, so we let
Emacs/the OS decide what encoding to use.

#+begin_src emacs-lisp
(when (fboundp 'set-charset-priority)
  (set-charset-priority 'unicode))
#+end_src

*** post init
:PROPERTIES:
:ID: 0f1da89a-2278-4493-ba62-e2a334204be6
:END:

**** incremental loading
:PROPERTIES:
:ID: c93aefa6-80ff-420d-86ae-a0c06c5c0e76
:END:

Some packages like =org= are really big. When loading such packages, we can
notice a pause. To keep the experience in emacs snappy and avoid noticeable
pauses, I load many small packages pre-emptively. I got this idea form reading
[[https://github.com/hlissner/doom-emacs/blob/develop/core/core.el#L355][Doom source code]]. Packages added to [[helpvar:void-incremental-packages][void:incremental-packages]] will be
incrementally. After Void has finished loading it will wait for
[[helpvar:void-initial-incremental-loading-delay][void:initial-incremental-loading-delay]] and then load one package from
~void:incremental-packages~ intervals of =N= idle seconds, where =N= is
[[helpvar:void-incremental-loading-interval][void:incremental-loading-interval]].

***** packages
:PROPERTIES:
:ID: 41201902-db03-4acb-9c03-953f1720d494
:END:

Later in my config I will add packages to [[helpvar:void-incremental-packages][void:incremental-packages]] (using
~nconc!~). But no incremental loading will happen until after Void is done loading.

#+begin_src emacs-lisp
(defvar void:incremental-packages nil
  "A list of packages to load incrementally after startup.")
#+end_src

***** timers
:PROPERTIES:
:ID: 154e4f5d-58fc-4946-b471-c0e5f636ab61
:END:

#+begin_src emacs-lisp
(defvar void:initial-incremental-loading-delay 6
  "How long (in idle seconds) until incremental loading starts.
Set this to nil to disable incremental loading.")

(defvar void:incremental-loading-interval 5
  "How long (in idle seconds) in between incrementally loading packages.")
#+end_src

***** load-incrementally
:PROPERTIES:
:ID: 747c8ead-18f0-467b-aa91-3922f1212743
:END:

#+begin_src emacs-lisp
(defun void:load-incrementally (packages)
  "Load PACKAGES incrementally.
This function tries to load a package from PACKAGES, a list of packages. It then
calls itself on the rest of PACKAGES in `void:incremental-loading-interval'
idle seconds."
  (let ((gc-cons-threshold VOID:GC-CONS-THRESHOLD-MAX)
        (gc-cons-percentage VOID:GC-CONS-PERCENTAGE-MAX)
        (file-name-handler-alist nil)
        (package (car packages))
        (rest (cdr packages)))
    (cond ((null package) nil)
          ((featurep package)
           (void:load-incrementally rest))
          (t
           (condition-case e
               (progn
                 (void:log "Incrementally loading %s" package)
                 (require package nil t))
             (error
              (message "Failed to load '%s' incrementally, because %s" package e)))
           (run-with-idle-timer
            void:incremental-loading-interval nil #'void:load-incrementally rest)))))
#+end_src

***** incremental load hook
:PROPERTIES:
:ID: 94c37e44-b03c-49c3-a376-696e6efb3e96
:END:

This hook triggers incremental loading to start.

#+begin_src emacs-lisp
(defhook! void:load-packages-incrementally-h ()
  "Begin incrementally loading packages in `void:incremental-packages'.
If this is a daemon session, load them all immediately instead."
  :hook emacs-startup-hook
  (cond
   ((daemonp)
    (mapc #'require (cdr void:incremental-packages)))
   ((numberp void:incremental-loading-interval)
    (run-with-idle-timer
     void:initial-incremental-loading-delay
     nil
     #'void:load-incrementally
     void:incremental-packages))
   (t nil)))
#+end_src

**** =tty=
:PROPERTIES:
:ID: 63e351ad-9ef6-4034-9fca-861881c74d6a
:END:

When running emacs in terminal tty is *tremendously* slow.

#+begin_src emacs-lisp
(unless (display-graphic-p)
  (advice-add #'tty-run-terminal-initialization :override #'ignore)
  (defhook! void:init-tty-h ()
    :hook window-setup-hook
    (advice-remove #'tty-run-terminal-initialization #'ignore)
    (tty-run-terminal-initialization (selected-frame) nil t)))
#+end_src

**** minibuffer
:PROPERTIES:
:ID: 83f47b4d-a0e2-4275-9c1a-7e317fdc4e41
:END:

[[helpvar:minibuffer-setup-hook][minibuffer-setup-hook]] and [[helpvar:minibuffer-exit-hook][minibuffer-exit-hook]] are the hooks run just before
entering and exiting the minibuffer (respectively). In the minibuffer I'll be
primarily doing searches for variables and functions. There are alot of
variables and functions so this can certainly get computationally expensive. To
keep things snappy I increase boost the [[helpvar:gc-cons-threshold][gc-cons-threshold]] just before I enter
the minibuffer, and restore it to it's original value a few seconds after it's closed.

It would take me forever to guess the name =minibuffer-setup-hook= from the
variable [[helpvar:minibuffer-exit-hook][minibuffer-exit-hook]]. If I knew the name =minibuffer-exit-hook= but did not
know what the hook to enter the minibuffer was, I'd probably
=minibuffer-enter-hook= because [[https://www.wordhippo.com/what-is/the-opposite-of/exit.html]["enter" is one of the main antonyms of "exit"]].
It'd take me forever to guess =startup=. Note that the only tricky thing about
this example.

At first I thought of =entry= but after more thought I realized
hook variables use action verbs in their names not nouns. So the =exit= in
=minibuffer-exit-hook= is actually the verb =exit= not the noun.

#+begin_src emacs-lisp
(defvaralias 'minibuffer-enter-hook 'minibuffer-setup-hook)

(defhook! void:boost-garbage-collection-h ()
  "Boost garbage collection settings to `VOID:GC-CONS-THRESHOLD-MAX'."
  :hook minibuffer-enter-hook
  (setq gc-cons-threshold VOID:GC-CONS-THRESHOLD-MAX))

(defhook! void:defer-garbage-collection-h ()
  "Reset garbage collection settings to `void:gc-cons-threshold' after delay."
  :append minibuffer-exit-hook
  (run-with-idle-timer 3 nil (lambda () (setq gc-cons-threshold VOID:GC-CONS-THRESHOLD))))
#+end_src

**** tangling
:PROPERTIES:
:ID: 3288c787-4b5c-4f0c-9d18-6f18afaf2b99
:END:

***** tangle hook
:PROPERTIES:
:ID: 549999d7-901b-4ab4-bdbe-81514b756ced
:END:

Void tangles itself just before quitting if [[helpfn:void-needs-tangling-p][void:needs-tangling-p]] returns true.
I tangle before quitting so I don't have to do it before startup. It's
preferable for quitting emacs to be slightly slower than for emacs startup to
be.

#+begin_src emacs-lisp
(defhook! void:tangle-on-quit-maybe-h ()
  "Tangle if `void:needs-tangling-p' returns t."
  :append kill-emacs-hook
  (when (void:needs-tangling-p)
    (void/tangle-org-file)))
#+end_src

***** tangle asynchronously upon saving
:PROPERTIES:
:ID: 00298d4e-6b18-4203-874f-f5a877a5cabf
:END:

This is another attempt to keep my =main.el= file in sync as much as possible with
[[helpvar:VOID-README-FILE][void:main-org-file]]. ~void:tangle-on-save-h~ is called whenever a buffer is being
saved to a file. The reason why I use ~cl-letf~ to temporarily override [[helpfn:load][load]] is
because ~VOID:INIT-FILE~ already contains all the code I need so I don't want it
to waste time loading ~void:main-elisp-file~.

#+begin_src emacs-lisp
(defhook! void:tangle-on-save-h ()
  "Tangle `VOID:README-FILE' asynchronously when it is saved."
  :hook after-save-hook
  (when (and (require 'async nil t)
             (string= (file-truename VOID:README-FILE)
                      (or (buffer-file-name (current-buffer)) ""))
             (void:needs-tangling-p))
    (async-start
     (lambda ()
       (let ((old-fn (symbol-function 'load))
             (user-init-file (concat user-emacs-directory "init.el")))
         (require 'cl)
         (cl-letf (((symbol-function 'load)
                    (lambda (file &rest args)
                      (when (string= user-init-file file)
                        (apply old-fn file args)))))
           (load user-init-file))))
     (lambda (_)
       (void:log
        (concat (if (void:needs-tangling-p) "✕ failed" "✓ succeeded")
                " tangling `VOID:README-FILE'."))))))
#+end_src

*** OS
:PROPERTIES:
:ID: e3d140d2-77c3-46bd-b94d-ab7196190a67
:END:

**** =abbreviated-home-dir=
:PROPERTIES:
:ID: 345958e8-fb62-4b27-b30e-c4e8b69804cd
:END:

Emacs on windows often confuses =HOME= (=C:\Users\<NAME>=) and =APPDATA=, causing
[[hvar:abbreviate-home-dir][abbreviate-home-dir]] to produce incorrect paths.

#+begin_src emacs-lisp
(with-os! windows
  (setq abbreviated-home-dir "\\`'"))
#+end_src

**** font caches
:PROPERTIES:
:ID: 339f6b4b-424c-4057-b7ea-d44c69b0f9fb
:END:

Font compacting can be terribly expensive, especially for rendering icon
fonts on Windows. Whether it has a noteable affect on Linux and Mac hasn't
been determined.

#+begin_src emacs-lisp
(with-os! windows
  (setq inhibit-compacting-font-caches t))
#+end_src

**** windows performance
:PROPERTIES:
:ID: eda95bfe-8033-42f0-9038-11da6f9bd8fb
:END:

Reduce the workload when doing file IO.

#+begin_src emacs-lisp
(with-os! windows
  (setq w32-get-true-file-attributes nil))
#+end_src

**** unnecessary command line options
:PROPERTIES:
:ID: 0bfbc8e5-88f3-4e19-a9d5-bc610ce09bb2
:END:

Some command line options aren't necessary.

#+begin_src emacs-lisp
(with-os! (:not linux)
  (setq command-line-x-option-alist nil))

(with-os! (:not mac)
  (setq command-line-ns-option-alist nil))
#+end_src

**** windows
:PROPERTIES:
:ID: 8bd7f515-0e56-4195-a04a-5003625b2dae
:END:

#+begin_src emacs-lisp
(with-os! windows
  (setq w32-get-true-file-attributes nil)
  (when (display-graphic-p)
    (setenv "GIT_ASKPASS" "git-gui--askpass")))
#+end_src

**** mac                                                              :disabled:
:PROPERTIES:
:ID: e502d7e6-8b19-4300-a4fd-9a797df98402
:END:

***** defaults                                                        :disabled:
:PROPERTIES:
:ID: 8e4e5a73-5616-4aca-b939-5bad62e6c657
:END:

#+begin_src emacs-lisp
(with-os! mac
  (setq mac-command-modifier 'meta)
  (setq mac-option-modifier  'alt)
  ;; sane trackpad/mouse scroll settings
  (setq mac-redisplay-dont-reset-vscroll t)
  (setq mac-mouse-wheel-smooth-scroll nil)
  ;;  one line at a time
  (setq mouse-wheel-scroll-amount '(5 ((shift) . 2)))
  ;; don't accelerate scrolling
  (setq mouse-wheel-progressive-speed nil)
  (setq ns-use-native-fullscreen nil)
  ;; Don't open files from the workspace in a new frame
  (setq ns-pop-up-frames nil))
#+end_src

***** exec path from shell                                            :disabled:
:PROPERTIES:
:ID: 0cc48982-6a3e-40ee-9e95-3e21dae157b5
:END:


A known problem with GUI Emacs on MacOS (or daemons started via
launchctl or brew services): it runs in an isolated
environment, so envvars will be wrong. That includes the path
Emacs picks up. [[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]] fixes this.

#+begin_src emacs-lisp
(leaf exec-path-from-shell
  :os mac
  :when (or (daemonp) (display-graphic-p))
  :require t
  :setq
  (exec-path-from-shell-check-startup-files . nil)
  (exec-path-from-shell-arguments . (delete "-i" exec-path-from-shell-arguments))
  (exec-path-from-shell-debug . void:debug-p)
  :init
  (nconc! exec-path-from-shell-variables
    '("LC_CTYPE" "LC_ALL" "LANG"))
  (exec-path-from-shell-initialize))
#+end_src

***** ns-auto-titlebar
:PROPERTIES:
:ID: 751ae26b-d0ae-4af1-80a5-c2b0ae360367
:END:

[[https://github.com/purcell/ns-auto-titlebar][ns-auto-titlebar]] syncs ns frame parameters with theme and fixes mismatching text
color in the frame title.

#+begin_src emacs-lisp
(use-package! ns-auto-titlebar
  :os mac
  :when (or (daemonp) (display-graphic-p))
  :require t)
#+end_src

***** osx-clipboard
:PROPERTIES:
:ID: 6eb19c02-ce40-4aec-9124-a58a4389855f
:END:

#+begin_src emacs-lisp
(use-package! osx-clipboard
  :os mac
  :when (or (daemonp) (not (display-graphic-p)))
  :hook emacs-startup-hook)
#+end_src

**** linux
:PROPERTIES:
:ID: 122381a6-784b-4f56-a97e-8c1a2d18dcc0
:END:

#+begin_src emacs-lisp
(with-os! linux
  (setq x-underline-at-descent-line t)
  (setq x-gtk-use-system-tooltips nil))
#+end_src

** Package Management                                                      :ewc:
:PROPERTIES:
:ID: 0397db22-91be-4311-beef-aeda4cd3a7f3
:END:

*** straight.el
:PROPERTIES:
:ID: a086d616-b90d-4826-b61f-93eb0b7efc8e
:END:

[[straight][straight.el]] is a package manager that strives to make emacs configurations
completely reproducable.

**** customize straight directory
:PROPERTIES:
:ID: 843cc8b9-edff-42f7-a767-65a59aa38fbc
:END:

The path of the straight directory within emacs is hardcoded into
straight so we need to trick it into thinking =VOID:PACKAGES-DIR= is the
our emacs directory. This needs to be done before bootstraping
straight, else the straight directory will be created anyway. I got
this from Doom's straight branch.

#+begin_src emacs-lisp
(defadvice! straight:use-packages-dir-a (orig-fn &rest args)
  "Use `VOID:PACKAGES-DIR' for straight directory."
  :around straight--emacs-dir
  (let ((user-emacs-directory VOID:PACKAGES-DIR))
    (apply orig-fn args)))
#+end_src

**** sources
:PROPERTIES:
:ID: 1491c0ff-1bce-45e2-ac36-2d33752e5d45
:END:

#+begin_src emacs-lisp
(defvar void:core-package-sources
  '((org-elpa :local-repo nil)
    (melpa
     :type git :host github
     :repo "melpa/melpa"
     :no-build t)
    (gnu-elpa-mirror
     :type git :host github
     :repo "emacs-straight/gnu-elpa-mirror"
     :no-build t)
    (emacsmirror-mirror
     :type git :host github
     :repo "emacs-straight/emacsmirror-mirror"
     :no-build t))
  "A list of recipes for straight's recipe repos.")
#+end_src

**** bootstrap code
:PROPERTIES:
:ID: 7816be80-4db8-4219-b7d1-9a6b1ea96035
:END:

This code initializes straight if it's not already installed.

#+begin_src emacs-lisp
(defun straight:init-fn ()
  "Initialize `straight.el'."
  (defvar boostrap-version 5 "Bootstrap version for straight.el")
  (let* ((user-emacs-directory VOID:PACKAGES-DIR)
         (straight-dir (concat VOID:PACKAGES-DIR "straight/"))
         (bootstrap-file (concat straight-dir "repos/straight.el/straight.el")))
    (unless (or (require 'straight nil t) (file-readable-p bootstrap-file))
      (void:log "Installing straight.el...")
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (void:log "Loading straight.el...")
    (load bootstrap-file nil t))
  (mapc #'straight-use-recipes void:core-package-sources))
#+end_src

**** straight-installer
:PROPERTIES:
:ID: 5b38a3da-d237-45f5-804f-5fd7e2f88d83
:END:

#+begin_src emacs-lisp
(defun straight:install-package (package-or-recipe)
  "Install PACKAGE with optional RECIPE."
  (unless (featurep 'straight) (straight:init-fn))
  (let ((package (or (car-safe package-or-recipe) package-or-recipe)))
    (condition-case err
        (progn (straight-use-package package-or-recipe)
               (void:log "✓ installed %s" package))
      (error
       (void:log "✕ failed to install %s because of %s" package err)))))
#+end_src

*** required packages
:PROPERTIES:
:ID: 453cc36d-9174-4b63-b3f2-4d1dd7e3521d
:END:

[[id:04560da8-1e8a-4bcc-bdeb-574d8bfc984d][Later]] I write a macro specifically designed for installing and configuring
packages. I could write this macro with just plain Emacs libraries but I prefer
using nice libraries. In byte compiled Void, they don't need to be installed.

#+begin_src emacs-lisp
(dolist (package '(leaf-keywords leaf))
  (funcall #'straight:install-package package)
  (require package))
(leaf-keywords-init)
#+end_src

*** leaf

:PROPERTIES:
:ID:       109f58d7-525e-43f4-b997-658b1d5da0a8
:END:

Like =use-package=, leaf is a macro that fascilitates package configuration.

**** naming
:PROPERTIES:
:ID:       941ce3dc-9648-4133-864b-eae2542a2b54
:END:

The name =leaf= is not descriptive about what I'm doing which is configuring a
package.

#+begin_src emacs-lisp
(defalias 'use-package! 'leaf)

(defmacro use-feature! (feature &rest args)
  (declare (indent defun))
  `(leaf ,feature :ensure nil ,@args))
#+end_src

**** leaf
:PROPERTIES:
:ID:       7d72aec8-5523-473d-860d-181ce3d484d7
:END:

#+begin_src emacs-lisp
(use-package! leaf
  :setq (leaf-defaults . '(:ensure t)))
#+end_src

**** define leaf keyword
:PROPERTIES:
:ID:       5f480daa-4561-400f-bbe2-4396fc7877ff
:END:

Leaf is very minimal and for the most part this is good. However, it does mean
defining leaf keywords is a bit of a pain. There are many low-level parts of
doing so that could be automated. This is my attempt to automate defining a leaf
keyword.

#+begin_src emacs-lisp
(cl-defun leaf:define-keyword (&key name where normalizer defer alias form)
  "Define leaf KEYWORD at PLACE.
PLACE is a list whose car is the symbol `before' or `after' and whose cadr is
one of leaf's available keywords. DEFER specifies whether the keyword is a
deferring keyword. ALIAS is an alias or a list of aliases for the keyword. FORM
is the form that will be added to."
  (setq name (intern (concat ":" (symbol-name name))))
  ;; Defer it if necessary.
  (when defer
    (push name leaf-defer-keywords))

  ;; Set up aliases.
  (let ((aliases alias))
    (dolist (alias aliases)
      (push (cons alias name) leaf-alias-keyword-alist)))

  ;; Add a normalizer.
  (when normalizer
    (push `((or (eq leaf--key ,name)
                (eq ,name (alist-get leaf--key leaf-alias-keyword-alist)))
            (funcall #',normalizer))
          leaf-normalize))

  ;; Insert it in proper place.
  (let* ((place (cadr where))
         (where (car where))
         (target-form (list name form))
         (insert-fn (cond ((eq where 'after) #'leaf-insert-list-after)
                          ((eq where 'before) #'leaf-insert-list-before)
                          (t (error)))))
    (setq leaf-keywords (funcall insert-fn leaf-keywords place target-form))))
#+end_src

**** custom setting keywords
:PROPERTIES:
:ID:       225cdf80-0770-47c0-8a94-6d69f4583374
:END:

Leaf keywords do not.

***** normalizers
:PROPERTIES:
:ID:       bcf96e13-f3bc-4b23-832f-f94b31dd48a5
:END:

leaf's setq does not correctly handle setting variables to forms that need to be
evaluated.

#+begin_src emacs-lisp
(defun leaf:normalizer-setq ()
  (mapcar (lambda (it) (cons (car it) (cdr it))) leaf--value))

(defun leaf:normalizer-commands ()
  (mapcar (lambda (elm)
            (cond ((memq leaf--key '(:after))
                   (if (eq elm t) leaf--name elm))
                  (t elm)))
          (delete-dups (delq nil (leaf-flatten leaf--value)))))
#+end_src

***** setq
:PROPERTIES:
:ID:       6f38c45b-9382-4d72-a7ae-6d7a8748d07f
:END:

#+begin_src emacs-lisp
(leaf:define-keyword
 :name 'void-setq
 :where '(before :setq)
 :normalizer #'leaf:normalizer-setq
 :alias (list :setq)
 :form (plist-get leaf-keywords :setq))
#+end_src

***** pre-setq
:PROPERTIES:
:ID:       aba01554-fa11-4120-9867-19e5e2025df4
:END:

#+begin_src emacs-lisp
(leaf:define-keyword
 :name 'void-pre-setq
 :where '(before :pre-setq)
 :normalizer #'leaf:normalizer-setq
 :alias (list :pre-setq)
 :form (plist-get leaf-keywords :pre-setq))
#+end_src

***** custom
:PROPERTIES:
:ID:       bfa61a7a-1660-4000-a80e-15851a32ffd5
:END:

#+begin_src emacs-lisp
(leaf:define-keyword
 :name 'void-custom
 :where '(before :custom)
 :normalizer #'leaf:normalizer-setq
 :alias (list :custom)
 :form (plist-get leaf-keywords :custom))
#+end_src

***** setq-default
:PROPERTIES:
:ID:       b8ab2bf6-2b4e-41db-93f8-ed5c86392c84
:END:

#+begin_src emacs-lisp
(leaf:define-keyword
 :name 'void-setq-default
 :where '(before :setq-default)
 :normalizer #'leaf:normalizer-setq
 :alias (list :setq-default)
 :form (plist-get leaf-keywords :setq-default))
#+end_src

**** defer keywords
:PROPERTIES:
:ID:       6a8189ab-9a7a-4670-aa7a-b6589c180011
:END:

These keywords are meant to improve on the deferred loading options already
provided by leaf. They are inspired from DOOM emacs.

***** leaf-generate-load-fn
:PROPERTIES:
:ID:       41c05e4a-a0f1-45e7-bed6-7de7a439faa1
:END:

#+begin_src emacs-lisp
(defun leaf:generate-load-form (package &optional hooks advice-place advices)
  "Return form that evals into function that loads the package."
  (let ((load-fn (intern (concat "leaf:load-" (symbol-name package)))))
    `(progn
       (defun ,load-fn (&rest _)
         (void:log "Loading %S..." ',package)
         (unless (require ',package nil t)
           (message "Error loading %S" ',package))
         ,@(mapcar (lambda (hook) `(remove-hook ',hook #',load-fn)) hooks)
         ,@(mapcar (lambda (advice) `(advice-remove #',advice #',load-fn)) advices)
         (fmakunbound #',load-fn))
       ,@(mapcar (lambda (hook) `(add-hook ',hook #',load-fn)) hooks)
       ,@(mapcar (lambda (advice) `(advice-add #',advice ,advice-place #',load-fn)) advices))))
#+end_src

***** before-call
:PROPERTIES:
:ID:       5378035c-206b-4479-8c60-4d57853e5754
:END:

#+begin_src emacs-lisp
(leaf:define-keyword
 :name 'before-call
 :where '(before :hook)
 :defer t
 :normalizer #'leaf:normalizer-commands
 :form '`(,(leaf:generate-load-form leaf--name nil :before leaf--value)
          ,@leaf--body))
#+end_src

***** after-call
:PROPERTIES:
:ID:       36389857-c070-4221-8f76-b6b0da257b34
:END:

#+begin_src emacs-lisp
(leaf:define-keyword
 :name 'after-call
 :where '(before :hook)
 :defer t
 :normalizer #'leaf:normalizer-commands
 :form '`(,(leaf:generate-load-form leaf--name nil :after leaf--value)
          ,@leaf--body))
#+end_src


***** on-hook
:PROPERTIES:
:ID:       6b4696f3-2bc0-4646-ab68-e5e5b61b0624
:END:

#+begin_src emacs-lisp
(leaf:define-keyword
 :name 'on-hook
 :where '(before :hook)
 :defer t
 :form '`(,(leaf:generate-load-form leaf--name leaf--value)
          ,@leaf--body))
#+end_src

***** defer-incrementally
:PROPERTIES:
:ID:       c7ab7604-6e7c-42d1-b956-c58854948e8f
:END:

#+begin_src emacs-lisp
(leaf:define-keyword
 :name 'load-incrementally
 :where '(before :before-call)
 :defer t
 :normalizer #'leaf:normalizer-commands
 :form '`((append! void:incremental-packages ',leaf--value)
          ,@leaf--body))
#+end_src

**** straight keyword
:PROPERTIES:
:ID:       cba57988-21b2-456b-aed2-27254febf873
:END:

This keyword is designed to be compiled away, leaving only forms adding package
paths to the load-path. This is so that package installation isn't done after
VOID is compiled.

#+begin_src emacs-lisp
(leaf:define-keyword
 :name 'void-straight
 :where '(before :straight)
 :alias (list :ensure)
 :form
 '`(,@(when (and leaf--value (car-safe leaf--value))
        `((straight:install-package ',(car leaf--value))))
    ,@leaf--body))

(push `((or (memq leaf--key '(:void-straight))
            (eq (alist-get leaf--key leaf-alias-keyword-alist) :void:straight))
        (cond ((eq t (car leaf--value))
               (list leaf--name))
              ((eq nil (car leaf--value))
               nil)
              ((listp (car-safe leaf--value))
               (list (cons leaf--name (car leaf--value))))))
      leaf-normalize)
#+end_src

**** popup
:PROPERTIES:
:ID:       30845314-ac19-49bb-9065-591c13e55489
:END:

The point of this keyword is to let me configure the display of buffers for
specific packages.

#+begin_src emacs-lisp
(leaf:define-keyword
 :name 'popup
 :where '(before :mode)
 :form '`(,@(mapcar (lambda (it) `(push ',it display-buffer-alist)) leaf--value)
          ,@leaf--body))
#+end_src

**** os
:PROPERTIES:
:ID:       3335e409-b963-4504-b9fb-2faf4fb0be3d
:END:

#+begin_src emacs-lisp
(leaf:define-keyword
 :name 'os
 :where '(before :when)
 :form '(when leaf--body `((with-os! ,leaf--value ,@leaf--body))))
#+end_src

**** straight
:PROPERTIES:
:ID:       9dff9894-667c-4e74-9624-8aee533f8f70
:END:

#+begin_src emacs-lisp
(use-package! straight
  :require t
  :setq
  (straight-disable-autoloads . nil)
  (straight-cache-autoloads . t)
  (straight-check-for-modifications . nil)
  (straight-enable-package-integration . nil)
  (straight-recipes-emacsmirror-use-mirror . t))
#+end_src

**** package.el
:PROPERTIES:
:ID:       550066df-89b4-4d4d-b8fd-daa1c28b1ceb
:END:

#+begin_src emacs-lisp
(use-feature! package
  :init (advice-add #'package--ensure-init-file :override #'ignore)
  :setq (package-archives . `(("gnu"   . "https://elpa.gnu.org/packages/")
                              ("melpa" . "https://melpa.org/packages/")
                              ("org"   . "https://orgmode.org/elpa/"))))
#+end_src

** Library
:PROPERTIES:
:ID: 3e9e5e7a-9f9b-4e92-b569-b5e8ba93820f
:END:

*** built-in
:PROPERTIES:
:ID: 40367976-12a0-4ccd-9aff-4df144a73edf
:END:

**** startup
:PROPERTIES:
:ID: 9725b7e0-54b8-4ab4-aa00-d950345d0aea
:END:

Emacs starts up with a default screen setup. No, thanks.

#+begin_src emacs-lisp
(use-feature! startup
  :setq
  (inhibit-startup-screen . t)
  (inhibit-default-init . t)
  (inhibit-startup-buffer-menu . t)
  (initial-major-mode . 'fundamental-mode)
  (initial-scratch-message . nil)
  (initial-buffer-choice . (if void:debug-p (lambda () (get-buffer "*Messages*")) t))
  (inhibit-startup-echo-area-message . user-login-name))
#+end_src

**** paren
:PROPERTIES:
:ID: 8ba80d6f-292e-4d44-acfe-d7b7ba939fa4
:END:

#+begin_src emacs-lisp
(use-feature! paren
  :hook (prog-mode-hook . show-paren-mode)
  :setq-default
  (show-paren-delay . 0))
#+end_src

**** clipboard
:PROPERTIES:
:ID: 60abb076-89b1-439b-8198-831b2df47782
:END:

#+begin_src emacs-lisp
;; Not windows.
(use-feature! select
  :setq
  (selection-coding-system . 'utf-8)
  (select-enable-clipboard . t)
  (select-enable-primary . t)
  (x-select-request-type . '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
#+end_src

**** simple
:PROPERTIES:
:ID: 89df102a-a2c9-4ece-9acc-ed90e8064ed8
:END:

#+begin_src emacs-lisp
(use-feature! simple
  :popup ("\\*Messages"
          (display-buffer-at-bottom)
          (window-height . 0.5))
  :setq-default
  (idle-update-delay . 1)
  (blink-matching-paren . t)
  (delete-trailing-lines . nil)
  :setq
  (mail-user-agent . 'mu4e-user-agent))
#+end_src

**** loaddefs
:PROPERTIES:
:ID:       5af4faf8-47e3-4db2-9d13-47fc828b8fca
:END:

These are *extremely* important lines if you use an external program as I do
([[https://wiki.archlinux.org/index.php/Msmtp][msmtp]]) to send your email. If you don't set these variables, emacs will
think you want to use =smtp=.

#+begin_src emacs-lisp
(use-feature! loaddefs
  :setq-default
  (disabled-command-function . nil)
  ;; very important if you're using msmtp
  ;; (sendmail-program (executable-find "msmtp"))
  )
#+end_src

**** files
:PROPERTIES:
:ID: 2a7862da-c863-416b-a976-4cf7840a8712
:END:

#+begin_src emacs-lisp
(use-feature! files
  :setq-default
  ;; Whether to add a newline automatically at the end of the file.
  ;; Whether confirmation is requested before visiting a new file or buffer.
  (confirm-nonexistent-file-or-buffer . nil)
  ;; How to ask for confirmation when leaving Emacs.
  (confirm-kill-emacs . #'y-or-n-p)
  (require-final-newline . nil)
  (trash-directory . (expand-file-name "Trash" "~"))
  (auto-save-default . nil)
  (auto-save-interval . 300)
  (auto-save-timeout . 30)
  (backup-directory-alist . (list (cons ".*" (concat VOID:DATA-DIR "backup/"))))
  (make-backup-files . nil)
  (version-control . nil)
  (kept-old-versions . 2)
  (kept-new-versions . 2)
  (delete-old-versions . t)
  (backup-by-copying . t)
  (backup-by-copying-when-linked . t))
#+end_src

**** subr
:PROPERTIES:
:ID:       61603f44-780e-4456-88c6-7ffe1e5c7197
:END:

#+begin_src emacs-lisp
(use-feature! subr
  :init
  (fset #'yes-or-no-p #'y-or-n-p)
  (fset #'display-startup-echo-area-message #'ignore))
#+end_src

**** subr-x
:PROPERTIES:
:ID:       1ed0ba00-e5a1-4642-9ed5-a52f4b917a4d
:END:

#+begin_src emacs-lisp
;; This is where `thread-last' and `thread-first' come from.
(use-feature! subr-x
  :require t)
#+end_src

**** ffap
:PROPERTIES:
:ID: b1229201-a5ac-45c7-91fa-7a6b39bbb879
:END:

Don't ping things that look like domain names.

#+begin_src emacs-lisp
(use-feature! ffap
  :setq
  (ffap-machine-p-known . 'reject))
#+end_src

**** server
:PROPERTIES:
:ID: 3ddeb65c-9df6-4ede-9644-eb106b3ba1dd
:END:

#+begin_src emacs-lisp
(use-feature! server
  :setq
  (server-auth-dir . (concat VOID:DATA-DIR "server/")))
#+end_src

**** tramp
:PROPERTIES:
:ID: 3af0a4d6-bd08-4fe2-bc5c-79b1b811fc6b
:END:

#+begin_src emacs-lisp
(use-feature! tramp
  :setq
  (tramp-backup-directory-alist . backup-directory-alist)
  (tramp-auto-save-directory . (concat VOID:DATA-DIR "tramp-auto-save/"))
  (tramp-persistency-file-name . (concat VOID:DATA-DIR "tramp-persistency.el")))
#+end_src

**** desktop
:PROPERTIES:
:ID: 3a6b72e7-57c8-42f0-a8d7-1bbde72de9bd
:END:

#+begin_src emacs-lisp
(use-feature! desktop
  :setq
  (desktop-dirname . (concat VOID:DATA-DIR "desktop"))
  (desktop-base-file-name . "autosave")
  (desktop-base-lock-name . "autosave-lock"))
#+end_src

**** cus-edit
:PROPERTIES:
:ID: 8bd5683d-91e1-4c1b-a8a5-3b39921e995d
:END:

#+begin_src emacs-lisp
(use-feature! cus-edit
  :setq
  (custom-file . (concat VOID:DATA-DIR "custom.el"))
  (custom-theme-directory . (concat VOID:LOCAL-DIR "themes/")))
#+end_src

**** url cache
:PROPERTIES:
:ID: e4b5bfce-1111-48b2-bfee-da754974aa46
:END:

#+begin_src emacs-lisp
(use-feature! url
  :setq
  (url-cache-directory . (concat VOID:DATA-DIR "url/cache/"))
  (url-configuration-directory . (concat VOID:DATA-DIR "url/configuration/")))
#+end_src

**** bytecomp
:PROPERTIES:
:ID:       6b375bfb-a8c3-473c-8dbd-530e692a15ab
:END:

#+begin_src emacs-lisp
(use-feature! bytecomp
  :setq
  (byte-compile-verbose . void:debug-p)
  (byte-compile-warnings . '(not free-vars unresolved noruntime lexical make-local)))
#+end_src

**** compile
:PROPERTIES:
:ID:       913aa4f2-e42b-4b74-a2d4-e87b1738a5bd
:END:

#+begin_src emacs-lisp
(use-feature! compile
  :setq-default
  (compilation-always-kill . t)
  (compilation-ask-about-save . nil)
  (compilation-scroll-output . 'first-error))
#+end_src

**** uniquify
:PROPERTIES:
:ID:       9ba2726b-3fef-4e9b-9387-a80ab09bdb7d
:END:

#+begin_src emacs-lisp
(use-feature! uniquify
  :setq-default
  (uniquify-buffer-name-style . 'forward))
#+end_src

**** ansi-color
:PROPERTIES:
:ID:       5feaab76-e5c1-450c-94a6-8fdfb95ddb94
:END:

#+begin_src emacs-lisp
(use-feature! ansi-color
  :setq-default
  (ansi-color-for-comint-mode . t))
#+end_src

**** image mode
:PROPERTIES:
:ID:       32e2118a-c92b-4e8d-b2db-048428462783
:END:

#+begin_src emacs-lisp
(use-feature! image-mode
  :setq
  ;; Non-nil means animated images loop forever, rather than playing once.
  (image-animate-loop . t))
#+end_src

**** window
:PROPERTIES:
:ID:       af27cd7e-2096-4f6d-a749-63e4c38d136c
:END:

#+begin_src emacs-lisp
(use-feature! window
  :setq-default
  (split-width-threshold . 160))
#+end_src

**** paragraphs
:PROPERTIES:
:ID:       f289ade4-ad16-4f6a-8868-1f9b7af5ddca
:END:

#+begin_src emacs-lisp
(use-feature! paragraphs)
#+end_src

**** indent
:PROPERTIES:
:ID:       a5d97d4d-3af9-4fde-ae14-953ad4d28edd
:END:

#+begin_src emacs-lisp
(use-feature! indent
  :setq-default
  (tab-always-indent . t))
#+end_src

**** mouse
:PROPERTIES:
:ID:       d0d6de11-50fa-4ae2-ad4b-69712f3e2c54
:END:

#+begin_src emacs-lisp
(use-feature! mouse
  :setq-default
  (mouse-yank-at-point . t))
#+end_src

**** calendar
:PROPERTIES:
:ID:       4ad7e704-f490-40e4-b2bc-8a30a10a7bb7
:END:

#+begin_src emacs-lisp
(use-feature! calendar
  :setq (diary-file . (concat VOID:DATA-DIR "diary")))
#+end_src

**** mule-cmds
:PROPERTIES:
:ID:       e48e925e-1f1e-4c79-8652-c92aafe06290
:END:

#+begin_src emacs-lisp
(use-feature! mule-cmds
  :init (prefer-coding-system VOID:DEFAULT-CODING-SYSTEM))
#+end_src

**** seq
:PROPERTIES:
:ID:       7b5752cf-be64-452b-95e7-35cc83bb5e0b
:END:

#+begin_src emacs-lisp
(use-feature! seq
  ;; :alias (seq-some-p . seq-some)
  ;; Don't know why seq-some doesn't end with a '-p'. It is a predicate function.
  :init (defalias 'seq-some-p 'seq-some)
  :require t)
#+end_src

**** gv
:PROPERTIES:
:ID:       84cc5883-a303-453e-af91-644d4544e3f9
:END:

=gv= is what contains the code for the =setf= macro.
https://emacs.stackexchange.com/questions/59314/how-can-i-make-setf-work-with-plist-get

#+begin_src emacs-lisp
(use-feature! gv
  :defer-config
  (gv-define-simple-setter plist-get plist-put))
#+end_src

*** external libraries
:PROPERTIES:
:ID: 6e4be80e-8149-424d-a801-d7871bfe8fc8
:END:

**** general
:PROPERTIES:
:ID: 706f35fc-f840-4a51-998f-abcd54c5d314
:END:

Keybindings are a key part of emacs (pun intended).

***** general
:PROPERTIES:
:ID: f1ad5258-17cb-4424-a161-b856ee6dc5ab
:END:

There are numerous keybinding functions in Emacs; and they all look a little
different: there's [[helpfn:global-set-key][global-set-key]], [[helpfn:local-set-key][local-set-key]], [[helpfn:define-key][define-key]] and the list goes
on. And with [[][evil]] which [[id:73366b3e-7438-4abf-a661-ed1553b1b8df][I use]] , there's also [[helpfn:evil-global-set-key][evil-global-set-key]] and
[[helpfn:evil-define-key][evil-define-key]]. It would be nice to have one keybinding function that can
handle all bindings. [[][general]] provides such a function ([[helpfn:general-define-key][general-define-key]]).

#+begin_src emacs-lisp
(use-package! general
  :require t
  :config
  (general-auto-unbind-keys))
#+end_src

***** prefix bindings
:PROPERTIES:
:ID: b0b5b51c-155e-46fc-a80a-0d45a32440ba
:END:

A popular strategy to mitigate the mental load of remembering many keybindings
is to bind them in a tree-like fashion. [[][spacemacs]].

****** leader Keys
:PROPERTIES:
:ID: 143211d6-b868-4ffb-a5d0-25a77dee401f
:END:

#+begin_src emacs-lisp
(defvar void:leader-key "SPC"
  "The evil leader prefix key.")

(defvar void:leader-alt-key "M-SPC"
  "The leader prefix key used for Insert and Emacs states.")
#+end_src

****** localleader keys
:PROPERTIES:
:ID: 45941bcb-209f-4aa3-829a-dee4e3ef2464
:END:

#+begin_src emacs-lisp
(defvar void:localleader-key "SPC m"
  "The localleader prefix key for major-mode specific commands.")

(defvar void:localleader-alt-key "C-SPC m"
  "The localleader prefix key for major-mode specific commands.")

(defvar void:localleader-short-key ","
  "A shorter alternative `void:localleader-key'.")

(defvar void:localleader-short-alt-key "M-,"
  "A short non-normal  `void:localleader-key'.")
#+end_src

****** definers
:PROPERTIES:
:ID: 6444d218-1627-48bd-9b5c-7bfffb17d912
:END:

As I've mentioned =general= uses the function =general-define-key= as a generic
do-all key binder. Sometimes though we have keys that we want to bind with
specific arguments to =general-define-key= pretty often. A typical example of
this is binding =leader= or =localleader= keys like [[https://github.com/syl20bnr/spacemacs][spacemacs]].

#+begin_src emacs-lisp
(general-create-definer define-leader-key!
  :prefix void:leader-key
  :non-normal-prefix void:leader-alt-key
  :keymaps 'override
  :states '(normal motion insert emacs))
#+end_src

****** localleader
:PROPERTIES:
:ID:       e4770eae-adf5-4216-9016-5ec4bc465e03
:END:

There's pros and cons to the =SPC m= binding. The main pro is that it's
consistent with =SPC=. With the leader and the localleader, this means that you
can reach any binding from just =SPC=. This means that you can discover all
bindings from just one root binding. This is a nice property to have. On the
other hand, bindings can get a bit long. That one extra character can really
make a difference. That's why.

#+begin_src emacs-lisp
(defmacro define-localleader-key! (&rest args)
  (declare (indent defun))
  (let ((shared-args '(:keymaps 'override :states '(normal motion insert emacs))))
    `(progn (general-def
              ,@args
              ,@shared-args
              :prefix void:localleader-key
              :non-normal-prefix void:localleader-alt-key)
            (general-def
              ,@args
              ,@shared-args
              :prefix void:localleader-short-key
              :non-normal-prefix void:localleader-short-alt-key))))
#+end_src

**** which-key
:PROPERTIES:
:ID: 79d530ab-ab32-459e-853c-b1ec9eee37ef
:END:

Emacs is full of so many keybindings, that it can be difficult to keep track of
them. Especially when you're starting out, but even when you're an Emacs-pro,
it's easy to forget what a particular functionality is bound to. Typically,
you'll remember the first few key strokes but struggle with the rest. To address
this [[github:][which-key]] displays key binding sequences in the minibuffer as your typing
them ([[][]] and [[][]] are screenshots of this in action). By doing this
you can "discover" the commands as you go along.

#+begin_src emacs-lisp
(use-package! which-key
  :hook emacs-startup-hook
  :setq
  (which-key-sort-uppercase-first . nil)
  (which-key-max-display-columns . nil)
  (which-key-add-column-padding . 1)
  (which-key-min-display-lines . 6)
  (which-key-side-window-slot . -10)
  (which-key-sort-order . #'which-key-prefix-then-key-order)
  (which-key-popup-type . 'minibuffer)
  :config
  (which-key-mode)
  (defhook! which:key-set-line-spacing-h ()
    :hook which-key-init-buffer-hook
    (setq line-spacing 3))
  (which-key-add-key-based-replacements void:leader-key "<leader>")
  (which-key-add-key-based-replacements void:localleader-key "<localleader>"))
#+end_src

**** dash                                                             :disabled:
:PROPERTIES:
:ID: 4e135d88-9dc3-4451-81dc-420184aecada
:END:

Dash is a library that provides functional (sometimes clojure-esque) like
abstractions for manipulating lists.

#+begin_src emacs-lisp
(use-package! dash
  :require t
  :config
  (defun dash-expand:&llist (key source)
    `(car (alist-get ,key ,source)))
  (defun dash-expand:&alist* (key source)
    "Generate extracting KEY from SOURCE for &alist destructuring."
    `(prog1 (alist-get ,key ,source)
       (setq ,source (--remove-first (equal (car it) ,key) ,source)))))
#+end_src

**** dash-functional
:PROPERTIES:
:ID: 5e74cff5-49e6-4dde-baf5-27de12d0063f
:END:

[[https://github.com/magnars/dash.el][dash-functional]] goes hand in hand with dash. It's a library of functions that
transform functions into other functions.

#+begin_src emacs-lisp
(use-package! dash-functional :require t)
#+end_src

**** anaphora
:PROPERTIES:
:ID: 0d0cd8ff-775d-4f45-876c-855815cf49d8
:END:

[[https://github.com/rolandwalker/anaphora][anaphora]] is a library of basic [[https://en.wikipedia.org/wiki/Anaphoric_macro][anaphoric]] macros. Often I'll need to reference
the condition of some if or while statement.

#+begin_src emacs-lisp
(use-package! anaphora :require t)
#+end_src

**** s
:PROPERTIES:
:ID: 4b82deb0-bbe1-452c-8b60-ef734efb86d8
:END:

#+begin_src emacs-lisp
(use-package! s :require t)
#+end_src

**** a
:PROPERTIES:
:ID: 7cacf86a-8790-4e08-95e6-6406f9dbf32d
:END:

This is an alist library--something badly needed in Emacs. Perhaps the most
important function for me in this library is =a-update=, a function that updates
an element of an alist.

#+begin_src emacs-lisp
(use-package! a)
#+end_src

**** shut-up
:PROPERTIES:
:ID: aaf02960-925b-4a67-b06b-5819e68d0c4d
:END:

Macro that silences output.

#+begin_src emacs-lisp
(use-package! shut-up
  :init
  (defalias 'shut-up! 'shut-up)
  (defalias 'quiet! 'shut-up))
#+end_src

**** noflet
:PROPERTIES:
:ID: e89b1560-bb57-4c97-94e5-4ff78ab5bdde
:END:

#+begin_src emacs-lisp
(use-package! noflet)
#+end_src

**** gc
:PROPERTIES:
:ID: 4f1477b7-7b28-4a20-9a31-cc34a10f5878
:END:

Wait until idle time to garbage collect while staving off garbage collector
while the user is working.

#+begin_src emacs-lisp
(use-package! gcmh
  :hook emacs-startup-hook
  :setq
  (gcmh-idle-delay . 10)
  (gcmh-verbose . void:debug-p)
  (gcmh-high-cons-threshold . (* 16 1024 1024)))
#+end_src

**** fn
:PROPERTIES:
:ID:       538fa10d-1c43-4402-b07e-5dd6605b5a90
:END:

#+begin_src emacs-lisp
(use-package! fn :require t)
#+end_src

**** mmt
:PROPERTIES:
:ID:       94c8da4a-3e2c-42ab-abb7-14f49e76e045
:END:

#+begin_src emacs-lisp
(use-feature! mmt)
#+end_src

*** custom macros and functions
:PROPERTIES:
:ID:       4029d357-1309-4c7f-89eb-db93a3470c42
:END:

**** windows
:PROPERTIES:
:ID: 039a9070-2ba3-4e01-abd4-7bdb49cc5a3d
:END:

***** split-right-and-focus
:PROPERTIES:
:ID: 6cb60d94-723b-48e5-850a-3483e78f6647
:END:

#+begin_src emacs-lisp
(defun void/window-split-right-and-focus ()
  "Split window right and select the window created with the split."
  (interactive)
  (select-window (split-window-right)))
#+end_src

***** split-below-and-focus
:PROPERTIES:
:ID: d6a4a81f-007d-4b7e-97a3-e0bba3ff97a4
:END:

#+begin_src emacs-lisp
(defun void/window-split-below-and-focus ()
  "Split window below and select the window created with the split."
  (interactive)
  (select-window (split-window-below)))
#+end_src

**** macros
:PROPERTIES:
:ID: 9d65f3e2-a6d2-4f84-8150-9f9df7d3a513
:END:

***** list mutation
:PROPERTIES:
:ID:       d9f77404-5c29-4305-ae53-e409e1b06b99
:END:

****** append!
:PROPERTIES:
:ID: f314672c-f9f3-4630-9402-a9a65215c153
:END:

#+begin_src emacs-lisp
(defmacro append! (sym &rest lists)
  "Append LISTS to SYM.
SYM is a symbol that stores a list."
  (declare (indent 1))
  `(setq ,sym (append ,sym ,@lists)))
#+end_src

****** prepend!
:PROPERTIES:
:ID: 3395dec3-0915-49cd-9445-d3db2b1ffe7f
:END:

#+begin_src emacs-lisp
(defmacro prepend! (sym &rest lists)
  (declare (indent defun))
  `(setq ,sym (append ,@lists ,sym)))
#+end_src

****** nconc!
:PROPERTIES:
:ID: b24d1d8f-f3e1-4dca-afdb-8fb73d5299c3
:END:

#+begin_src emacs-lisp
(defmacro nconc! (sym &rest lists)
  "Append LISTS to SYM by altering them in place."
  (declare (indent 1))
  `(setq ,sym (nconc ,sym ,@lists)))
#+end_src

***** anaphora
:PROPERTIES:
:ID:       9938b1e1-6c6e-4a45-a85e-1a7f2d0bf6df
:END:

Anaphora refers to the ability to refer to. After much deliberation, I have
decided it is best to use =<>= to denote the symbol referred to by anaphoric
symbols because it is easy to type (assuming parentheses completion), it's a a
symbol surrounded by =<>= is uncommon in lisp, and I like that it looks like a slot
or placeholder.

https://en.wikipedia.org/wiki/Anaphoric_macro

****** anaphoric symbol regexp
:PROPERTIES:
:ID:       40c97bd5-dab1-44df-86f7-90274d5a8ea0
:END:

#+begin_src emacs-lisp
(defconst VOID:ANAPHORIC-SYMBOL-REGEXP
  (eval-when-compile (rx "<" (group (1+ (not (any white ">" "<")))) ">"))
  "Regular expression that matches an anaphoric symbol.")
#+end_src

****** anaphoric symbol
:PROPERTIES:
:ID:       db8169ba-1630-42fe-9ab7-e29c110a18c3
:END:

#+begin_src emacs-lisp
(defun void:anaphoric-symbol-p (obj)
  "Return t if OBJ is an anaphoric symbol."
  (and (symbolp obj)
       (s-matches-p VOID:ANAPHORIC-SYMBOL-REGEXP (symbol-name obj))))
#+end_src

****** true anaphora name
:PROPERTIES:
:ID:       2833cd75-9c85-4c0e-9523-4489d387150a
:END:

#+begin_src emacs-lisp
(defun void:anaphoric-true-symbol (symbol)
  "Return the symbol that corresponds to the anaphoric symbol.
For example, 'hi would correspond to '<hi>."
  (save-match-data
    (string-match VOID:ANAPHORIC-SYMBOL-REGEXP (symbol-name symbol))
    (intern (match-string 1 (symbol-name symbol)))))
#+end_src

****** body symbols
:PROPERTIES:
:ID:       2bae458e-404a-48e7-b57e-ce7f543f6e6d
:END:

#+begin_src emacs-lisp
(defun void:anaphoric-body-symbols (body &optional contains-p)
  "Return all the anaphoric symbols in body."
  (thread-last (flatten-list body)
    (seq-filter #'void:anaphoric-symbol-p)
    (seq-uniq)))
#+end_src

****** all anaphoric symbols in obj
:PROPERTIES:
:ID:       e0c0eb8c-52b3-4411-ab0b-06255490dacf
:END:

#+begin_src emacs-lisp
(defun void:anaphoric-symbols-in-obj (obj)
  "Return a list of anaphoric symbols in OBJ."
  (s-match-strings-all VOID:ANAPHORIC-SYMBOL-REGEXP (void:make-string obj)))
#+end_src

***** pair value extraction
:PROPERTIES:
:ID: e546a63f-eb75-4b72-9392-2a6041f87f50
:END:

When extracting one value from a plist, alist or another lisp data structure at
a time, it often suffices to use =plist-get=, =alist-get= or whatever function
is used to get a particular value based on the structure. Sometimes, however, we
need to get and use many values from the data structure. And in these cases it
becomes repetative to have to do ~(plist-get plist key)~ all the time.

****** with structure
:PROPERTIES:
:ID: c88dac35-9345-49f5-bdb5-e856071e6764
:END:

#+begin_src emacs-lisp
(defmacro with-structure! (structure fn &rest body)
  "Access items from STRUCTURE.
FN is a function that accepts two arguments, the structure and a symbol name. FN
should return the value of structure for that symbol.
BODY contains any number of `<NAME>' where NAME refers to the name of the symbol."
  (declare (indent 2))
  (let* ((symbols (thread-last (flatten-list body)
                    (seq-filter #'void:anaphoric-symbol-p)
                    (seq-uniq)))
         (names (seq-map #'void:anaphoric-true-symbol symbols)))
    `(let (,@(seq-map (-lambda ((sym name)) `(,sym (funcall ,fn ,structure ',name)))
                      (seq-mapn #'list symbols names)))
       ,@body)))
#+end_src

****** with plist
:PROPERTIES:
:ID: f84e30a9-b725-415e-b1df-7b4489913d2c
:END:

#+begin_src emacs-lisp
(defmacro with-plist! (plist &rest body)
  (declare (indent 1))
  `(with-structure! ,plist #'plist-get ,@body))
#+end_src

****** with-alist
:PROPERTIES:
:ID: d594c666-0ec1-4c72-9159-5ddea9702d03
:END:

#+begin_src emacs-lisp
(defmacro with-alist! (alist &rest body)
  (declare (indent 1))
  `(with-structure! ,alist (lambda (key) (alist-get key alist)) ,@body))
#+end_src

**** symbols
:PROPERTIES:
:ID: 2cdf8ab1-4e59-4128-a8a4-e5519ca0f4bf
:END:

Here I have convenience functions for primarily used for writing macros. They
help me convert a combinations of strings and symbols or numbers into another
type without any manual hassle.

***** symbol intern
:PROPERTIES:
:ID: 659e8389-84c5-4ac4-a9ba-7dd40599191d
:END:

#+begin_src emacs-lisp
(defun void:symbol-intern (&rest args)
  "Return ARGS as a symbol."
  (declare (pure t) (side-effect-free t))
  (intern (apply #'void:make-string args)))
#+end_src

***** keyword intern
:PROPERTIES:
:ID: f2668044-13b2-46e7-bf84-fcf998591e37
:END:

#+begin_src emacs-lisp
(defun void:keyword-intern (&rest args)
  "Return ARGS as a keyword."
  (declare (pure t) (side-effect-free t))
  (apply #'void:symbol-intern ":" args))
#+end_src

***** keyword name
:PROPERTIES:
:ID: fb867938-d62b-42fc-bf07-092f10b64f22
:END:

#+begin_src emacs-lisp
(defun void:keyword-name (key)
  "Return the name of the key without the prepended :."
  (declare (pure t) (side-effect-free t))
  (substring-no-properties (void:make-string key) 1))
#+end_src

***** make string
:PROPERTIES:
:ID: 4ef52875-4ce6-4940-8b7e-13c96bedcb3d
:END:

#+begin_src emacs-lisp
(defun void:make-string (&rest args)
  "Return ARGS as a string."
  (declare (pure t) (side-effect-free t))
  (with-output-to-string
    (dolist (a args) (princ a))))
#+end_src

**** void specific funtions
:PROPERTIES:
:ID: 1b49e07a-466f-41da-8b31-18c28421cf62
:END:

***** all
:PROPERTIES:
:ID: e97267e8-fca8-4bf2-9899-7ec694e8a767
:END:

****** quit emacs without hook
:PROPERTIES:
:ID: b82f721c-39f5-4d41-bb0f-d4c391238eb4
:END:

Sometimes something goes wrong with [[helpvar:kill-emacs-hook][kill-emacs-hook]] and because of that I can't
close emacs. For that reason, I have this function.

#+begin_src emacs-lisp
(defun void/kill-emacs-no-hook ()
  "Kill emacs, ignoring `kill-emacs-hook'."
  (interactive)
  (when (yes-or-no-p "Quit without `kill-emacs-hook'?")
    (let (kill-emacs-hook) (kill-emacs))))
#+end_src

****** quit emacs brutally
:PROPERTIES:
:ID: 8753217c-4722-4183-bbb3-049707a37e54
:END:

I've never had to use this. But better be safe than sorry.

#+begin_src emacs-lisp
(defun void/kill-emacs-brutally ()
  "Tell an external process to kill emacs."
  (interactive)
  (when (yes-or-no-p "Do you want to BRUTALLY kill emacs?")
    (call-process "kill" nil nil nil "-9" (number-to-string (emacs-pid)))))
#+end_src

****** new emacs instance
:PROPERTIES:
:ID: eaf80ec3-2bd4-4f05-8a9c-fa525894a6fe
:END:

#+begin_src emacs-lisp
(defun void/open-emacs-instance ()
  "Open a new emacs instance in debug-mode."
  (interactive)
  (cond ((eq system-type 'darwin)
         (start-process-shell-command
          "emacs"
          nil "open -n /Applications/Emacs.app --args --debug-init"))
        ((eq system-type 'gnu/linux)
         (start-process "emacs" nil "emacs" "--debug-init"))))
#+end_src

****** kill all process of program
:PROPERTIES:
:ID: 913952e2-3727-4b38-aefc-4618c2771730
:END:

#+begin_src emacs-lisp
(defun void/kill-emacs-processes ()
  (interactive)
  (let ((count 1) (process "emacs"))
    (kill-process process)
    (while (ignore-errors (kill-process process))
      (setq process (format "emacs<%d>" count))
      (cl-incf count))
    (message "killed %d processes" count)))
#+end_src

****** qutebrowser
:PROPERTIES:
:ID: 77bace13-5af8-4974-981a-e07bf271182f
:END:

#+begin_src emacs-lisp
(defun void/open-qutebrowser ()
  "Open qutebrowser."
  (interactive)
  (start-process "qutebrowser" nil "qutebrowser"))
#+end_src

***** messages buffer
:PROPERTIES:
:ID: 7064ea0e-20e0-481c-9d07-18e4506ee3e8
:END:

In Emacs, messages. The messages buffer is where messages displayed at the bottom
of the Emacs frame are recorded after they expire.

#+begin_src emacs-lisp
(defun void/switch-to-messages ()
  (interactive)
  (select-window (display-buffer (get-buffer "*Messages*"))))
#+end_src

***** main org file
:PROPERTIES:
:ID: fb605553-f234-410a-b27e-697dc667831b
:END:

#+begin_src emacs-lisp
(defun void/switch-to-main-org-file ()
  (interactive)
  (find-file (concat VOID:EMACS-DIR "README.org")))
#+end_src

***** main todo file
:PROPERTIES:
:ID: 2accd21d-7316-4fa5-bd8f-8f40935ed621
:END:

#+begin_src emacs-lisp
(defun void/switch-to-todo-file ()
  (interactive)
  (switch-to-buffer (find-file VOID:TODO-FILE)))
#+end_src

***** turn on debug-mode
:PROPERTIES:
:ID: c1ac481a-6ebd-49ce-a930-3b0593283aee
:END:

#+begin_src emacs-lisp
(defun void/enable-debug-mode ()
  (interactive)
  (setq void:debug-p t))
#+end_src

***** switch to init file
:PROPERTIES:
:ID: 50c5e173-d737-4264-bac5-f13190d468dc
:END:

#+begin_src emacs-lisp
(defun void/switch-to-init-org-file ()
  "Switch to Void's init.el file."
  (interactive)
  (switch-to-buffer VOID:INIT-FILE))
#+end_src

***** quit emacs no prompt
:PROPERTIES:
:ID: d530718a-2b42-4e9b-8d7d-7813e0ae6381
:END:

#+begin_src emacs-lisp
(defun void/quit-emacs-no-prompt ()
  "Quit emacs without prompting."
  (interactive)
  (let (confirm-kill-emacs)
    (kill-emacs)))
#+end_src

** UI
:PROPERTIES:
:ID: c21a5946-38b1-40dd-b6c3-da41fb5c4a5c
:END:

*** maybe get rid of UI elements
:PROPERTIES:
:ID: 3f466dd8-13f1-4160-a2a5-da1acd4f3d3e
:END:

Emacs 27 and above allows the user to customize the UI in =early-init.el=. For
easy backwards usage previous version of emacs (25 and 26) I include.

#+begin_src emacs-lisp
(when (version< emacs-version "27")
  (ignore-errors
    (tool-bar-mode -1)
    (scroll-bar-mode -1)
    (menu-bar-mode -1)))
#+end_src

*** fullscreen
:PROPERTIES:
:ID: f0aad350-7da3-4350-8041-45bc5372ef7e
:END:

By default start emacs as fullscreen.

#+begin_src emacs-lisp
(add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src

*** hooks
:PROPERTIES:
:ID: ede94ae4-1c73-4435-81ba-e28070225b99
:END:

**** switching buffers
:PROPERTIES:
:ID: 55b1e136-2271-42e8-bad6-9c13fff33c31
:END:

***** switch buffer hook
:PROPERTIES:
:ID: 3be5191d-8525-4d03-90db-fc61c628ff57
:END:

#+begin_src emacs-lisp
(defvar void:after-switch-buffer-hook nil
  "A list of hooks run after changing the current buffer.")
#+end_src

***** inhibit switch buffer hook
:PROPERTIES:
:ID: d21029d7-31ca-49ff-b4c6-07e4a4678901
:END:

#+begin_src emacs-lisp
(defvar void:inhibit-switch-buffer-hooks nil
  "When non-nil, switch buffer hooks are inhibited.")
#+end_src

***** switching
:PROPERTIES:
:ID: ae5ad47f-9efe-4609-85fb-009d8685edc7
:END:

#+begin_src emacs-lisp
(defadvice! void:run-switch-buffer-hooks-a (orig-fn buffer-or-name &rest args)
  "Run `void:after-switch-buffer-hook'."
  :around (switch-to-buffer display-buffer)
  (let ((gc-cons-threshold most-positive-fixnum))
    (if (or void:inhibit-switch-buffer-hooks
            (eq (current-buffer) (get-buffer buffer-or-name))
            (and (eq orig-fn #'switch-to-buffer) (car args)))
        (apply orig-fn buffer-or-name args)
      (let ((void:inhibit-switch-buffer-hooks t))
        (when-let (buffer (apply orig-fn buffer-or-name args))
          (with-current-buffer (if (windowp buffer)
                                   (window-buffer buffer)
                                 buffer)
            (run-hooks 'void:after-switch-buffer-hook))
          buffer)))))
#+end_src

***** next previous
:PROPERTIES:
:ID: f69fe190-f134-46dc-baff-dcf42f1ab331
:END:

#+begin_src emacs-lisp
(defadvice! void:run-prev-or-next-buffer-hooks-a (orig-fn &rest args)
  :around (switch-to-next-buffer switch-to-previous-buffer)
  (let ((gc-cons-threshold most-positive-fixnum))
    (if void:inhibit-switch-buffer-hooks
        (apply orig-fn args)
      (let ((void:inhibit-switch-buffer-hooks t))
        (when-let (buffer (apply orig-fn args))
          (with-current-buffer buffer
            (run-hooks 'void:after-switch-buffer-hook)))))))
#+end_src

*** font
:PROPERTIES:
:ID: 893a1c9b-985b-4da8-9d9b-73028be5a2db
:END:

**** determine which font to use
:PROPERTIES:
:ID: 86cc1277-91ef-4a47-800b-8ec58cd8c6c6
:END:

I want Void to be flexible when choosing a font. I create a list of my preferred
fonts in =void:backup-fonts=. They are in order of most preferred to least
preferred. To compute the value of =void:font=, Void checks each of these fonts
in turn for the first available font. If none is availabe it just uses the
system font.

This process is time consuming (at least relative to the total emacs startup
time). But it benefits from byte-compilation.

#+begin_src emacs-lisp
(defvar void:backup-fonts
  '("Inconsolata-18" "Fira Code-18" "DejaVu Sans Mono-18"))

(defvar void:font "Courier 10 Pitch-18"
  "Default font for Void Emacs.
The font for Void is the first font in `void:backup-fonts' that's found in the
computer. If no font in `void:backup-fonts' is found then it uses the default
system font.")
#+end_src

**** specify =void:font= as default
:PROPERTIES:
:ID: 911e25ba-0893-487f-9f6b-8a574faf6f7d
:END:

The =default-frame-alist= is an alist of the default values for creating a
frame. So here I'm making the default font for all Emacs frames =void:font=.

#+begin_src emacs-lisp
(add-to-list 'default-frame-alist (cons 'font void:font))
#+end_src

**** catch undefined fonts
:PROPERTIES:
:ID: e7c8fa94-5efa-462e-9302-57a6935a1c89
:END:

#+begin_src emacs-lisp
(defadvice! void:frame-notice-user-settings-a (orig-fn &rest args)
  "Try `void:font' followed each of `void:backup-fonts' until success.
If none of the fonts work, just use the default system font."
  ;; :when (display-graphic-p)
  :around frame-notice-user-settings
  (condition-case nil
      (progn (apply orig-fn args)
             (void:log "Font is: %s" (face-attribute 'default :font)))
    (error
     (if void:backup-fonts
         (progn
           ;; (push (cons err nil) void:init-errors)
           (void:log "Setting %s failed. Trying %s..." void:font (car void:backup-fonts))
           (setq void:font (pop void:backup-fonts))
           (setq default-frame-alist
                 (--remove-first (eq (car it) 'font) default-frame-alist))
           (add-to-list 'default-frame-alist (cons 'font void:font))
           ;; I want to call the function with advice in it.
           (apply #'frame-notice-user-settings args))
       (setq void:font (face-attribute 'default :font))
       (void:log "None of the backup-fonts worked, defaulting to: %s"
                 void:font)
       (add-to-list 'default-frame-alist (cons 'font void:font))
       (apply #'frame-notice-user-settings args)))))
#+end_src

**** size
:PROPERTIES:
:ID: 4bf24b65-6f23-4e42-930e-4d43f766545c
:END:

Face attribute height is a magnitude of 10 greater than what we typically
use as font sizes (eg. font-size 14 corresponds to a face-height of 140).
I want to make sure I don't input 14 thinking about font size (it's
happened before and it's a huge pain resetting the font-size when the
font is super small). Therefore, I check the code.

#+begin_src emacs-lisp
(defun void/set-font-size ()
  "Set the font size interactively."
  (interactive)
  (let* ((old-font-size (face-attribute 'default :height))
         (prompt "The font size is %d. What do you want to change it to? ")
         (font-size (string-to-number (read-string (format prompt old-font-size))))
         (digits (+ 1 (floor (log font-size 10)))))

    ;; Make the font-size be 3 digits (Do what I mean not what I say).
    (when (< digits 3)
      (setq font-size (* font-size (expt 10 (- 3 digits)))))
    (when (> digits 3)
      (setq font-size (/ font-size (expt 10 (- digits 3)))))

    ;; If font size is still doesn't make sense, ask me to make sure it's what I want.
    (if (or (< font-size 280)
            (y-or-n-p
             (format "You're choosing a pretty large font size: %d. Is this what you intended?)"
                     font-size)))
        (progn
          (set-face-attribute 'default nil :height font-size)
          (message "Your Font Size was %s. Font size is now: %s"
                   old-font-size
                   font-size))
      (message "Font Size has been cancelled."))))
#+end_src

*** theme
:PROPERTIES:
:ID: 2ac7c2fe-a2ba-4e55-a467-ff4af8850331
:END:

**** theme to load
:PROPERTIES:
:ID: cd085611-9e56-4df4-97dd-f087899562c0
:END:

#+begin_src emacs-lisp
(defvar void:theme 'one-light
  "The theme to load on startup.
The value of this variable is updated to the current theme whenever `load-theme'
is called.")

(setq custom-safe-themes t)
#+end_src

**** initialize at startup
:PROPERTIES:
:ID: 06b1f381-9066-4062-88d5-f376ad5d6df0
:END:

#+begin_src emacs-lisp
(defhook! void:init-theme-h ()
  "Set the theme and load the font, in that order."
  :hook window-setup-hook
  (when (and void:theme (not (memq void:theme custom-enabled-themes)))
    (condition-case nil
        (load-theme void:theme t)
      (error (void:log "Could not load %s" void:theme)))))
#+end_src

**** loading theme
:PROPERTIES:
:ID: 7ae02d32-4652-494c-9e14-05f60ca60395
:END:

Sometimes there are things that need tidying up after loading a theme. For
example, if I'm using evil I need to update the cursor color.

#+begin_src emacs-lisp
(defvar void:after-load-theme-hook nil
  "Hook run after the theme is loaded with `load-theme'.")

(defadvice! void:run-after-load-theme-hook-a (theme &rest _)
  "Set up `void:load-theme-hook' to run after `load-theme' is called."
  :after load-theme
  (setq void:theme theme)
  (run-hooks 'void:after-load-theme-hook))
#+end_src

**** disable old themes first
:PROPERTIES:
:ID: 9d2f985b-8b0f-497f-982b-6f69c62179a9
:END:

Sometimes we end up with remants of the faces of old themes when we load a new
one. For this reason, I make sure to disable any enabled themes before applying
a new theme.

#+begin_src emacs-lisp
(defadvice! void:disable-old-themes-first-a (orig-fn &rest args)
  "Disable old themes before loading new ones."
  :around load-theme
  (mapc #'disable-theme custom-enabled-themes)
  (apply orig-fn args))
#+end_src

* Window Management
:PROPERTIES:
:ID: 29dbf899-17cd-4b00-aacb-090ccd20e133
:END:

Window management is one of the most important things to get right if you're
going to be efficient in emacs (that is unless you're using primarily frames
instead of windows).

** ace-window
:PROPERTIES:
:ID: b7cb25b4-ede8-4350-846c-d5c243a4a937
:END:

[[https://github.com/abo-abo/ace-window][ace-window]] uses avy to navigate windows in cases when there are many. There is
an alternative package for this, [[https://github.com/dimitri/switch-window][switch-window]]. The advantage of =switch-window=
is that the characters used for switching to a window are *really* easy to see,
but you can't see the buffer contents. That's a no-go for me I need to see them.

#+begin_src emacs-lisp
(use-package! ace-window
  :commands ace-window ace-swap-window
  :bind ([remap other-window] . ace-window)
  :setq
  (aw-keys . '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
  (aw-background . t))
#+end_src

** eyebrowse
:PROPERTIES:
:ID: 4ad6f8e6-0465-4d84-aa71-8848e69ccc5c
:END:

[[https://github.com/wasamasa/eyebrowse][eyebrowse]] is for managing workspaces. A workspace in Emacs a specific window
setup. It's for when you are doing some task let's say researching some
eyebrowse code and then you want to take a break and do something else but you
don't want to close all the nice windows you have up (and have to set them up
again later). You can create a new workspace with [[helpfn:eyebrowse-create-window-config][eyebrowse-create-window-config]]
and switch to it with [[helpfn:eyebrowse-next-window-config][eyebrowse-next-window-config]]. You can always go back to
your previous workspace now with [[helpfn:eyebrowse-prev-window-config][eyebrowse-prev-window-config]] or
[[helpfn:eyebrowse-switch-to-window-config][eyebrowse-switch-to-window-config]].

#+begin_src emacs-lisp
(use-package! eyebrowse
  :commands eyebrowse-create-window-config
  :setq (eyebrowse-wrap-around . t))
#+end_src

** window divider
:PROPERTIES:
:ID: 0bcebb71-f730-427f-9919-1538bd63456c
:END:

Emacs can add border to windows using a mode called [[helpfn:window-divider-mode][window-divider-mode]].
Often in emacs you have multiple windows displaying different buffers on the
screen. By default the border between these windows is very thin, so it can be
hard to distinguish windows sometimes. The point of adding borders to windows is
to distinguish them easily from one another.

*** window dividers
:PROPERTIES:
:ID: 849718ae-9d4a-43ab-b113-584aefa87c5b
:END:

Window dividers are useful in general so I don't get confused about when one
window ends and another begins (see [[helpfn:window-divider-mode][window-divider-mode]]). When using [[I like emacs][exwm]] it
makes emacs feel like a window manager with gaps.

#+begin_src emacs-lisp
(use-feature! frame
  :hook (window-setup-hook . window-divider-mode)
  :custom
  (window-divider-default-places       . t)
  (window-divider-default-bottom-width . 10)
  (window-divider-default-right-width  . 10)
  :config
  (set-face-foreground 'window-divider "black")
  (blink-cursor-mode -1))
#+end_src

*** update on theme change
:PROPERTIES:
:ID: 342bd557-889b-4dbd-8e76-5cd9da3b0f74
:END:

#+begin_src emacs-lisp
(defhook! frame:update-divider-h ()
  :hook void:after-load-theme-hook
  (unless (bound-and-true-p window-divider-mode)
    (window-divider-mode 1)))
#+end_src

*** adjust window divider gap size
:PROPERTIES:
:ID:       5485c926-fac0-4e87-ae97-f7bf25d0a55c
:END:

**** TODO increase gap size
:PROPERTIES:
:ID:       867fad5c-b4d4-4cba-929e-0dc23f007c5b
:END:

Somtimes I might want to adjust this.

#+begin_src emacs-lisp
(defun frame:adjust-window-divider-size (amount)
  "Adjust the gap size of window-divider by AMOUNT."
  (general-setq window-divider-default-bottom-width
                (+ amount window-divider-default-bottom-width))
  (general-setq window-divider-default-right-width
                (+ amount window-divider-default-right-width)))
#+end_src

**** increase
:PROPERTIES:
:ID:       ebd6b013-6213-42a1-9e95-fefc7e7da991
:END:

#+begin_src emacs-lisp
(defun frame/increment-window-divider-size ()
  "Increase window divider size."
  (interactive)
  (frame:adjust-window-divider-size 1))
#+end_src

**** decrease
:PROPERTIES:
:ID:       6b1eb1cd-1cfd-4b82-a413-cb61fa13e0a4
:END:

#+begin_src emacs-lisp
(defun frame/decrement-window-divider-size ()
  "Decrease window divider size."
  (interactive)
  (frame:adjust-window-divider-size -1))
#+end_src

** transpose-frame
:PROPERTIES:
:ID: 5487535d-2534-4857-b1e0-c63b40917710
:END:

https://www.emacswiki.org/emacs/TransposeFrame

#+begin_src emacs-lisp
(use-package! transpose-frame
  :commands (transpose-frame
             flip-frame
             flop-frame
             rotate-frame
             rotate-frame-clockwise))
#+end_src

** exwm
:PROPERTIES:
:ID: dbb69880-2180-4ecc-897d-78ff72a6358b
:END:

[[https://github.com/ch11ng/exwm][EXWM]] (Emacs X-Window Manager) is a full-featured window manager in Emacs.
There are benefits and drawbacks to making emacs your window manager. One
benefit is that you get a super consistent window management experience. If you
use a typical window manager, you have to.

*** exwm
:PROPERTIES:
:ID: 18ee4dd8-445b-4101-adfb-ba8e18a71bb4
:END:

In fact, EXWM does not need to be loaded on startup. It is only needed when you
actually want to open another application such as a separate Emacs instance or
the web browser. This is great because EXWM actually does consume significant
startup time. Instead of loading =EXWM= immediately, I add advises to the
functions which open external linux applications.

#+begin_src emacs-lisp
(use-package! exwm
  :hook (exwm-mode-hook . hide-mode-line-mode)
  :before-call (void/open-qutebrowser counsel-linux-app void/open-emacs-instance)
  :setq (exwm-replace . nil)
  :defer-config
  (exwm-init)
  ;; Enable the clipboard.
  (require 'exwm-systemtray)
  (exwm-systemtray-enable))

(defhook! exwm:setup-hide-mode-line-h ()
  :hook exwm-mode-hook
  (add-hook 'exwm-floating-setup-hook #'exwm-layout-hide-mode-line)
  (add-hook 'exwm-floating-exit-hook #'exwm-layout-show-mode-line))
#+end_src

*** appropriate name for exwm buffers
:PROPERTIES:
:ID: b9712cdc-2cf9-482f-8f62-b2e4f56b9c97
:END:

#+begin_src emacs-lisp
(defhook! exwm:rename-buffer-to-title-h ()
  "Rename buffer to title."
  :hook exwm-update-title-hook
  (exwm-workspace-rename-buffer exwm-title))
#+end_src

*** to start in char mode
:PROPERTIES:
:ID: 790c7f6e-6f66-4074-b51a-56b491bcde99
:END:

=EXWM= has two modes, =line-mode= and =char-mode=. It's best for Emacs and Next to
start with =char-mode= because they both have keys that are important for their
use (like =M-x=) which conflict with Emacs (the instance that's managing the
windows).

#+begin_src emacs-lisp
(defhook! exwm:start-in-char-mode-h ()
  "Decide whether to start program in char mode."
  :hook exwm-manage-finish-hook
  (when (seq-some-p (-rpartial #'string-prefix-p exwm-instance-name)
                    (list "emacs"))
    (exwm-input-release-keyboard (exwm--buffer->id (window-buffer)))))
#+end_src

*** keybindings
:PROPERTIES:
:ID: 293bc7c5-1320-4f3f-af2b-198d56694f71
:END:

#+begin_src emacs-lisp
(after! exwm
  (funcall (get 'exwm-input-global-keys 'custom-set)
           'exwm-input-global-keys
           `((,(kbd "s-R") . exwm-reset)
             (,(kbd "s-x") . exwm-input-toggle-keyboard)
             (,(kbd "s-h") . windmove-left)
             (,(kbd "s-j") . windmove-down)
             (,(kbd "s-k") . windmove-up)
             (,(kbd "s-l") . windmove-right)
             (,(kbd "s-t") . transpose-frame)
             (,(kbd "s-D") . kill-this-buffer)
             (,(kbd "s-b") . switch-to-buffer)
             (,(kbd "s-f") . find-file)
             (,(kbd "s-O") . exwm-layout-toggle-fullscreen)
             (,(kbd "s-p") . previous-buffer)
             (,(kbd "s-n") . next-buffer)
             (,(kbd "s-q") . void/open-qutebrowser)
             (,(kbd "s-e") . void/open-emacs-instance))))

(general-def
  "s-R" #'exwm-reset
  "s-x" #'exwm-input-toggle-keyboard
  "s-h" #'windmove-left
  "s-j" #'windmove-down
  "s-k" #'windmove-up
  "s-l" #'windmove-right
  "s-t" #'transpose-frame
  "s-D" #'kill-this-buffer
  "s-b" #'switch-to-buffer
  "s-f" #'find-file
  "s-O" #'exwm-layout-toggle-fullscreen
  "s-p" #'previous-buffer
  "s-n" #'next-buffer
  "s-q" #'void/open-qutebrowser
  "s-e" #'void/open-emacs-instance)
#+end_src

*** exwm-edit
:PROPERTIES:
:ID: 1a167827-b791-4a69-a90e-c2d30bd83abb
:END:

The dream is to do all text editing in Emacs. This package is a big step towards
achieving that dream. =exwm-edit= allows the user to edit text fields in
external packages with an emacs buffer. It acts a lot like =org-edit-src-code=:
it copies any text in the text field to a buffer, you edit the buffer, then
press a binding to insert the buffer text into the text field. It goes without
saying that when the text is in an emacs buffer, you can use the full-force of
Emacs's text editing capabilities on it.

#+begin_src emacs-lisp
(use-package! exwm-edit :after exwm)
#+end_src

*** exwm firefox
:PROPERTIES:
:ID:       a78eec54-687f-4a40-8c68-db096112ef52
:END:

#+begin_src emacs-lisp
(use-package! exwm-firefox-evil
  :disabled t
  :after exwm
  :hook (exwm-manage-finish-hook . exwm-firefox-evil-activate-if-firefox)
  :config
  (dolist (k `(escape))
    (cl-pushnew k exwm-input-prefix-keys)))
#+end_src

** buffer expose
:PROPERTIES:
:ID: df46e75c-0613-41e4-a4e4-a477f112adcb
:END:

#+begin_src emacs-lisp
(use-package! buffer-expose
  :commands (buffer-expose
             buffer-expose-no-stars
             buffer-expose-major-mode
             buffer-expose-dired-buffers
             buffer-expose-stars
             buffer-expose-current-mode)
  :setq
  (buffer-expose-show-current-buffer . t)
  (buffer-expose-rescale-factor      . 0.5)
  (buffer-expose-highlight-selected  . nil)
  (buffer-expose-max-num-windows     . 8)
  (buffer-expose-auto-init-aw        . t)
  (buffer-expose-hide-modelines      . nil)
  (buffer-expose-key-hint            . "")
  :bind
  (:buffer-expose-grid-map
   ("l" . buffer-expose-next-window)
   ("h" . buffer-expose-prev-window)
   ("L" . buffer-expose-next-page)
   ("H" . buffer-expose-prev-page)
   ("j" . buffer-expose-down-window)
   ("k" . buffer-expose-up-window)))
#+end_src

* Completion
:PROPERTIES:
:ID: 056384d1-a95a-4dcb-bc9d-ffe95bbb52a8
:END:

Completion has certainly become an integral part of any efficient workflow. One
commonality among things like searching emails, code-completing a word, surfing
the web is that in one way or another all of these things involve the suggestion
of likely candidates from a population that is too time consuming to look
through on our own. It's not much different in Emacs. We're constantly sifting
though files, buffers, commands, words--all to try to get through to the subset
of things that we actually want at this moment.

** snippets                                                           :disabled:
:PROPERTIES:
:ID:       02dd54d0-f545-447e-89cf-c0cfcd941c76
:END:

*** defsnippet
:PROPERTIES:
:ID:       bfaa2631-a300-4f38-b31d-ec7457b18491
:END:

I find it painful to write and edit long one-liner snippets with lots of inner
elisp code. Additionally, I dislike having many different files for snippets. To
me it's a potential source of errors and it makes it so I have to go looking for
a snippet whenever I want to edit it.

These grievances have inspired me to write an API for writing snippet templates
in a declarative syntax as opposed to via a snippet file.

**** defsnippet

This is the user-facing function to define yasnippets.

#+begin_src emacs-lisp
(defun defsnippet:new-snippet (&rest plist)
  "Define a snippet."
  (let* ((keys '(:key :name :contributor :group :expand-env :binding :type :uuid)))
    (with-plist! plist
      (cl-assert (seq-every-p (-not #'null) (list <:name> <:mode> <:body>)))
      (alet (append
             (list "# -*- mode: snippet -*-\n")
             (seq-map (lambda (key)
                        (format "# %s: %s\n" (void:keyword-name key) (plist-get plist key)))
                      (seq-filter (-partial #'plist-get plist) keys))
             (list "# --\n")
             (list (defsnippet:compute-body <:body> <:placeholders>)))
        (with-temp-buffer
          (insert (s-join "\n" it))
          (yas-load-snippet-buffer <:mode> t))))))
#+end_src

**** compute body
:PROPERTIES:
:ID:       e6bbca2d-ee83-4cab-b115-9098bb0962c6
:END:

#+begin_src emacs-lisp
(defun defsnippet:compute-body (body placeholders)
  "Return the result of PLACEHOLDERS applied to BODY."
  (alet (seq-map (-lambda ((number name form))
                   (if (eq '_  name)
                       (format "${%d:$$%S}" number form)
                     (format "${%d:%s$%S}" number name form)))
                 placeholders)
    (apply #'format body it)))
#+end_src

**** list symbols
:PROPERTIES:
:ID:       56de420c-0cb7-47fb-ad34-c562047cd4fd
:END:

#+begin_src emacs-lisp
(defun defsnippet:list-symbols (&optional pred)
  "List interned symbols."
  (setq pred (or pred #'identity))
  (let (acc)
    (mapatoms (lambda (it)
                (when (and (symbolp it)
                           (not (eq 'nil it))
                           (funcall pred it))
                  (push it acc))))
    (nreverse acc)))
#+end_src

**** defsnippet!
:PROPERTIES:
:ID:       36e73e8a-86bb-4ab0-adc6-e6ff3e263237
:END:

This macro helps me define snippets declaratively without worrying about whether
yasnippet is loaded or not.

#+begin_src emacs-lisp
(defmacro defsnippet! (snippet &rest properties)
  "Syntactic sugar for defining a snippet on time."
  (declare (indent defun))
  `(after! yasnippet
     (defsnippet:new-snippet
       :name ,(void:make-string snippet)
       ,@properties)))
#+end_src

**** snippets
:PROPERTIES:
:ID:       a2fd6032-4c48-43c6-9afa-350dc74f47ac
:END:

It's really nice being able to re-evaluate a snippet with an elisp form as
opposed to going to the snippet buffer, editing it and reloading it.

***** org links
:PROPERTIES:
:ID:       df615fc9-cfac-4bed-b8ef-c5fcf57dffca
:END:

****** helpfn
:PROPERTIES:
:ID:       ca5d380a-05a9-4d74-8440-8e972d86661c
:END:

For extremely good documentation.

#+begin_src emacs-lisp
(defsnippet! help-function
  :key "hfn"
  :mode 'org-mode
  :body "[[helpfn:%s][$1]%s"
  :placeholders '((1 function (yas-auto-next (yas-choose-value (defsnippet:list-symbols))))
                  (0 _ (insert "]"))))
#+end_src

****** helpvar
:PROPERTIES:
:ID:       c1b65fb3-1d6f-4ec4-81b2-23d92e713332
:END:

#+begin_src emacs-lisp
(defsnippet! help-variable
  :mode 'org-mode
  :key "hvar"
  :body "[[helpvar:$1][%s]%s"
  :placeholders '((1 variable (thread-last (defsnippet:list-symbols #'helpful--variable-p)
                               (yas-choose-value)
                               (yas-auto-next)))
                  (0 _ (insert "]"))))
#+end_src

****** id
:PROPERTIES:
:ID:       84b143bb-cd83-4dd4-b0e1-264b7e2d4aaa
:END:

#+begin_src emacs-lisp
(defsnippet! org-id
  :name "id"
  :mode 'org-mode
  :key "oid"
  :body "[[id:%s][#%s]$0"
  :placeholders '((1 _ (thread-last (hash-table-keys org-id-locations)
                        (yas-choose-value)
                        (yas-auto-next)))
                  (2 _ (substring (yas-field-value 1) 0 5))
                  (0 _ (insert "]"))))
#+end_src

***** elisp
:PROPERTIES:
:ID:       996f1990-991a-4cce-bfc9-629e52286ad6
:END:

****** defun
:PROPERTIES:
:ID:       ae185254-d541-42a8-acc9-c2907236a945
:END:

#+begin_src emacs-lisp
(defsnippet! defun
  :mode 'emacs-lisp-mode
  :key "dfn"
  :body "(defun %s (%s)\n  \"%s\"\n  %s)"
  :placeholders '((1 name)
                  (2 args)
                  (3 docstring (-> (rx-to-string `(or ,@(s-split "\s" (yas-field-value 2) t)))
                                (replace-regexp-in-string #'upcase yas-text)
                                (ignore-errors)))
                  (4 body)))
#+end_src

*** yasnippet
:PROPERTIES:
:ID: 1f362298-2b47-4929-9484-ce7f26f80adf
:END:

[[https://github.com/joaotavora/yasnippet][yasnippet]] is a template completion package. You can define templates which can
be inserted and interactively completed.

#+begin_src emacs-lisp
(use-package! yasnippet
  :hook (prog-mode-hook . yas-minor-mode-on)
  :setq
  (yas-snippet-dir . (concat VOID:DATA-DIR "snippets/"))
  (yas-verbosity . (if void:debug-p 3 0))
  (yas-indent-line . 'auto)
  (yas-prompt-functions . '(yas-completing-prompt yas-ido-prompt))
  (yas-use-menu . nil)
  (yas-triggers-in-field . t)
  :defer-config
  (unless (file-exists-p yasnippet:dir) (mkdir yasnippet:dir))
  (delq #'yas-dropdown-prompt yas-prompt-functions)
  (after! smartparens
    ;; tell smartparens overlays not to interfere with yasnippet keybinds
    (advice-add #'yas-expand :before #'sp-remove-active-pair-overlay)))
#+end_src

*** snippet collection
:PROPERTIES:
:ID:       ceb066ac-2242-492d-9609-9e3b879b10b7
:END:

#+begin_src emacs-lisp
(use-package! yasnippet-snippets)
#+end_src

** frameworks
:PROPERTIES:
:ID: 9784c474-56ee-4d76-bbd0-3f611fc001ee
:END:

*** helm                                                              :disabled:
:PROPERTIES:
:ID: 19772582-4016-4e6b-8d70-7f608d50fc37
:END:

Helm is the most popular emacs completion framework. It is full-featured and
extremely customizable. I haven't found an official manual for it but I often
see people reference [[http://tuhdo.github.io/helm-intro.html][this helm intro]] that showcase many useful helm commands. A huge
advantage helm has is the breath of its support. The biggest complaint heard
about Helm is that it's too bloated and slow.

**** helm-core
:PROPERTIES:
:ID: 17c16fa7-9612-43dc-b1bb-c2a7f4e3ab79
:END:

#+begin_src emacs-lisp
(use-package! helm
  :commands helm-M-x
  :popup
  ("\\*Helm"
   (display-buffer-at-bottom)
   (side . bottom)
   (slot . 1)
   (window-height . 0.5)
   (window-parameters . ((no-other-window . t))))
  :pre-setq
  (helm-default-display-buffer-functions . '(pop-to-buffer))
  (helm-display-buffer-height . .6)
  (helm-display-buffer-default-height . 0.6)
  (helm-candidate-number-limit . 50)
  (helm-display-header-line . nil)
  (helm-mode-line-string . nil)
  :config
  (helm-mode 1))

(use-package! helm-files
  :setq
  (helm-ff-auto-update-initial-value . nil)
  (helm-ff-lynx-style-map . nil)
  (helm-find-files-doc-header . nil))
#+end_src

**** helm-mode
:PROPERTIES:
:ID: e505c504-63ac-404a-93ae-6c32f599e22e
:END:

#+begin_src emacs-lisp
(use-package! helm-files
  ;; (:after-hook pre-command-hook)
  :bind
  ([remap apropos]                  . helm-apropos)
  ([remap find-library]             . helm-locate-library)
  ([remap execute-extended-command] . helm-M-x)
  ([remap find-file]                . helm-find-files)
  ([remap locate]                   . helm-locate)
  ([remap imenu]                    . helm-semantic-or-imenu)
  ([remap noop-show-kill-ring]      . helm-show-kill-ring)
  ([remap recentf]                  . helm-recentf)
  ([remap switch-to-buffer]         . helm-mini))
#+end_src

**** helm swoop
:PROPERTIES:
:ID: 9d9f4072-b75e-41d0-9a48-961a3a8cd85a
:END:

[[https://github.com/emacsorphanage/helm-swoop][helm-swoop]] is an helm version of swiper. It gives me an overview of searches.

#+begin_src emacs-lisp
(use-package! helm-swoop
  :commands helm-swoop
  :setq
  (helm-swoop-pre-input-function   . (lambda () ""))
  (helm-swoop-use-line-number-face . nil)
  (helm-swoop-move-to-line-cycle   . t)
  (helm-swoop-speed-or-color       . nil)
  (helm-swoop-use-fuzzy-match      . t))
#+end_src

**** helm descbinds
:PROPERTIES:
:ID: b30b7467-1715-4040-ba2a-78cbb5a9d0a7
:END:

#+begin_src emacs-lisp
(use-package! helm-descbinds
  :hook (helm-mode-hook . helm-descbinds-mode))
#+end_src

**** helm-mode-map
:PROPERTIES:
:ID: 94edac5d-d40e-447f-a347-51b0d4d63331
:END:

#+begin_src emacs-lisp
(after! (helm evil)
  (general-def '(emacs insert) helm-map
    "C-m" #'helm-toggle-visible-mark-forward
    "M-m" #'helm-toggle-visible-mark-forward
    "C-j" #'helm-next-line
    "C-k" #'helm-previous-line
    "C-n" #'helm-next-page
    "C-a" #'helm-select-action
    "TAB" #'helm-next-line
    "C-l" #'helm-execute-persistent-action
    [backtab] #'helm-previous-line
    "<RET>" #'helm-maybe-exit-minibuffer))
#+end_src

**** helm-system-packages
:PROPERTIES:
:ID: 832ad8ea-df31-45c4-a0b2-b8cdff00a23d
:END:

[[https://github.com/emacs-helm/helm-system-packages][helm-system-packages]] incorporates helm with your operating system's package manager.

#+begin_src emacs-lisp
(use-package! helm-system-packages
  :commands helm-system-packages)
#+end_src

**** helm-exwm                                                        :disabled:
:PROPERTIES:
:ID: 4c3a384d-846b-41dd-9878-dc739f97ccd7
:END:

#+begin_src emacs-lisp
(use-package! helm-exwm)
#+end_src

**** hide helm modeline
:PROPERTIES:
:ID: c82ddad1-a41c-48ec-aa84-d916cdeed66f
:END:

#+begin_src emacs-lisp
(after! helm
  (defun helm--hide:mode-line (&rest _)
    (with-current-buffer (helm-buffer-get)
      (unless helm-mode-line-string
        (hide-mode-line-mode +1))))
  (add-hook 'helm-after-initialize-hook #'helm--hide:mode-line)
  (advice-add #'helm-display-mode-line :override #'helm--hide:mode-line))
#+end_src

**** helm-dash
:PROPERTIES:
:ID: de4aa3ef-c0b8-40e6-b8b4-f9cf148bc41b
:END:

#+begin_src emacs-lisp
(use-package! helm-dash
  :commands helm-dash
  :setq
  (helm-dash-docsets-path . (concat VOID:DATA-DIR "/dash-docsets"))
  (helm-dash-browser-func . (if (executable-find "w3m") #'w3m #'browse-url)))
#+end_src

**** helm-org
:PROPERTIES:
:ID:       1e19a081-d107-4593-8af4-e72c84bbaeff
:END:

***** org capture
:PROPERTIES:
:ID:       a11e2fe3-8596-4a15-bed7-08a988c561a0
:END:

[[https://github.com/emacs-helm/helm-org][helm-org]] doesn't have everything I need for org mode--or rather what it
does have isn't good enough.

#+begin_src emacs-lisp
(after! helm
  (defun helm:org-capture-candidates ()
    "Return an alist."
    (let* ((alist (thread-first (org-capture-upgrade-templates org-capture-templates)
                    (org-contextualize-keys it org-capture-templates-contexts)
                    (seq-map (-lambda ((name key)) (cons key name)) it)))
           (keys (seq-map #'cdr alist)))
      (seq-remove (-lambda ((elt &as _ . key))
                    (seq-every-p (lambda (it) (not (string-prefix-p key it)))
                                 (-remove-item key keys)))
                  alist)))
  (setq helm:org-capture-source
        (helm-build-sync-source "helm/org-capture"
                                :candidates #'helm:org-capture-candidates
                                :action (helm-make-actions "Capture" (lambda (keys) (org-capture nil keys)))))

  (defun helm/org-capture ()
    "Select a capture template."
    (interactive)
    (helm :sources helm:org-capture-source :prompt "capture: "))

  (general-def [remap org-capture] #'helm/org-capture))
#+end_src

***** helm-org
:PROPERTIES:
:ID: c73e9389-5dee-425f-b54f-0f23cf2bd91a
:END:

#+begin_src emacs-lisp
(use-package! helm-org)
#+end_src

**** helm pass
:PROPERTIES:
:ID: 22516c69-0339-42be-962f-fc4433933665
:END:

#+begin_src emacs-lisp
(use-package! helm-pass :commands helm-pass)
#+end_src

**** ace-helm-jump-line
:PROPERTIES:
:ID: a0032cc5-d211-48ee-8f30-7538306122dd
:END:

[[https://github.com/cute-jumper/ace-jump-helm-line/issues][ace-jump-helm-line]] allows me to jump to helm candidates using [[https://github.com/abo-abo/avy][avy]].

#+begin_src emacs-lisp
(use-package! ace-jump-helm-line
  :bind (:helm-map ("C-'" . ace-jump-helm-line))
  :setq
  (ace-jump-helm-line-idle-delay     . 0)
  (ace-jump-helm-line-default-action . 'select)
  (ace-jump-helm-line-style          . 'pre)
  (ace-jump-helm-line-select-key     . ?e)
  (ace-jump-helm-line-move-only-key  . ?o)
  (ace-jump-helm-line-persistent-key . ?p))
#+end_src

*** ivy
:PROPERTIES:
:ID: cf88854e-4f88-4f64-962d-5d0ff99cd94f
:END:

Ivy is considered to be the main alternative to helm. It's main advantage is
that it is faster than helm in many cases. I haven't done benchmarking but even
when eyeballing candidate completion between [[helpfn:counsel-M-x][counsel-M-x]] and [[helpfn:helm-M-x][helm-M-x]],
=counsel-M-x= is noticeably (albeit slightly) faster. Ivy strives to be more
minimal and more predictable than helm.

**** ivy
:PROPERTIES:
:ID: 4bf12e8b-7f71-45cc-bf48-c1aec795c9fe
:END:

[[github:abo-abo/swiper][ivy]] provides a user interface for choosing from a list of options by typing a
query to narrow the list, and then selecting one of the remaining candidates.

#+begin_src emacs-lisp
(use-package! ivy
  :hook emacs-startup-hook
  :custom
  (ivy-initial-inputs-alist     . nil)
  :bind
  ([switch-to-buffer] . ivy-switch-buffer)
  :setq
  (ivy-height . 18)
  (ivy-wrap                     . t)
  (ivy-fixed-height-minibuffer  . t)
  (ivy-use-selectable-prompt    . t)
  (ivy-use-virtual-buffers      . t)
  (ivy-virtual-abbreviate       . 'full)
  (ivy-on-delete-error-function . nil)
  (ivy-use-selectable-prompt    . t)
  (ivy-count-format             . ""))
#+end_src

**** ivy-avy
:PROPERTIES:
:ID:       ae043d9b-e057-4f3e-b0d7-a96624b307d4
:END:

#+begin_src emacs-lisp
(use-package! ivy-avy
  :ensure nil
  :commands ivy-avy)
#+end_src

**** ivy prescient
:PROPERTIES:
:ID: ec8cd466-c6cf-4b25-9624-07e9d0e0fd0c
:END:

[[https://github.com/raxod502/prescient.el][ivy-prescient]] keeps track of recently selected ivy candidates in the
[[helpvar:prescient-save-file][prescient-save-file]] and makes sure that these recent items are added to the top
of the next ivy selection. Most of us only use a subset of commands. A recent
command is likely to be.

#+begin_src emacs-lisp
(use-package! ivy-prescient
  :hook ivy-mode-hook
  :hook (ivy-prescient-mode . prescient-persist-mode)
  :setq
  (prescient-filter-method . '(literal regexp initialism fuzzy))
  (prescient-save-file . (concat VOID:DATA-DIR "prescient-save.el"))
  (ivy-prescient-sort-commands . '(:not swiper swiper-isearch ivy-switch-buffer counsel-grep
                                   counsel-git-grep counsel-ag counsel-rg counsel-imenu
                                   counsel-yank-pop counsel-recentf counsel-buffer-or-recentf))
  (ivy-prescient-retain-classic-highlighting . t)
  :defer-config
  (prescient-persist-mode 1))
#+end_src

**** amx
:PROPERTIES:
:ID:       ae950812-773f-4f54-a1f5-d6777864adcf
:END:

#+begin_src emacs-lisp
(use-package! amx
  :hook ivy-mode-hook
  :pre-setq (amx-save-file . (concat VOID:DATA-DIR "amx-save-file")))
#+end_src

**** counsel
:PROPERTIES:
:ID: f1f77877-1cbc-40c4-b62c-4239a0c338e6
:END:

=ivy= is designed to be pretty minimal. [[https://github.com/abo-abo/swiper][counsel]] is a library that replaces a lot
of stock emacs functions with a version that using =ivy= for completion.

#+begin_src emacs-lisp
(use-package! counsel
  :hook ivy-mode-hook
  :commands counsel-org-goto
  :bind
  ([remap load-theme]               . counsel-load-theme)
  ([remap apropos]                  . counsel-apropos)
  ([remap bookmark-jump]            . counsel-bookmark)
  ([remap describe-bindings]        . counsel-descbinds)
  ([remap info-lookup-symbol]       . counsel-info-lookup-symbol)
  ([remap org-set-tags-command]     . counsel-org-tag)
  ([remap unicode-chars-list-chars] . counsel-unicode-char)
  ([remap locate]                   . counsel-locate)
  ([remap describe-face]            . counsel-describe-face)
  ([remap describe-function]        . counsel-describe-function)
  ([remap describe-variable]        . counsel-describe-variable)
  ([remap execute-extended-command] . counsel-M-x)
  ([remap find-file]                . counsel-find-file)
  ([remap find-library]             . counsel-find-library)
  ([remap info-lookup-symbol]       . counsel-info-lookup-symbol)
  ([remap imenu]                    . counsel-imenu)
  ([remap recentf-open-files]       . counsel-recentf)
  ([remap org-capture]              . counsel-org-capture)
  ([remap swiper]                   . counsel-grep-or-swiper)
  ([remap evil-ex-registers]        . counsel-evil-registers)
  ([remap yank-pop]                 . counsel-yank-pop)
  :setq
  (counsel-find-file-ignore-regexp . "\\(?:^[#.]\\)\\|\\(?:[#~]$\\)\\|\\(?:^Icon?\\)")
  (counsel-describe-function-function . #'helpful-callable)
  (counsel-describe-variable-function . #'helpful-variable)
  ;; Add smart-casing and compressed archive searching (-zS) to default
  ;; command arguments:
  (counsel-rg-base-command . "rg -zS --no-heading --line-number --color never %s .")
  (counsel-ag-base-command . "ag -zS --nocolor --nogroup %s")
  (counsel-pt-base-command . "pt -zS --nocolor --nogroup -e %s"))
#+end_src

**** swiper
:PROPERTIES:
:ID: 732421fb-2eb6-4701-be12-d4b03c726df8
:END:

[[https://github.com/abo-abo/swiper][Swiper]] is a package that interactively search items.

#+begin_src emacs-lisp
(use-package! swiper
  :commands swiper swiper-isearch)
#+end_src

**** minibuffer bindings
:PROPERTIES:
:ID:       5a21af24-4383-40dc-8c53-562f2cf68961
:END:

These bindings are partly influenced by helm. I strongly prefer the names helm
chose for their minibuffer commands. Things like "persistent" action make much
more sense to me than this "dispatching" and "immediate" "done" stuff.

#+begin_src emacs-lisp
(general-def '(emacs insert) ivy-minibuffer-map
  "C-k"     #'ivy-previous-line
  "C-j"     #'ivy-next-line
  [backtab] #'ivy-previous-line
  "TAB"     #'ivy-next-line
  "C-SPC"   #'ivy/toggle-mark
  "C-m"     #'ivy/toggle-mark
  "C-a"     #'ivy-dispatching-done
  "C-n"     #'ivy-toggle-marks
  "C-l"     #'ivy-next-line-and-call
  "C-o"     #'ivy-occur
  "C-'"     #'ivy-avy
  "RET"     #'ivy-done)
#+end_src

**** toggle mark
:PROPERTIES:
:ID: 2414a29d-e874-4174-8f90-b9d80c001026
:END:

#+begin_src emacs-lisp
(defun ivy/toggle-mark ()
  "Toggle mark."
  (interactive)
  (if (ivy--marked-p) (ivy-unmark) (ivy-mark)))
#+end_src

**** ivy rich                                                         :disabled:
:PROPERTIES:
:ID: 83df9e3a-d384-4b59-b3f2-7d57ee46b25e
:END:

[[https://github.com/Yevgnen/ivy-rich][ivy-rich]] provides an easy way (the plist [[helpvar:ivy-rich-display-transformers-list][ivy-rich-display-transformers-list]]) to
provide a more informative interface to ivy commands.

***** ivy rich
:PROPERTIES:
:ID: 4b4cd57a-2812-4f47-91a8-4c1be0934f27
:END:

#+begin_src emacs-lisp
(use-package! ivy-rich
  :after ivy
  :setq
  (ivy-rich-display-transformers-list . nil)
  (ivy-rich-parse-remote-buffer . nil)
  :init
  (ivy-rich-mode)
  (setcdr (assq t ivy-format-functions-alist) #'ivy-format-function-line))

(use-package! all-the-icons-ivy
  :after ivy-rich
  :require t)
#+end_src

***** icons
:PROPERTIES:
:ID: 07d448d4-73ac-4222-a13c-d9ea9e937103
:END:

#+begin_src emacs-lisp
(defun ivy:rich-switch-buffer-icon (candidate)
  "Testing icons in switch to buffer from Yevgnen/ivy-rich."
  (with-current-buffer (get-buffer candidate)
    (let ((icon (all-the-icons-icon-for-mode major-mode)))
      (if (symbolp icon)
          (all-the-icons-icon-for-mode 'fundamental-mode)
        icon))))
#+end_src

***** M-x
:PROPERTIES:
:ID: bcc47223-f662-4820-9031-d2ef38312021
:END:

#+begin_src emacs-lisp
(after! ivy-rich
  (nconc! ivy-rich-display-transformers-list
    '(counsel-M-x
      (:columns
       ((counsel-M-x-transformer (:width 40))
        (ivy-rich-counsel-function-docstring (:face font-lock-doc-face)))))))
#+end_src

***** ivy-switch-buffer
:PROPERTIES:
:ID: 1fdb0710-efe6-4d23-9c79-16db51fb3e2c
:END:

#+begin_src emacs-lisp
(after! ivy-rich
  (nconc! ivy-rich-display-transformers-list
    '(ivy-switch-buffer
      (:columns
       ((ivy:rich-switch-buffer-icon :width 2)
        (ivy-rich-candidate (:width 30))
        (ivy-rich-switch-buffer-size (:width 7))
        (ivy-rich-switch-buffer-indicators (:width 4 :face error :align right))
        (ivy-rich-switch-buffer-major-mode (:width 12 :face warning))
        (ivy-rich-switch-buffer-project (:width 15 :face success))
        (ivy-rich-switch-buffer-path (:width (lambda (x) (ivy-rich-switch-buffer-shorten-path x (ivy-rich-minibuffer-width 0.3))))))
       :predicate
       (lambda (cand) (get-buffer cand))))))
#+end_src

***** helpful callable
:PROPERTIES:
:ID: d89f7c98-aae3-4b07-b8be-3bd63aa41779
:END:

#+begin_src emacs-lisp
(after! ivy-rich
  (nconc! ivy-rich-display-transformers-list
    '(helpful-callable
      (:columns
       ((counsel-describe-function-transformer (:width 40))
        (ivy-rich-counsel-function-docstring (:face font-lock-doc-face)))))))
#+end_src

***** helpful variable
:PROPERTIES:
:ID: 6dce36ab-3f83-4530-918f-d698f79adf8f
:END:

#+begin_src emacs-lisp
(after! ivy-rich
  (nconc! ivy-rich-display-transformers-list
    '(helpful-variable
      (:columns
       ((counsel-describe-variable-transformer (:width 40))
        (ivy-rich-counsel-variable-docstring (:face font-lock-doc-face)))))))
#+end_src

**** customizing specific functions
:PROPERTIES:
:ID:       ee303d38-fb3a-4b31-a226-4c8e04a63d1a
:END:

***** no sort
:PROPERTIES:
:ID:       3c1f1892-d9cb-4767-82a5-aa157de739de
:END:

#+begin_src emacs-lisp
(after! ivy (push '(counsel-org-goto . nil) ivy-sort-functions-alist))
#+end_src

***** make the default action setting the font
:PROPERTIES:
:ID:       17f2d06a-835c-4bba-960b-d0f8c028a91a
:END:

#+begin_src emacs-lisp
(after! ivy
  (ivy-set-actions #'counsel-fonts (list (list "o" #'void:set-font "set font")))
  (defun void:set-font (font)
    (set-face-attribute 'default nil :font font)))
#+end_src

***** don't include binding information
:PROPERTIES:
:ID:       50e3991d-8c46-4dcb-86d9-79c2bede4e50
:END:

#+begin_src emacs-lisp
(advice-add #'counsel-M-x-transformer :override #'identity)
#+end_src

*** selectrum                                                         :disabled:
:PROPERTIES:
:ID: abfc6965-d021-4d71-9cf4-42f8fd1de0e8
:END:

Selectrum is a new (as of time of writing) and budding completing-framework. It
strives to be less buggy and have cleaner, less hacky code than either Helm or
Ivy even if this comes at the expense of less features (such as multiple
completion and/or multiple actions). It seeks to reuse the Emacs's existing
completing-read framework as opposed to creating it's own function for any
existing completing-read-using commands.

**** selectrum
:PROPERTIES:
:ID: 13ff73f6-a491-44ab-9295-9613843afe9f
:END:

#+begin_src emacs-lisp
(use-package! selectrum
  :hook emacs-startup-hook
  :setq
  (selectrum-count-style              . nil)
  (selectrum-show-indices             . nil)
  (selectrum-fix-minibuffer-height    . t)
  (selectrum-num-candidates-displayed . 15)
  :bind
  ([remap swiper] . selectrum/swiper)
  ([remap switch-to-buffer] . selectrum/buffer-or-recentf)
  ([remap org-set-tags-command] . selectrum/org-set-tags)
  :config
  (append! selectrum-minibuffer-bindings
    '(([tab]     . selectrum-next-candidate)
      ([backtab] . selectrum-previous-candidate)
      ("C-SPC"   . selectrum-insert-current-candidate)
      ("C-j"     . selectrum-next-candidate)
      ("C-k"     . selectrum-previous-candidate))))
#+end_src

**** selectrum prescient
:PROPERTIES:
:ID: ef02c8dc-c9e3-460a-a0a1-d7f415297447
:END:

#+begin_src emacs-lisp
(use-package! selectrum-prescient
  :ensure (:host github :repo "raxod502/prescient.el"
           :files ("selectrum-prescient.el"))
  :after selectrum
  :require t
  :defer-config (selectrum-prescient-mode 1))
#+end_src

**** jump to line
:PROPERTIES:
:ID:       b4ccbc1d-b2fa-4bfa-95ef-3bde8ce57655
:END:

This is a replacement for swiper. It lets me fuzzy jump to a particular line in
a file.

#+begin_src emacs-lisp
(defvar selectrum:swiper-jump-to-line-history nil
  "Submission history for `selectrum/jump-to-line'.")

(defun selectrum/swiper ()
  "Search for a line and jump to it."
  (interactive)
  (let* ((selectrum-should-sort-p nil)
         (gc-cons-threshold VOID:GC-CONS-THRESHOLD-MAX)
         (line-choices (let ((minimum-line-number (line-number-at-pos (point-min) t))
                             (buffer-text-lines (split-string (buffer-string) "\n")))
                         (seq-map-indexed (lambda (it it-index) (format "%d\t%s" it-index it)) buffer-text-lines)))
         ;; Get the matching line.
         (chosen-line (completing-read "Jump to matching line: " line-choices
                                       nil t nil 'selectrum:swiper-jump-to-line-history))
         ;; Get the corresponding line number.
         (chosen-line-number (progn (string-match "\\([[:digit:]]+\\)[[:space:]]\\(?:.\\|\n\\)*" chosen-line)
                                    (string-to-number (match-string-no-properties 1 chosen-line))))
         ;; Get the current line number for determining the travel distance.
         (current-line-number (line-number-at-pos (point) t)))
    (push-mark (point) t)
    (forward-line (1+ (- chosen-line-number current-line-number)))
    (beginning-of-line-text 1)
    (when (eq major-mode 'org-mode)
      (org-adjust-nearby-headlines-a)
      (when (org:heading-folded-p)
        (outline-toggle-children)))))
#+end_src

**** recent buffer
:PROPERTIES:
:ID:       9de994ec-e4f2-4375-9466-6ec7f5ea907e
:END:

#+begin_src emacs-lisp
(defun selectrum/buffer-or-recentf ()
  "Jump to buffer or recentf candidate."
  (interactive)
  (require 'recentf)
  (let* ((selectrum-should-sort-p nil)
         (live-buffers (seq-remove (lambda (it) (string-match-p (rx bol white) it))
                                   (seq-map #'buffer-name (buffer-list))))
         (recentf-buffers (seq-map (lambda (it) (cons (propertize (shrink-path-file it) 'face 'font-lock-comment-face) it))
                                   recentf-list)))
    (alet (completing-read "File: " (append live-buffers recentf-buffers))
      (setq it (or (alist-get it recentf-buffers nil nil #'string=) it))
      ;; (message "name %s|buffer: %s" it (get-buffer it))
      (switch-to-buffer (or (get-buffer it) (find-file-noselect it))))))
#+end_src

**** tag headlines
:PROPERTIES:
:ID:       ae87e87d-3e58-4d8c-b495-0d61770d8d74
:END:

#+begin_src emacs-lisp
(defun selectrum/org-set-tag ()
  "Add or remove tags from an org-mode headline."
  (interactive)
  (let* ((org-use-fast-tag-selection nil)
         (current-tags (org-get-tags))
         (all-tags (seq-uniq (flatten-list (org-map-entries (lambda () (org-get-tags (point) t))))))
         (selected-tags (completing-read-multiple "set tags: " all-tags)))
    (org-set-tags
     (append (seq-remove (lambda (it) (member it current-tags)) selected-tags)
             (seq-remove (lambda (it) (member it selected-tags)) current-tags)))))
#+end_src

**** TODO qutebrowser links                                           :disabled:
:PROPERTIES:
:ID:       e304a673-08fd-466f-bcb0-6b3f57acc60d
:END:

#+begin_src emacs-lisp
(defun void/browser-links ()
  "For now use completing read to see qutebrowser links. TODO: do something with the choosen link(s)."
  (interactive)
  (let ((links nil)
        (selectrum-should-sort-p nil)
        (qutebrowser-history-path "~/.local/share/qutebrowser/history.sqlite")
        (regexp "https:\\(?:[[:alpha:]]\\|[[:digit:]]\\|[[:punct:]]\\|[[:space:]]\\)+"))
    (with-current-buffer (find-file-noselect qutebrowser-history-path)
      (revert-buffer)
      (goto-char (point-min))
      (while (re-search-forward regexp nil t nil)
        (push (match-string 0) links))
      (setq links (reverse links))
      ;; If the link is too long shorten it.
      (setq links (seq-map (lambda (it) (cons (s-truncate 110 it) it)) links))
      (completing-read "link: " links))))
#+end_src

** abbrev                                                               :abbrev:
:PROPERTIES:
:ID: ce3011f3-c8c6-468a-928b-c7bc3ba22f60
:END:

An [[info:emacs#Abbrevs][abbrev]] is a word that expand into some different text when it's inserted. It
is code completion, but an extremely minimal variant of it. There's no popups,
no suggestions of any kind and no flashy display; you just type the abbreviation
and after you press /SPC/ or a period, the expansion replaces the abbreviation.
I'd guess that when many emacsers that come accross abbrev undervalue it because
when they compare it to =company= or =yasnippet= it comes up pretty short. The
advantage of abbrevs lies in its minimalistic nature. Company completion, great
as it is, can be expensive. Additionally, if overused it can be clunky and
distracting. When I'm typing code I'm all for =company= because most of the time I
can't remember exact variable or function names. However, when I'm typing a
paragraph such as this one. Imagine having a popup open up every time you type a
word. And yet, it is tiring typing the same words and phrases again and again.
This is where abbrev can fill in.

*** bootstrap
:PROPERTIES:
:ID: dbdc3171-b30f-4b6c-bba2-151748998acd
:END:

#+begin_src emacs-lisp
(use-feature! abbrev
  ;; :tag "built-in"
  ;; :hook (prog-mode-hook org-mode-hook)
  :pre-setq (abbrev-file-name . (concat VOID:DATA-DIR "abbrev.el"))
  :defer-config
  (add-hook 'kill-emacs-hook #'write-abbrev-file))
#+end_src

*** abbreviation algorithm
:PROPERTIES:
:ID: 6ff789a8-8732-40e6-a765-dc92c85cc9c9
:END:

When you type a word and call one of the default Emacs abbrev functions,
[[helpfn:add-global-abbrev][add-global-abbrev]] and [[helpfn:add-mode-abbrev][add-mode-abbrev]], prompt you for the abbreviation to give
to the word you just typed. I noticed that deciding on an abbreviation myself
took too much mental energy and distracted me from my current task. I would
think: /"What's the best abbreviation for apple? Ple? Apl? Pl?"./ Not only that
but my abbreviations would be inconsistent, making them difficult to recall and,
worse, unpredictable. If you asked me on Saturday how to abbreviate /apple/ I
might say /pl/ but if you asked me a week from then, I might say /ple/. There was no
standard.

For these reasons, I wrote my own abbreviation function. That function takes in
a word and returns an abbreviation for that word. Doing this I remove an entire
step from the abbreviation creating process. Invoking ~add-global-abbrev~,
thinking of an abbrev, and then typing it in has been reduced to just invoking
[[helpfn:abbrev/add-global-abbrev][+abbrev/add-global-abbrev]]. Not only that but now if I know I created an
abbreviation for something but don't remember exactly I can predict the /exact/
abbreviation. Before I'd have to remember or just look it up.

**** list of common suffixes
:PROPERTIES:
:ID: d0dc7884-9f36-4ac0-8560-322c3f8c52a2
:END:

I found that it's superfluous to abbreviate words with their suffixes. It leads
to longer abbreviations that perhaps are not as meaningful because of the
suffix. I don't know though

#+begin_src emacs-lisp
(defvar abbrev:suffixes
  '("tion" "sion" "ship" "ate" "ing")
  "Common suffixes in the english language.")
#+end_src

**** abbreviating multiple words
:PROPERTIES:
:ID: 781738d6-e88d-43c7-84aa-0d5f6002f00f
:END:

For multiple modes, I want the same, simple thing: abbreviate the expression from the
first letter of each word.

#+begin_src emacs-lisp
(defun abbrev:abbreviate-words (words)
  "Abbreviate WORDS.
WORDS is a string of non whitespace and whitespace."
  (thread-last (s-split "\s" words t)
    (seq-map (lambda (it) (char-to-string (aref it 0))))
    (seq-map #'downcase)
    (apply #'concat)))
#+end_src

**** abbreviate a single word
:PROPERTIES:
:ID: 92b35cfc-878c-42df-bfe1-d4de2d8b0ac5
:END:

Abbreviating a single word is harder.

#+begin_src emacs-lisp
(defun abbrev:abbreviate-word (word)
  "Abbreviate WORD.
WORD is a string with no whitespace characters."
  (let!* ((vowel-regexp (rx (or "a" "e" "i" "o" "u" "y")))
          (letters (--> word
                        (s-chop-suffixes abbrev:suffixes it)
                        (s-split "" it t)))
          (no-vowels (seq-remove (-partial #'string-match-p vowel-regexp)
                                 letters)))
         (thread-last no-vowels
           (seq-uniq)
           (seq-map #'downcase)
           (apply #'concat))))
#+end_src

**** general abbreviate function
:PROPERTIES:
:ID: b56b6968-99db-423b-a87e-ef36ebace906
:END:

#+begin_src emacs-lisp
(defun abbrev:abbreviate (words)
  "Abbreviate WORDS.
WORDS is a string containing one or more words."
  (if (s-contains? "\s" words)
      (abbrev:abbreviate-words words)
    (abbrev:abbreviate-word words)))
#+end_src

*** interactive abbrev function
:PROPERTIES:
:ID: 9e95bf92-26fe-495d-bcf1-735be2de32dc
:END:

**** helpers
:PROPERTIES:
:ID: 01dfc103-081b-4934-b072-d4d0dbec8c90
:END:

***** abbrev alist
:PROPERTIES:
:ID: 27c7e3ef-de67-45a7-be74-35601003ec98
:END:

#+begin_src emacs-lisp
(defun abbrev--alist+ ()
  "Alist of (abbrev . expansion)."
  (let (alist)
    (mapatoms
     (lambda (sym)
       (when (symbol-value sym)
         (push (cons sym (symbol-value sym)) alist)))
     global-abbrev-table)
    alist))
#+end_src

***** last word(s) before point
:PROPERTIES:
:ID: 3ae1f1a1-d07f-48a8-a5dd-0f53f9f0ab7d
:END:

#+begin_src emacs-lisp
(defun abbrev--last:words (word-count)
  "Get WORD-COUNT previous words."
  (and (>= word-count 0)
       (buffer-substring-no-properties
        (point)
        (if (= word-count 0) (mark)
          (save-excursion (forward-word (- word-count)) (point))))))
#+end_src

***** interactive function helper
:PROPERTIES:
:ID: 7dc7e86b-e4d6-4624-a6be-ba66525717fb
:END:

#+begin_src emacs-lisp
(defun abbrev--add:abbrev (type word-count)
  "Helper for adding abbrev to table."
  (let* ((table (if (string= type "global")
                    global-abbrev-table
                  local-abbrev-table))
         (expansion (abbrev--last:words word-count))
         (abbrev (abbrev:abbreviate-word expansion))
         (existing (abbrev-expansion abbrev abbrev)))
    (when (or (not existing)
              (y-or-n-p (format "%s expands to \"%s\"; redefine? " abbrev existing)))
      (define-abbrev table abbrev expansion)
      (message "new abbrev: %s -> %s" abbrev expansion))))
#+end_src

**** global abbrev
:PROPERTIES:
:ID: bef7fe74-8d69-406d-90ae-9d08021d9b45
:END:

#+begin_src emacs-lisp
(defun abbrev/add-global-abbrev (word-count)
  "Replacement for `add-global-abbrev'."
  (interactive "p")
  (abbrev--add:abbrev "global" word-count))
#+end_src

**** mode abbrev
:PROPERTIES:
:ID: b028d151-5f4a-4e7f-b536-036fdf0f4922
:END:

#+begin_src emacs-lisp
(defun abbrev/add-mode-abbrev (word-count)
  "Replacement for `add-mode-abbrev'."
  (interactive "p")
  (abbrev--add:abbrev "mode" word-count))
#+end_src

**** delete abbrev
:PROPERTIES:
:ID: 47a37f4f-055d-4f38-b055-83c96db788f4
:END:

#+begin_src emacs-lisp
(defun abbrev/delete-abbrev ()
  "Delete abbrev."
  (interactive)
  (-let* ((selected (completing-read
                     "abbrev to delete:"
                     (seq-map (-lambda ((abbrev . expansion))
                                (format "%s -> %s" abbrev expansion))
                              (abbrev--alist+))))
          ((abbrev _ _) (s-split "\s" selected)))
    (message "deleted abbrev: %s" selected)
    (define-abbrev global-abbrev-table abbrev nil)))
#+end_src

** company
:PROPERTIES:
:ID: 436d68f7-09f1-470a-a730-fd79d9c183ee
:END:

*** company
:PROPERTIES:
:ID: 89fcd613-f7ea-461b-a91c-0d9a0ae28093
:END:

[[https://github.com/company-mode/company-mode][company]] offers code completion.

#+begin_src emacs-lisp
(use-package! company
  :hook prog-mode-hook
  :bind (:company-active-map
         ([tab] . company-select-next)
         ([backtab] . company-select-previous)
         ("C-k"     . company-select-previous)
         ("C-j"     . company-select-next))
  :setq
  (company-frontends . '(company-pseudo-tooltip-frontend))
  (company-tooltip-align-annotations . t)
  (company-show-numbers . t)
  (company-dabbrev-downcase . nil)
  (company-idle-delay . 0.15)
  (company-tooltip-limit . 14)
  (company-minimum-prefix-length . 1)
  (company-minimum-prefix-length . 1)
  (company-require-match . 'never))
#+end_src

*** backends
:PROPERTIES:
:ID: 976f3260-992a-44ee-af91-5eff0b398b20
:END:

[[helpvar:company-backends][company-backends]] is what you have to keep in mind when you're using
company. According to its documentation, =company-backends= contain
individual backends or groups of backends. This is important so it's
worth quoting here:

**** backends-alist
:PROPERTIES:
:ID: 1ca376a2-e92f-4b77-8a91-3c2d00c0c5b7
:END:

#+begin_src emacs-lisp
(defvar company:backend-alist
  '((text-mode :derived (company-dabbrev company-yasnippet company-ispell))
    (prog-mode :derived ((:separate company-capf company-yasnippet)))
    (conf-mode :derived (company-capf company-dabbrev-code company-yasnippet))
    (org-mode  :only (company-yasnippet)))
  "An alist matching modes to company backends.")
#+end_src

**** initialize a backend
:PROPERTIES:
:ID: 24288386-3600-4a23-90d1-d38f9862aca0
:END:

#+begin_src emacs-lisp
(defhook! company:init-backends-h ()
  "Set `company-backends' for the current buffer."
  :hook company-mode-hook
  (require 'company)
  (unless (eq major-mode 'fundamental-mode)
    (set (make-local-variable 'company-backends) (company--backends+)))
  (add-hook 'after-change-major-mode-hook #'company:init-backends-h nil 'local))
#+end_src

**** get backends
:PROPERTIES:
:ID: 985f9898-2608-4aa2-8ee9-98a178a4d5e5
:END:

#+begin_src emacs-lisp
(defun company--backends+ ()
  "Compute company backends."
  (or
   (-when-let ((mode type backends)
               (assoc major-mode company:backend-alist))
     (when (eq type :only) backends))
   (mapcan (-lambda ((mode type backends))
             (when (or (and (eq type :derived) (derived-mode-p mode))
                       (and (eq type :exact)
                            (or (eq major-mode mode)
                                (and (boundp mode) (symbol-value mode)))))
               backends))
           company:backend-alist)))
#+end_src

**** local hook
:PROPERTIES:
:ID: 49a1e8e6-c557-4a9c-9a3a-a1aa60f90924
:END:

#+begin_src emacs-lisp
(after! company
  (put 'company:init-backends-h 'permanent-local-hook t))
#+end_src

*** close company on escape
:PROPERTIES:
:ID: 750cc608-865e-4f69-a7b2-826fc66a7b71
:END:

#+begin_src emacs-lisp
(defhook! company:close-tooltip-h ()
  "Close company tooltip."
  :hook void:escape-hook
  (when (and (boundp 'company-mode)
             (eq company-mode t))
    (company-abort)
    t))
#+end_src

*** company prescient
:PROPERTIES:
:ID: df21548a-c262-4802-8e76-71a3135789cb
:END:

[[https://github.com/raxod502/prescient.el][company-prescient]] is the same as =prescient= but for =company= instead of =ivy=.

#+begin_src emacs-lisp
(use-package! company-prescient :hook company-mode-hook)
#+end_src

* Email
:PROPERTIES:
:ID: b31fc41c-135d-45d9-9c05-5889d21d1cd4
:END:

In today's world communication is largely done via emails. Whether at work or at
school it's common to receive emails every day. In fact, you hear of people that
have 20,000+ emails in a particular account. Unsurprisingly, when we're getting
so many emails, it's easy to become overwhelmed. Fortunately, there are numerous
ways to read and send emails in Emacs.

** sendmail
:PROPERTIES:
:ID:       48c3332f-975d-4f22-94a8-4ccd394ca82a
:END:

#+begin_src emacs-lisp
(use-feature! sendmail
  :setq
  (send-mail-function . #'sendmail-send-it)
  (mail-specify-envelope-from . t))
#+end_src

** smtpmail
:PROPERTIES:
:ID: 4dc1e0a6-5441-4b3e-8b75-ed3626a59154
:END:

#+begin_src emacs-lisp
(use-feature! smtpmail
  :disabled t
  :setq
  (smtp-default-mail-server . "mail.example.com")
  (smtp-smtp-server . "mail.example.com")
  (smtpmail-smtp-service . 587)
  (smtpmail-debug-info . t))
#+end_src

** message
:PROPERTIES:
:ID:       4cf38804-18d6-470c-a9c3-e3327f2bebf9
:END:

#+begin_src emacs-lisp
(use-feature! message
  :setq
  (message-signature . user-full-name)
  (message-sendmail-envelope-from . 'header)
  (message-send-mail-function . #'smtpmail-send-it)
  (message-kill-buffer-on-exit . t))
#+end_src

** mu4e
:PROPERTIES:
:ID: 1ec73e33-5b94-4199-976d-1d72f8fb5a8e
:END:

The most popular emacs mail client is =mu4e=. And, there is good reason why. =mu4e=
has many juicy features. Overall, =mu4e= is definitely a great mail client.
However, it's not all roses and rainbows; it does have a few annoying quicks.
One is that unlike virtually all other emacs packages it does not come decoupled
from =mu=. Another is that it is hard to set up multiple accounts properly despite
it's [[explicit support]] for multiple accounts. =mu4e= comes bundled with =mu=. A
significant advantage of using it is it's the most popular option and,
therefore, has the most support (in the form of setup blogs and packages).

*** mu4e
:PROPERTIES:
:ID: 565eff90-8626-4ec8-a576-4ff3dfb307ae
:END:

#+begin_src emacs-lisp
(use-package! mu4e
  :load-path "/usr/share/emacs/site-lisp/mu4e/"
  :commands mu4e
  :setq
  (mu4e-completing-read-function . #'completing-read)
  (mu4e-view-show-addresses . t)
  (mu4e-view-show-images . t)
  (mu4e-view-image-max-width . 800)
  (mu4e-compose-signature-auto-include . t)
  (mu4e-compose-format-flowed . t)
  (mu4e-get-mail-command . "mbsync -a")
  (mu4e-index-cleanup . t)
  (mu4e-index-lazy-check . nil)
  (mu4e-update-interval . 180)
  (mu4e-headers-auto-update . t)
  (mu4e-context-policy . 'pick-first)
  (mu4e-compose-context-policy . 'ask-if-none)
  (mu4e-confirm-quit . nil)
  (mu4e-header-fields . '((:human-date . 12)
                          (:flags . 4)
                          (:from . 25)
                          (:subject)))
  (mu4e-html2text-command . (if (executable-find "w3m") "w3m -dump -T text/html" #'mu4e-shr2text)))
#+end_src

*** mu4e headers
:PROPERTIES:
:ID: 8b59c5bb-180c-461e-9b1a-4a0c95cb7671
:END:

#+begin_src emacs-lisp
(use-package! mu4e-headers
  :after mu4e
  :setq
  (mu4e-use-fancy-chars . t)
  (mu4e-headers-draft-mark     . (cons "D" (all-the-icons-faicon "pencil")))
  (mu4e-headers-flagged-mark   . (cons "F" (all-the-icons-faicon "flag")))
  (mu4e-headers-new-mark       . (cons "N" (all-the-icons-material "fiber_new")))
  (mu4e-headers-passed-mark    . (cons "P" (all-the-icons-faicon "arrow-right")))
  (mu4e-headers-seen-mark      . (cons "S" (all-the-icons-faicon "eye")))
  (mu4e-headers-attach-mark    . (cons "a" (all-the-icons-material "attach_file")))
  (mu4e-headers-replied-mark   . (cons "R" (all-the-icons-faicon "reply")))
  (mu4e-headers-unread-mark    . (cons "u" (all-the-icons-faicon "eye-slash")))
  (mu4e-headers-encrypted-mark . (cons "x" (all-the-icons-octicon "lock")))
  (mu4e-headers-signed-mark    . (cons "s" (all-the-icons-faicon "certificate")))
  (mu4e-headers-trash-mark     . (cons "T" (all-the-icons-faicon "trash"))))
#+end_src

*** org mu4e
:PROPERTIES:
:ID: 9045b0f5-af8c-481e-914e-a19c4bbf2941
:END:

Mu4e's org integration lets you write emails in org mode and convert it to html
before sending--very interesting indeed. I have yet to explore this feature but
it is definitely on my list of things to try out.

#+begin_src emacs-lisp
(use-package! org-mu4e
  :disabled t
  :hook (mu4e-compose-mode-hook . org-mu4e-compose-org-mode)
  :setq
  (org-mu4e-link-query-in-headers-mode . nil)
  (org-mu4e-convert-to-html . t)
  :defer-config
  ;; Only render to html once. If the first send fails for whatever reason,
  ;; org-mu4e would do so each time you try again.
  (defhook! org-mu4e-render-html-only-once-h ()
    :hook message-send-hook
    (setq-local org-mu4e-convert-to-html nil)))
#+end_src

*** multiple accounts
:PROPERTIES:
:ID: ad6de3a4-674c-490f-841e-19b8f891cd65
:END:

Mu4e certainly gave me some trouble setting up multiple accounts despite [its
attempt] to make this easy. I have one directory =~/.mail= where which stores all
my mail. The subdirectories of =~/.mail= correspond to my individual email
accounts. Until I set multiple accounts correctly it keeps prompting me to
create folders (such as =sent/=) in the =~/.mail= directory. I think part of the
reason I spent so much time setting this up is because.

**** email accounts
:PROPERTIES:
:ID: 0e71d857-f945-4b82-a49f-3621ebd6a5e0
:END:

#+begin_src emacs-lisp
(defvar mu4e:email-accounts
  '((:name "snhu"
     :email "luis.henriquez@snhu.edu"
     :sent "Sent Items"
     :trash "Deleted Items"
     :drafts "Drafts"
     :server "smtp.office365.com"
     :port 587)
    (:name "gmail"
     :email "luishenriquezperez@gmail.com"
     :server "smtp.gmail.com"
     :port 587)
    (:name "luishp"
     :email "luis@luishp.xyz"
     :sent "Sent"
     :trash "Trash"
     :drafts "Drafts"
     :server "mail.luishp.xyz"
     :port 25))
  "Email account information for mu4e.")
#+end_src

**** account setter
:PROPERTIES:
:ID: e56b64ac-ed36-4689-b8f4-8711c1f4f79f
:END:

#+begin_src emacs-lisp
(defun mu4e:init-accounts ()
  "Initialize all accounts in `mu4e:email-accounts'.
Create an mu4e-context for each email account in `mu4e:email-accounts'."
  (dolist (account mu4e:email-accounts)
    (with-plist! account
      (thread-first `((mu4e-sent-folder . ,(concat "/%s/" (or <sent> "sent")))
                      (mu4e-trash-folder . ,(concat "/%s/" (or <trash> "trash")))
                      (mu4e-drafts-folder . ,(concat "/%s/" (or <drafts> "drafts")))
                      (user-email-address . "%s")
                      (smtpmail-smtp-server . ,(or $server))
                      (smtpmail-smtp-user . "%s"))
        (seq-map (-lambda ((var . val)) (cons var (format val <email>))) it)
        (cons `(smtpmail-smtp-service . ,(or <port> 25)) it)
        (make-mu4e-context :name <name> :vars it)
        (push it mu4e-contexts)))))
#+end_src

**** shortcuts
:PROPERTIES:
:ID: 565ce4bc-2cdb-4e1a-b871-e2d7d34137de
:END:

#+begin_src emacs-lisp
(defun mu4e/view-today-emails ()
  (interactive)
  (mu4e t)
  (mu4e-headers-search "date:today..now"))

(defun mu4e/view-shnu-account ()
  (interactive)
  (mu4e t)
  (mu4e-headers-search "to:luis.henriquez@snhu.edu"))

(defun mu4e/view-luishp-account ()
  (interactive)
  (mu4e t)
  (mu4e-headers-search "to:luis@luishp.xyz"))

(defun mu4e/view-gmail-account ()
  (interactive)
  (mu4e-headers-search "to:luishenriquezperez@gmail.com"))
#+end_src

*** bindings
:PROPERTIES:
:ID: 6b7e8206-24aa-485f-87e0-98a997936205
:END:

#+begin_src emacs-lisp
(general-def 'normal mu4e-headers-mode-map
  "q" #'kill-buffer-and-window
  "i" #'ignore
  "I" #'ignore
  "D" #'mu4e-headers-mark-for-delete
  "F" #'mu4e-headers-mark-for-flag
  "u" #'mu4e-headers-mark-for-unmark
  "x" #'mu4e-mark-execute-all
  "t" #'mu4e-headers-mark-for-trash
  "c" #'mu4e-compose
  "o" #'org-mu4e-compose-org-mode
  "s" #'mu4e-headers-search
  "r" #'mu4e-compose-reply
  "RET" #'mu4e-headers-view-message)

(general-def 'normal mu4e-view-mode-map
  "q" #'kill-buffer-and-window)

(define-localleader-key! mu4e-compose-mode-map
  "s" (list :def #'message-send-and-exit :which-key "send and exit")
  "d" (list :def #'message-kill-buffer :which-key "kill buffer")
  "S" (list :def #'message-dont-send :which-key "save draft")
  "a" (list #'mail-add-attachment :which-key "attach"))
#+end_src

*** truncate lines in messages
:PROPERTIES:
:ID: e6addd49-6aa4-4b9e-8e50-4f0ea43aedb7
:END:

#+begin_src emacs-lisp
(defhook! mu4e:wrap-text-in-message ()
  :hook mu4e-view-mode-hook
  (setq-local truncate-lines nil))
#+end_src

** notmuch
:PROPERTIES:
:ID: 9bc1dad1-e2ec-4699-b471-a25b28aaaf26
:END:

Notmuch is probably the most elegant email solution of the three. It operates
purely on tags. Mu4e uses tags in the background but =notmuch= goes all out.
There's no concept of folders. A great thing about this is you avoid the
headache of Mu4e contexts because there is no such thing as a context to
=notmuch=. =notmuch= couldn't care less about how your emails are organized. Also,
=notmuch= is even faster than Mu4e when it comes to indexing email. Though this
probably won't be a significant practical difference unless you have *many*
emails.

*** bootstrap
:PROPERTIES:
:ID: e0cbf1d5-6e48-4a11-8f68-1151d2fc3e28
:END:

#+begin_src emacs-lisp
(use-package! notmuch
  :commands notmuch
  :setq
  (notmuch-search-oldest-first . nil)
  ;; Don't show notmuch logo.
  (notmuch-show-logo . nil)
  (notmuch-show-mark-read-tags . '("-unread")))
#+end_src

*** accounts
:PROPERTIES:
:ID: 5db186cb-8650-4be9-9b9a-9b001a951d35
:END:

I want this command to be a replacement to `notmuch'. Calling `notmuch'
displays an (ugly) intro screen. I find that most of the time I just want to
see my inbox, no questions asked.

#+begin_src emacs-lisp
(defun notmuch/display-inbox ()
  "Display the inbox."
  (interactive)
  (notmuch-search "tag:inbox" notmuch-search-oldest-first))

(defun notmuch/luishp-account ()
  (interactive)
  (notmuch-search "to:luis@luishp.xyz" notmuch-search-oldest-first))

(defun notmuch/luishenriquezperez-account ()
  (interactive)
  (notmuch-search "to:luishenriquezperez@gmail.com NOT tag:spam" notmuch-search-oldest-first))

(defun notmuch/snhu-account ()
  (interactive)
  (notmuch-search "to:luis.henriquez@snhu.edu"))
#+end_src

*** update mail
:PROPERTIES:
:ID: e98aae10-ae2f-479b-97b5-2a84a202e5fe
:END:

#+begin_src emacs-lisp
(defun notmuch/update ()
  (interactive)
  (start-process-shell-command
   "notmuch update" nil
   "mbsync -a && notmuch new")
  ;; (notmuch-tag "tag:new and folder:luishenriquezperez@gmail.com/spam" '("+spam" "-new" "-unread"))
  ;; tag new spam email as spam.
  ;; mark new email as new.
  )
#+end_src


** gnus                                                               :disabled:
:PROPERTIES:
:ID: d9ce252d-5f33-469b-a88c-84131f6f0eaa
:END:

Perhaps the least popular way of using emails is using gnus. It is actually how
[[][John Wiegley]], one of Emacs's maintainers, has managed his email for over
20 years. Gnus is really a mixed bag. One the one hand, I absolutely love the
fact that it's written in pure elisp (making it extremely customizable) and that
it's built-in to emacs. You can be on a completely different computer and set up
have a working client with just Emacs--that's pretty incredible. On the other
hand, the abstraction it is based on is extremely outdated making many of it's
variables and functions more difficult to understand (just by reading their
name) than normal; and it's pretty slow when dealing with many emails (by many I
mean 2000 which is not a lot by today's standard).

*** bootstrap
:PROPERTIES:
:ID: 80d3161d-0d0d-4c34-abf7-5ca12501f16c
:END:

#+begin_src emacs-lisp
(use-feature! gnus
  :commands gnus
  :setq
  (gnus-summary-line-format "%U%R%z %-16,16&user-date; %-30,30f  %B%S\n")
  (gnus-select-method . '(nnnil))
  (gnus-agent . t)
  (gnus-agent-article-alist-save-format . 1)
  (gnus-agent-cache . t)
  (gnus-agent-confirmation-function . 'y-or-n-p)
  (gnus-agent-consider-all-articles .  nil)
  (gnus-agent-directory . "~/News/agent/")
  (gnus-agent-enable-expiration . 'ENABLE)
  (gnus-agent-expire-all . nil)
  (gnus-agent-expire-days . 30)
  (gnus-agent-mark-unread-after-downloaded . t)
  (gnus-agent-queue-mail . t)
  (gnus-agent-synchronize-flags . nil))
#+end_src

*** gnus start
:PROPERTIES:
:ID: fe201237-301d-4b52-b24e-b16eb37aa31d
:END:

#+begin_src emacs-lisp
(use-feature! gnus-start
  :after gnus
  :setq
  (gnus-use-dribble-file . nil)
  (gnus-always-read-dribble-file . nil))
#+end_src

*** gnus sum
:PROPERTIES:
:ID: e16c4665-d404-49df-9cee-fec2a159e1c1
:END:

#+begin_src emacs-lisp
(use-package! gnus-sum
  :setq
  (gnus-user-date-format-alist . '(((gnus-seconds-today) . "Today at %R")
                                   ((+ 86400 (gnus-seconds-today)) . "Yest. at %R")
                                   (t . "%m-%d %R")))
  (gnus-sum-thread-tree-false-root . "")
  (gnus-sum-thread-tree-indent . " ")
  (gnus-sum-thread-tree-leaf-with-other . "├─➤ ")
  (gnus-sum-thread-tree-root . "")
  (gnus-sum-thread-tree-single-leaf . "└─➤ ")
  (gnus-sum-thread-tree-vertical . "│"))
#+end_src

*** accounts
:PROPERTIES:
:ID: 87d48ed6-cf36-4aa0-8d6d-1615ebb6a4cf
:END:

**** luis
:PROPERTIES:
:ID: fd91766f-36ec-4a13-ae90-44eaa930f58a
:END:

#+begin_src emacs-lisp
(ignore!
 (append! gnus-secondary-select-methods
   '(nnimap "luis"
     (nnimap-address "mail.luishp.xyz")
     (nnimap-stream ssl)
     (nnimap-authenticator 'login)
     (nnimap-log-command "pass"))))

(append! gnus-secondary-select-methods
  '(nnmaildir "luis"
    (directory "~/.mail/luis@luishp.xyz")))
#+end_src

**** snhu
:PROPERTIES:
:ID: 620f1fcd-e5c8-42b9-a117-87e704b188af
:END:

#+begin_src emacs-lisp
(ignore!
 (append! gnus-secondary-select-methods
   '(nnimap "school"
     (nnimap-address "outlook.office365.com")
     (nnimap-stream ssl)
     (nnimap-log-command "pass"))))

(append! gnus-secondary-select-methods
  '((nnmaildir "snhu"
     (directory "~/.mail/luis.henriquez@snhu.edu/"))))
#+end_src

**** gmail
:PROPERTIES:
:ID: a76bea4c-7922-4b63-9e74-d377eb943e88
:END:

#+begin_src emacs-lisp
(append! gnus-secondary-select-methods
  '(nnimap "gmail"
    (nnimap-address "imap.gmail.com")
    (nnimap-stream ssl)
    (nnimap-log-command "pass")))
#+end_src

*** gnus group
:PROPERTIES:
:ID: 1f022c0d-6157-4ba3-9676-860ef8c00258
:END:

#+begin_src emacs-lisp
(use-feature! gnus-group
  :setq
  (gnus-group-line-format . "%M\ %S\ %p\ %P\ %5y:%B%(%g%)\n"))
#+end_src

*** gnus art
:PROPERTIES:
:ID: 1642c04a-5332-484b-81e5-36bd16ca69a0
:END:

#+begin_src emacs-lisp
(use-package! gnus-art
  :after gnus
  :setq
  (gnus-article-browse-delete-temp . 'ask)
  (gnus-article-over-scroll . nil)
  (gnus-article-show-cursor . t)
  (gnus-article-sort-functions
   '(gnus-article-sort-by-most-recent-number
     gnus-article-sort-by-most-recent-date))
  (gnus-article-truncate-lines . nil)
  ;; (gnus-html-frame-width 80)
  ;; (gnus-html-image-automatic-caching t)
  (gnus-inhibit-images . t)
  (gnus-max-image-proportion . 0.3)
  (gnus-treat-display-smileys . nil)
  ;; (gnus-article-mode-line-format "%G %S %m")
  (gnus-visible-headers
   '("^From:" "^To:" "^Cc:" "^Newsgroups:" "^Subject:" "^Date:"
     "Followup-To:" "Reply-To:" "^Organization:" "^X-Newsreader:"
     "^X-Mailer:"))
  (gnus-sorted-header-list . gnus-visible-headers))
#+end_src

* Web Browsing
:PROPERTIES:
:ID: f0960e47-5dbb-4cca-a17a-f8eb0da445d3
:END:

In current times we are fortunate enough to have a wealth of information
available to us only a web search away.

** w3m
:PROPERTIES:
:ID: e5e13423-bc70-49b0-969e-94897c798d54
:END:

[[http://w3m.sourceforge.net/][w3m]] is a text-based web browser. There are many other text-based browsers out
there, but =w3m= has the benefit of having comprehensive [[https://github.com/emacs-w3m/emacs-w3m][emacs interface]]. Why
use this when you can use the GUI browser? Well, using the Emacs interface I can
view an Emacs webpage as plain text, which means I can perform searches on it
with [[][swiper]], or any other Emacs operation on it. Another advantage is that
because the w3m interface's backend is a terminal application, it will (I'm
guessing; no benchmarks made) typically be faster than browsers at rendering
plain text webpages. Of course, the main limitation is that w3m will typically
only display text based web pages well--not ones with lots of interactive
javascript code.

*** w3m
:PROPERTIES:
:ID: 10ddb49f-9280-49f4-8ca4-c46310d8a1dd
:END:

#+begin_src emacs-lisp
(use-package! w3m
  :commands w3m
  :setq (w3m-search-default-engine . "google"))
#+end_src

*** traversing
:PROPERTIES:
:ID: aded77d8-8088-4aad-b0b9-bb5a45d343f2
:END:

#+begin_src emacs-lisp
(general-def 'normal w3m-mode-map
  "o" #'w3m-search
  "O" #'w3m-search-new-session
  ;; Jump to a link with avy in the current session.
  "f" #'ace-link-w3m
  "F" #'ace-link-open-new-session
  ;; Delete the current emacs-w3m buffer and switch to the previous one.
  "D" #'w3m-delete-buffer
  ;; Move through tabs.
  "J" #'w3m-tab-move-right
  "K" #'w3m-tab-move-left
  ;; Move back COUNT pages in the history.
  "H" #'w3m-view-previous-page
  ;; Move forward COUNT pages in history.
  "L" #'w3m-view-next-page)
#+end_src

** browse-url
:PROPERTIES:
:ID: c705a76a-26a9-4956-915a-d6d2561fe923
:END:

Emacs's go-to function for browsing the web is stored in the variable
[[helpvar:browse-url-browser-function][browse-url-browser-function]].

#+begin_src emacs-lisp
(setq browse-url-browser-function #'browse-url-qutebrowser)

(defun browse-url-qutebrowser (url &optional _new-window)
  "Ask the Qutebrowser WWW browser to load URL.
Default to the URL around or before point.  The strings in
variable `browse-url-qutebrowser-arguments' are also passed to
Qutebrowser.
The optional argument NEW-WINDOW is not used."
  (interactive (browse-url-interactive-arg "URL: "))
  (setq url (browse-url-encode-url url))
  (let* ((process-environment (browse-url-process-environment)))
    (apply 'start-process
           (concat "qutebrowser " url) nil
           (executable-find "qutebrowser")
           (append nil (list url)))))
#+end_src

** xwebkit                                                            :disabled:
:PROPERTIES:
:ID: b33151c3-e980-41d3-8656-350d514f9925
:END:

*** going to url                                                      :disabled:
:PROPERTIES:
:ID: 1079a7c8-e596-40d4-b86e-e916944e9030
:END:

#+begin_src emacs-lisp
(use-package! xwwp-follow-link
  :straight (:host github :repo "canatella/xwwp")
  :bind (:xwidget-webkit-mode-map
         ("v" . #'xwwp-follow-link))
  :setq (xwwp-follow-link-completion-system . 'ivy))
#+end_src

* Multimedia
:PROPERTIES:
:ID: 20a915a0-8525-413c-bd68-f1d5c14ce3da
:END:

I'm using "multimedia" here as an umbrella term for non-text sources of
information such as music, videos, images, and gifs.

** youtube
:PROPERTIES:
:ID: 10642631-365c-46b4-ad29-e28e509aa1ae
:END:

Youtube contains a *huge* library of videos.

*** TODO ytdl
:PROPERTIES:
:ID:       27739f6e-9104-4e2f-b8e5-c8f56e5bb69b
:END:

=ytdl= is an emacs interface to youtube-dl.

#+begin_src emacs-lisp
(use-package! ytdl
  :setq
  (ytdl-downloads-folder . VOID:DOWNLOAD-DIR)
  (ytdl-music-folder . VOID:MUSIC-DIR)
  (ytdl-video-folder . (expand-file-name VOID:VIDEO-DIR))
  (ytdl-always-query-default-filename . nil)
  (ytdl-always-ask-delete-confirmation . t)
  (ytdl-always-query-default-filename . nil)  ;; :defer-config
  (ytdl-media-player . "mpv")
  (ytdl-max-mini-buffer-download-type-entries . 0)
  ;; (ytdl-add-field-in-download-type-list "Music" "p" (expand-file-name "~/podcasts") nil)
  )
#+end_src

*** TODO ytel
:PROPERTIES:
:ID:       167bc712-5552-4cfe-83ce-d0bb9927fa6a
:END:

=ytel= is a YouTube search front-end. It is designed to let the user collect
YouTube search results into a buffer and manipulate them with emacs lisp.

#+begin_src emacs-lisp
(use-package! ytel
  ;; depends on curl (executable-find "curl")
  :commands ytel
  :defer-config
  (defun ytel/watch ()
    "Stream video at point in mpv."
    (interactive)
    (let* ((video (ytel-get-current-video))
     	   (id    (ytel-video-id video)))
      (start-process "ytel mpv" nil
		             "mpv"
		             (concat "https://www.youtube.com/watch?v=" id))
	  "--ytdl-format=bestvideo[height<=?720]+bestaudio/best")
    (message "Starting streaming...")))
#+end_src

** emms
:PROPERTIES:
:ID: 5d1abf3e-d0e5-4074-8d06-2b6eba47c6e4
:END:

[[https://www.gnu.org/software/emms/][emms]] is a very complete music player. https://github.com/daedreth/UncleDavesEmacs

*** emms
:PROPERTIES:
:ID: 5d28b703-a87f-47ca-b320-785e7589fea6
:END:

#+begin_src emacs-lisp
(use-package! emms
  :commands emms
  :setq
  (emms-directory . (concat VOID:DATA-DIR "emms/"))
  (emms-seek-seconds . 5)
  (emms-player-list . '(emms-player-mpd))
  (emms-volume-change-function . 'emms-volume-mpd-change)
  (emms-player-mpd-music-directory . (file-truename "~/Music"))
  (emms-player-mpd-server-name . "127.0.0.1")
  (emms-player-mpd-server-port . "6600")
  (emms-source-file-default-directory . (expand-file-name "~/Music"))
  (emms-source-file-directory-tree-function . 'emms-source-file-directory-tree-find)
  (emms-playlist-buffer-name . "*Music*")
  (mpc-host . "127.0.0.1:6600"))
#+end_src

*** quitting                                                          :disabled:
:PROPERTIES:
:ID: 545e6534-f289-4a89-838a-2a65ac74fe72
:END:

#+begin_src emacs-lisp
(defhook! emms:quit-h ()
  "Shut down EMMS."
  :hook kill-emacs-hook
  (when emms-player-playing-p (emms-pause))
  (emms-stop)
  ;; kill any existing mpd processes
  (when (member 'emms-player-mpd emms-player-list)
    (call-process "killall" nil nil nil "mpd")))
#+end_src

*** connect to mpd
:PROPERTIES:
:ID: 1fc7b846-7bbc-4d19-85f2-b7a091ca678d
:END:

#+begin_src emacs-lisp
(defun emms ()
  "Initialize EMMS."
  (interactive)
  (fmakunbound #'emms)
  (when (executable-find "mpd")
    (require 'emms-setup)
    (require 'emms-player-mpd)
    (emms-all)
    ;; kill any existing mpd processes
    (call-process "killall" nil nil nil "mpd")
    ;; start mpd
    (shell-command "mpd /home/luis/.config/mpd/mpd.conf")
    ;; update mpd database
    (call-process "mpc" nil nil nil "update")
    (emms-player-mpd-connect)
    (emms-cache-set-from-mpd-all)
    (emms-add-directory-tree emms-source-file-default-directory)
    (void:log "Set up emms"))
  (funcall #'emms))
#+end_src

** screenshot
:PROPERTIES:
:ID: 0038e1ed-ac6a-4529-9ecd-dfa8a44d40c9
:END:

Pictures or GIFs of behaviors can relate emacs behaviors in away descriptions
cannot. From my experience looking at posts on [[https://emacs.stackexchange.com/][emacs stackexchange]] or [[https://www.reddit.com/r/emacs/][emacs-reddit]] or
even other [[https://github.com/caisah/emacs.dz][emacs configs]], screenshots are underutilized (or often not
utilized at all). In Void, where documentation is *very* important, I supplement
my description of problems with pictures.

*** screenshot
:PROPERTIES:
:ID: c0975eae-c03b-4d2a-a546-06c05197eded
:END:

[[][]] is another emacs screenshot package that.

#+begin_src emacs-lisp
(use-package! screenshot :commands screenshot)
#+end_src

*** escr                                                              :disabled:
:PROPERTIES:
:ID:       06f23fc2-7f6b-4812-a14d-185b42a42976
:END:

#+begin_src emacs-lisp
(use-package! escr :disabled t)
#+end_src

*** scrot
:PROPERTIES:
:ID: 325935aa-b0f1-49b6-8c67-1173c5a1d42b
:END:

Like [[][screenshot]], [[https://github.com/dakra/scrot.el][scrot]] is screenshot taking utility. Interestingly, scrot
has a function that can capture a screenshot of a particular emacs window.

#+begin_src emacs-lisp
(use-package! scrot :ensure (:host github :repo "dakra/scrot.el"))
#+end_src

** gifs
:PROPERTIES:
:ID: 28387a67-7037-47ce-97c9-c35d77f7cb22
:END:

This package allows for the creation of gifs from within emacs.

#+begin_src emacs-lisp
(use-package! gif-screencast)
#+end_src

** keypression
:PROPERTIES:
:ID: 1943c432-4d47-43a5-ba92-2f17205bbae0
:END:

[[https://github.com/chuntaro/emacs-keypression][keypression]] is displays keypresses from within Emacs--no external tools
necessary! It [[https://raw.githubusercontent.com/wiki/chuntaro/emacs-keypression/images/screencast.gif][looks]] pretty professional!

#+begin_src emacs-lisp
(use-package! keypression
  :ensure (:host github :repo "chuntaro/emacs-keypression")
  :setq
  (keypression-frame-justify . 'keypression-right-justified))
#+end_src

* Text Editing
:PROPERTIES:
:ID: 42e0838f-f72a-43f3-8db2-a406d2d89adb
:END:

** highlight-numbers
:PROPERTIES:
:ID: d6e3227c-7678-47f0-95a8-3a6fda1638d6
:END:

What [[https://github.com/Fanael/highlight-numbers][highlight-numbers]] does is pretty self explanatory: it highlights numbers.

#+begin_src emacs-lisp
(use-package! highlight-numbers
  :hook (prog-mode-hook conf-mode-hook)
  :setq (highlight-numbers-generic-regexp . "\\_<[[:digit:]]+\\(?:\\.[0-9]*\\)?\\_>"))
#+end_src

** highlight-escape-sequences                                         :disabled:
:PROPERTIES:
:ID: 608d94c5-806f-4303-bb81-0b95a3dfcacc
:END:

Also pretty self explanatory is [[https://github.com/dgutov/highlight-escape-sequences][highlight-escape-sequences]].

#+begin_src emacs-lisp
(use-package! highlight-escape-sequences
  :ensure (:host github :repo "hlissner/highlight-escape-sequences")
  :hook (prog-mode-hook conf-mode-hook))
#+end_src

** hideshow
:PROPERTIES:
:ID: 915f65c3-8121-4480-b246-f190fe117950
:END:

Hiding text can be extremely useful. It is something that's used extensively in
Org Mode. The feature responsible for doing this is [[][hideshow]].

#+begin_src emacs-lisp
(use-package! hideshow
  :hook (prog-mode-hook . hs-minor-mode)
  :commands hs-minor-mode hs-toggle-hiding hs-already-hidden-p
  :setq (hs-hide-comments-when-hiding-all . nil))
#+end_src

** rainbow-delimiters
:PROPERTIES:
:ID: c771a943-593f-4119-8754-9d7e5da4466b
:END:

[[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]] colors parentheses different colors based on level. This is a
great idea! It makes it really easy to see which parentheses go together.

#+begin_src emacs-lisp
(use-package! rainbow-delimiters
  :hook (prog-mode-hook reb-mode-hook)
  :setq (rainbow-delimiters-max-face-count . 9))
#+end_src

** edit-indirect
:PROPERTIES:
:ID: 82e6a83b-f238-46e1-bcc2-a23bddf412be
:END:

Edit indirect is a package that allows me to edit a region from one buffer in a
different buffer. If know about [[info:org#Summary][org-mode]] and [[info:org#Working with Source Code][source blocks]], this should
sound familiar. There are two major reasons for me why doing this kind of
editing has advantages over just editing the original buffer as is. One is that
it eases cognitive effort by allowing you to focus on one bite-sized region of a
buffer instead the whole thing. The second is that it allows you apply
specialized modes to a region that may not be appropriate for the buffer as a
whole. I use this package for editing source blocks instead of [[helpfn:org-edit-src-code][org-edit-src-code]]
mainly for consistency.

*** edit-indirect
:PROPERTIES:
:ID: 4da94b9a-9e3b-4e3b-8f56-d574969cb812
:END:

#+begin_src emacs-lisp
(use-package! edit-indirect
  :before-call (org/edit:description-at-point org/dwim-edit-source-block)
  :popup ("\\*edit-indirect"
          (display-buffer-at-bottom)
          (window-height . 0.5)
          (slot . 10)))
#+end_src

*** list of headline elements
:PROPERTIES:
:ID: 3d77c526-1061-4a91-998b-06b4c3d5b48b
:END:

Striving to edit org buffers as functionally as possible as opposed to using
side-effects is very important. It makes code easier and less error prone to
write because you deal with actual lisp object as opposed to less tangible
buffer text. It also makes code easier to debug because you can test for the
correctness of values returned as opposed to the state change of the buffer.

#+begin_src emacs-lisp
(defun org:element-headline-elements ()
  "Return the list of org elements from the current headline to the next."
  (save-excursion
    (unless (org-at-heading-p) (org-back-to-heading))
    (cons (org-element-at-point)
          (--unfold (when (and it (not (eq 'headline (org-element-type it))))
                      (cons it (ignore-errors (org-forward-element)
                                              (org-element-at-point))))
                    (when (ignore-errors (org-down-element))
                      (org-element-at-point))))))
#+end_src

*** editing headline descriptions
:PROPERTIES:
:ID: 84867fc3-0808-437a-8037-5ab8e2e2b24e
:END:

As I've [[][mentioned]], Org mode provides syntax to systematically delineate
different languages from one another. Editing the contents of these languages is
typically done through the use of [[helpfn:org-edit-src-code][org-edit-src-code]] (although I do it via
[[helpfn:edit-indirect-region][edit-indirect-region]]). =org-edit-src-code= provides a convenient and elegant way
to edit these languages. It pop open a buffer with the contents of the source block.

However, as I will argue there's one "language" which does not require source
block syntax separation in org mode and that is plain text. In org mode, plain
prose is typically utilized to describe the contents of a headline just as I'm
doing right now. While (I think at least) it is technically not differentiated
from org mode syntax.

However, org mode does not go far enough. If you think about it descriptions
under headlines are also in a "different language"--they're in plain prose. And
this is different from org-mode syntax. They utilize a different editing style
and require different modes from org-mode.

**** whether an element is a paragraph
:PROPERTIES:
:ID: 8f23f8e6-cd9e-4da2-872d-8413fbe2773b
:END:

This function isn't necessary. However, it's very convenient to abbreviate ~(eq
(org-element-type elt) 'paragraph)~--more so because it's a check I perform all
the time.

#+begin_src emacs-lisp
(defun org:element-paragraph-p (element)
  "Return non-nil if the current element is a paragraph."
  (eq (org-element-type element) 'paragraph))
#+end_src

**** point in org element
:PROPERTIES:
:ID: 73a096e6-93d2-4c68-b02f-c31e66cfece5
:END:

#+begin_src emacs-lisp
(defun org:element-contains-point-p (point element)
  "Return t if POINT is inside ELEMENT."
  (and (>= point (org-element-property :begin element))
       (>= (org-element-property :end element) point)))
#+end_src

**** paragraph bounds
:PROPERTIES:
:ID: a049f3ec-8936-499b-af03-e6f4be22163b
:END:

#+begin_src emacs-lisp
(defun org:edit-desc-bounds (point elements)
  "Return the bounds of the description at point.
ELEMENTS is a list of headline elements (see `org:element-headline-elements')."
  (awhen (--first (--any-p (-partial #'org:element-contains-point-p point) it)
                  (thread-last (cdr elements)
                    (-partition-by #'org:element-paragraph-p)
                    (seq-filter (lambda (it) (org:element-paragraph-p (car it))))))
    (cons (org-element-property :contents-begin (-first-item it))
          (org-element-property :contents-end (-last-item it)))))
#+end_src

**** org edit description at point
:PROPERTIES:
:ID: d37dd016-d5ec-4524-974d-d157bba231fc
:END:

#+begin_src emacs-lisp
(defun org/edit:description-at-point ()
  "Edit the description at point."
  (interactive)
  (-let [(beg . end) (org:edit-desc-bounds (point) (org:element-headline-elements))]
    (when (and beg end)
      (edit-indirect-region beg end t))))
#+end_src

**** dwim paragraph bounds
:PROPERTIES:
:ID: 8c321bbc-d6ee-42d6-90f5-ff8b9106c51b
:END:

I don't want to have to travel to a description to edit it. Ideally, I'd like to
travel to anywhere I need within a heading from the headline itself.

#+begin_src emacs-lisp
(defun org:dwim-description-bounds (point elements)
  "Return the beginning and end of description bounds."
  (acond
   ;; There's a paragraph among the elements.
   ((-some->> elements
      (seq-drop-while (-not (-partial #'org:element-contains-point-p (point))))
      (seq-first #'org:element-paragraph-p)
      (org-element-property :begin))
    (org:edit-desc-bounds it elements))
   ;; Skip property drawers.
   ((seq-first (lambda (it) (eq 'property-drawer (org-element-type it)))
               (reverse elements))
    (alet (org-element-property :end it) (cons it it)))
   ;; There's no paragraphs or property drawers.
   ((save-excursion (goto-char (org-element-property :begin (-first-item elements)))
                    (end-of-line)
                    (org-skip-whitespace)
                    (point))
    (cons it it))))
#+end_src

**** maybe add newlines
:PROPERTIES:
:ID: 476da722-8530-4652-821d-77cdd4869680
:END:

Edit indirect has two hooks (four if you include == ==). This is great! The
problem is that you will likely use =edit-indirect= for various different
things. And for these different things, you might want to use different hooks
(i.e. a hook for editing a comment in an =edit-indirect= buffer might not be
appropriate for editing a source block.) You don't want the hooks stepping over
eachother.

The best way I could think of achieving this is through temporary or transient
hooks.

#+begin_src emacs-lisp
(defun edit:indirect-add-newlines-maybe-h ()
  "Add newlines to edit-indirect buffer before commiting."
  (when (aand edit-indirect--overlay
              (= (overlay-start it) (overlay-end it)))
    (add-hook 'edit-indirect-before-commit-hook
              (lambda ()
                ;; (not (string-match-p "\\(?:[[:space:]]\\|\n\\)+" (buffer-string)))
                (end-of-buffer) (insert "\n\n"))
              0
              :local)))
#+end_src

**** dwim edit description
:PROPERTIES:
:ID: b409f0d6-c681-4554-9ee5-2a303bd613b3
:END:

I shouldn't hard-code things modes like =spell-fu= into editing a description.
However, I'll address this later. For now I just want things working well.

#+begin_src emacs-lisp
(defun org/dwim-edit-description ()
  "Edit a description the way I want to."
  (interactive)
  (-let* ((elements (org:element-headline-elements))
          ((beg . end) (org:dwim-description-bounds (point) elements))
          (edit-indirect-guess-mode-function (lambda (&rest _) (text-mode)))
          (edit-indirect-after-creation-hook edit-indirect-after-creation-hook))
    (general-add-hook '(edit-indirect-after-creation-hook)
                      (list #'edit:indirect-add-newlines-maybe-h
                            #'aggressive-fill-paragraph-mode
                            ;; #'spell-fu-mode
                            (lambda () (quiet! (org-link-minor-mode)))
                            #'evil-insert-state))
    (edit-indirect-region beg end t)))
#+end_src

**** org link minor mode
:PROPERTIES:
:ID: 7af9c8bb-f3ad-43a1-8c9b-aeac6a4fdb36
:END:

#+begin_src emacs-lisp
(use-package! org-link-minor-mode
  :commands org-link-minor-mode)
#+end_src

*** editing source blocks
:PROPERTIES:
:ID: c6269fa0-936c-4daf-8803-a4caea3955ef
:END:

Why use this package to edit source blocks when there's already an org function
which does it? One reason is consistently. Eventually, I want all separate
editing buffers to be from =edit-indirect=. That why I don't have to configure
both =edit-indirect= and org source block function to work the way I want; I can
deal with just one source.

**** prevent ending with no newline
:PROPERTIES:
:ID: 9ac56ec5-5fbd-4b5c-bd24-eac81b3b196b
:END:

=edit-indirect= buffers with source block contents must end in a newline
otherwise the =#+end_src= code block delimiter will not end up in its own line
(see this for example).

#+begin_src emacs-lisp
(defun edit:indirect-ensure-end-in-newline-h ()
  "Ensure edit-indirect buffers end with newline."
  (add-hook 'edit-indirect-before-commit-hook
            (lambda () (unless (string-match-p (rx (1+ anything) "\n" eos) (buffer-string))
                         (setf (buffer-string) (concat (buffer-string) "\n"))))
            0
            :local))
#+end_src

**** edit source block at point
:PROPERTIES:
:ID: 786a9971-d0de-4a1a-81e8-82617bdfe88e
:END:

#+begin_src emacs-lisp
(defun org/edit:source-block-at-point ()
  "Edit the source block at point."
  (interactive)
  (alet (org-element-context)
    (when (or (null it) (not (eq 'src-block (org-element-type it))))
      (user-error "No element at point."))
    (-let* (((beg end) (org-src--contents-area it))
            (lang (plist-get (-second-item it) :language))
            (edit-indirect-guess-mode-function `(lambda (&rest _) (funcall (org-src-get-lang-mode ,lang))))
            (edit-indirect-after-creation-hook edit-indirect-after-creation-hook))
      (add-hook 'edit-indirect-after-creation-hook #'edit:indirect-ensure-end-in-newline-h)
      (edit-indirect-region beg end t))))
#+end_src

**** dwim edit source block
:PROPERTIES:
:ID: 195b3fdf-4bea-40e7-9ad2-3621e4de3ddb
:END:

I want to be able to edit a source block without actually going to the source
block.

#+begin_src emacs-lisp
(defun org/dwim-edit-source-block ()
  "Edit the source block."
  (interactive)
  (if (or (org-in-src-block-p)
          (alet (--first (eq (org-element-type it) 'src-block)
                         (org:element-headline-elements))
            (goto-char (org-element-property :begin it))))
      (org/edit:source-block-at-point)
    (user-error "No source block at point.")))
#+end_src

*** editing comments                                                  :disabled:
:PROPERTIES:
:ID: d7f9a526-3906-4b8e-80b9-17e3e12a6061
:END:

Many think of html or markdown when asked about cases where you have many
languages intermingled in one file. However, any programming language with
comments and docstrings is also an example! Comments and docstrings are used to
add plain prose to a language. Necessarily, plain prose requires it's own set of
tools (like spell-checking) which is not something used (at least in the typical
sense) in programming languages. Some solutions to this have been to try to lump
in spell checking and such tools into programming modes (one example is
[[helpfn:flyspell-prog-mode][flyspell-prog-mode]] which checks for spelling only in a language's comments.
However, I argue that this approach is misguided. The problem is not that
programming language modes lack spell-checking in comments; rather, it's that
we're trying to edit plain prose in a file specifically designed to edit the
programming language. Solution? Take the prose out, edit it in a mode with all
prose-editing features enabled, then put it back in. This way we can leverage
existing modes instead of trying to fit everything into one.

**** separedit
:PROPERTIES:
:ID: 678b68dc-67a5-4b96-9f9a-12211ddbd503
:END:

Separedit is a package that's designed for editing comments and docstring in
edit indirect buffers. Interestingly, it can also edit source blocks inside
comments.

#+begin_src emacs-lisp
(use-package! separedit)
#+end_src

**** disable separedit header line
:PROPERTIES:
:ID: caaf863f-fc16-4c50-8b38-dda6f09da45d
:END:

By default =separedit= displays a headerline at the top of its =edit-indirect=
buffer that tells you which binding you need get out of it and the one you need
to abort it. For experienced users (like me), this is not necessary. Therefore,
I remove it.

#+begin_src emacs-lisp
(defhook! separedit:remove-headerline-h ()
  "Disable the separedit headerline."
  (:hook separedit-buffer-creation-hook)
  (setq-local header-line-format nil))
#+end_src

*** bindings inside edit-indirect
:PROPERTIES:
:ID: 42992d1e-5d65-4570-ba96-02b3be31b97b
:END:

I want quick, convenient bindings I can use to abort or commit (which is
=edit-indirect= lingo for writing the contents of the buffer back into its source
file, see [[helpfn:edit-indirect-commit][edit-indirect-commit]].

#+begin_src emacs-lisp
(define-localleader-key! edit-indirect-mode-map
  "," #'edit-indirect-commit
  "c" #'edit-indirect-commit
  "a" #'edit-indirect-abort)
#+end_src

*** org bindings
:PROPERTIES:
:ID: cc9b15f0-3abe-4189-b43b-a70b1f4b215f
:END:

#+begin_src emacs-lisp
(after! (evil edit-indirect)
  (evil-make-overriding-map edit-indirect-mode-map 'normal))

(define-localleader-key! org-mode-map
  "d" #'org/dwim-edit-description
  "e" #'org/dwim-edit-source-block)
#+end_src


** spacing and indentation
:PROPERTIES:
:ID: 4f5e0d70-fe6d-4dda-8949-8154464160e1
:END:

*** aggressive-indent
:PROPERTIES:
:ID: f1b9a36e-26e4-4305-99ae-cbcf6a90013d
:END:

[[https://github.com/Malabarba/aggressive-indent-mode][aggressive-indent]] indents portions of the text your working on as your typing
it. It's pretty smart and very convenient.

#+begin_src emacs-lisp
(use-package! aggressive-indent :hook emacs-lisp-mode-hook)
#+end_src

*** electric indent
:PROPERTIES:
:ID: 4f7e6aa4-be34-4cdd-a2a8-63df24da44a1
:END:

#+begin_src emacs-lisp
(use-package! electric
  :config
  (electric-indent-mode -1))
#+end_src

*** ws-bulter
:PROPERTIES:
:ID: 7e0c30ea-a109-4176-a92b-4a1de4922032
:END:

[[https://github.com/lewang/ws-butler][ws-butler]] cleans up whitespace.

#+begin_src emacs-lisp
(use-package! ws-butler
  :hook (prog-mode-hook org-mode-hook)
  :defer-config
  (append! ws-butler-global-exempt-modes
    '(special-mode comint-mode term-mode eshell-mode)))
#+end_src

*** ialign
:PROPERTIES:
:ID: 55570266-36e8-426e-aef6-5005bce6d73b
:END:

Package [[https://github.com/mkcms/interactive-align][ialign]] lets me use regular expressions to align text.

#+begin_src emacs-lisp
(use-package! ialign :commands ialign)
#+end_src

** lisp editing
:PROPERTIES:
:ID: f616348a-ba44-44f6-aeb6-3dc0a312143e
:END:

*** smartparens
:PROPERTIES:
:ID: 17257f23-c45e-4b7b-a3b4-7fd2333edf4d
:END:

**** bootstrap
:PROPERTIES:
:ID: f1c64411-ad51-4c24-8dad-b4aa7b8fc3b5
:END:

#+begin_src emacs-lisp
(use-package! smartparens
  :hook (prog-mode-hook eshell-mode-hook ielm-mode-hook)
  :setq
  (sp-highlight-pair-overlay . nil)
  (sp-highlight-wrap-overlay . nil)
  (sp-highlight-wrap-tag-overlay . nil)
  (sp-show-pair-from-inside . t)
  (sp-cancel-autoskip-on-backward-movement . nil)
  (sp-show-pair-delay . 0.1)
  (sp-max-pair-length . 4)
  (sp-max-prefix-length . 50)
  (sp-escape-quotes-after-insert . nil)
  :defer-config
  (sp-local-pair 'emacs-lisp-mode "<" ">")
  (require 'smartparens-config)
  (sp-local-pair 'minibuffer-inactive-mode "'" nil :actions nil))
#+end_src

**** disable =smartparens-navigate-skip-match=
:PROPERTIES:
:ID: fda1875b-b3f7-4f43-83b1-873f3db3ae77
:END:

#+begin_src emacs-lisp
(defhook! smartparens:disable-smartparens-navigate-skip-match-h ()
  "Disable smartparents skip match feature."
  :hook after-change-major-mode-hook
  (setq sp-navigate-skip-match nil)
  (setq sp-navigate-consider-sgml-tags nil))
#+end_src

**** autopairing
:PROPERTIES:
:ID: e860ce7e-aaac-477b-a373-a8b01957481d
:END:

#+begin_src emacs-lisp
(defhook! smartparens:init-in-eval-expression-h ()
  "Enable `smartparens-mode' in the minibuffer, during `eval-expression' or
`evil-ex'."
  :hook minibuffer-setup-hook
  (when (memq this-command '(eval-expression evil-ex))
    (smartparens-mode)))
#+end_src

**** enable smartparens in eval-expression
:PROPERTIES:
:ID: f97f493c-33f5-4e59-8c66-14b98150604b
:END:

#+begin_src emacs-lisp
(defhook! smartparens:init-in-minibuffer-h ()
  "Enable smartparens for `eval-expression' and `evil-ex'."
  :hook minibuffer-setup-hook
  (when (memq this-command '(eval-expression evil-ex))
    (smartparens-mode 1)))
#+end_src

*** lispyville
:PROPERTIES:
:ID: 9d22714a-086d-49a1-9f8b-66da3b646110
:END:

[[https://github.com/noctuid/lispyville][lispyville]] helps vim commands work better with lisp by providing
commands (like [[helpfn:lispyville-delete][lispyville-delete]]) which preserve parentheses.

**** initialize
:PROPERTIES:
:ID: 5567b70d-60f2-4161-9a19-d6098f45cd95
:END:

#+begin_src emacs-lisp
(use-package! lispyville
  :commands lispyville-comment-or-uncomment-line
  :hook lisp-mode-hook
  :bind
  ([remap evil-yank]                 . lispyville-yank)
  ([remap evil-delete]               . lispyville-delete)
  ([remap evil-change]               . lispyville-change)
  ([remap evil-yank-line]            . lispyville-yank-line)
  ([remap evil-delete-line]          . lispyville-delete-line)
  ([remap evil-change-line]          . lispyville-change-line)
  ([remap evil-delete-char]          . lispyville-delete-char-or-splice)
  ([remap evil-delete-backward-char] . lispyville-delete-char-or-splice-backwards)
  ([remap evil-substitute]           . lispyville-substitute)
  ([remap evil-change-whole-line]    . lispyville-change-whole-line)
  ([remap evil-join]                 . lispyville-join))
#+end_src

**** text objects
:PROPERTIES:
:ID: d553eee0-9b35-4a7d-a048-0f4a550b2471
:END:

#+begin_src emacs-lisp
(general-def evil-inner-text-objects-map
  "a" #'lispyville-inner-atom
  "l" #'lispyville-inner-list
  "x" #'lispyville-inner-sexp
  "c" #'lispyville-inner-comment
  ;; "f" #'lispyville-inner-function
  ;; "c" #'evilnc-inner-comment
  ;; overriding inner-sentence.
  "s" #'lispyville-inner-string)

(general-def evil-outer-text-objects-map
  "a" #'lispyville-a-atom
  "l" #'lispyville-a-list
  "x" #'lispyville-a-sexp
  "c" #'lispyville-a-comment
  ;; "f" #'lispyville-a-function
  ;; "c" #'evilnc-outer-commenter
  ;; "c" #'evilnc-outer-commenter
  "s" #'lispyville-a-string)
#+end_src

**** slurp/barf
:PROPERTIES:
:ID: 21626641-98e3-4134-958d-03227e4da6b5
:END:

#+begin_src emacs-lisp
(general-def 'normal lispyville-mode-map
  ">" #'lispyville-slurp
  "<" #'lispyville-barf)
#+end_src

**** escape
:PROPERTIES:
:ID: b355e1a1-6242-47f5-b357-5c3f5adbd200
:END:

=lispyville= binds escape to [[helpfn:lipyville-normal-state][lispyville-normal-state]]. So for =void:escape-hook=
to still happen on escape, I need to add [[helpfn:evil:escape-a][evil:escape-a]] as advice to
=lispyville-normal-state=.

Sometimes =evil-normal-state= enters visual state.

#+begin_src emacs-lisp
(general-def '(emacs insert) lispyville-mode-map [escape] #'lispyville-normal-state)
(advice-add #'lispyville-normal-state :after #'evil:dwim-abort-after-escape-a)
#+end_src

**** additional
:PROPERTIES:
:ID: 1fbafa78-87a0-45ee-9c7c-0c703df2ac66
:END:

#+begin_src emacs-lisp
(general-def '(emacs insert) lispyville-mode-map
  "SPC" #'lispy-space
  ";"   #'lispy-comment)

(general-def '(normal visual) lispyville-mode-map
  "M-j" #'lispyville-drag-forward
  "M-k" #'lispyville-drag-backward
  "M-R" #'lispyville-raise-list
  "M-v" #'lispy-convolute-sexp)
#+end_src

*** lispy
:PROPERTIES:
:ID: 4b4bfc73-e4e3-44f0-9553-61ac5182c946
:END:

For learning how to use lispy. [[https://github.com/abo-abo/lispy][the README]] and the [[http://oremacs.com/lispy/#lispy-different][lispy function reference]] were
very useful to me.

#+begin_src emacs-lisp
(use-package! lispy
  :hook emacs-lisp-mode-hook
  :setq
  (lispy-avy-style-paren . 'at-full)
  (lispy-eval-display-style . 'overlay)
  (lispy-safe-delete . t)
  (lispy-safe-copy . t)
  (lispy-safe-paste . t)
  (lispy-safe-actions-no-pull-delimiters-into-comments . t)
  (lispy-delete-sexp-from-within . t)
  (lispy-parens-only-left-in-string-or-comment . nil)
  ;; TODO see how performant is at larger thresholds and optimize
  (lispy-safe-threshold . 5000)
  (lispy-use-sly . t)
  ;; allow space before asterisk for headings (e.g. ";; *")
  (lispy-outline . "^;;\\(?:;[^#]\\|[[:space:]]*\\*+\\)")
  (lispy-key-theme . nil)
  :defer-config
  ;; You'll get void variable if you don't do this.
  (after! avy (setq lispy-avy-keys avy-keys)))
#+end_src

** writing
:PROPERTIES:
:ID: 27e382d7-5735-4f33-87c8-3dec2d2ca082
:END:

*** spell-number
:PROPERTIES:
:ID: 9cc794c5-dc10-4fb5-8af1-dd555c749071
:END:

#+begin_src emacs-lisp
(use-package! spell-number
  :setq
  (spelln-language . 'english-us)
  (spelln-country . 'united-states)
  (spelln-period-character . ?,)
  (spelln-decimal-character . ?.))
#+end_src

*** fill paragraph
:PROPERTIES:
:ID: 4f57fd49-b466-4eea-b91a-2cc8f0b07297
:END:

#+begin_src emacs-lisp
(use-package! aggressive-fill-paragraph)
#+end_src

*** spell check                                                       :disabled:
:PROPERTIES:
:ID: fc68d949-246f-43bf-85c2-7fbb947af7e9
:END:

#+begin_src emacs-lisp
(use-package! spell-fu
  :ensure (:host gitlab :repo "ideasman42/emacs-spell-fu")
  :commands spell-fu-mode
  :setq (spell-fu-directory . (concat VOID:DATA-DIR "spell-fu/")))
#+end_src

*** autocapitalize
:PROPERTIES:
:ID: 35c7c4c0-5009-43d6-8c34-43d6111ceb28
:END:

[[https://github.com/emacsmirror/auto-capitalize][auto-capitalize]] automatically capitalizes the first word of a sentence for me.
It will also upcase any word I add to [[helpvar:auto-capitalize-words][auto-capitalize-words]].

#+begin_src emacs-lisp
(use-package! auto-capitalize
  :setq (auto-capitalize-words . '("I" "English")))
#+end_src

*** thesaurus                                                         :disabled:
:PROPERTIES:
:ID: 5578aaf2-796f-4006-af60-de87b215120a
:END:

#+begin_src emacs-lisp
(use-package! powerthesaurus
  :commands (powerthesaurus-lookup-word-at-point power-thesaurus-lookup-word-dwim))
#+end_src

*** dictionary
:PROPERTIES:
:ID: 9ddc66c9-87be-43d1-8366-1bdb40718892
:END:

#+begin_src emacs-lisp
(use-package! define-it
  :commands define-it define-it-at-point
  :setq
  (define-it-output-choice . 'view)
  (define-it-show-google-translate . nil))
#+end_src

** evil
:PROPERTIES:
:ID: 73366b3e-7438-4abf-a661-ed1553b1b8df
:END:

*** evil
:PROPERTIES:
:ID: 3b9aaf0c-a69c-474a-b1a3-f0e748e83558
:END:

[[https://github.com/emacs-evil/evil][evil]] is an extensible vi layer for Emacs. It emulates the main features of Vim,
and provides facilities for writing custom extensions. Also see our page on
[[emacswiki:Evil][EmacsWiki]]. See a brief [[https://bytebucket.org/lyro/evil/raw/default/doc/evil.pdf][manual]]. See the [[https://github.com/noctuid/evil-guide][evil-guide]] by noctuid.

**** evil
:PROPERTIES:
:ID: 7dba80e1-58d6-46d2-a0e3-64c535e556e2
:END:

#+begin_src emacs-lisp
(use-package! evil
  :require t
  :hook window-setup-hook
  :custom
  (evil-want-C-u-scroll    . t)
  (evil-want-C-d-scroll    . t)
  (evil-want-C-w-delete    . t)
  (evil-want-Y-yank-to-eol . t)
  (evil-overriding-maps    . nil)
  (evil-want-minibuffer    . t)
  :pre-setq
  (evil-want-keybinding                 . nil)
  :setq
  (evil-want-C-w-in-emacs-state         . nil)
  (evil-want-visual-char-semi-exclusive . t)
  ;; Whether the cursor can move past the end of the line.
  (evil-move-beyond-eol                 . nil)
  (evil-magic                           . t)
  (evil-echo-state                      . nil)
  (evil-indent-convert-tabs             . t)
  (evil-ex-search-vim-style-regexp      . t)
  (evil-ex-substitute-global            . t)
  (evil-ex-visual-char-range            . t)
  (evil-insert-skip-empty-lines         . t)
  (evil-mode-line-format                . nil)
  (evil-respect-visual-line-mode        . t)
  (evil-symbol-word-search              . t)
  (shift-select-mode                    . nil))
#+end_src

**** cursors
:PROPERTIES:
:ID: a5f558fb-221c-4b33-a7cd-29308ef74b0d
:END:

It's nice to have cursors change colors (and sometimes shape) depending on the
current evil state. It makes it easy to tell which state you're in. I define
some colors here. Evil has a cursor variable for each state. The cursor variable
for insert state, for example, is [[helpvar:evil-insert-state-cursor][evil-insert-state-cursor]]. Its value is of the
form: ~((CURSOR-SHAPE . CURSOR-WIDTH) COLOR)~.

***** colors and shapes
:PROPERTIES:
:ID: 3f3cd5c9-1f6d-4c3b-b73f-82c9ee00395e
:END:

Evil differentiates what state you're in based on the cursor color.

#+begin_src emacs-lisp
(defhook! evil:init-cursors-h ()
  "Initialize the default cursor shape and size."
  :hook evil-mode-hook
  (setq evil-insert-state-cursor   '((bar . 3)   "chartreuse3"))
  (setq evil-emacs-state-cursor    '((bar . 3)   "SkyBlue2"))
  (setq evil-normal-state-cursor   '( box        "DarkGoldenrod2"))
  (setq evil-visual-state-cursor   '((hollow)    "dark gray"))
  (setq evil-operator-state-cursor '((hbar . 10) "hot pink"))
  (setq evil-replace-state-cursor  '( box        "chocolate"))
  (setq evil-motion-state-cursor   '( box        "plum3")))
#+end_src

***** updating cursors
:PROPERTIES:
:ID: ea4da6d4-4a2c-42cf-b397-cea1555781ce
:END:

After a theme is loaded, the cursor color won't automatically update. Therefore,
I add a hook in [[helpvar:void-after-load-theme-hook][void:after-load-theme-hook]]. Now after a new theme is loaded, the
cursor color will update.

#+begin_src emacs-lisp
(defhook! evil:enable-cursor-refresh-h ()
  "Enable cursor refreshing after theme change."
  :hook evil-mode-hook
  (if (bound-and-true-p evil-mode)
      (add-hook 'void:after-load-theme-hook #'evil-refresh-cursor 100)
    (remove-hook 'void:after-load-theme-hook #'evil-refresh-cursor)))
#+end_src

**** normal state everywhere
:PROPERTIES:
:ID:       e6126bd7-94b8-4ce0-b547-0536b59437ea
:END:

#+begin_src emacs-lisp
(defhook! evil:make-normal-state-default-state-h ()
  :hook evil-mode-hook
  (setq evil-normal-state-modes (append evil-emacs-state-modes evil-normal-state-modes))
  (setq evil-emacs-state-modes nil)
  (setq evil-motion-state-modes nil))

(defadvice! evil:treat-motion-as-normal-state (orig-fn &rest args)
  "Advice for `evil-make-overriding-map' that inhibits motion state."
  :around evil-make-overriding-map
  (-let [(keymap state copy) args]
    (funcall orig-fn keymap (if (eq state 'motion) 'normal state) copy)))

(defadvice! evil:set-initial-state (orig-fn &rest args)
  :around evil-set-initial-state
  (-let [(mode state) args]
    (funcall orig-fn mode (if (eq state 'motion) 'normal state))))

(advice-add #'evil-motion-state :override #'evil-normal-state)
#+end_src

**** insert state in minibuffer
:PROPERTIES:
:ID: a23137c5-62a0-4e77-9e51-6a7372dac703
:END:

Before I just used ~(evil-change-state evil-previous-state)~ to revert the
state back to what it last was. But this fails with ~evil-force-normal-state~
which is what I'm currently using to exit the minibuffer because then the
last state is normal state if the minibuffer is aborted. Using a
=evil:state-before-minibuffer= ensures that the state will be reverted to
the correct one.

#+begin_src emacs-lisp
(defvar evil:state-before-minibuffer nil
  "Evil state before entering in the minibuffer.
This variable will be nil when the minibuffer is closed.")

(defhook! evil:enable-insert-state-in-minibuffer ()
  :hook evil-mode-hook
  (let ((fn (if (bound-and-true-p evil-mode) #'add-hook #'remove-hook)))
    (funcall fn 'minibuffer-enter-hook #'evil:save-state-before-minibuffer-h)
    (funcall fn 'minibuffer-exit-hook #'evil:restore-state-after-minibuffer-h)))

(defun evil:save-state-before-minibuffer-h ()
  "Save state before minibuffer."
  (setq evil:state-before-minibuffer evil-state)
  (evil-insert-state))

(defun evil:restore-state-after-minibuffer-h ()
  "Restore state after minibuffer."
  (evil-change-state evil:state-before-minibuffer)
  (setq evil:state-before-minibuffer nil))
#+end_src

**** escape
:PROPERTIES:
:ID:       e4b9d33d-c64d-47ef-9bff-baa80d1b34b2
:END:

***** escape
:PROPERTIES:
:ID: ea9378de-e5c5-482c-b53b-743a81e3bc8e
:END:

We want escape to be a general "quit everything".

#+begin_src emacs-lisp
(general-define-key :states '(emacs insert) [escape] #'evil-force-normal-state)

(defadvice! evil:dwim-abort-after-escape-a ()
  "Exits out of whatever is happening after escape."
  :after evil-force-normal-state
  (cond ((minibuffer-window-active-p (minibuffer-window))
         (abort-recursive-edit))
        ((run-hook-with-args-until-success 'void:escape-hook))
        ((or defining-kbd-macro executing-kbd-macro) nil)
        (t (keyboard-quit))))
#+end_src

***** TODO keychord integration
:PROPERTIES:
:ID:       33fa6402-f56e-4bea-a9b5-bd5a6f44792f
:END:

Sometimes we don't have access to a convenient escape key--I mean that caps-lock
is not bound to escape. Or, perhaps, we might find it faster or preferable to
press =jk= really quickly to invoke escape.

This is better than evil escape as it only binds in insert.

#+begin_src emacs-lisp
(use-package! key-chord
  :after-call (evil-insert-state evil-emacs-state)
  :defer-config
  (quiet! (key-chord-mode 1))
  (general-define-key :states '(visual insert)
                      (general-chord "jk") 'evil-force-normal-state
                      (general-chord "kj") 'evil-force-normal-state))
#+end_src

**** saving
:PROPERTIES:
:ID: 8181807e-9811-427c-beec-f380d91040f9
:END:

#+begin_src emacs-lisp
(setq save-silently t)

(defun evil:save-message ()
  (message "\"%s\" %dL, %dC written"
           (buffer-name)
           (count-lines (point-min) (point-max))
           (buffer-size)))
#+end_src

**** text objects
:PROPERTIES:
:ID: 07366548-2960-49c6-9ab7-cb177b06ad70
:END:

To edit text efficiently Vim has the concept of [[https://blog.carbonfive.com/2011/10/17/vim-text-objects-the-definitive-guide/][text objects]]. Text objects are
structures that are seen in text. For example, a set of words followed by a
period is a sentence. A words between two closing parentheses is a sexp.

***** general delimiter text object
:PROPERTIES:
:ID: f551956d-440c-431b-8fb0-8e71c9714f11
:END:

I discovered this the =form= text object from using [[https://github.com/luxbock/evil-cleverparens][evil-cleverparens]] in the past.
The package =evil-cleverparens= was too slow for my taste; noctuid's [[https://github.com/sp3ctum/evil-lispy][evil-lispy]] is
much faster and gave me the functionality that I needed most from
=evil-cleverparens=: deleting and copying text with parentheses intelligently.
However, many of the ideas of =evil-cleverparens= were excellent. One particular
idea was to have a general =form= text object. Instead of specifying the
particular surrounding bounds when doing an evil operator command you just use a
single key for them. It's kind of like a =Do-What-I-Mean= surround operator. This
is suprisingly useful because it takes significant time to specify whether you
want =[]= or ={=}= or =()= or =""=. The main drawback you cannot distinguish between
surround characters at multiple levels--it just takes the closest one. In
practice, this is rarely an issue.

#+begin_src emacs-lisp
(after! evil
  (evil-define-text-object evil:textobj-inner-form (count &rest _)
    "Inner sexp object."
    (-if-let ((beg . end)
              (thread-last (list (lispy--bounds-list) (lispy--bounds-string))
                (-non-nil)
                (--sort (< (- (cdr it) (car it)) (- (cdr other) (car other))))
                (car)))
        (evil-range (1+ beg) (1- end) 'inclusive :expanded t)
      (error "No surrounding form found.")))

  (evil-define-text-object evil:textobj-outer-form (count &rest _)
    "Smartparens inner sexp object."
    (-if-let ((beg . end)
              (thread-last (list (lispy--bounds-list) (lispy--bounds-string))
                (-non-nil)
                (--sort (< (- (cdr it) (car it)) (- (cdr other) (car other))))
                (car)))
        (evil-range beg end 'inclusive :expanded t)
      (error "No surrounding form found.")))

  (general-def evil-inner-text-objects-map
    "f" #'evil:textobj-inner-form)
  (general-def evil-outer-text-objects-map
    "f" #'evil:textobj-outer-form))
#+end_src

***** fix vim/evil around =""=
:PROPERTIES:
:ID: b57bf245-3d63-4078-8bcb-2ec0b9952ab9
:END:

=Vim= and =Evil= both have the interesting (inconsistent?) behavior that doing an
outer text object operator on a comment grabs some whitespace on the left side.
Try doing =va"= to ~(progn "hello world")~ and you'll see that =\s"hello world"= is
selected instead of just "hello world".

Why not just go to the end of the ="= like any other around operator?

#+begin_src emacs-lisp
(after! evil
  (evil-define-text-object evil:textobj-a-string (count &rest _)
    "An outer comment text object as defined by `lispy--bounds-string'."
    (-if-let ((beg . end) (lispy--bounds-string))
        (evil-range beg end 'exclusive :expanded t)
      (error "Not inside a comment.")))

  (general-def evil-outer-text-objects-map
    "\"" #'evil:textobj-a-string))
#+end_src

**** package specific setup                                           :disabled:
:PROPERTIES:
:ID: 5f9025e0-156c-4270-96ab-49011df83632
:END:

***** helpful
:PROPERTIES:
:ID: 81552b9b-46aa-46c8-8541-500059dda695
:END:

#+begin_src emacs-lisp
(after! (evil helpful)
  (evil-set-initial-state 'helpful-mode 'normal))
#+end_src

***** magit
:PROPERTIES:
:ID: a27830b2-b60a-4aca-b65a-4042392d7105
:END:

#+begin_src emacs-lisp
(after! (evil magit)
  (add-hook 'git-commit-mode-hook #'evil-insert-state))
#+end_src

***** org
:PROPERTIES:
:ID: 62d87b9a-6219-4feb-b46c-a6e2e4155a90
:END:

****** insert state
:PROPERTIES:
:ID: b9cde044-5190-4789-97c4-a124c6701cd4
:END:

#+begin_src emacs-lisp
(after! (evil org)
  (add-hook 'org-insert-heading-hook #'evil-insert-state)
  (after! org-capture
    (add-hook 'org-capture-mode-hook #'evil-insert-state)))
#+end_src

***** Info                                                            :disabled:
:PROPERTIES:
:ID: c6c401dc-a7cf-460d-9188-1ee8bb2dad24
:END:

#+begin_src emacs-lisp
(general-define-key
 (:map Info-mode-map)
 (:m "h"   #'Info-backward-node)
 (:m "l"   #'Info-forward-node)
 (:m "H"   #'Info-history-back)
 (:m "L"   #'Info-history-forward)
 (:m "r"   #'Info-history)
 (:m "J"   #'evil-scroll-page-down)
 (:m "K"   #'evil-scroll-page-up)
 (:m "f"   #'ace-link-info)
 (:m "u"   #'Info-up)
 (:m "U"   #'Info-top-node)
 (:m "m"   #'Info-menu)
 (:m "s"   #'Info-search)
 (:m "RET" #'Info-follow-nearest-node)
 (:m "q"   #'quit-window))
#+end_src

***** eshell
:PROPERTIES:
:ID: 0a974596-2004-4ed2-9053-8bc6db1acd84
:END:

****** evil operators
:PROPERTIES:
:ID: 142162a1-0495-427e-bac6-f2e8e63dd184
:END:

******* evil-change
:PROPERTIES:
:ID: 1a47ff34-8f3b-4845-b3e9-0ae0937c5c84
:END:

#+begin_src emacs-lisp
(after! eshell
  (evil-define-operator eshell/evil-change (beg end type register yank-handler delete-func)
    "Like `evil-change' but will not delete/copy the prompt."
    (interactive "<R><x><y>")
    (save-restriction
      (narrow-to-region eshell-last-output-end (point-max))
      (evil-change (max beg (point-min))
                   (if (eq type 'line) (point-max) (min (or end (point-max)) (point-max)))
                   type register yank-handler delete-func))))
#+end_src

******* evil-change-line
:PROPERTIES:
:ID: 296c4f58-261f-4f1b-a333-7807ebef331b
:END:

#+begin_src emacs-lisp
(after! eshell
  (evil-define-operator eshell/evil-change-line (beg end type register yank-handler)
    "Change to end of line."
    :motion evil-end-of-line
    (interactive "<R><x><y>")
    (eshell/evil-change beg end type register yank-handler #'evil-delete-line)))
#+end_src

******* evil-delete
:PROPERTIES:
:ID: 63b0c253-a59e-409a-b593-36ddd84d8777
:END:

#+begin_src emacs-lisp
(after! eshell
  (evil-define-operator eshell/evil-delete (beg end type register yank-handler)
    "Like `evil-delete' but will not delete/copy the prompt."
    (interactive "<R><x><y>")
    (save-restriction
      (narrow-to-region eshell-last-output-end (point-max))
      (evil-delete (if beg (max beg (point-min)) (point-min))
                   (if (eq type 'line) (point-max) (min (or end (point-max)) (point-max)))
                   type register yank-handler))))
#+end_src

******* evil-delete-line
:PROPERTIES:
:ID: 017b5fe8-a27e-4bab-a014-8bf53258b92a
:END:

#+begin_src emacs-lisp
(after! eshell
  (evil-define-operator eshell/evil-delete-line (_beg end type register yank-handler)
    "Change to end of line."
    :motion nil
    :keep-visual t
    (interactive "<R><x>")
    (eshell/evil-delete (point) end type register yank-handler)))
#+end_src

****** update cursors after entering eshell
:PROPERTIES:
:ID: 5384f57c-9eba-4f00-953a-92814a253ce9
:END:

#+begin_src emacs-lisp
(after! evil
  (evil-set-initial-state 'eshell-mode 'insert))
#+end_src

***** smartparens
:PROPERTIES:
:ID: 4977e770-2c5b-4819-8c6d-ed2c794737fe
:END:

#+begin_src emacs-lisp
;; smartparens breaks evil-mode's replace state
(after! (evil smartparens)
  (add-hook 'evil-replace-state-entry-hook #'turn-off-smartparens-mode)
  (add-hook 'evil-replace-state-exit-hook  #'turn-on-smartparens-mode))
#+end_src

***** debugger-mode
:PROPERTIES:
:ID: 614215d3-33b1-482e-bf0e-c9d66cdb1c24
:END:

#+begin_src emacs-lisp
(after! evil (evil-set-initial-state 'debugger-mode 'emacs))
#+end_src

***** autoyasnippet
:PROPERTIES:
:ID: 851aaa47-5220-43a2-9861-b36d4cb9b803
:END:

#+begin_src emacs-lisp
(use-package! auto-yasnippet
  :defer-config (advice-add #'aya-expand :after #'evil-insert-state)
  :setq (aya-persist-snippets-dir . (concat VOID:LOCAL-DIR "auto-snippets/")))
#+end_src

***** yasnippet
:PROPERTIES:
:ID: d3b2a618-d008-427e-9947-44741bb0bbf9
:END:

#+begin_src emacs-lisp
(after! (evil lispy)
  (define-key!
    (:map evil-lispy-state-map)
    ("l" #'lispy-right)
    ("h" #'lispy-left)
    ("f" #'lispy-flow)
    ("j" #'lispy-down)
    ("k" #'lispy-up)
    ("d" #'lispy-different)
    ("o" #'lispy-other-mode)
    ("p" #'lispy-eval-other-window)
    ("P" #'lispy-paste)
    ("y" #'lispy-occur)
    ("z" #'lh-knight/body)))
#+end_src

*** evil-surround
:PROPERTIES:
:ID: ef933441-4891-48d8-a4aa-016702e55b48
:END:

#+begin_src emacs-lisp
(use-package! evil-surround :hook prog-mode-hook text-mode-hook)
#+end_src

*** evil-matchit
:PROPERTIES:
:ID: 30ff273a-253b-4cdc-8e86-22e5705f44c1
:END:

#+begin_src emacs-lisp
(use-package! evil-matchit :hook prog-mode)
#+end_src

*** evil-exchange
:PROPERTIES:
:ID: d1c40ac0-d143-4e27-847b-d3d8e72a552a
:END:

Package [[https://github.com/Dewdrops/evil-exchange][evil-exchange]] lets me swap two regions of text.

#+begin_src emacs-lisp
(use-package! evil-exchange
  :commands evil-exchange
  :init
  (general-def 'normal
    :prefix "g"
    "X" (list :def #'evil-exchange-cancel :wk "cancel")
    "x" (list :def #'evil-exchange :wk "exchange")))
#+end_src

*** evil-visualstar
:PROPERTIES:
:ID: 6ebca72d-f90a-4423-9ecd-706f9d426002
:END:

[[https://github.com/bling/evil-visualstar][evil-visualstar]]

#+begin_src emacs-lisp
(use-package! evil-visualstar
  :commands (evil-visualstar/begin-search-backward evil-visualstar/begin-search-forward)
  :bind (:evil-visual-state-map
         ("#" . evil-visualstar/begin-search-backward)
         ("*" . evil-visualstar/begin-search-forward)))
#+end_src

** expand-region
:PROPERTIES:
:ID: 417c9c53-a776-4779-9afc-1eaa35a145c6
:END:

[[https://github.com/magnars/expand-region.el][expand-region]] allows me to toggle a key ("v" in my case) to select progressively
larger text objects. It's saves me keystrokes.

#+begin_src emacs-lisp
(use-package! expand-region
  :commands (er/expand-region er/contract-region er/mark-symbol er/mark-word)
  :init
  (general-def 'visual
    "V" #'er/contract-region
    "v" #'er/expand-region)
  :defer-config
  (defadvice! void:quit-expand-region-a ()
    "Properly abort an expand-region region."
    :before evil-escape evil:escape-a
    (when (memq last-command '(er/expand-region er/contract-region))
      (er/contract-region 0))))
#+end_src

** avy
:PROPERTIES:
:ID: 71d016e2-a118-4468-8a01-fe86863bc030
:END:

[[https://github.com/abo-abo/avy][Avy]]

*** bootstrap
:PROPERTIES:
:ID: eff03171-05b3-4a70-93ee-0a0f2b2c64f4
:END:

#+begin_src emacs-lisp
(use-package! avy
  :commands avy-jump
  :setq
  (avy-background . t)
  ;; Jump only on current window.
  (avy-all-windows . nil)
  ;; Use avy keys.
  (avy-keys-alist . nil)
  (avy-keys . (list
               ;; homerow keys in alternating order.
               ?a ?j ?s ?k ?d ?l ?f ?\;
               ;; middle homerow keys
               ?g ?h
               ;; keys above homerow in alternating order
               ?t ?y ?r ?u ?e ?i ?w ?o ?q ?p
               ;; keys below homerow
               ?b ?n ?v ?m ?c ?, ?x ?. ?z ?/))
  (avy-style . 'at))
#+end_src

*** avy-command-helper
:PROPERTIES:
:ID:       814e98f9-5823-4e8f-9f89-49cdecf3d809
:END:

#+begin_src emacs-lisp
(defun avy:jump-to-regexp (regexp)
  (avy-jump regexp
            :beg (window-start)
            :end (window-end)
            :pred `(lambda () (/= (1+ ,(point)) (point)))))
#+end_src

*** avy commands
:PROPERTIES:
:ID: 01ee387f-f153-497e-b9fb-d62d5df9ebe1
:END:

#+begin_src emacs-lisp
(defun void/evil-beginning-of-word ()
  (interactive)
  (avy:jump-to-regexp (rx word-start nonl)))

(defun void/evil-beginning-of-WORD ()
  (interactive)
  (avy:jump-to-regexp (rx symbol-start nonl)))

(defun void/evil-end-of-word ()
  (interactive)
  (avy:jump-to-regexp (rx nonl word-end)))

(defun void/evil-end-of-WORD ()
  (interactive)
  (avy:jump-to-regexp (rx nonl symbol-end)))
#+end_src

*** bindings
:PROPERTIES:
:ID: a8febb0e-768b-412d-9d86-1f1439eced0e
:END:

#+begin_src emacs-lisp
(general-def 'normal
  "f" #'avy-goto-char
  "w" #'void/evil-beginning-of-word
  "W" #'void/evil-beginning-of-WORD
  "e" #'void/evil-end-of-word
  "E" #'void/evil-end-of-WORD)
#+end_src

** undo                                                               :disabled:
:PROPERTIES:
:ID: 87fde0b2-5db6-4b5f-8945-d469449f1207
:END:

*** undo-fu
:PROPERTIES:
:ID: 2cb27d5e-e26c-4805-9ee7-f93222d75220
:END:

#+begin_src emacs-lisp
(use-package! undo-fu
  :after-hook void:after-switch-buffer-hook
  :before-call after-find-file
  :setq
  (undo-limit . 400000)
  (undo-strong-limit . 3000000)
  (undo-outer-limit . 3000000)
  :bind
  ([remap undo] . undo-fu-only-undo)
  ([remap redo] . undo-fu-only-redo)
  :defer-config
  (global-undo-tree-mode -1))
#+end_src

* Utility
:PROPERTIES:
:ID: 15266577-fc6e-4ec7-8277-3a94b6f4f926
:END:

** eshell
:PROPERTIES:
:ID: 5f04a252-2985-46b4-ab0b-eb4567de5dd9
:END:

[[info:eshell#Top][eshell]] is a built-in shell written entirely in elisp. This means that it's as
portable and customizable as emacs itself. It can run elisp functions as
commands. There's a good article about it in [[https://masteringemacs.org/article/complete-guide-mastering-eshell][mastering-emacs]]. Other articles I
have like about eshell: [[https://ambrevar.xyz/emacs-eshell/][ambrevar's eshell post]], [[http://www.howardism.org/Technical/Emacs/eshell-fun.html][Howard Abram's Post]].

*** bootstrap
:PROPERTIES:
:ID: 8ed5b69c-be1f-4181-bd01-88fc33b148d6
:END:

#+begin_src emacs-lisp
(use-feature! eshell
  :commands eshell
  :load-incrementally
  em-alias em-banner em-basic em-cmpl
  em-dirs em-glob em-hist em-ls em-prompt
  em-script em-term em-unix
  :popup ("\\*eshell"
          (display-buffer-at-bottom)
          (window-height . 0.5)
          (side . bottom)
          (slot . 2))
  :setq
  (eshell-directory-name . (concat VOID:DATA-DIR "eshell/"))
  (eshell-history-file-name . (concat eshell-directory-name "history"))
  (eshell-prefer-lisp-functions . nil)
  (eshell-scroll-to-bottom-on-input . 'all)
  (eshell-scroll-to-bottom-on-output . 'all)
  (eshell-buffer-shorthand . t)
  (eshell-kill-processes-on-exit . t)
  (eshell-hist-ignoredups . t)
  (eshell-input-filter . #'eshell-input-filter-initial-space)
  (eshell-glob-case-insensitive . t)
  (eshell-error-if-no-glob . t)
  (eshell-banner-message . '(format "%s %s\n\n"
                             (propertize (format " %s " (string-trim (buffer-name)))
                              'face 'mode-line-highlight)
                             (propertize (current-time-string)
                              'face 'font-lock-keyword-face)))
  :defer-config
  (remove-hook 'eshell-output-filter-functions
               'eshell-postoutput-scroll-to-bottom))
#+end_src

*** visual commands
:PROPERTIES:
:ID: fedfa200-7d17-408d-ba42-da401cba6419
:END:

#+begin_src emacs-lisp
(after! em-term
  (dolist (command '("tmux" "htop" "bash" "zsh" "fish" "vim" "nvim" "ncmpcpp"))
    (add-to-list 'eshell-visual-commands command)))
#+end_src

*** improvements
:PROPERTIES:
:ID: b3da5d39-1591-4a19-ae96-45a117a13f24
:END:

Eshell uses pcomplete as its completion engine.

**** pcomplete
:PROPERTIES:
:ID: 63de7a7f-431c-4652-aa55-45973b5a4c2a
:END:

This replaces the default popup window at the bottom of eshell. By using the
=completion-in-region= backend, it triggers ivy/helm for completion.

#+begin_src emacs-lisp
(defun eshell/pcomplete ()
  "Use pcomplete with completion-in-region backend."
  (interactive)
  (require 'pcomplete)
  (ignore-errors (pcomplete-std-complete)))
#+end_src

**** go to prompt on insert
:PROPERTIES:
:ID: 76bd909c-901c-4bc6-8848-d84b121a06c3
:END:

#+begin_src emacs-lisp
(defun eshell:goto-prompt-on-insert-h ()
  "Move cursor to the prompt when switching to insert mode."
  (when (< (point) eshell-last-output-end)
    (goto-char
     (if (memq this-command '(evil-append evil-append-line))
         (point-max)
       eshell-last-output-end))))
#+end_src

*** eshell commands
:PROPERTIES:
:ID: 4a7074f6-7f53-4950-9c92-be39b23e1d70
:END:

**** eshell-z
:PROPERTIES:
:ID: 497798a0-7b62-4779-bf15-f67500528f03
:END:

#+begin_src emacs-lisp
(use-package! eshell-z
  :after eshell
  :commands eshell/z
  :setq (eshell:z-file . (expand-file-name "z" eshell-directory-name))
  :defer-config
  (defalias 'eshell:z-file 'eshell-z-freq-dir-hash-table-file-name))
#+end_src

**** eshell-up
:PROPERTIES:
:ID: 478219b9-1c6f-4907-b428-a2dfe0f45e5c
:END:

This is an Emacs package for quickly navigating to a specific parent directory
in ~eshell~ without having to repeatedly typing ~cd ..~.

#+begin_src emacs-lisp
(use-package! eshell-up
  :after eshell
  :commands eshell-up eshell-up-peek
  :init
  (defalias 'eshell/up 'eshell-up)
  (defalias 'eshell/pk 'eshell-up-peek)
  (defalias 'eshell/peek 'eshell-up-peek))
#+end_src

**** eshell-clear
:PROPERTIES:
:ID: 6ae332e7-f2e8-4a78-9bb8-c9b4f271a6a2
:END:

The shell often gets cluttered with many commands. It's often useful to clear it
and indeed there are many suggestions on how to do so online. However, many of
them involve erasing the eshell buffer or making it's previous contents
inaccessable. I don't like getting rid of information that could be important.
All I really wanted is to just scroll up to the top of the window so that the
previous contents weren't visible. Note that it is important that this command
returns nil. Eshell shell ignores output returns nil. However, when it returns
non-nil it prints it to the eshell buffer, which results in a residue
line--that's not what we want.

https://emacs.stackexchange.com/questions/28819/eshell-goes-to-the-bottom-of-the-page-after-executing-a-command

#+begin_src emacs-lisp
(defun eshell/clear ()
  "Scroll eshell buffer to top.
The effect of this is to clear the contents of the eshell buffer."
  (progn (call-interactively #'evil-scroll-line-to-top) nil))
#+end_src

*** display
:PROPERTIES:
:ID: 66d647e3-b83b-4469-bb62-75546c2fee64
:END:

**** banner message
:PROPERTIES:
:ID: c104955c-4109-4d49-8e1d-1a78b7ed2170
:END:

The banner message is the text above the eshell prompt that you see initially
which says /"Welcome to the Emacs Shell"/.

#+begin_src emacs-lisp
#+end_src

**** prompt
:PROPERTIES:
:ID: c21591c9-43a2-4c6b-aac8-b46b41f4dc63
:END:

I got a lot of inspiration from the [[http://www.modernemacs.com/post/custom-eshell/][modern emacs blog]]. I think the
author's code is in general a good example of how to use macros to abstract a
task and make it much simpler than it would be otherwise.

***** with-face
:PROPERTIES:
:ID: ae757b22-27e1-4243-8da0-35c3a8e6ff65
:END:

#+begin_src emacs-lisp
(defmacro with-face! (string &rest props)
  "Return STR propertized with PROPS."
  `(propertize ,string 'face '(,@props)))
#+end_src

***** helpers
:PROPERTIES:
:ID: c29bac50-32e4-4128-8446-6f4153d3a7a0
:END:

Eshell prompt function finds eshell section functions specified by
[[helpvar:eshell:enabled-sections][+eshell-enabled-sections]] and concatenates their results in order to
generate the body of the eshell prompt.

#+begin_src emacs-lisp
(defun eshell:acc (acc x)
  "Accumulator for evaluating and concatenating `eshell:enabled-sections'."
  (--if-let (funcall x)
      (if (s-blank? acc)
          it
        (concat acc eshell:sep it))
    acc))

(defun eshell:prompt-func ()
  "Generate the eshell prompt.
This function generates the eshell prompt by concatenating `eshell:header' with
valid `eshell:enabled-sections' and the `eshell-prompt-string'."
  (concat eshell:header
          (thread-last eshell:enabled-sections
            (seq-map (lambda (it) (void:symbol-intern 'eshell-prompt-- it)))
            (seq-filter #'fboundp)
            (-reduce-from #'eshell:acc ""))
          eshell-prompt-string))
#+end_src

***** eshell components
:PROPERTIES:
:ID: c22a9cdb-9b9f-4f06-9c09-f330d454ab1f
:END:

This heading contains the parts that make up the eshell prompt. They are the
header, the separator, the section delimiter and, the meat of the prompt, the
actual eshell sections.

#+begin_src emacs-lisp
(defvar eshell:sep "\s|\s"
  "Separator between eshell sections.")

(defvar eshell:section-delim "\s"
  "Separator between an eshell section icon and form.")

(defvar eshell:header "\s"
  "Eshell prompt header.")

(defvar eshell:enabled-sections '(dir git)
  "List of enabled eshell sections.
Each element of the list is an abbreviated.")

;; This is a regex that matches your eshell prompt so that eshell knows what to
;; keep readonly and what not to.
(setq eshell-prompt-regexp (rx (*? anything) "-> "))
(setq eshell-prompt-string " -> ")

(setq eshell-prompt-function #'eshell:prompt-func)
#+end_src

**** text wrapping
:PROPERTIES:
:ID: 7d155cf8-a90c-4183-a9be-5ffdc266d82a
:END:

#+begin_src emacs-lisp
(defhook! eshell:enable-text-wrapping-h ()
  "Enable text wrapping."
  :hook eshell-mode-hook
  (visual-line-mode +1)
  (set-display-table-slot standard-display-table 0 ?\ ))
#+end_src

**** fringes
:PROPERTIES:
:ID: 312652e5-9975-4241-b709-7ed5b8537202
:END:

#+begin_src emacs-lisp
(defhook! eshell:remove-fringes-h ()
  "Remove fringes for eshell."
  :hook eshell-mode-hook
  (set-window-fringes nil 0 0)
  (set-window-margins nil 1 nil))
#+end_src

**** hide modeline
:PROPERTIES:
:ID: 6dc13e60-abd4-40d0-be15-55b11c1faeb2
:END:

#+begin_src emacs-lisp
(add-hook 'eshell-mode-hook #'hide-mode-line-mode)
#+end_src

*** hooks
:PROPERTIES:
:ID: bfe31d56-9fae-4841-b078-d1f276f29611
:END:

**** aliases
:PROPERTIES:
:ID: 4f53fbac-9d9f-4e58-8e3a-0baad56d2ae9
:END:

***** setup
:PROPERTIES:
:ID: 1a346816-85a1-402e-81ac-c0dd0ef6dfc7
:END:

They are meant to emulate useful shell utilities, like fasd and bd.
Note that you may overwrite these in your [[helpvar:eshell-aliases-file][eshell-aliases-file]]. This is
here to provide an alternative, elisp-centric way to define your
aliases.

#+begin_src emacs-lisp
(defvar eshell:aliases
  '(("q"  "exit")
    ("ff"  "find-file $1")
    ("rg" "rg --color=always $*")
    ("ag" "ag --color=always $*")
    ("l"  "ls -lh")
    ("ll" "ls -lah"))
  "An alist of default eshell aliases. ")
#+end_src

***** initialize
:PROPERTIES:
:ID: 08af337e-61f3-4dce-bbf8-bab10c8d9793
:END:

#+begin_src emacs-lisp
(defvar eshell--default:aliases nil)

(defhook! eshell:init-aliases-h ()
  "Initialize eshell aliases."
  :hook eshell-alias-load-hook
  (setq eshell--default:aliases eshell-command-aliases-list
        eshell-command-aliases-list
        (append eshell-command-aliases-list
                eshell:aliases)))

(advice-add #'eshell-write-aliases-list :override #'ignore)
#+end_src

*** shrink-path
:PROPERTIES:
:ID: eef8ea28-4de2-44ab-a09d-26f58c0a75ac
:END:

#+begin_src emacs-lisp
(use-package! shrink-path
  :commands shrink-path-file)
#+end_src

** TODO org goto heading
:PROPERTIES:
:ID: 7c70f9e4-c47f-4f2c-8b0d-9bafac116be6
:END:

*** selectrum
:PROPERTIES:
:ID: 70aaadda-abfe-4ac2-af31-229d2208a859
:END:

#+begin_src emacs-lisp
(defun org/jump-to-headline ()
  "Prompt the user to select one of the headline paths.
And go to the start of the path selected by the headline."
  (interactive)
  (let ((selectrum-should-sort-p nil)
        (selectrum-refine-candidates-function #'selectrum-default-candidate-refine-function)
        (paths (org:headline-paths)))
    (--> (seq-map #'car paths)
         (completing-read "Headlines: " it)
         (alist-get it paths nil nil #'string=)
         (goto-char it))
    (org-adjust-nearby-headlines-a)
    (when (org:heading-folded-p)
      (outline-toggle-children))))
#+end_src

*** steps to add selectrum
:PROPERTIES:
:ID: a252c3c0-c4e7-43cf-b916-f1e956f1ba98
:END:

#+begin_src emacs-lisp
(defun org:headline-paths ()
  "Return an alist whose elements are (headline-path . point).
HEADLINE-PATH is the path to a headline and POINT is the start of the headline."
  (save-excursion
    (goto-char (point-min))
    (let ((case-fold-search nil))
      (--unfold
       (when (re-search-forward void:headline-regexp nil t nil)
         (let ((last-level (length it))
               (level (length (match-string 1)))
               (headline (match-string-no-properties 4))
               (start (match-beginning 0)))
           (setq it (cons headline
                          (nthcdr (max 0 (1+ (- last-level level))) it)))
           (cons (cons (s-join "/" (reverse it)) start) it)))
       nil))))
#+end_src

** command-log-mode
:PROPERTIES:
:ID: 10226327-4c31-41db-b202-e4a9f44fc6fe
:END:

[[https://github.com/lewang/command-log-mode][command-log-mode]] keeps track of all the commands you run and displays them to
you on a side window.

#+begin_src emacs-lisp
(use-package! command-log-mode
  :commands command-log-mode global-command-log-mode
  :setq
  (command-log-mode-auto-show . t)
  (command-log-mode-open-log-turns-on-mode . nil)
  (command-log-mode-is-global . t))
#+end_src

** recentf
:PROPERTIES:
:ID: f26bedb3-a172-4543-afd0-4c47f5872d15
:END:

=recentf= is a built-in program that tracks the files you've opened recently
persistently. This is a great idea because these are the files you'll likely
revisit. In practice, I look at this list of files in addition to the buffers I
already have open using a [[][completion-framework]]. Because of this I rarely
have to set out to look for a file with =dired=.

*** recentf
:PROPERTIES:
:ID: 527f55e1-48c3-4d90-a2ef-9dd463e6d1fd
:END:

#+begin_src emacs-lisp
(use-feature! recentf
  :before-call find-file
  :load-incrementally easymenu tree-widget timer
  :commands recentf-open-files
  :defer-config
  (advice-add #'recentf-save-list :before #'recentf-cleanup)
  (recentf-mode 1)
  :setq
  (recentf-exclude . (list #'file-remote-p
                           "\\.\\(?:gz\\|gif\\|svg\\|png\\|jpe?g\\)$"
                           ;; ignore private Void temp files (but not all of them)
                           #'(lambda (file)
                               (-any-p (-partial #'file-in-directory-p file)
                                (list VOID:DATA-DIR)))))
  (recentf-max-menu-items . 0)
  (recentf-max-saved-items . 700)
  :custom
  (recentf-save-file . (concat VOID:DATA-DIR "recentf"))
  (recentf-auto-cleanup . 'never)
  (recentf-filename-handlers . '(file-truename abbreviate-file-name)))
#+end_src

*** silence recentf
:PROPERTIES:
:ID: 15a971c4-b43a-4539-846e-70fe4e90d84a
:END:

#+begin_src emacs-lisp
(defadvice! recentf:shut-up-a (orig-fn &rest args)
  "Shut up recentf."
  :around recentf-mode
  (shut-up! (apply orig-fn args)))
#+end_src

** saveplace
:PROPERTIES:
:ID: 6da42724-3137-4d70-9aed-9a978357679f
:END:

As its name suggests, =save-place= is a built-in package that stores the buffer
location you left off at in a particular buffer. When you visit that buffer
again, you are taken to the location you left off. This is very convenient.

#+begin_src emacs-lisp
(use-feature! saveplace
  :after-call after-find-file
  :setq
  (save-place-file . (concat VOID:DATA-DIR "saveplace"))
  (save-place-limit . nil)
  :config
  (save-place-mode)
  (defadvice! save-place-recenter-on-load-saveplace-a (&rest _)
    "Recenter on cursor when loading a saved place."
    :after-while save-place-find-file-hook
    (when buffer-file-name (ignore-errors (recenter)))))
#+end_src

** savehist
:PROPERTIES:
:ID: 23867595-32fd-4270-97bd-3101cc681f00
:END:

#+begin_src emacs-lisp
(use-package! savehist
  :load-incrementally custom
  :hook emacs-startup-hook
  :setq
  (savehist-save-minibuffer-history . t)
  (savehist-autosave-interval       . nil)
  (savehist-additional-variables    . '(kill-ring search-ring regexp-search-ring))
  (savehist-file                    . (concat VOID:DATA-DIR "savehist")))

(defhook! void:unpropertize-kill-ring-h ()
  "Remove text properties from `kill-ring'."
  :append kill-emacs-hook
  (setq kill-ring
        (seq-map (lambda (it) (when (stringp it) (substring-no-properties it)))
                 (-non-nil kill-ring))))
#+end_src

** bookmarks
:PROPERTIES:
:ID: e1a569f8-d27a-4e0c-924a-3b123c62b6a2
:END:

[[info:emacs#Bookmarks][Bookmarks]] persistently store file locations. I use [[https://github.com/emacsmirror/bookmark-plus][bookmark-plus]] an increadibly
featureful bookmark extension package. Usually =xah lee= has good basic overviews
of topics on his site, check out the [[http://ergoemacs.org/emacs/bookmark.html — Emacs: Bookmark][one on bookmarks]]. I had already known about
=bookmark-plus=, however I hadn't really done anything with it. It was after I
read this [[https://emacs.stackexchange.com/questions/51853/retracing-steps-with-emacs-when-programming-exploring — search - Retracing steps with emacs (When programming /exploring) - Emacs Stack Exchange][question]].

#+begin_src emacs-lisp
(use-feature! bookmark
  :tag "built-in"
  :pre-setq
  (bookmark-default-file . (concat VOID:DATA-DIR "bookmarks"))
  (bookmark-save-flag . t))
#+end_src

** elfeed
:PROPERTIES:
:ID: 7454a51a-cb50-47e4-b0ab-7ac493d9d09d
:END:

[[https://github.com/skeeto/elfeed][elfeed]] is a news feed reader. I can give it a set of rss-feeds to blogs I like
to read and then read the articles in emacs! Typically, you'd set the feeds via
[[helpvar:elfeed-feeds][elfeed-feeds]], but with [[https://github.com/remyhonig/elfeed-org][elfeed-org]] I can do it by specifying a set of org files
from which to read my feeds. The org file I use is [[file:.local/config/elfeed.org][elfeed.org]]. The [[helpvar:rmh-elfeed-org-tree-id][rmh-elfeed-org-tree-id]] is the
tags that =elfeed-org= will consider when checking for feeds. Note that it's
case-sensitive so consider this if your tags (like me) capitalized. The
[[helpvar:elfeed-search-filter][elfeed-search-filter]] specifies how far back to go when looking for newsfeed
posts. So if you have some infrequent blogs, you might have to go further back
in time to see older posts.

#+begin_src emacs-lisp
(use-package! elfeed
  :commands elfeed
  :setq
  (elfeed-search-filter         . "@1-year-old")
  (elfeed-db-directory          . (concat VOID:DATA-DIR "elfeed/db/"))
  (elfeed-enclosure-default-dir . (concat VOID:DATA-DIR "elfeed/enclosures/"))
  (elfeed-show-entry-switch     . #'pop-to-buffer)
  (elfeed-show-entry-delete     . #'elfeed-kill-buffer)
  (shr-max-image-proportion     . 0.8))
#+end_src

** elfeed org
:PROPERTIES:
:ID: e385b9b0-4681-4faa-9bfe-c759080ff5d9
:END:

#+begin_src emacs-lisp
(use-package! elfeed-org
  :after elfeed
  :require t
  :setq
  (rmh-elfeed-org-files      . (list (concat VOID:ORG-DIR "elfeed.org")))
  (rmh-elfeed-org-tree-id    . "ELFEED")
  (rmh-elfeed-org-ignore-tag . "IGNORE"))
#+end_src

** pomodoro
:PROPERTIES:
:ID: d8056c5a-6b10-49d1-befc-842cea64419e
:END:

[[https://github.com/baudtack/pomodoro.el][pomodoro]] is meant to provide functions to follow the pomodoro style of working.
There is a slight lag in emacs when I play a sound with ~(play-sound-file sound)~.
I might consider doing this asynchronously.

#+begin_src emacs-lisp
(use-package! pomodoro
  :commands pomodoro-start
  :setq
  (pomodoro-play-sounds       . t)
  (pomodoro-work-start-sound  . "~/Music/beeps/A-Tone-His_Self-1266414414.wav")
  (pomodoro-break-start-sound . "~/Music/beeps/A-Tone-His_Self-1266414414.wav")
  (pomodoro-work-time         . 25)
  (pomodoro-break-time        . 5)
  (pomodoro-long-break-time   . 15))

(defadvice! pomodoro:play-sound-a (sound)
  "Play sound without using the call-process."
  :override play-pomodoro-sound
  (play-sound-file sound))
#+end_src

** file browsing
:PROPERTIES:
:ID: a8a9edfe-a4c0-4531-92d5-a59991f4af92
:END:

*** dired
:PROPERTIES:
:ID: 4021c260-0529-4a65-a3c4-4651cc33c6ae
:END:

**** dired
:PROPERTIES:
:ID: 55109eeb-8e59-4d15-926e-fbe42ed28056
:END:

#+begin_src emacs-lisp
(use-feature! dired
  :setq
  (dired-recursive-copies . 'always)
  (dired-recursive-deletes . 'top)
  (dired-hide-details-hide-symlink-targets . nil))
#+end_src

**** sort directories first
:PROPERTIES:
:ID: 4b6c0ed8-dbf2-4a65-adcc-1ce326eac465
:END:

#+begin_src emacs-lisp
(defhook! dired:sort-directories-first-h ()
  "List directories first in dired buffers."
  :hook dired-after-readin-hook
  (save-excursion
    (let (buffer-read-only)
      (forward-line 2) ;; beyond dir. header
      (sort-regexp-fields t "^.*$" "[ ]*." (point) (point-max))))
  (and (featurep 'xemacs)
       (fboundp 'dired-insert-set-properties)
       (dired-insert-set-properties (point-min) (point-max)))
  (set-buffer-modified-p nil))
#+end_src

**** Create non-existent directory
:PROPERTIES:
:ID: 66981d0c-fe40-4552-9f63-2c39a7d584d2
:END:

#+begin_src emacs-lisp
(defun dired:create-non-existent-directory-h ()
  "Automatically create missing directories when creating new file."
  (let ((parent-directory (file-name-directory buffer-file-name)))
    (when (and (not (file-exists-p parent-directory))
               (y-or-n-p (format "Directory `%s' does not exist! Create it?" parent-directory)))
      (make-directory parent-directory t))))

(after! dired
  (add-to-list 'find-file-not-found-functions 'dired:create-non-existent-directory-h nil #'eq))
#+end_src

*** ranger
:PROPERTIES:
:ID: 7504cab0-ddd9-4069-b6bb-9a5f3161cace
:END:

[[github:ralesi/ranger.el][ranger]] is a file browser built on top of dired that seeks to emulate [[github:ranger/ranger][a VIM
inspired file manager]] of also called =ranger=.

**** bindings
:PROPERTIES:
:ID: 6e779de2-86b8-4856-8569-33f6e69e3b17
:END:

***** important
:PROPERTIES:
:ID: d1835a7a-2a51-4bc5-98f6-4e13d2b98ee4
:END:

#+begin_src emacs-lisp
(general-def 'normal ranger-mode-map
  "m" #'dired-mark
  "d" #'dired-do-delete
  "s" #'dired-do-symlink
  "e" #'eshell
  "c" #'dired-do-copy
  "M" #'dired-mark-files-containing-regexp
  "r" #'dired-do-rename
  "U" #'dired-unmark-all-marks
  "x" #'dired-do-shell-command
  "a" #'avy-goto-line
  "C-r" #'ranger-refresh
  "f" #'find-file
  "q" #'ranger-close)
#+end_src


***** generic
:PROPERTIES:
:ID: 0b160960-0eab-4faa-911d-0d8aef12cc47
:END:

#+begin_src emacs-lisp
(general-def 'normal ranger-mode-map
  "A" #'dired-do-find-regexp
  "C" #'dired-do-copy
  "B" #'dired-do-byte-compile
  "D" #'dired-do-delete
  "H" #'dired-do-hardlink
  "L" #'dired-do-load
  "M" #'dired-do-chmod
  "O" #'dired-do-chown
  "P" #'dired-do-print
  "Q" #'dired-do-find-regexp-and-replace
  "R" #'dired-do-rename
  "S" #'dired-do-symlink
  "T" #'dired-do-touch
  "X" #'dired-do-shell-command
  "Z" #'dired-do-compress
  "c" #'dired-do-compress-to
  "!" #'dired-do-shell-command
  "&" #'dired-do-async-shell-command)
#+end_src

***** other
:PROPERTIES:
:ID: 45dab1c7-6558-42bc-a33e-91e1015d94ab
:END:

#+begin_src emacs-lisp
(general-def 'normal ranger-mode-map
  "["                   #'dired-prev-dirline
  "]"                   #'dired-next-dirline
  "<"                   #'dired-prev-dirline
  ">"                   #'dired-next-dirline
  "^"                   #'dired-up-directory
  "k"                   #'dired-previous-line
  "j"                   #'dired-next-line
  "h"                   #'dired-up-directory
  "l"                   #'dired-find-file
  "RET"                 #'dired-find-file
  [remap next-line]     #'dired-next-line
  [remap previous-line] #'dired-previous-line)
#+end_src

***** other
:PROPERTIES:
:ID: 1caa851b-211b-4bee-8d2b-0df643410640
:END:

#+begin_src emacs-lisp
(general-def 'normal ranger-mode-map
  :prefix "%"
  "u" #'dired-upcase
  "l" #'dired-downcase
  "d" #'dired-flag-files-regexp
  "r" #'dired-do-rename-regexp
  "C" #'dired-do-copy-regexp
  "H" #'dired-do-hardlink-regexp
  "R" #'dired-do-rename-regexp
  "S" #'dired-do-symlink-regexp
  "&" #'dired-flag-garbage-files)
#+end_src

***** marking
:PROPERTIES:
:ID: a4fff7fe-a895-4cf9-9737-685aa1b68e2f
:END:

#+begin_src emacs-lisp
(general-def 'normal ranger-mode-map
  :prefix "*"
  "*"         #'dired-mark-executables
  "/"         #'dired-mark-directories
  "@"         #'dired-mark-symlinks
  "%"         #'dired-mark-files-regexp
  "("         #'dired-mark-sexp
  "."         #'dired-mark-extension
  "O"         #'dired-mark-omitted
  "c"         #'dired-change-marks
  "s"         #'dired-mark-subdir-files
  "m"         #'dired-mark
  "u"         #'dired-unmark
  "?"         #'dired-unmark-all-files
  "!"         #'dired-unmark-all-marks
  " <delete>" #'dired-unmark-backward
  " C-n"      #'dired-next-marked-file
  " C-p"      #'dired-prev-marked-file
  "t"         #'dired-toggle-marks)
#+end_src

***** other
:PROPERTIES:
:ID: 64d0879a-6b01-4898-976f-e3363b0a2d2c
:END:

#+begin_src emacs-lisp
(general-def 'normal ranger-mode-map
  [remap read-only-mode]   #'dired-toggle-read-only
  [remap toggle-read-only] #'dired-toggle-read-only
  "<delete>"               #'dired-unmark-backward
  [remap undo]             #'dired-undo
  [remap advertised-undo]  #'dired-undo)
#+end_src

**** entry
:PROPERTIES:
:ID: 2edf3f72-726f-4b31-9ff0-20e5e7d251b1
:END:

#+begin_src emacs-lisp
(use-package! ranger
  :commands deer ranger
  :setq
  (ranger-override-dired-mode . t)
  (ranger-cleanup-eagerly . t)
  (ranger-cleanup-on-disable . t)
  (ranger-omit-regexp . "^\.DS_Store$")
  (ranger-excluded-extensions . '("mkv" "iso" "mp4"))
  (ranger-deer-show-details . nil)
  (ranger-max-preview-size . 10)
  (ranger-modify-header . t)
  (ranger-hide-cursor . t)
  (ranger-dont-show-binary . t))

(setq image-dired-dir (concat VOID:DATA-DIR "image-dir"))
(setq dired-omit-verbose nil)
#+end_src

**** toggle dotfiles
:PROPERTIES:
:ID: 5b9b190c-b4a6-4834-b8c9-def16b0457ac
:END:

There's this wierd intermidiate stage between =hidden= and =format= called =prefer= in
which only some files are hidden. That's wierd, so I get rid of it.

#+begin_src emacs-lisp
(defadvice! ranger:toggle-dotfiles-a ()
  "Show/hide dot-files."
  :override ranger-toggle-dotfiles
  (interactive)
  (setq ranger-show-hidden
        (cl-case ranger-show-hidden
          (hidden 'format)
          (format 'hidden)))
  (ranger-setup))
#+end_src

**** silence window check                                              :silence:
:PROPERTIES:
:ID: e9d83b37-1257-4d78-ae5f-863c4e7198d1
:END:

#+begin_src emacs-lisp
(defadvice! ranger:window-check-shutup-a (orig-fn &rest args)
  "Silence `ranger-window-check'."
  :around ranger-window-check
  (quiet! (apply orig-fn args)))
#+end_src


*** dired icons
:PROPERTIES:
:ID: 3b4561b3-18a5-475f-a8e8-e9cb7e213881
:END:

#+begin_src emacs-lisp
(use-package! all-the-icons-dired :hook ranger-mode-hook)
#+end_src

** restart emacs
:PROPERTIES:
:ID: 2855f9fe-baac-43c4-9e7d-08c6fd118252
:END:

As it's name suggests [[https://github.com/iqbalansari/restart-emacs][restart-emacs]] provides a function (called ~restart-emacs~)
that restarts emacs. I haven't tested this in EXWM mode.

#+begin_src emacs-lisp
(use-package! restart-emacs :commands restart-emacs)
#+end_src

** version control
:PROPERTIES:
:ID: d99a378c-449f-4a0d-9b88-dd77d5a41bb1
:END:

*** transient
:PROPERTIES:
:ID: baf64a0f-f9fa-4700-bebf-d996018f894f
:END:

#+begin_src emacs-lisp
(use-package! transient
  :setq
  (transient-default-level . 5)
  (transient-levels-file   . (concat VOID:DATA-DIR "transient/levels"))
  (transient-values-file   . (concat VOID:DATA-DIR "transient/values"))
  (transient-history-file  . (concat VOID:DATA-DIR "transient/history")))
#+end_src

*** magit
:PROPERTIES:
:ID: c8a37b6a-46c7-406e-8793-1186f14407e0
:END:

#+begin_src emacs-lisp
(use-package! magit
  :commands magit-status magit-get-current-branch
  :load-incrementally f s with-editor git-commit package eieio lv transient
  :popup ("magit:"
          (display-buffer-at-bottom)
          (window-height . 0.5))
  :bind (:magit-status-mode-map
         ([remap magit-mode-bury-buffer] . magit/quit))
  :setq
  (magit-completing-read-function . (if (featurep 'ivy)
                                        #'ivy-completing-read
                                      #'magit-builtin-completing-read))
  (magit-revision-show-gravatars . '("^Author:     " . "^Commit:     "))
  (magit-diff-refine-hunk . t)
  (magit-auto-revert-mode . nil)
  :defer-config
  (add-hook 'magit-popup-mode-hook #'hide-mode-line-mode))
#+end_src

*** quitting
:PROPERTIES:
:ID: 49088c3e-6d3a-41b7-aee4-f0bb34c71a0c
:END:

#+begin_src emacs-lisp
(defun magit/quit ()
  "Clean up magit buffers after quitting `magit-status'."
  (interactive)
  (let ((buffers (magit-mode-get-buffers)))
    (magit-restore-window-configuration)
    (mapc #'kill-buffer buffers)))
#+end_src

*** evil-magit
:PROPERTIES:
:ID: 02025227-8f1a-45aa-b40a-aabf43a3041c
:END:

#+begin_src emacs-lisp
(use-package! evil-magit
  :before-call magit-status
  :defer-config
  (shut-up! (evil-magit-init))
  (setq evil-magit-state 'normal)
  (require 'evil-magit nil :no-error))
#+end_src

*** git-gutter
:PROPERTIES:
:ID: 96f0c876-533c-4b1a-a4c1-7b6c9bf58c03
:END:

#+begin_src emacs-lisp
(use-package! git-gutter :commands git-gutter-mode)
#+end_src

** server                                                             :built-in:
:PROPERTIES:
:ID: b2bc973f-7d24-431c-90bc-4c1055a9fc0a
:END:

#+begin_src emacs-lisp
(when (display-graphic-p)
  (after! server
    (when-let* ((name (getenv "EMACS_SERVER_NAME")))
      (setq server-name name))
    (unless (server-running-p)
      (server-start))))
#+end_src

** TODO autorevert
:PROPERTIES:
:ID: 1d7c8bac-e523-4251-bb3c-b85f592fbfc3
:END:

#+begin_src emacs-lisp
(use-feature! autorevert
  :after-call switch-to-buffer find-file
  :setq
  (auto-revert-verbose . t)
  (auto-revert-use-notify . nil)
  (auto-revert-stop-on-user-input . nil)
  (revert-without-query . (list "."))
  :defer-config
  (defhook! auto-revert:buffer-h ()
    "Auto revert current buffer, if necessary."
    :hook void:after-switch-buffer-hook
    (unless (or (bound-and-true-p auto-revert-mode)
                (active-minibuffer-window))
      (auto-revert-handler)))

  (defhook! auto-revert:visible-buffers-h ()
    "Auto revert stale buffers in visible windows, if necessary."
    :hook (focus-in-hook after-save-hook)
    (seq-each (lambda (it) (with-current-buffer it (auto-revert:buffer-h)))
              (seq-uniq (seq-map #'window-buffer (window-list))))))
#+end_src

** security
:PROPERTIES:
:ID: 313aedc2-c737-42b4-afaa-069ec33803aa
:END:

*** pass
:PROPERTIES:
:ID: 78e2ac6e-e465-482c-80bf-19ddfdaff31d
:END:

**** pass
:PROPERTIES:
:ID: 4ab61136-e27a-4bd1-bfd6-d99015819a1b
:END:

#+begin_src emacs-lisp
(use-package! pass
  :commands pass
  :setq
  (pass-username-field . "username"))
#+end_src

**** get password
:PROPERTIES:
:ID: 52d9423c-32fb-4538-9e69-537e458b52d5
:END:

#+begin_src emacs-lisp
(defun pass/get-password ()
  "Copy password from entry into kill ring."
  (interactive)
  (require 'pass)
  (password-store-copy
   (completing-read "Copy password of entry: "
                    (password-store-list (password-store-dir))
                    nil
                    t)))
#+end_src

**** auth source pass
:PROPERTIES:
:ID: 2cd2fcee-e503-4430-9f37-43fecb12ac19
:END:

#+begin_src emacs-lisp
(use-package! auth-source-pass
  ;; (:after-hook pre-command-hook)
  :setq
  (auth-source-pass-filename . "~/.password-store")
  (auth-source-pass-port-separator . ":")
  :defer-config (auth-source-pass-enable))
#+end_src

**** epa
:PROPERTIES:
:ID: 9eeb5714-a5dc-4f88-8992-0bd3a158878b
:END:

#+begin_src emacs-lisp
(use-package! epa
  :setq
  (epg-gpg-program . "gpg2")
  (epa-pinentry-mode . 'loopback))
#+end_src

*** password-generator
:PROPERTIES:
:ID: 11bc4d9a-78df-4010-b81a-4a87b1443ea9
:END:

I'm sure that =pass= can generate custom passwords with some options or other, but
I do not like dealing with the command line. I want real elisp code please.

#+begin_src emacs-lisp
(use-package! password-generator
  :commands password-generator-simple password-generator-paranoid)
#+end_src

** uuidgen
:PROPERTIES:
:ID: 9becd3bb-e74e-4644-a716-5b941fbbda50
:END:

#+begin_src emacs-lisp
(use-package! uuidgen)
#+end_src

** xr
:PROPERTIES:
:ID: 75c56163-9ce1-4726-969a-350fcc56395f
:END:

This package is the inverse of =rx=. It takes a regular expression and returns the
=rx= representation.

#+begin_src emacs-lisp
(use-package! xr
  ;; :functions xr xr-pp
  )
#+end_src

** pdf-tools
:PROPERTIES:
:ID: 163d8880-6a7d-4479-a7e4-e333e4f930da
:END:

#+begin_src emacs-lisp
(use-package! pdf-tools
  :magic ("%PDF" . pdf-view-mode)
  :mode ("\\.[pP][dD][fF]\\'" . pdf-view-mode)
  :bind (:pdf-view-mode-map
         ("j" . pdf-view-next-line-or-next-page)
         ("k" . pdf-view-previous-line-or-previous-page)))
#+end_src

** circe
:PROPERTIES:
:ID: 65495471-b9b4-47cc-aa85-5a6ead4c6538
:END:

#+begin_src emacs-lisp
(use-package! circe)
#+end_src

** peristent scratch
:PROPERTIES:
:ID: 8180d63f-1c0c-4a03-8dbc-9a99bf0c9f0b
:END:

#+begin_src emacs-lisp
(use-package! persistent-scratch
  :commands persistent-scratch-restore
  :setq (persistent-scratch-save-file . (concat VOID:DATA-DIR "scratch")))
#+end_src

** alert
:PROPERTIES:
:ID: 07960fe7-7ef5-48db-bfd9-86c980a7599d
:END:

Notifications are very important. Messages from the =*Messages*= buffer are not enough.

#+begin_src emacs-lisp
(use-package! alert
  :setq
  (alert-default-style . 'libnotify)
  (alert-log-messages . t))
#+end_src

** sudo-edit
:PROPERTIES:
:ID:       38a9aec6-f826-4ebc-82f1-08ace40c2287
:END:

Sometimes I'll want edit files with root privileges. This package let's you edit
a file from another user (=root= by default). To use it you just call [[helpfn:sudo-edit][sudo-edit]]
on the buffer you'd like to edit.

#+begin_src emacs-lisp
(use-package! sudo-edit :commands sudo-edit)
#+end_src

** yadm
:PROPERTIES:
:ID:       5783c785-cee0-4705-9b6b-eec5124f34a0
:END:

#+begin_src emacs-lisp
(defun void/dotfile-status ()
  (interactive)
  (require 'tramp)
  (add-to-list 'tramp-methods
               '("yadm"
                 (tramp-login-program "yadm")
                 (tramp-login-args (("enter")))
                 (tramp-login-env (("SHELL") ("/bin/sh")))
                 (tramp-remote-shell "/bin/sh")
                 (tramp-remote-shell-args ("-c"))))
  (magit-status "/yadm::"))
#+end_src

* Languages
:PROPERTIES:
:ID: 51e3b9b1-0e74-431e-a113-fe6f86a4b22a
:END:

** lisp
:PROPERTIES:
:ID: 9b7ec12e-e62b-447a-90dd-2fef0cc952ad
:END:

*** sly
:PROPERTIES:
:ID: 2e4ddfa7-2243-458c-8045-ef4a9f652d9c
:END:

[[https://github.com/joaotavora/sly][sly]] is an alternative to [[https://github.com/slime/slime][slime]].

#+begin_src emacs-lisp
(use-package! sly
  :setq (inferior-lisp-program . "/usr/bin/sbcl"))
#+end_src

*** clojure
:PROPERTIES:
:ID: 7941233e-6524-4da1-b6d9-05faf8991824
:END:

[[https://github.com/clojure-emacs/cider][cider]] is a repl for clojure.

#+begin_src emacs-lisp
(use-package! cider :commands cider)
#+end_src

*** emacs lisp
:PROPERTIES:
:ID: f90ab909-dd53-41ca-bc77-849fb89ac6c8
:END:

**** printing
:PROPERTIES:
:ID: 954a5a72-1db9-4a40-b9cb-e9099bfd0f83
:END:

#+begin_src emacs-lisp
(setq eval-expression-print-length nil)
(setq eval-expression-print-level nil)
#+end_src

**** electric-pair
:PROPERTIES:
:ID: 1febf5ab-f545-4a72-97ef-892740575a3a
:END:

#+begin_src emacs-lisp
#+end_src

**** fix elisp indentation
:PROPERTIES:
:ID: aa7f846f-8802-4c75-88d8-a438e2f63ccd
:END:

A problem with elisp indentation is indents quoted lists the way functions
should be indented. It has been discussed in at least three stackoverflow
questions [[https://emacs.stackexchange.com/questions/10230/how-to-indent-keywords-aligned/10233#10233][here]], [[https://stackoverflow.com/questions/49222433/align-symbols-in-plist][here]] and [[https://stackoverflow.com/questions/22166895/customize-elisp-plist-indentation][here]]. In all these questions the solutions have not
been satisfactory. Some of them recommend using [[helpfn:common-lisp-indent-function][common-lisp-indent-function]] as
the value of [[helpvar:lisp-indent-function][lisp-indent-function]]. This works for indenting a quoted list
properly, but at the expense of changing the way that many other elisp forms are
indented. Common Lisp's indentation is different from Elisp's. Others recommend
using [[https://github.com/Fuco1/.emacs.d/blob/af82072196564fa57726bdbabf97f1d35c43b7f7/site-lisp/redef.el#L12-L94][Fuco1's lisp indent function hack]]. This also is not ideal. For one thing it
only works for quoted lists with keywords but not generic symbols. Another thing
is that the change should really be occurring in [[helpfn:calculate-lisp-indent][calculate-lisp-indent]].
~calculate-lisp-indent~ is a function that returns what the indentation should be
for the line at point. Since Fuco1 did not modify ~calculate-lisp-indent~ the
*wrong* indentation still returned by this function and the modified
~lisp-indent-function~ just cleans up the mess. Better is just fixing the source
of the problem. You can check out a more in-depth explanation looking at my
[[https://www.reddit.com/r/emacs/comments/d7x7x8/finally_fixing_indentation_of_quoted_lists/][reddit-post]] or looking at an answer I gave to [[https://emacs.stackexchange.com/questions/10230/how-to-indent-keywords-aligned][this question]].

#+begin_src emacs-lisp
(defadvice! void:calculate-lisp-indent-a (&optional parse-start)
  "Add better indentation for quoted and backquoted lists.
The change to this function."
  :override calculate-lisp-indent
  (defvar calculate-lisp-indent-last-sexp)
  (save-excursion
    (beginning-of-line)
    (let ((indent-point (point))
          state
          ;; setting this to a number inhibits calling hook
          (desired-indent nil)
          (retry t)
          calculate-lisp-indent-last-sexp containing-sexp)
      (cond ((or (markerp parse-start) (integerp parse-start))
             (goto-char parse-start))
            ((null parse-start) (beginning-of-defun))
            (t (setq state parse-start)))
      (unless state
        ;; Find outermost containing sexp
        (while (< (point) indent-point)
          (setq state (parse-partial-sexp (point) indent-point 0))))
      ;; Find innermost containing sexp
      (while (and retry
                  state
                  (> (elt state 0) 0))
        (setq retry nil)
        (setq calculate-lisp-indent-last-sexp (elt state 2))
        (setq containing-sexp (elt state 1))
        ;; Position following last unclosed open.
        (goto-char (1+ containing-sexp))
        ;; Is there a complete sexp since then?
        (if (and calculate-lisp-indent-last-sexp
                 (> calculate-lisp-indent-last-sexp (point)))
            ;; Yes, but is there a containing sexp after that?
            (let ((peek (parse-partial-sexp calculate-lisp-indent-last-sexp
                                            indent-point 0)))
              (if (setq retry (car (cdr peek))) (setq state peek)))))
      (if retry
          nil
        ;; Innermost containing sexp found
        (goto-char (1+ containing-sexp))
        (if (not calculate-lisp-indent-last-sexp)
            ;; indent-point immediately follows open paren.
            ;; Don't call hook.
            (setq desired-indent (current-column))
          ;; Find the start of first element of containing sexp.
          (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
          (cond ((looking-at "\\s(")
                 ;; First element of containing sexp is a list.
                 ;; Indent under that list.
                 )
                ((> (save-excursion (forward-line 1) (point))
                    calculate-lisp-indent-last-sexp)
                 ;; This is the first line to start within the containing sexp.
                 ;; It's almost certainly a function call.
                 (if (or
                      (= (point) calculate-lisp-indent-last-sexp)

                      (when-let (after (char-after (1+ containing-sexp)))
                        (char-equal after ?:))

                      (when-let (point (char-before containing-sexp))
                        (char-equal point ?'))

                      (let ((quoted-p nil)
                            (point nil)
                            (positions (nreverse (butlast (elt state 9)))))
                        (while (and positions (not quoted-p))
                          (setq point (pop positions))
                          (setq quoted-p
                                (or
                                 (and (char-before point)
                                      (char-equal (char-before point) ?'))
                                 (save-excursion
                                   (goto-char (1+ point))
                                   (looking-at-p "quote[\t\n\f\s]+(")))))
                        quoted-p))
                     ;; Containing sexp has nothing before this line
                     ;; except the first element.  Indent under that element.
                     nil
                   ;; Skip the first element, find start of second (the first
                   ;; argument of the function call) and indent under.
                   (progn (forward-sexp 1)
                          (parse-partial-sexp (point)
                                              calculate-lisp-indent-last-sexp
                                              0 t)))
                 (backward-prefix-chars))
                (t
                 ;; Indent beneath first sexp on same line as
                 ;; `calculate-lisp-indent-last-sexp'.  Again, it's
                 ;; almost certainly a function call.
                 (goto-char calculate-lisp-indent-last-sexp)
                 (beginning-of-line)
                 (parse-partial-sexp (point) calculate-lisp-indent-last-sexp
                                     0 t)
                 (backward-prefix-chars)))))
      ;; Point is at the point to indent under unless we are inside a string.
      ;; Call indentation hook except when overridden by lisp-indent-offset
      ;; or if the desired indentation has already been computed.
      (let ((normal-indent (current-column)))
        (cond ((elt state 3)
               ;; Inside a string, don't change indentation.
               nil)
              ((and (integerp lisp-indent-offset) containing-sexp)
               ;; Indent by constant offset
               (goto-char containing-sexp)
               (+ (current-column) lisp-indent-offset))
              ;; in this case calculate-lisp-indent-last-sexp is not nil
              (calculate-lisp-indent-last-sexp
               (or
                ;; try to align the parameters of a known function
                (and lisp-indent-function
                     (not retry)
                     (funcall lisp-indent-function indent-point state))
                ;; If the function has no special alignment
                ;; or it does not apply to this argument,
                ;; try to align a constant-symbol under the last
                ;; preceding constant symbol, if there is such one of
                ;; the last 2 preceding symbols, in the previous
                ;; uncommented line.
                (and (save-excursion
                       (goto-char indent-point)
                       (skip-chars-forward " \t")
                       (looking-at ":"))
                     ;; The last sexp may not be at the indentation
                     ;; where it begins, so find that one, instead.
                     (save-excursion
                       (goto-char calculate-lisp-indent-last-sexp)
                       ;; Handle prefix characters and whitespace
                       ;; following an open paren.  (Bug#1012)
                       (backward-prefix-chars)
                       (while (not (or (looking-back "^[ \t]*\\|([ \t]+"
                                                     (line-beginning-position))
                                       (and containing-sexp
                                            (>= (1+ containing-sexp) (point)))))
                         (forward-sexp -1)
                         (backward-prefix-chars))
                       (setq calculate-lisp-indent-last-sexp (point)))
                     (> calculate-lisp-indent-last-sexp
                        (save-excursion
                          (goto-char (1+ containing-sexp))
                          (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
                          (point)))
                     (let ((parse-sexp-ignore-comments t)
                           indent)
                       (goto-char calculate-lisp-indent-last-sexp)
                       (or (and (looking-at ":")
                                (setq indent (current-column)))
                           (and (< (line-beginning-position)
                                   (prog2 (backward-sexp) (point)))
                                (looking-at ":")
                                (setq indent (current-column))))
                       indent))
                ;; another symbols or constants not preceded by a constant
                ;; as defined above.
                normal-indent))
              ;; in this case calculate-lisp-indent-last-sexp is nil
              (desired-indent)
              (t
               normal-indent))))))
#+end_src

**** highlight-quoted
:PROPERTIES:
:ID: afacf700-86a9-4c1b-9062-7a28c11dcf69
:END:

[[https://github.com/Fanael/highlight-quoted][highlight-quoted]] highlights quotes, backticks and.

#+begin_src emacs-lisp
(use-package! highlight-quoted
  :hook emacs-lisp-mode-hook)
#+end_src

**** buttercup
:PROPERTIES:
:ID: 228fb805-620d-4519-822f-f633540f7b58
:END:

[[https://github.com/jorgenschaefer/emacs-buttercup][buttercup]] is an emacs debugging suite.

#+begin_src emacs-lisp
(use-package! buttercup)
#+end_src

**** outorg
:PROPERTIES:
:ID: a3461ce0-8c5d-4bea-950e-b18ea6422672
:END:

Outorg adds overlays to make an org buffer look more readable. I do not want
these overlays.

#+begin_src emacs-lisp
(use-package! outorg
  ;; TODO: should be changed to `:functions'
  :commands outorg-convert-back-to-code outorg-convert-to-org)

(defadvice! outorg:do-not-add-overlays-a (orig-fn &rest args)
  :around outorg-wrap-source-in-block
  (noflet ((overlay-put (&rest _) nil))
    (apply orig-fn args)))
#+end_src

**** outshine
:PROPERTIES:
:ID: ffeddf0d-aa29-473f-b73c-d94971d91da9
:END:

[[https://github.com/alphapapa/outshine][outshine]] is a clever package that tries to make elisp mode more like org mode.
It colors certain comments like org headings, and adds function for convertion
from elisp to org. My [[helpvar:VOID-INIT-FILE][void:init-file]] is written with =outshine= in mind.

#+begin_src emacs-lisp
(use-package! outshine
  :hook emacs-lisp-mode-hook
  :defer-config
  (general-def '(normal) emacs-lisp-mode-map
    "TAB" #'outline-toggle-children))
#+end_src

**** macrostep
:PROPERTIES:
:ID: 81e59dcc-7e23-4dd1-9917-06f0ab59f2a6
:END:

[[https://github.com/joddie/macrostep][macrostep]]

#+begin_src emacs-lisp
(use-package! macrostep
  :commands (macrostep-expand macrostep-collapse macrostep-collapse-all)
  :init (define-localleader-key!
          :infix "m"
          :keymaps 'emacs-lisp-mode-map
          "e" (list :def #'macrostep-expand :wk "expand")
          "c" (list :def #'macrostep-collapse :wk "collapse")
          "C" (list :def #'macrostep-collapse-all :wk "collapse all")))
#+end_src

*** hy
:PROPERTIES:
:ID: 6b62fbdd-448b-4b69-82f8-1e1231a10c3e
:END:

#+begin_src emacs-lisp
(use-package! hy-mode :mode "\\.hy\\'")
#+end_src

** markdown
:PROPERTIES:
:ID: 9d684855-961a-4294-8b90-44d2796526e2
:END:

I'm adding [[https://github.com/jrblevin/markdown-mode][markdown-mode]] so I can see =README= files.

#+begin_src emacs-lisp
(use-package! markdown-mode :mode "\\.md\\'")
#+end_src

** org
:PROPERTIES:
:ID: 7fd3bb4f-354c-4427-914c-9de2223f5646
:END:

Org mode introduces an elegant way of dealing with different languages in one
file. In an org file the background language is Org's own markup language that's
typically composed mostly of outline headlines. In the org markup language you
can embed multiple different languages in [[][source blocks]]. Additionally, org
mode provides a library of functions for dealing with these files. This includes
things like executing (or evaluating) source blocks, moving headlines to other
files, or even converting an org mode document into another format. As the name
=org= suggests, org is tool that's used for organization of data.

*** structures
:PROPERTIES:
:ID: 85ac0a35-4e44-41e6-a1f1-54698cb86212
:END:

**** todo-keywords
:PROPERTIES:
:ID: a32da379-654e-4b1a-83f4-cf9e4003d578
:END:

***** todo keywords
:PROPERTIES:
:ID: 2f0459d4-9afd-4fd9-bdba-c0a3dc993963
:END:

#+begin_src emacs-lisp
(after! org
  (setq org-todo-keywords
        '((sequence "TODO(t)" "PROJ(p)" "NEXT" "WAITING" "|" "DONE")
          (sequence "|" "DUPLICATE")
          (sequence "|" "CANCELLED"))))
#+end_src

***** return todo-keywords
:PROPERTIES:
:ID: 38385aee-1326-46d8-9eef-3bfa2e57c0cc
:END:

Knowing what the exact todo-keywords are is important so that I know exactly
when headline contents begin.

#+begin_src emacs-lisp
(defun org:todo-keywords ()
  "Return list of all TODO keywords."
  (seq-filter (lambda (it) (and (stringp it) (not (string= "|" it))))
              (flatten-list org-todo-keywords)))
#+end_src

***** heading start
:PROPERTIES:
:ID: 0ebf90e8-cd14-4364-b26a-da6676b29089
:END:

#+begin_src emacs-lisp
(defun org:heading-start-regexp ()
  "Compute regexp for heading start."
  (rx-to-string `(: bol (1+ "*") space (opt (or ,@(org:todo-keywords)) space))))

(defun org:heading-goto-start ()
  "Go to first letter of headline."
  (let (case-fold-search)
    (beginning-of-line)
    (re-search-forward (org:heading-start-regexp)
                       (line-end-position))))
#+end_src

**** return
:PROPERTIES:
:ID: c161f1b0-dbc0-4240-8102-69e95f3fd62f
:END:

#+begin_src emacs-lisp
(defun org/dwim-return ()
  "Do what I mean."
  (interactive)
  (cond
   (and (org-at-heading-p)
        (looking-at-p (rx (* (or "\s" "\t"))
                          (opt (1+ ":" (1+ letter)) ":") eol)))
   (org/insert-heading-below)
   (t
    (call-interactively #'org-return))))
#+end_src

**** TODO scroll window to top
:PROPERTIES:
:ID: 149e9f0c-e984-42e6-afb1-03502eda41ea
:END:

I need this function for some org actions. Evil has this as
[[helpfn:evil-scroll-line-to-top][evil-scroll-line-to-top]] but I didn't want to depend on evil.

#+begin_src emacs-lisp
(defun org:scroll-window-to-top ()
  (let ((line (line-number-at-pos (point)))
        (col (current-column)))
    (goto-char (point-min))
    (forward-line (1- line))
    (move-to-column col)))
#+end_src

**** TODO fix nearby line adjustment
:PROPERTIES:
:ID: 6168590a-db23-4f0b-bdd9-9d9666624af6
:END:

=counsel-org-goto= is an increadible command that lets you fuzzy select a subtree
you want to see. Only problem is after you get there, it looks scrunchy and
akwardly folded. This advice adjusts headings around as well as putting the
headline in view.

#+begin_src emacs-lisp
(defadvice! org-adjust-nearby-headlines-a (&rest _)
  :after org/jump-to-headline
  (save-excursion
    (while (org-up-heading-safe)
      (outline-show-children)))
  (outline-show-children)
  ;; From `evil-scroll-line-to-top'.
  (let ((line (line-number-at-pos (point))))
    (goto-char (point-min))
    (forward-line (1- line)))
  (recenter (1- (max 1 scroll-margin)))
  (org:heading-goto-start))
#+end_src

**** helpers
:PROPERTIES:
:ID: 50b79866-2905-459e-9723-6b822dde9127
:END:

***** org-heading-folded-p
:PROPERTIES:
:ID: 919b2b6e-2c43-4fd5-87cc-cfc62cf75405
:END:

#+begin_src emacs-lisp
(defun org:heading-folded-p ()
  "Return t if an current heading is folded."
  (outline-invisible-p (line-end-position)))
#+end_src

***** headline-name
:PROPERTIES:
:ID: 97ac2e07-9db1-43e4-a71b-1a4ed959c7b1
:END:

#+begin_src emacs-lisp
(defun org:heading-name ()
  "Return the headline of the current heading."
  (interactive)
  (save-excursion
    (org-back-to-heading)
    (unless org-complex-heading-regexp
      (let ((major-mode 'org-mode))
        (org-set-regexps-and-options)))
    (looking-at org-complex-heading-regexp)
    (match-string 4)))
#+end_src

***** beginning-of-headline
:PROPERTIES:
:ID: ac43317c-485e-4efb-aff7-36c3ab69ea79
:END:

#+begin_src emacs-lisp
(defun org:beginning-of-headline (&optional end)
  "Return the character position at the end of the headline."
  (let (case-fold-search)
    (save-excursion
      (org-back-to-heading)
      (looking-at org-complex-heading-regexp)
      (funcall (if end #'match-end #'match-beginning) 4))))
#+end_src

***** end-of-headline
:PROPERTIES:
:ID: b9f9115c-4f84-4894-b926-8c1b948c0246
:END:

#+begin_src emacs-lisp
(defun org:end-of-headline ()
  "Return the character position at the end of the headline."
  (interactive)
  (org:beginning-of-headline t))
#+end_src

***** heading
:PROPERTIES:
:ID: f6b74522-180a-485c-b946-f7fa2e18a826
:END:

#+begin_src emacs-lisp
(defun org:heading-end-of-heading ()
  "Return point at end of heading.")

(defun org:heading-block-lang ()
  "Return the language of the current language's source block."
  (save-excursion
    (org-back-to-heading)
    (re-search-forward org-babel-src-block-regexp)))
#+end_src

**** preserve point
:PROPERTIES:
:ID: 52781cc9-e1ca-4618-aa1b-6845494b5dc6
:END:

If possible org commands should preserve =point=. If this isn't possible (ie. when
deleting a subtree with), then should leave point at a place that is easy to
predict and convenient (as opposed to a random location).

***** start on beginning of first heading
:PROPERTIES:
:ID: 81732dde-85f7-4336-a9fd-351d8f74671f
:END:

It looks nice if when I'm on a heading when I first enter an org file.

#+begin_src emacs-lisp
(defhook! org:goto-first-heading-h ()
  "Go to first heading when entering an org-mode file."
  :hook org-mode-hook
  (when (org-at-heading-p)
    (beginning-of-line)
    (org:heading-goto-start)))
#+end_src

***** fix bug with next visible heading
:PROPERTIES:
:ID: 9a3759e8-8928-47cb-97c9-9ce5ee673cba
:END:

[[helpfn:outline-next-visible-heading][outline-next-visible-heading]] continues to =EOB= after reaching the last visible
heading. It should just stop at the last visible heading. This advice checks to
see if it's gone farther than it should have and in that case goes back.

#+begin_src emacs-lisp
(defadvice! outline:dont-end-at-eob-a (orig-fn &rest args)
  "Fix bug where the next heading moves past last visible heading."
  :around outline-next-visible-heading
  (apply orig-fn args)
  (when (eobp) (apply #'outline-previous-visible-heading args)))
#+end_src

***** go to proper point after refile
:PROPERTIES:
:ID: 591045df-8d3e-4ff7-b4bc-c949222a0717
:END:

#+begin_src emacs-lisp
(defadvice! org:end-at-start-of-headline-a (&rest _)
  "After running body end at headline start."
  :after org-refile org-cut-subtree org-copy-subtree org/jump-to-headline
  (when (org-at-heading-p) (org:heading-goto-start)))
#+end_src

**** commands
:PROPERTIES:
:ID: 86f0b9be-0033-46bd-8d02-7e506fe73ead
:END:

***** dwim
:PROPERTIES:
:ID: 93a6e45c-b23b-4639-9e1c-9f1aef0fb95a
:END:

****** insert
:PROPERTIES:
:ID: 1b8ccbb8-2614-4d2e-ab7c-e8bd23c2c02d
:END:

#+begin_src emacs-lisp
(defun org/dwim-insert-elisp-block ()
  "Insert elisp block."
  (interactive)
  (save-excursion
    (unless (org-at-heading-p)
      (org-back-to-heading))
    (org-end-of-subtree)
    (goto-char (line-end-position))
    (insert (concat "\n\n"
                    "#+begin_src emacs-lisp"
                    "\n"
                    "#+end_src"))
    (forward-line -1)))
#+end_src

****** eval
:PROPERTIES:
:ID: e804805a-ba96-41d0-aa6f-6756c65e9abf
:END:

#+begin_src emacs-lisp
(defun org/dwim-eval-block ()
  "Eval block contents."
  (interactive)
  (unless (org-at-heading-p)
    (user-error "Not in source block"))
  (org-babel-execute-subtree))
#+end_src

****** next-line
:PROPERTIES:
:ID: d8d118a7-78e8-4602-81b3-17fd1d8ab79c
:END:

#+begin_src emacs-lisp
(defun org/dwim-next-line (&optional backward)
  "Go to the start of the next heading.
If DIR is a negative integer, go the opposite direction: the start of the
  previous heading."
  (interactive)
  (outline-next-visible-heading (if backward -1 1))
  (when (org-at-heading-p)
    (org:heading-goto-start)))
#+end_src

****** previous-line
:PROPERTIES:
:ID: e7562921-77ca-4d90-be57-1d586ec26ee5
:END:

#+begin_src emacs-lisp
(defun org/dwim-previous-line (&optional forward)
  (interactive)
  (funcall #'org/dwim-next-line (not forward)))
#+end_src

****** up-heading
:PROPERTIES:
:ID: 1f25d3b0-7280-4012-94b5-b0fea2f686b3
:END:

#+begin_src emacs-lisp
(defun org/dwim-up-heading ()
  ""
  (interactive)
  (condition-case nil
      (progn (outline-up-heading 1)
             (outline-hide-subtree)
             (outline-show-children)
             (org:heading-goto-start))
    (error
     (unless (outline-invisible-p (line-end-position))
       (outline-hide-subtree))
     (org:heading-goto-start))))
#+end_src

***** jump to heading                                                      :avy:
:PROPERTIES:
:ID: 3c396b33-437c-410f-aff6-2106ade42621
:END:

#+begin_src emacs-lisp
(defun org/avy-jump-to-heading ()
  "Jump to the beginning of a visible heading using `avy'."
  (interactive)
  (org-back-to-heading)
  (avy-jump (rx bol (1+ "*") space (group nonl))
            :beg (window-start)
            :end (window-end)
            :pred `(lambda () (/= (1+ ,(point)) (point)))
            :action (lambda (point) (goto-char point)
                      (org:heading-goto-start))
            :group 1))
#+end_src

***** dwim jump to heading
:PROPERTIES:
:ID: 7ad9d757-57ba-4537-821f-8beae57f39eb
:END:

#+begin_src emacs-lisp
(defun org/dwim-jump-to-heading ()
  ""
  (interactive)
  (let ((origin (point)))
    (if (and (org/avy-jump-to-heading)
             (org:heading-folded-p))
        (progn (outline-toggle-children)
               (org:scroll-window-to-top))
      (goto-char origin))))
#+end_src

***** inserting
:PROPERTIES:
:ID: e99abeff-328b-48e4-aebb-00db34fa98e8
:END:

In my eyes, many Org functions are unnecessarily complicated and long. Often they
need to perform a simple task (like inserting a heading) but lose their
fundamental purpose in their inclusion of numerous obscure and opinionated
options. For this reason I wrote my own insert heading functions.

****** newlines between headings
:PROPERTIES:
:ID: e0dcf718-120c-488d-9d37-96243132bf0b
:END:

#+begin_src emacs-lisp
(defvar org:newlines-between-headings "\n\n"
  "Number of newlines between headings.")
#+end_src

****** heading above
:PROPERTIES:
:ID: 6c227dea-e10b-4f86-a01b-5d223d18e3a4
:END:

#+begin_src emacs-lisp
(defun org/insert-heading-above (&optional below)
  "Insert a heading above the current heading."
  (interactive)
  (funcall #'org/insert-heading-below (not below)))
#+end_src

****** heading below
:PROPERTIES:
:ID: b059a431-e29c-4f2c-ab5e-8d2d02636405
:END:

#+begin_src emacs-lisp
(defun org/insert-heading-below (&optional above)
  "Insert heading below."
  (interactive)
  (let* ((on-heading-p (ignore-errors (org-back-to-heading)))
         (newlines org:newlines-between-headings)
         (level (or (org-current-level) 1))
         (heading (concat (make-string level ?*) "\s")))
    (cond ((not on-heading-p)
           (insert heading))
          (above
           (goto-char (line-beginning-position))
           (insert heading)
           (save-excursion (insert newlines)))
          (t ; below
           (org-end-of-subtree)
           (insert (concat newlines heading))))
    (run-hooks 'org-insert-heading-hook)))
#+end_src

****** subheading
:PROPERTIES:
:ID: cf910dcf-6250-4b6a-80d5-63ac457d4a81
:END:

#+begin_src emacs-lisp
(defun org/insert-subheading ()
  "Insert subheading below current heading."
  (interactive)
  (org/insert-heading-below)
  (org-demote))
#+end_src

*** source blocks
:PROPERTIES:
:ID: 2bb1b8ef-f41c-4dfa-8e47-549326f7ce05
:END:

Many of these =org-src= variables are not very applicable to me anymore because I
use =edit-indirect= to edit source blocks.
:PROPERTIES:
:ID: 3329768f-2669-43be-ad85-da2239082cc2
:END:

#+begin_src emacs-lisp
(use-feature! org-src
  :setq
  (org-edit-src-persistent-message . nil)
  (org-src-window-setup . 'current-window)
  (org-src-fontify-natively . t)
  (org-src-ask-before-returning-to-edit-buffer . nil)
  (org-src-preserve-indentation . t)
  (org-src-tab-acts-natively . t)
  (org-confirm-babel-evaluate . nil)
  (org-babel-default-header-args . '((:session . "none")
                                     (:results . "silent")
                                     (:exports . "code")
                                     (:cache . "no")
                                     (:initeb . "no")
                                     (:hlines . "no")
                                     (:tangle . "yes"))))
#+end_src

*** org-mode
:PROPERTIES:
:ID: c1c5724e-028a-42a5-a982-28d57203b335
:END:

#+begin_src emacs-lisp
(use-package! org
  :load-incrementally
  calendar find-func format-spec org-macs org-compat org-faces org-entities
  org-list org-pcomplete org-src org-footnote org-macro ob org org-agenda
  org-capture
  :setq
  (org-directory . VOID:ORG-DIR)
  (org-archive-location . (concat org-directory "archive.org::"))
  (org-default-notes-file . (concat org-directory "notes.org"))
  (org-fontify-emphasized-text . t)
  (org-hide-emphasis-markers . t)
  (org-pretty-entities . t)
  (org-fontify-whole-heading-line . t)
  (org-fontify-done-headline . t)
  (org-fontify-quote-and-verse-blocks . t)
  (org-adapt-indentation . nil)
  (org-cycle-separator-lines . 2)
  (outline-blank-line . t)
  (org-enforce-todo-dependencies . t)
  (org-use-fast-tag-selection . nil)
  (org-tags-column . -80)
  (org-tag-alist . nil))
#+end_src

*** asthetic
:PROPERTIES:
:ID: 52f5560d-6e52-4234-88d8-d326bc97525a
:END:

To be honest, org mode has some pretty ugly syntax. The asterixes at the
beginning of a heading are ugly, org block end and begin lines are ugly,
property drawers are ugly. For a nice-looking, minimal, and non-distracting
appearance all this needs to be improved.

**** visibility
:PROPERTIES:
:ID: 71462363-ddd0-4734-a074-7b00fde06e82
:END:

***** hide lines
:PROPERTIES:
:ID: 533c108a-36d0-4686-9476-2588647402ed
:END:
=hide-lines= is a package which, as its name suggests, hides certain lines.
Specifically, it hides lines that match a regular expression you provide. You
can reveal them with [[helpfn:hide-lines-show-all][hide-lines-show-all]].

****** hide lines
:PROPERTIES:
:ID: a2ea1e7e-5049-4b5e-bb06-4f31cf89ae32
:END:

Particularly in boilerplate heavy languages like Org, hiding certain lines can
make reading documents much easier by reducing visual distraction. This package
though is in need of an update. It didn't work out of the box (see [[id:b358f324-9b64-4e83-8168-231ff1ab115d][hide-lines]] and
[[id:a3e62e0a-452b-429c-9558-139e7b83cf80][hl overlay fix]]).

#+begin_src emacs-lisp
(use-package! hide-lines
  :commands hide-lines hide-lines-matching)
#+end_src

****** =hl= overlay fix
:PROPERTIES:
:ID: a3e62e0a-452b-429c-9558-139e7b83cf80
:END:

The line ~(overlay-put overlay 'invisible 'hl)~ in [[helpfn:][hide-lines-add-overlay]] wouldn't
work with the argument =hl=. It works when you set it to =t= instead. Maybe =hl= is
depreciated.

#+begin_src emacs-lisp
(defadvice! hide:lines-fix-add-overlay-a (start end)
  "Add an overlay from `start' to `end' in the current buffer.
Push the overlay into `hide-lines-invisible-areas'."
  :override hide-lines-add-overlay
  (let ((overlay (make-overlay start end)))
    (setq hide-lines-invisible-areas (cons overlay hide-lines-invisible-areas))
    (overlay-put overlay 'invisible t)))
#+end_src

****** make sure all lines are hidden
:PROPERTIES:
:ID: b358f324-9b64-4e83-8168-231ff1ab115d
:END:

When I tried hiding property drawers [[hfn:hide-lines-matching][hide-lines-matching]] left out the start and end property
lines. Only the property block body was hidden. This advice fixes this.

#+begin_src emacs-lisp
(defadvice! hide:lines-fix-hide-matching-a  (search-text)
  :override hide-lines-matching
  "Hide lines matching the specified regexp."
  (interactive "MHide lines matching regexp: ")
  (set (make-local-variable 'line-move-ignore-invisible) t)
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward search-text nil t)
      (hide-lines-add-overlay (match-beginning 0) (match-end 0)))))
#+end_src

***** toggle org properties
:PROPERTIES:
:ID: c2c54bd5-9148-45e9-a675-154bcbf13674
:END:

I want properties to exist--they are useful even if it's just to store an ID.
Yet, like most raw org syntax it looks ugly and takes up a lot of space.
Unless I explicitly ask for properties I don't want to see them.

#+begin_src emacs-lisp
(defun org/hide-property-drawers ()
  "Hide property drawers."
  (interactive)
  (let (selective-display-ellipses org-ellipsis)
    ;; If properties are folded, ellipsis will show.
    (org-show-all '(drawers))
    (hide-lines-matching (concat (s-chop-suffix "$" org-property-re) "\n"))))
#+end_src

***** toggle end source lines
:PROPERTIES:
:ID: 18fdd2a0-df15-486f-97c6-594cba018a3e
:END:

#+begin_src emacs-lisp
(defun org/hide-source-block-delimiters ()
  "Hide property drawers."
  (interactive)
  (let (selective-display-ellipses org-ellipsis)
    ;; If properties are folded, ellipsis will show.
    (org-show-all)
    (hide-lines-matching (rx "#+" (or "begin" "end") "_src" (* nonl) "\n"))))
#+end_src

***** ensure that everything is folded
:PROPERTIES:
:ID: 86437909-e4df-48ae-9e2f-bf364e92cc86
:END:

#+begin_src emacs-lisp
(setq-default org-startup-folded 'fold)

(defadvice! org:set-startup-visibility-h ()
  "Completely hide all text properties."
  :override org-set-startup-visibility
  ;; Hide property drawers on startup.
  (org/hide-property-drawers)
  (org-overview))
#+end_src

***** ensure headings are visible
:PROPERTIES:
:ID: c0395fe0-fa69-49c1-94ed-cdbb94031868
:END:

Sometimes the heading inserted doesn't remain visible.

#+begin_src emacs-lisp
(defhook! org:ensure-heading-visible-h ()
  "Ensure that heading remains visible."
  :hook org-insert-heading-hook
  (-when-let (o (cdr (get-char-property-and-overlay (point) 'invisible)))
    (move-overlay o (overlay-start o) (line-end-position 0))))
#+end_src

***** display children in window
:PROPERTIES:
:ID: f7a9c5e7-fcf8-434a-a9b3-dbe4eadead78
:END:

#+begin_src emacs-lisp
(defun org:display-children-in-window ()
  "Scroll up window to maximize view of unfolded subtree.
If the subtree is unfolded and the end of the current subtree is outside of the
visible window, scroll up until the whole subtree is visible. If the whole
subtree can't fit on the visible window, only scroll up until the top of the
subtree is on the first line of the window (in other words, the beginning of
th subtree should always be visible)."
  (interactive)
  ;; Don't use `window-beg' and `window-end' because their values are
  ;; unreliable.
  (let ((subtree-beg
         (save-excursion (org-back-to-heading)
                         (line-beginning-position)))
        (subtree-end
         (save-excursion (org-end-of-subtree)
                         (line-end-position))))
    (save-excursion
      (while (and (pos-visible-in-window-p subtree-beg)
                  (not (pos-visible-in-window-p subtree-end)))
        (scroll-up 1))
      ;; Sometimes the line at the end is not fully visible. So I try to
      ;; scroll down an extra line.
      (unless (pos-visible-in-window-p subtree-beg)
        (scroll-down 1)))))
#+end_src

***** ensure children are visible
:PROPERTIES:
:ID: 479455ed-a0be-4ecc-af66-559abf53c77c
:END:

If I unfold a subtree and the end of the subtree is outside of the window and
there's space in the window above the subtree, scroll up as much as possible.

Note that I don't use [[helpfn:window-start][window-start]] and [[helpfn:window-end][window-end]] because [[info:elisp#Window Start and End][their values are
unreliable]]. They update when [[helpfn:redisplay][redisplay]] is called; and for efficiency, I don't
want to call this function through every iteration of the loop. Instead I used
[[helpfn:pos-visible-in-window-p][pos-visible-in-window-p]] to tell me if a point is still in the visible window. In
hindsight, using this function is even easier than using ~window-beg~ and
~window-end~ because it doesn't require any math on my part.

#+begin_src emacs-lisp
(defadvice! org:ensure-children-visible-a ()
  "Ensure children are visible after toggling."
  :after outline-toggle-children
  (unless (org:heading-folded-p)
    (org:display-children-in-window)))
#+end_src

**** fancy priorities
:PROPERTIES:
:ID: 306faaf1-fa4d-42bd-8863-ae73ca12cb61
:END:

[[package:org-fancy-priorities][org-fancy-priorities]] is a package that displays org priorities with an icon.

#+begin_src emacs-lisp
(use-package! org-fancy-priorities
  :hook org-mode-hook
  :setq
  (org-fancy-priorities-list . (list (all-the-icons-material "priority_high")
                                     (all-the-icons-octicon "arrow-up")
                                     (all-the-icons-octicon "arrow-down")
                                     (all-the-icons-material "low_priority"))))
#+end_src

**** org superstar
:PROPERTIES:
:ID: c43700f5-ff24-46b2-aed5-a12f8d8bb347
:END:

[[package:org-superstar][org-superstar]] is a an =org-bullets= remake redesigned from the ground up.

#+begin_src emacs-lisp
(use-package! org-superstar
  :hook org-mode-hook
  :pre-setq
  (org-superstar-headline-bullets-list . (list "◉" "○" "▷"))
  :setq
  (org-superstar-special-todo-items . t)
  (org-superstar-leading-bullet . ?\s))
#+end_src

*** links
:PROPERTIES:
:ID: dbc3d205-9831-41f0-95f8-1e8746e0be3a
:END:

To me links are one of the biggest drawing points to org-mode. The ability to
have documentation that can link to websites, files, info docs and even github
commits is too juicy to pass up. Why in the 21st century do we still have to
deal with such weak, plain text code documentation when we could use a more
powerful markup language?

**** ol
:PROPERTIES:
:ID: 21148ef5-0887-4560-9997-6059b3529a2d
:END:

#+begin_src emacs-lisp
(use-feature! ol
  :after org
  :custom
  (org-link-descriptive . t)
  (org-link-use-indirect-buffer-for-internals . t))
#+end_src

**** custom link types
:PROPERTIES:
:ID: 76f86439-8ee3-4688-b117-a51d18d365ce
:END:

***** helpvar
:PROPERTIES:
:ID: 20f9629a-f145-44df-b8b4-69c5394dc773
:END:

=helpvar= I a new link type that when pressed, opens a help buffer from [[https://github.com/Wilfred/helpful][helpful]] if
it's installed, otherwise it defaults to bringing up an regular emacs help buffer.

#+begin_src emacs-lisp
(after! org
  (defun ol:helpvar-face (link)
    (if (boundp (intern link)) 'org-link 'error))

  (defun ol:helpvar-follow (link)
    (let ((var (intern link)))
      (if (require 'helpful nil :noerror)
          (helpful-variable var)
        (describe-variable var))))

  (org-link-set-parameters "helpvar" :face #'ol:helpvar:face :follow #'ol:helpvar:follow))
#+end_src

***** helpfn
:PROPERTIES:
:ID: 449a3953-dce5-41a1-afdf-129fa6fae573
:END:

=helpfn= is the same as helpvar except with functions.

#+begin_src emacs-lisp
(after! org
  (defun ol:helpfn-face (link)
    (let ((fn (intern link)))
      (if (fboundp fn) 'org-link 'error)))

  (defun ol:helpfn-follow (link)
    (let ((fn (intern link)))
      (if (require 'helpful nil :no-error)
          (helpful-callable fn)
        (describe-function fn))))

  (org-link-set-parameters "helpfn" :face #'ol:helpfn-face :follow #'ol:helpfn-follow))
#+end_src

**** toggle link display                                              :disabled:
:PROPERTIES:
:ID: 06d2b812-5d76-4bc4-bdce-3b6fcf5a9070
:END:

#+begin_src emacs-lisp
(define-key!
  (:localleader "t")
  (:map org-mode-map)
  ("l" #'org-toggle-link-display)
  ("p" #'org/toggle-property-drawer-display))
#+end_src

*** org capture
:PROPERTIES:
:ID: 81197df0-6744-4a63-a202-f7279d7b7119
:END:

Ever been in the middle of doing something when a thought in your head pops up
about some thing else? You can stop what you're doing but then you lose focus.
You can resolve to make note of it later but then you might forget. Capturing is
designed to confront this problem. While in the middle of a task you can quickly
jump into a small org buffer and write down an idea that you have, then close
it.

**** org capture
:PROPERTIES:
:ID:       8fc5d248-ff21-45e4-a48b-57cecd57b7a3
:END:

#+begin_src emacs-lisp
(use-feature! org-capture
  :after org
  :commands org-capture)
#+end_src

**** completing read for templates
:PROPERTIES:
:ID: 799ac569-85e8-43c0-93ae-a00cf982777f
:END:

The default Org capture templates use this ido-like popup for selecting capture
templates. They shouldn't have made this popup. Org should have just left this
for completing read. Fortunately, there's a package that provides a
completing-read-using replacement for [[helpfn:org-capture][org-capture]] called
[[helpfn:counsel-org-capture-string][counsel-org-capture-string]].

#+begin_src emacs-lisp
(use-package! counsel-org-capture-string
  :after org ivy
  :commands counsel-org-capture-string)
#+end_src

**** remove capture headerline
:PROPERTIES:
:ID: 7b8a8e1d-3c72-492f-9311-56a2428a1f1d
:END:

This was the answer to [[https://emacs.stackexchange.com/questions/53648/eliminate-org-capture-message][my question]]. I need to disable =org-capture's= header-line.

#+begin_src emacs-lisp
(defhook! org:capture-turn-off-header-line-h ()
  "Turn of the header line message."
  :hook org-capture-mode-hook
  (setq-local header-line-format nil))
#+end_src

**** doct
:PROPERTIES:
:ID: 287fb9c7-110e-4758-aab2-71f74079ade2
:END:

[[https://github.com/progfolio/doct][doct]] is a package designed to ease writing and understanding capture templates
by allowing you to write them in a declarative style (see [[][doct docstring]]).
In org mode, capture templates are [[][represented as plain lists]]. This makes
it easy to forget what a certain element meant or to accidentally omit a capture
template element as you're writing it.

#+begin_src emacs-lisp
(use-package! doct
  :after org-capture
  :require t
  :config
  ;; (require 'doct)
  ;; doct just returns the new template.
  (defadvice! doct:add-to-capture-templates (orig-fn &rest args)
    "Automatically add the template to capture templates."
    :around doct
    (alet (apply orig-fn args)
      (prepend! org-capture-templates it))))
#+end_src

**** capture templates
:PROPERTIES:
:ID: aeb0bc04-84a1-4f85-89f9-c2e04cefce92
:END:

***** emacs
:PROPERTIES:
:ID: e6109a54-37af-44ba-852f-a1c34f910cb9
:END:

#+begin_src emacs-lisp
(after! org-capture
  (doct (list "Emacs"
              :keys "e"
              :file (lambda nil (concat VOID:ORG-DIR "todo.org"))
              :prepend t
              :empty-lines 1
              :ID (lambda () (require 'uuidgen) (uuidgen-4))
              :template '("* %{todo-state} %?"
                          ":PROPERTIES:"
                          ":ID: %{ID}"
                          ":CREATED: %U"
                          ":END:")
              :children
              '(("Todo" :keys "1" :todo-state "TODO")
                ("Bug" :keys "2" :todo-state "BUG")))))
#+end_src

***** notes
:PROPERTIES:
:ID: b5af648e-d9fa-4d48-b68b-419c53dcd144
:END:

Sometimes there are things I want to capture that's not a =TODO=, but more like
information I don't want to forget or that I feel like I might need to reference
in the future. I use this template for this.

#+begin_src emacs-lisp
(after! org-capture
  (doct (list "Notes"
              :keys "n"
              :file (lambda nil (concat VOID:ORG-DIR "notes.org"))
              :prepend t
              :empty-lines 1
              :ID (lambda () (require 'uuidgen) (uuidgen-4))
              :template '("* %?"
                          ":PROPERTIES:"
                          ":ID: %{ID}"
                          ":CREATED: %U"
                          ":END:"))))
#+end_src

*** org agenda
:PROPERTIES:
:ID: 65b2885d-aca6-42b8-a8ad-e3ae077b9aae
:END:

[[helpfn:org-agenda-list][org-agenda-list]] is the function that actually takes you to the agenda for the current week.

#+begin_src emacs-lisp
(use-feature! org-agenda
  :after org
  :commands (org-agenda org-agenda-list)
  :setq
  (org-agenda-files . (seq-map (lambda (it) (concat org-directory it))
                               '("todo.org")))
  (org-agenda-start-on-weekday . 0)
  (org-agenda-timegrid-use-ampm . nil)
  (org-agenda-skip-unavailable-files . nil)
  (org-agenda-time-leading-zero . t)
  (org-agenda-text-search-extra-files . '(agenda-archives))
  (org-agenda-dim-blocked-tasks . nil)
  (org-agenda-inhibit-startup . t))
#+end_src

*** org refile
:PROPERTIES:
:ID: 0174a708-8043-403e-b024-8ae29868564d
:END:

#+begin_src emacs-lisp
(use-feature! org-refile
  :after org
  :setq
  (org-refile-targets . `((,VOID:README-FILE . (:maxlevel . 10))
                          (,VOID:TODO-FILE . (:maxlevel . 1))))
  (org-refile-use-outline-path . 'file)
  (org-refile-allow-creating-parent-nodes . t)
  (org-reverse-note-order . t)
  (org-outline-path-complete-in-steps . nil))
#+end_src

*** org id
:PROPERTIES:
:ID: e7ecff83-7ba6-4620-ac05-ebac2f250b7a
:END:

=org-id= is a built-in package that creates that provides tools for creating and
storing universally unique IDs. This is primarily used to disguish and
referenance org headlines.

#+begin_src emacs-lisp
(use-feature! org-id
  :commands org-id-get-create
  :setq
  (org-id-locations-file . (concat VOID:DATA-DIR "org-id-locations"))
  ;; Global ID state means we can have ID links anywhere. This is required for
  ;; `org-brain', however.
  (org-id-locations-file-relative . t)
  :hook (org-insert-heading-hook . org-id-get-create))
#+end_src

*** org clock
:PROPERTIES:
:ID:       d378471c-89df-48c9-a755-b79880f27308
:END:

=org-clock= is a built-in package that provides time logging functions for
tracking the time you spend on a particular task.

#+begin_src emacs-lisp
(use-feature! org-clock
  :commands org-clock-in
  ;; :before-call ((org-clock-in org-clock-out org-clock-in-last org-clock-goto org-clock-cancel) . (org-clock-load))
  :hook (kill-emacs-hook . org-clock-save)
  :setq
  ;; org-clock-sound
  ;; org-show-notification-handler
  (org-clock-persist . 'history)
  (org-clock-persist-file . (concat VOID:DATA-DIR "org-clock-save.el"))
  ;; Resume when clocking into task with open clock
  (org-clock-in-resume . t)
  :config
  ;; set up hooks for persistence.
  (org-clock-persistence-insinuate))
#+end_src

*** org crypt
:PROPERTIES:
:ID:       f5278890-8b84-43df-b5dc-0ef8074bfba9
:END:

#+begin_src emacs-lisp
(use-package! org-crypt
  :commands org-encrypt-entries org-encrypt-entry org-decrypt-entries org-decrypt-entry
  :hook (org-reveal-start . org-decrypt-entry)
  ;; :preface
  ;; ;; org-crypt falls back to CRYPTKEY property then `epa-file-encrypt-to', which
  ;; ;; is a better default than the empty string `org-crypt-key' defaults to.
  ;; (defvar org-crypt-key nil)
  ;; (after! org
  ;;   (add-to-list 'org-tags-exclude-from-inheritance "crypt")
  ;;   (add-hook! 'org-mode-hook
  ;;              (add-hook 'before-save-hook 'org-encrypt-entries nil t)))
  )
#+end_src

*** org-journal
:PROPERTIES:
:ID:       c3056303-5fa1-49f9-ae2d-294942e25f54
:END:

=org-journal= is a package that provides functions to maintain a simple
diary/journal using =org-mode=.

#+begin_src emacs-lisp
(use-package! org-journal
  :commands org-journal-new-entry
  :setq
  (org-journal-file-type . 'yearly)
  (org-journal-dir . (concat VOID:ORG-DIR "journal/"))
  (org-journal-find-file . 'find-file))
#+end_src

*** keybindings
:PROPERTIES:
:ID: ee444a86-1266-42dd-9fe8-40192db1fdde
:END:

**** narrowing and widening                                           :disabled:
:PROPERTIES:
:ID: 72bd1c81-bd60-472f-8166-20bb2a16093d
:END:

#+begin_src emacs-lisp
(define-key!
  (:localleader "n")
  (:map org-mode-map)
  (:wk "Narrow" "" nil)
  (:wk "To Element" :n "e" #'org-narrow-to-element)
  (:wk "To Block"   :n "b" #'org-narrow-to-block)
  (:wk "To Subtree" :n "s" #'org-narrow-to-subtree)
  (:wk "Widen"      :n "w" #'widen))
#+end_src

**** replace evil folding commands to outline folding
:PROPERTIES:
:ID: b3a4908d-538e-4d4c-acc9-fbd822220f03
:END:

By default evil binds =za= to [[helpfn:evil-open-folds][evil-open-folds]] and =zb= to [[helpfn:evil-close-folds][evil-close-folds]]. They do
work in =org-mode= but I'd rather use the folding commands provided by =outline.el.=
The outline api actually seems pretty solid; better coded and simpler than the org api it seems.

#+begin_src emacs-lisp
;; (define-key!
;;   (:leader "z")
;;   (:n "a" #'outline-show-all)
;;   (:n "m" #'outline:hide-all-sublevels))

(general-def 'normal org-mode-map
  [tab] #'outline-toggle-children
  "TAB" #'outline-toggle-children)

(defun outline:hide-all-sublevels ()
  (interactive)
  (outline-hide-sublevels 1))

(general-def 'normal org-mode-map
  "j" #'org/dwim-next-line
  "k" #'org/dwim-previous-line
  "b" #'org/dwim-insert-elisp-block
  "o" #'org/insert-heading-below
  "O" #'org/insert-heading-above
  "l" #'org-do-demote
  "h" #'org-promote-subtree
  "L" #'org-demote-subtree
  "t" #'org-set-tags-command
  "r" #'org-capture
  "s" #'org-schedule
  "S" #'org-deadline
  "R" #'org-refile
  "T" #'org-todo
  "D" #'org-cut-subtree
  "Y" #'org-copy-subtree
  "K" #'org-metaup
  "J" #'org-metadown)
#+end_src

** lua
:PROPERTIES:
:ID: 9f458b76-489f-45e0-b99a-ad6a9a2ae182
:END:

#+begin_src emacs-lisp
(use-package! lua-mode :mode "\\.lua\\'")
#+end_src

* User Interface
:PROPERTIES:
:ID: ee57f711-9a4f-421f-b831-ab4907402e52
:END:

** helpful
:PROPERTIES:
:ID: 25270809-b64e-4b9a-b0c2-95ffd047280c
:END:

[[github:wilfred/helpful][helpful]] provides a complete replacement for the built-in
Emacs help facility which provides much more contextual information
in a better format.

#+begin_src emacs-lisp
(use-package! helpful
  :popup
  ("\\*Help.*"
   (display-buffer-at-bottom)
   (window-width . 0.50)
   (side . bottom)
   (slot . 4))
  :bind
  ([remap describe-function] . helpful-callable)
  ([remap describe-command]  . helpful-command)
  ([remap describe-variable] . helpful-variable)
  ([remap describe-key]      . helpful-key))
#+end_src

** elisp demos
:PROPERTIES:
:ID: d1164fd9-bfc6-4436-a249-136a63c76e40
:END:

This package improves help further by allowing you to add examples on how to use
a function or macro. It seems simple but having examples can really ease the
understanding of a verbally terse and dry command description.

#+begin_src emacs-lisp
(use-package! elisp-demos
  ;; :functions elisp-demos-advice-helpful-update
  :commands elisp-demos-add-demo
  :init (advice-add #'helpful-update :after #'elisp-demos-advice-helpful-update))
#+end_src

* Asthetic
:PROPERTIES:
:ID: bd21a69a-794c-4ff1-97d0-9e5911a26ad7
:END:

It's easy to underestimate how much of a difference having an asthetically
pleasing Emacs configuration can have. Ugliness really can take its toll.

** dashboard
:PROPERTIES:
:ID: 20926522-b78b-4bca-b70e-9ef4213c4344
:END:

[[https://github.com/emacs-dashboard/emacs-dashboard][dashboard]] is an extensible emacs startup screen. I love the idea of =dashboard=:
having an extensible, fast, nice-looking dashboard when starting emacs is
nice. It's not only nice asthetically, it's also strategic too. First, you can
use it as a launching point to get to your tasks quicker. And second, it doesn't
require any expensive modes. I've often been starting out with the scratch
buffer and I've wanted to have the scratch buffer start off with
=emacs-lisp-mode=, but I don't want it to trigger =company=, =yasnippet=, etc. on
startup. If I start my emacs with =dashboard= I can avoid this.

*** dashboard
:PROPERTIES:
:ID: 9de45782-1683-40ef-aff2-95c0dbaa4ba7
:END:

#+begin_src emacs-lisp
(use-package! dashboard
  :require t
  :hook (window-setup-hook . dashboard-insert-startupify-lists)
  :setq
  (dashboard-items . nil)
  (dashboard-startup-banner . 2)
  (dashboard-center-content . t)
  (initial-buffer-choice . (lambda () (get-buffer-create dashboard-buffer-name))))
#+end_src

*** dashboard-init-info
:PROPERTIES:
:ID: 92c199ad-5862-4fe3-be04-44c94d4286b6
:END:

[[helpvar:void-init-time][void:init-time]] is more accurate than dashboard's init time measure. So I use it instead.

#+begin_src emacs-lisp
(defadvice! dashboard:set-init-info-a (&rest _)
  "Use `void:init-time' dashboard."
  :before dashboard-insert-startupify-lists
  (setq dashboard-init-info
        (format "%d packages loaded in %.2f seconds"
                (cond ((featurep 'straight)
                       (hash-table-size straight--profile-cache))
                      (t
                       (package (length package-activated-list))))
                (string-to-number (emacs-init-time)))))
#+end_src

*** banner path
:PROPERTIES:
:ID: 597af7c3-f5d2-4cf5-a93e-3dd3564fb34a
:END:

#+begin_src emacs-lisp
(defadvice! dashboard:custom-banner-path-a (&rest _)
  "Use the Void text banner."
  :override dashboard-get-banner-path
  (concat VOID:LOCAL-DIR "void-banner.txt"))
#+end_src

** hide-mode-line
:PROPERTIES:
:ID: 043e3474-7b66-4e73-9e0b-3347897dbdcc
:END:

[[https://github.com/hlissner/emacs-hide-mode-line][hide-mode-line]] is another package that does exactly what it's name says: hide
the mode line.

#+begin_src emacs-lisp
(use-package! hide-mode-line
  :hook Man-mode completion-list-mode)
#+end_src

** all-the-icons
:PROPERTIES:
:ID: 6a7c7438-42c0-4833-9398-fa9fd58515d1
:END:

A little bit of decoration and spice can go a long way. As its name suggests,
[[all-the-icons][all-the-icons]] is a package that contains a lot of icons ([[][here]] you can see
a few). In practice I use these icons to (1) make things look nicer and more
colorful and (2) enhance readability of plain text.

*** install all the icons if not installed :disabled:
:PROPERTIES:
:ID: 1cda0692-8f42-4bb3-b11d-da52e2004a55
:END:

This will install the icons if they're not already installed. Unless somehow the
fonts are deleted, this code should only take effect the first time installing
void. This helps achieve the goal to automate as much as possible on a fresh
VOID install. For writing this code I referenced the body of
[[helpfn:all-the-icons-install-fonts][all-the-icons-install-fonts]].

#+begin_src emacs-lisp
(let ((font-dir
       (cl-case window-system
         (x (concat (or (getenv "XDG_DATA_HOME")
                        (concat (getenv "HOME") "/.local/share"))
                    "/fonts/"))
         (mac (concat (getenv "HOME") "/Library/Fonts/" ))
         (ns (concat (getenv "HOME") "/Library/Fonts/" )))))
  (unless (seq-every-p (lambda (it) (file-exists-p (concat font-dir it)))
                       '("all-the-icons.ttf"
                         "file-icons.ttf"
                         "fontawesome.ttf"
                         "material-design-icons.ttf"
                         "octicons.ttf"
                         "weathericons.ttf"))
    (void:log "No icons installed. Installing...")
    (all-the-icons-install-fonts :ignore-prompt)))
#+end_src

*** boostrap
:PROPERTIES:
:ID: a13cf0ec-14e2-4d4b-b313-65fe68f0655b
:END:

#+begin_src emacs-lisp
(use-package! all-the-icons
  :commands (all-the-icons-octicon
             all-the-icons-faicon
             all-the-icons-fileicon
             all-the-icons-wicon
             all-the-icons-material
             all-the-icons-alltheicon))
#+end_src

*** disable in tty
:PROPERTIES:
:ID: fce313d3-aa5a-4ea8-b994-1f9a8e33ab9d
:END:

In terminals these icons will not display correctly. I usually use emacs as a
graphical interface but.

#+begin_src emacs-lisp
(defadvice! void:disable-all-the-icons-in-tty-a (orig-fn &rest args)
  "Disable icons in tty."
  :around (all-the-icons-octicon
           all-the-icons-material
           all-the-icons-faicon
           all-the-icons-fileicon
           all-the-icons-wicon
           all-the-icons-alltheicon)
  (if (display-graphic-p) (apply orig-fn args) ""))
#+end_src

** themes
:PROPERTIES:
:ID: fb192344-8aef-4ab1-800d-6b5cd8c900b9
:END:

I am one of the few that prefers light themes over dark ones. I find light
themes more readable. And if I had to guess, I'd guess humans have evolved to
see dark on light better than light on dark.

#+begin_src emacs-lisp
(use-package! humanoid-themes
  :pre-setq (humanoid-org-bold . nil))

(use-package! spacemacs-theme
  :pre-setq
  (spacemacs-theme-org-bold . nil)
  (spacemacs-theme-comment-italic . t)
  (spacemacs-theme-org-bold . nil)
  (spacemacs-theme-org-height . nil))

(use-package! tao-theme)

(use-package! zenburn-theme)

(use-package! color-theme-sanityinc-tomorrow)

(use-package! gruvbox-theme)

(use-package! one-themes)

(use-package! solarized-theme
  :pre-setq (solarized-use-variable-pitch . nil))

(use-package! avk-emacs-themes)
#+end_src

* Keybindings
:PROPERTIES:
:ID: 226e2c5b-2b81-483a-9942-d0ca0fc80f1f
:END:

** general
:PROPERTIES:
:ID: 3260f794-2d7f-4a68-a36a-78af01e4a4a9
:END:

This heading is dedicated to general keybinding decisions I make.

*** execute extended command
:PROPERTIES:
:ID: d8071a32-e58c-41ab-8fd7-7d7732708ee8
:END:

One of the most common--if not the most common--command you use in Emacs is
[[helpfn:execute-extended-command][execute-extended-command]]. This command let's you search any other command and
upon pressing enter, then you execute the command. The fact that this command is
invoked so frequently demands it have one of the shortest, easiest to press
bindings. I chose to give it =SPC SPC= and =;=. =SPC SPC= is short and quick to
type as well as consistent with other =SPC= bindings. While =;= is super fast to
press as well and even faster than =SPC SPC=.

#+begin_src emacs-lisp
(define-leader-key! "SPC" (list :def #'execute-extended-command :wk "M-x"))

(general-def
  "A-x" #'execute-extended-command
  "M-x" #'execute-extended-command)

(general-def 'normal ";" #'execute-extended-command
  "q" #'delete-window)
#+end_src

*** scrolling pages
:PROPERTIES:
:ID: 4861fa41-7185-471f-bfad-bba1283414ce
:END:

I scroll pages all the time. The default binding for scrolling pages in evil are
=C-j= to scroll down and =C-k= to scroll up. These chords are too much for such
common commands however, so I bound them to =J= and =K= respectively.

#+begin_src emacs-lisp
(general-def 'normal
  "K" #'evil-scroll-page-up
  "J" #'evil-scroll-page-down)
#+end_src

*** increasing text scale
:PROPERTIES:
:ID: 927dedb6-eee9-47ff-9298-c2e21bbce524
:END:

As someone who spends much of his day on the computer.

#+begin_src emacs-lisp
(general-def '(emacs normal)
  "M--" #'text-scale-decrease
  "M-=" #'text-scale-increase)
#+end_src

** windows
:PROPERTIES:
:ID: 784956e2-3696-4f92-80ca-41b7e30e5b2b
:END:

Efficient window management in Emacs crucial for success. These keys all pertain
to window/workspace actions.

#+begin_src emacs-lisp
(define-leader-key!
  :infix "w"
  ""  (list :ignore nil                              :wk "window")
  "w" (list :def #'display-buffer :wk "display buffer")
  "o" (list :def #'other-window                      :wk "other window")
  "S" (list :def #'void/window-split-below-and-focus :wk "split below and focus")
  "V" (list :def #'void/window-split-right-and-focus :wk "split right and focus")
  "s" (list :def #'split-window-below                :wk "split below")
  "v" (list :def #'split-window-right                :wk "split right")
  "M" (list :def #'maximize-window                   :wk "maximize")
  "m" (list :def #'minimize-window                   :wk "minimize")
  "b" (list :def #'balance-windows                   :wk "move left")
  "d" (list :def #'delete-window                     :wk "delete current")
  "D" (list :def #'delete-other-windows              :wk "delete others")
  "h" (list :def #'windmove-left                     :wk "move left")
  "j" (list :def #'windmove-down                     :wk "move down")
  "k" (list :def #'windmove-up                       :wk "move up")
  "l" (list :def #'windmove-right                    :wk "move right")
  "x" (list :def #'ace-swap-window                   :wk "swap windows")
  "t" (list :def #'transpose-frame                   :wk "transpose")
  "n" (list :def #'eyebrowse-create-window-config    :wk "save window config")
  "J" (list :def #'eyebrowse-next-window-config      :wk "next window config")
  "K" (list :def #'eyebrowse-prev-window-config      :wk "prev window config"))
#+end_src

** buffer
:PROPERTIES:
:ID: e3eec4f8-88d8-4010-adb5-2f8e05f14677
:END:

In emacs, we change the buffer a window's displaying pretty often. That's why
efficient buffer navigation is a must. There are particular buffers which I
visit so often that it's worth having keybindings just for them.

#+begin_src emacs-lisp
(define-leader-key!
  :infix "b"
  ""  (list :def nil                            :wk "buffer")
  "e" (list :def #'buffer-expose                :wk "expose")
  "p" (list :def #'previous-buffer              :wk "previous")
  "n" (list :def #'next-buffer                  :wk "next")
  "s" (list :def #'switch-to-buffer             :wk "switch")
  "b" (list :def #'switch-to-buffer             :wk "switch")
  "d" (list :def #'display-buffer               :wk "display")
  "t" (list :def #'void/switch-to-todo-file     :wk "Void TODO")
  "S" (list :def #'void/open-scratch            :wk "*scratch*")
  "i" (list :def #'void/switch-to-init-org-file :wk "fallback")
  "I" (list :def #'void/switch-to-main-elisp    :wk "main.el")
  "m" (list :def #'void/switch-to-main-org-file :wk "Void README")
  "M" (list :def #'void/switch-to-messages      :wk "*messages*"))

(define-leader-key!
  :infix "b k"
  ""  (list :ignore t             :wk "kill")
  "c" (list #'kill-current-buffer :wk "current"))
#+end_src

** app
:PROPERTIES:
:ID: 3f09a41a-03b8-4d5c-85c5-d7adeb7dd328
:END:

These keybindings are for opening particular apps. When I'm testing Void I like
to open another emacs instance.

#+begin_src emacs-lisp
(define-leader-key!
  :infix "a"
  ""  (list :ignore t                       :wk "app")
  "a" (list :def #'counsel-linux-app :wk "open app")
  "E" (list :def #'elfeed                   :wk "elfeed")
  "d" (list :def #'deer                     :wk "deer")
  "r" (list :def #'ranger                   :wk "ranger")
  "e" (list :def #'void/open-emacs-instance :wk "emacs")
  "q" (list :def #'void/open-qutebrowser    :wk "qutebrowser")
  "q" (list :def #'void/open-next           :wk "next")
  "w" (list :def #'w3m                      :wk "w3m")
  "c" (list :def #'org-capture              :wk "capture"))
#+end_src

** file
:PROPERTIES:
:ID: 2231147b-88c9-4c63-9c75-488cd1465807
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "f"
  ""  (list :ignore t          :wk "file")
  "S" (list :def #'sudo-edit   :wk "sudo")
  "s" (list :def #'save-buffer :wk "save buffer")
  "f" (list :def #'find-file   :wk "find file")
  "r" (list :def #'ranger      :wk "ranger")
  "d" (list :def #'deer        :wk "deer"))
#+end_src

** eval
:PROPERTIES:
:ID: afa6be08-a38c-45f1-867a-5620fc290aac
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "e"
  ""  (list :ignore t                   :wk "eval")
  "r" (list :def #'eval-region          :wk "region")
  "d" (list :def #'eval-defun           :wk "defun")
  "l" (list :def #'eval-print-last-sexp :wk "sexp")
  "b" (list :def #'eval-buffer          :wk "buffer"))
#+end_src

** code
:PROPERTIES:
:ID: 661f77fb-3435-4e4f-8adb-c4d6390ea6b8
:END:

These bindings are for generally working with code.

#+begin_src emacs-lisp
(define-leader-key!
  :infix "c"
  ""  (list :ignore t                                   :wk "code")
  "a" (list :def #'ialign                               :wk "align")
  "l" (list :def #'lispyville-comment-or-uncomment-line :wk "toggle comment")
  "y" (list :def #'lispyvile-comment-and-cone-dwim      :wk "copy comment"))
#+end_src

** toggle
:PROPERTIES:
:ID: 10d6851b-6af6-4185-8976-0ad65b3d1d28
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "t"
  ""  (list :ignore t                    :wk "toggle/set")
  "r" (list :def #'read-only-mode        :wk "read-only")
  "t" (list :def #'load-theme            :wk "load theme")
  "c" (list :def #'caps-lock-mode        :wk "caps lock")
  "d" (list :def #'toggle-debug-on-error :wk "debug")
  "F" (list :def #'counsel-fonts         :wk "set font")
  "f" (list :def #'void/set-font-size    :wk "font size"))

(define-leader-key!
  :infix "t"
  :keymaps 'org-mode-map
  "l" (list :def #'org-toggle-link-display :wk "link display"))
#+end_src

** help
:PROPERTIES:
:ID: c7f3b699-7cf9-480b-a88c-10bdae4c165e
:END:

There's a lot of documentation finding and information searching involved in
Emacs and for that we need all the help we can get.

#+begin_src emacs-lisp
(define-leader-key!
  :infix "h"
  ""  (list :ignore t                      :wk "help")
  "h" (list :def #'describe-function       :wk "function")
  "v" (list :def #'describe-variable       :wk "variable")
  "c" (list :def #'describe-char           :wk "char")
  "k" (list :def #'describe-key            :wk "key")
  "f" (list :def #'describe-function       :wk "function")
  "l" (list :def #'global-command-log-mode :wk "command log")
  "a" (list :def #'apropos                 :wk "apropos"))
#+end_src

** quit
:PROPERTIES:
:ID: d4828ea9-5ee1-4424-8ff0-f700876d34fd
:END:

There's many ways to quit Emacs. Sometimes I'd like to save all the buffers I
had been working on. Sometimes, when I'm testing something and I mess up
[[helpvar:kill-emacs-hook][kill-emacs-hook]] I want Emacs to just quit even if it means ignoring that hook.
Most of the time, I know what I'm doing when I quit Emacs, so I don't want a
prompt asking me if I'm sure.

#+begin_src emacs-lisp
(define-leader-key!
  :infix "q"
  ""  (list :ignore t                        :wk "quit")
  "q" (list :def #'evil-quit-all             :wk "normally")
  "s" (list :def #'void/quit-emacs-no-prompt :wk "with no prompt")
  "Q" (list :def #'evil-save-and-quit        :wk "and save")
  "x" (list :def #'void/kill-emacs-no-hook   :wk "with no hook")
  "e" (list :def #'void/kill-emacs-processes :wk "emacs processes")
  "b" (list :def #'void/kill-emacs-brutally  :wk "brutally")
  "r" (list :def #'restart-emacs             :wk "and restart"))
#+end_src

** packages
:PROPERTIES:
:ID: d3286920-ead4-4f7c-bf9d-8a6ed3d7ba46
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "p"
  ""  (list :ignore t                       :wk "package")
  "i" (list :def #'straight-use-package     :wk "install")
  "r" (list :def #'straight-rebuild-package :wk "rebuild")
  "p" (list :def #'straight-pull-package    :wk "pull")
  "s" (list :def #'straight/search-package  :wk "search"))
#+end_src

** search
:PROPERTIES:
:ID: b50ed0da-652d-4d20-8a4e-e0cf053548a6
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "s"
  ""  (list :ignore t :wk "search")
  "s" (list :def #'swiper :wk "swiper"))

(define-leader-key!
  :infix "s"
  :keymaps 'org-mode-map
  "h" (list :def #'counsel-org-goto :wk "headlines"))
#+end_src

** git
:PROPERTIES:
:ID: 87ba6613-6606-423c-84ec-f7c9ae10c9a6
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "g"
  ""  (list :ignore t           :wk "git")
  "c" (list :def #'magit-commit :wk "commit")
  "s" (list :def #'magit-status :wk "status"))
#+end_src
