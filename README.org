* table of contents                                                        :TOC:
:PROPERTIES:
:ID:       55f0c499-f347-49eb-b243-ad7afd705465
:END:

- [[#about][about]]
  - [[#highlights][highlights]]
  - [[#goals][goals]]
  - [[#why-set-up-my-dot-files-this-way][why set up my dot files this way?]]
  - [[#a-word-on-some-org-links][a word on some org links]]
  - [[#why-emacs-as-an-os][why Emacs as an OS]]
- [[#bootstrap][bootstrap]]
  - [[#helpers][helpers]]
  - [[#simple-generic-tangling][simple generic tangling]]
  - [[#collecting-blocks][collecting blocks]]
  - [[#ensuring-my-emacs-has-handles-errors-gracefully][ensuring my Emacs has handles errors gracefully]]
- [[#helpers-1][helpers]]
  - [[#evaluation-nowebs][evaluation nowebs]]
- [[#xinitrc][xinitrc]]
  - [[#first-remap-caps-lock-with-escape][first remap caps lock with escape]]
  - [[#then-load-emacs][then load emacs]]
- [[#guix][guix]]
  - [[#starting-org-on-guix][starting org on guix]]
- [[#gpg-agent][gpg-agent]]
- [[#git-config][git-config]]
- [[#emacs][emacs]]
  - [[#naming-conventions][naming conventions]]
  - [[#early-init][early-init]]
  - [[#initel][init.el]]
- [[#email][email]]
  - [[#some-notes-on-the-config][some notes on the config]]
  - [[#helpers-2][helpers]]
  - [[#mbsync][mbsync]]
  - [[#msmtprc][msmtprc]]

* about
:PROPERTIES:
:ID:       35454181-33bc-412e-a4a6-4268909d26d7
:END:

This README contains the information to generate my [[https://www.quora.com/What-are-dotfiles?share=1][dotfiles]]. It is written in
[[https://html.duckduckgo.com/html?q=org%20mode%20%22emacs%22][Org]] and centers around [[https://www.gnu.org/software/emacs/][Emacs]].

** highlights
:PROPERTIES:
:ID:       acc521a7-7244-48de-88dc-fbf1f0ad72f5
:END:

This headline contains things I think make my dotfiles special and unique. I
don't expect the reader to have the time to go through this whole file. So I
include this here as a quick summary.

*** an *extremely* powerful emacs configuration
:PROPERTIES:
:ID:       bea8c3aa-8b2b-4269-ba6e-dcb037f32606
:END:

My Emacs configuration is the centerpiece of my dotfiles. Emacs is the interace
I use to do everything on my computer. This is why it is very heavily configured.

**** heavy use of [[https://github.com/jwiegley/use-package][use-package]]
:PROPERTIES:
:ID:       527f3a4b-e1f9-4a6d-9452-5ea686368cee
:END:

To be honest I was very skeptical of use-package when I heard about it in the
Emacs community. And, I've been on an off with it. When I decided to experiement
not using it I feel that I've gained a deeper understanding of the reasoning
behind the use-package macro.

**** a rich set of [[id:62cec5ac-a2f9-435b-96a7-4db0d9691f25][custom use-package keywords]]
:PROPERTIES:
:ID:       82ced1c3-f08e-474a-9aa6-967404ca01f6
:END:

When creating use-package keywords I tried to think of things that I do often
when configuring packages. I came up with many useful new use-package
keywords. I think that even if a reader does not decide to incorporate the
keywords I defined in their config, they can still benefit from seeing how
use-package keywords are defined (to me at least =use-package= README wasn't
enough).

**** interesting [[id:cfe0d468-92ee-4a4f-9908-4ea0b1964ac4][custom macros]]
:PROPERTIES:
:ID:       12caf923-a9f1-4536-85be-3c81e93fa3b4
:END:

I have a good variety of macros to add useful syntax. Some of these include
[[][after!]], block.

**** a plethora of configured packages
:PROPERTIES:
:ID:       a626c6c1-daa8-43eb-a553-6e3983ad8748
:END:

I have an ever-growing quanity of packages :package:. The list is great but some
are...

**** next-level documentation
:PROPERTIES:
:ID:       9b7b1fe0-50c3-4835-ba98-059ccf50c54b
:END:

Because I'm using an org configuration I can write rich documentation for my
Emacs config where I link to other headlines, to screenshots or gifs I've taken,
or to websites online. Check out this [[https://orgmode.org/quickstart.html][org-quickstart]] for a taste of the ways I
can spice up documentation.:paperclip: 

Additionally, I use [[id:d3e15439-f690-4ced-b701-0882fb911a5c][emojis]]. Documentation doesn't have to be terse and dry.

**** naming-convention
:PROPERTIES:
:ID:       1adf42e5-4928-4e37-9d5d-d86119558c4f
:END:

Naming conventions are important in my Emacs config. In fact, naming in general
is very important--it is a part of documentation.:name_badge: 

**** introspectable
:PROPERTIES:
:ID:       914b6bff-cbde-425b-9730-7b06ba9fa843
:END:

I log the actions of hooks and advices using [[id:d73fd7b1-5610-4d93-8802-1aa57c8c1918][elog]]. :mag-right:

**** fast candidate selection featuring [[https://github.com/raxod502/selectrum][selectrum]]
:PROPERTIES:
:ID:       e3544a41-90fe-49e8-8afe-ee51d93fe9fb
:END:

**** a strong focus on speed and performance
:PROPERTIES:
:ID:       8505fa5c-e0eb-4349-bca0-d6d334910d7d
:END:

I'll list some things that I do to improve performance.

***** load certain packages before a function is called
:PROPERTIES:
:ID:       b196836f-588b-42ee-884f-fa4c4d683106
:END:

***** use a higher rate of garbage collection by default
:PROPERTIES:
:ID:       c5aefa48-2d51-4471-82a2-59fc48c8e5ad
:END:

***** pause garbage collection for performance intensive functions
:PROPERTIES:
:ID:       d0e6ff64-75fc-4cba-abc1-904106737dff
:END:

***** lazy load packages whenever possible
:PROPERTIES:
:ID:       9893f500-4073-411d-a7e4-784453120df0
:END:

*** guix =config.scm= configuration
:PROPERTIES:
:ID:       fdfd18ef-db82-422f-83fa-9f245238513a
:END:

I have a working =config.scm= configuration.

*** org-mode dotfile setup
:PROPERTIES:
:ID:       de124433-d177-4e76-aa93-5b0f3a5530c4
:END:

Org dotfile setups are extremely uncommon even among Emacs users. It is also
uncommon--even among Emacs users--to completely center your OS around Emacs,
using it even as your window manager. This configuration does both these
things. I avoid using shell commands like the plauge, not because they're too
hard or I can't learn them but because elisp is just much more expressive.

*** clean code
:PROPERTIES:
:ID:       4750db36-7d1d-41e7-87d6-99a227e4ab01
:END:

I want to make the point with my config that it is possible to program with
small functions. I avoid having too much code in one function. I think this
makes each source block much easier to understand; and, overall, it makes it
easier for me to make fine-grained changes. I find short blocks of well-written
code to be easy to read and reason with than huge functions.

** goals
:PROPERTIES:
:ID:       a5988006-d29d-4718-bd1f-189ddd9702f2
:END:

Here I describe in more depth what goals I had in mind when I wrote these
dotfiles.

*** reproducability and easy set-up
:PROPERTIES:
:ID:       5700ee45-a841-4223-9548-b3810e57f07d
:END:

The main goal of my dotfiles is to provide me with a completely reproducable
setup. I want to be able to generate my complete workspace with just two things,
a usb containing my private gpg key and my dotfiles stored on github. It is my
goal to one day make the setup /completely/ reproducable down to the package
versions. It is now possible to do this with [[https://guix.gnu.org/][guix]] and [[https://github.com/raxod502/straight.el][straight.el]].

*** center everything around emacs
:PROPERTIES:
:ID:       099f0d22-e47c-49cf-bc45-a5019160c5ad
:END:

I use Emacs every day. I feel that it is currently the most cutomizable and
efficient way to use a computer. One goal is to avoid "leaving" Emacs as much as
possible. By leaving Emacs I mean having to configure files in some other
language.

*** help others
:PROPERTIES:
:ID:       922c122d-990c-4144-9e00-ee58b777e2f2
:END:

I've spent *alot* of time on Emacs. I feel an obligation to others. I feel I am
very fortunate to have learned so many things. So I want to do my part to share
what I have learned. This is also by the way one of the reasons I choose org
mode. With Org I can express myself better--and, in turn, better explain to
others what I did, why I did it, how I did it, what my thoughts are about it,
etc.

** why set up my dot files this way?
:PROPERTIES:
:ID:       59aa853c-1764-41f6-bee4-b01bea1733ff
:END:

It took me a long time to come to the conclusion to set up my dotfiles like
this. It's certainly unorthodox. However, I was convinced by the benefits.

*** simple file/directory structure
:PROPERTIES:
:ID:       ed3ac468-ef9b-4be5-8f2d-44fb29a6ac77
:END:

It is simpler to have everything (except a small amount of bootstrap code) in
one file as opposed to having a complex heirarchy of files and directories.

*** consistent documentation throughout
:PROPERTIES:
:ID:       4fb4fd3b-508c-4454-b831-db7e8827e035
:END:

Configuration files are often in different languages. Different languages have
different comment syntax. Having my configuration files in an org-mode files
means I can have consistent documentation that's all in the same
syntax. Moreover, the structure of an Org file does well to homogenize the
varying differences of a language.

*** more expressive documentation
:PROPERTIES:
:ID:       d55cdbb7-f2c1-4cae-a80f-0ff22652f1c4
:END:

Documentation comments are not expressive enough. Sometimes, I want to show a
picture or a gif of what I'm talking about. Other times, I want to reference
some other file or some place in a file or a link to a website. Even adding
emphasis to certain things could be useful. Comments can't do any of this, but
[[https://orgmode.org/][Org]] can.

*** dynamism
:PROPERTIES:
:ID:       f77797b8-172e-4482-87a4-5ede829b3b13
:END:

When you initialize dotfiles on different machine settings can be
different. Using elisp to generate my dotfiles allows me to have dotfiles which
dynamically change depending on the situation.

** a word on some org links
:PROPERTIES:
:ID:       c569cf46-4481-4e55-9adb-46ac87c691b0
:END:

You may find some links don't work. The reason might just be because the website
link is broken or I made a mistake on my end. But I wanted to note that there
are some org links that a site hosting this repo wouldn't know about. Links I've
defined myself fall under this category such as [[][helpvar]] and [[helpfn]]. These
links need to execute elisp to work and I doubt any site will now how to do
that, so these links would only work if you define them yourself in an Emacs
session. There are also some links that such a site might simply not have
support for, for instance.

** why Emacs as an OS
:PROPERTIES:
:ID:       d5dd828b-43bc-4909-84f1-d841340dc3ab
:END:

You'll notice that I use Emacs as my window manager, which is pretty unorthodox
not only compared to the population as a whole but also even relative to
programmers and linux users. The desire of people like me to use Emacs as an OS
belies a desire to have a truly programmable operating system written in
primarily one language that is rich and turing complete--and is a lisp.

* bootstrap
:PROPERTIES:
:ID:       33e48baf-fada-40d6-a219-fec0116ae480
:END:

The purpose of this headline is to contain the code I need for bootstraping
Emacs.

I'm not doing a typical tangle for a couple of reasons. One is that I want the
Emacs subtree to be tangled first so that I can run Emacs before tangling
anything else. The reason is I use some libraries not built-in to Emacs such as
[[https://github.com/okamsn/loopy][loopy]] and [[https://github.com/magnars/dash.el][dash]]. Additionally, I want to have some choice between which dotfiles
are tangled/generated and which are not. For sure I'm going to want Emacs
tangled no matter what but I might not want to tangle other dotfiles. On a
computer with Windows or Mac OS, for example, there's no point in tangling the
=.xinitrc= because I can't use Xorg. Finally, I want to add some error catching
functionality that would take advantage of the fact that my Emacs config is
separated into blocks.

** helpers
:PROPERTIES:
:ID:       4e0bacda-d2e8-4ede-b2c8-3e2557d5996d
:END:

*** evaluate source block with headline
:PROPERTIES:
:ID:       d6b0d623-532f-4bb2-abb2-e2cc11fad9d5
:END:

I need to load specific org blocks.

#+begin_src emacs-lisp
(defun org:load-subtree (id file)
  "Evaluate the contents of source block at headline."
  (let ((regexp (rx-to-string `(seq bol ":ID:" (1+ space) ,id))))
    (with-temp-buffer
      (insert-file-contents file)
      (re-search-forward regexp nil t nil)
      (org-back-to-heading)
      (org-narrow-to-subtree)
      (org-babel-execute-subtree))))
#+end_src

** simple generic tangling
:PROPERTIES:
:ID:       86586de0-8c3a-4cd1-83bd-ce05a5e57b8b
:END:

#+begin_src emacs-lisp
(defun xl-tangle-dotfiles (name)
  "Tangle emacs dotfiles from `XL-README'."
  (require 'org)
  (with-current-buffer (get-file-buffer "~/README.org")
    (save-excursion
      (save-restriction
	(widen)
	(goto-char (point-min))
	(re-search-forward (rx-to-string `(seq bol "*" space ,name)) nil t nil)
	(org-back-to-heading)
	(org-narrow-to-subtree)
	(org-babel-tangle)))))
#+end_src

** collecting blocks
:PROPERTIES:
:ID:       7a645ddb-37f0-480b-a15d-ecee311ce8f0
:END:

#+begin_src emacs-lisp
(with-temp-file user-init-file
  (insert (org:block-contents-at-id ""))
  (org-babel-map-src-blocks nil
    (insert (xl-string-wrap-form :body))))
#+end_src

** ensuring my Emacs has handles errors gracefully
:PROPERTIES:
:ID:       f2a0e118-a1e7-45fa-a851-2cabf8bda993
:END:

After you modify your Emacs, you'll likely make some mistakes. It's always
annoying to have to debug your Emacs config without actually having your Emacs
config to do it. That's why I create a macro.

#+begin_src emacs-lisp
(defmacro elisp-block! (headline-data &rest body)
  "Report errors in body."
  `(condition-case error
       (progn ,@body)
     (error (message "error at %s %S"))))
#+end_src

* helpers
:PROPERTIES:
:ID:       67138086-b894-43b7-8c97-1980acad52b8
:END:

** evaluation nowebs
:PROPERTIES:
:ID:       8d68503c-75a2-463b-b286-6490c9c8b97b
:END:

=nowebs= are what I mean when I say [[id:f77797b8-172e-4482-87a4-5ede829b3b13][dynamic]] generation. Typically nowebs are
used to insert a block of code somewhere else, kind of like a copy paste sort of
things. This can be useful, specifically when you want to talk about with lisp
code that is in one form such as the [[id][config.scm]].

It allows me to add the result of a lisp expression that was computed when the
org file was tangled.

One way you could insert the evaluated code is by using <<noweb()>>.

*** give =org= the ability to evaluate sexps in noweb
:PROPERTIES:
:ID:       56390470-b5a6-4bc9-a4db-349bc8377e6e
:END:

#+name: eval
#+begin_src emacs-lisp :var string=""
string
#+end_src

*** as a string
:PROPERTIES:
:ID:       b857023e-1ad5-4ad5-8d61-6e5aeef6aba5
:END:

#+name: string
#+begin_src emacs-lisp :var string=""
(format "%S" string)
#+end_src

*** function that takes an org-id
:PROPERTIES:
:ID:       ce115a7d-ab3e-4921-9f20-c34fb81241dc
:END:

I'm interested in producing side-effects when tangling.

Evaluating source blocks whose id.

#+begin_src emacs-lisp :tangle ~/.config/emacs/init.el
(require 'org-id)
#+end_src

* xinitrc
:PROPERTIES:
:ID:       cf328230-ca3a-48a2-8dda-b4e9e4ff1e4c
:HEADER-ARGS: :tangle ~/.xinitrc
:END:

The [[https://wiki.archlinux.org/index.php/Xinit#xinitrc][.xinitrc]] is what [[https://wiki.archlinux.org/index.php/Xorg][xorg]] uses to determine how to set up a graphical
environment.

** first remap caps lock with escape
:PROPERTIES:
:ID:       fa0904bb-1597-45bf-a944-8b48955cef0c
:END:

Coming from a vim background and currently using [[git][evil]], I've come to rely on the
escape key heavily as a "quit everything" binding. I press it much more often
than the caps-lock key--actually I think I don't ever use the caps-lock
key. Even in emacs, there's [[https://github.com/emacs-straight/caps-lock][caps-lock]], so I'm not sure if I need it at all.

#+begin_src sh
setxkbmap -option caps:swapescape
#+end_src

** then load emacs
:PROPERTIES:
:ID:       af14d611-79a0-4604-8c02-24bc608d32fb
:END:

Obviously, we load our OS. In the future, I may use a display manager so I can
easily switch between emacs, stumpwm or any other window manager of my
choosing. I don't use the default display manager provied with =guix= because.

#+begin_src sh
exec emacs
#+end_src

* guix
:PROPERTIES:
:ID:       cf1f31f9-bf79-409e-bc58-9756896000e0
:END:

** starting org on guix
:PROPERTIES:
:ID:       9bd14aeb-1b7d-4cdd-8c79-5e92da7606dc
:END:

I'm am not keen on paying the cost of starting a [[https://wiki.archlinux.org/index.php/Display_Manager#Console][login manager]] at startup. I
don't see a great benefit to having a graphical login manager and I prefer the
flexibility of being able to use the command line before initializing a
graphical display.

Right now, shepard is admittedly rather slow in starting up. It's even slower
when it has to begin a display manager.

So below I implement the advice given in [[https://lists.gnu.org/archive/html/help-guix/2018-07/msg00080.html][this email]] to create a command that can
run =xorg= in guix. When I log in I run =sh xinit.sh= to start xorg.

#+begin_src sh :tangle ~/xinit.sh
#!/bin/sh

DIR=$HOME/.guix-profile

$DIR/bin/xinit -- $DIR/bin/Xorg :0 vt1 -keeptty \
	       -configdir $DIR/share/X11/xorg.conf.d \
	       -modulepath $DIR/lib/xorg/modules
#+end_src

* gpg-agent
:PROPERTIES:
:ID:       58a65d49-cd9f-4b5d-86d7-d43209424cf3
:HEADER-ARGS: :tangle ~/.config/gnupg/gpg-agent.conf
:END:

Of course we want emacs to manage our pinentry. While it may be less secure I
like not being prompted for a gpg password.

#+begin_src conf
pinentry-program <<eval((executable-find "pinentry-emacs"))>>
allow-loopback-pinentry
allow-emacs-pinentry
default-cache-ttl 60000
#+end_src

* git-config
:PROPERTIES:
:ID:       a4cf5803-05b1-4133-bd73-01638673d2e3
:HEADER-ARGS: ~/.config/git/config
:END:

The [[https://www.git-scm.com/book/en/v2/Customizing-Git-Git-Configuration][git-config]] contains settings you need for making a commit, such as your name
and email and optionally your public gpg key.

#+begin_src conf
[user]
	name = Luis Henriquez-Perez
	email = luis@luishp.xyz
	signingkey = C3F33DA91721A6B7365FBF668DAA027F8C199794
[commit]
	gpgsign = true
[gpg]
	program = <<eval((executable-find "gpg"))>>
#+end_src

* emacs
:PROPERTIES:
:ID:       8c10b42b-9317-49a8-8ce0-128a2efc8905
:END:

This heading is for Emacs. Emacs is a lisp-interpreter which just happens to
have very useful libraries for editing text.

** naming conventions
:PROPERTIES:
:ID:       2a6bc275-da71-4704-baec-904c5a750267
:END:

In this headline I describe the naming convenions I set for my Emacs functions
and variables.

*** summary
:PROPERTIES:
:ID:       c6272a6b-e712-4c5b-b49f-62e43b5a9ec4
:END:

|----------------+---------------------+---------------------------------------------|
| thing          | name                | description                                 |
|----------------+---------------------+---------------------------------------------|
| fn-I-wrote     | xl-fn               |                                             |
|----------------+---------------------+---------------------------------------------|
| feature-fn     | feature:fn          | An extension function to a feature/package. |
|----------------+---------------------+---------------------------------------------|
| macro          | macro!              | A macro I defined.                          |
|----------------+---------------------+---------------------------------------------|
| hook-fn        | hook-var&hook-fn    | A function added to a hook.                 |
|----------------+---------------------+---------------------------------------------|
| advice-fn      | some-fn@advice-fn   | A function added to as an advice.           |
|----------------+---------------------+---------------------------------------------|
| constant-var   | CONST-VAR           | A variable declared with defconst           |
|----------------+---------------------+---------------------------------------------|
| interactive-fn | feature/interactive | An interactive function.                    |
|----------------+---------------------+---------------------------------------------|

*** *no anonymous lambdas allowed*
:PROPERTIES:
:ID:       88a5aead-9dc2-4f37-9d0d-a382c292042a
:END:

I will never use an anonymous lambda for advices, for hooks or for
bindings. Every function should be named. The only time an anonymous lambda is
O.K. to use is in some calculation. It is not hard to name functions
appropriately. And doing so increases the readability and introspectabilty of my
config--now you can list hooks in a variable or advices on a function and get
descriptive idea of what's happening. Moreover, removing unnamed hooks or
advices can be more of a chore because you can't reference them by name.

** early-init
:PROPERTIES:
:ID:       1b29f0d7-63ab-46b8-abf4-51cb930d8be8
:HEADER-ARGS: :tangle ~/.config/emacs/early-init.el
:END:

The early-init file is loaded before the frame is initialized.

*** compute the font upon tangling
:PROPERTIES:
:ID:       62b28647-262f-4657-a57e-79e8a98c2a11
:END:

There's a chicken and egg problem with fonts. What you'd like to do to have a
robust emacs config is have a list of backup fonts that you check in order of
preference until you find the one that is available on your system. Moreover, to
be efficient, you'd like to do this check before the frame is initialized.
Problem is the functions emacs provide to check system fonts depend on the
initialization of the emacs frame.

Note I have not yet tested this. I'm not sure if the frame is created when I run
Emacs from a script. :confused: I'm sure there's some way to do it.

#+name: font
#+begin_src emacs-lisp :tangle no
(defvar xl-backup-fonts (list "hermit" "mononoki" "iosevka" "anonymous-pro")
  "List of fonts that should be used.")

(defun xl-most-preferred-font-available ()
  "Return the most prefered font that's available."
  (loopy ((list font xl-backup-fonts)
	  (expr available-fonts (x-list-fonts font))
	  (when available-fonts
	    (return (-last-item available-fonts))))
	 (return nil)))

(format "%S" (xl-most-preferred-font-available))
#+end_src

*** ensure lexical binding
:PROPERTIES:
:ID:       2b8148c3-1418-4896-ba53-1673d2d82659
:END:

Emacs by default uses dynamic binding. Lexical binding is a [[https://nullprogram.com/blog/2016/12/22/][known way to boost
startup speed]]. To enable it you add the following [[info:elisp#Using Lexical Binding][buffer-local variable]] on the
top of your elisp file.

#+begin_src emacs-lisp
;; -*- lexical-binding: t -*-
#+end_src

*** pause garbage collection
:PROPERTIES:
:ID:       33c4ed1f-9382-49ff-9706-6ce5c0fd0d7c
:END:

During computationally intensive tasks, it is better stop garbage collecting
until the task is done. Initializing emacs is such a task. Therefore, I
effectively stop garbage collection by setting the [[helpvar:gc-cons-threshold][gc-cons-threshold]] to
[[helpvar:most-positive-fixnum][most-positive-fixnum]].

#+begin_src emacs-lisp
(setq gc-cons-threshold most-positive-fixnum)
#+end_src

*** disable tool bar, menu bar, and scroll bar
:PROPERTIES:
:ID:       f439de9a-b2b1-4926-a4ae-3d94ff83d05a
:END:

By default the frame is initialized with the tool-bar, menu-bar, and
scroll-bar. Many emacs users, me included, prefer not to see these things. Since
I operate via keybindings I would never use them anyway. But because emacs loads
the init file after the initialization of the frame, it used to be the case that
it was inevitable to catch a glipse of these UI elements during your Emacs
initializaition. Not is it distracting, but rendering those things also
contributed significantly to startup time.

Before the advent of the [[helpvar:early-init-file][early-init-file]], the only way to prevent it was to set
up an [[https://wiki.archlinux.org/index.php/X_resources][xresources]].

#+begin_src emacs-lisp
(push '(menu-bar-lines . 0) default-frame-alist)
(push '(tool-bar-lines . 0) default-frame-alist)
(push '(vertical-scroll-bars) default-frame-alist)
#+end_src

*** set the font
:PROPERTIES:
:ID:       54d9be27-74b3-49fd-9bdb-b6d1e024b80b
:END:

This is the most efficient way to set the font. Reason being, it's done before
the initialization of the frame and it avoids the usage of functions like
[[helpfn:set-frame-font][set-frame-font]], which more than just set the font. A caveat is that this will
cause your emacs to crash if the font you specify does not exist. And, you can't
check the existing fonts at this time either because the [[https://emacs.stackexchange.com/questions/62318/storing-string-in-variable-fails-to-work-in-early-init-el/62320?noredirect=1#comment98194_62320][frame hasn't been
initialized yet]] so functions like [[helpfn:font-family-list][font-family-list]] and [[helpfn:find-font][find-font]] will not return
reliable values (trust me, I tried).

#+begin_src emacs-lisp :noweb yes
(push (cons 'font <<font()>>) default-frame-alist)
#+end_src

*** disable fringes
:PROPERTIES:
:ID:       bb1264f6-1580-4463-9d72-d2913771ebb4
:END:

#+begin_src emacs-lisp
(push '(left-fringe  . 0) default-frame-alist)
(push '(right-fringe . 0) default-frame-alist)
#+end_src

*** stop package.el from writing in our init file
:PROPERTIES:
:ID:       c5df3859-6099-4d99-9780-8d33383c3626
:END:

In Emacs 27+, package initialization occurs before [[helpvar:user-init-file][user-init-file]] is
loaded, but after [[helpvar:early-init-file][early-init-file]].

#+begin_src emacs-lisp
(setq package-enable-at-startup nil)
(advice-add #'package--ensure-init-file :override #'ignore)
#+end_src

*** ignore x-resources
:PROPERTIES:
:ID:       51391771-ed2f-42f7-b904-3f655b86cac0
:END:

Ignore X resources; its settings would be redundant with the other settings in
this file and can conflict with later config (particularly where the cursor
color is concerned). [[id:f439de9a-b2b1-4926-a4ae-3d94ff83d05a][Like I said]], we no longer need xresources anymore.

#+begin_src elisp
(advice-add #'x-apply-session-resources :override #'ignore)
#+end_src

*** prevent default mode line from showing
:PROPERTIES:
:ID:       0177fd1a-617d-47c6-bd03-db64439fd4cc
:END:

While the modeline is a huge point of interest among emacs users, I find it
distracting and space-consuming. The modeline is displayed in every buffer,
which means that it does not scale well with vertical splits. It will consume an
additional line for every additional window. And yet, I (and I suspect everyone
else) only ever focus on one window at a time. This is why I opt for disabling
the modeline (I use [[https://github.com/kiennq/emacs-mini-modeline][mini-modeline]] instead). Similar to the gui bars it is enabled
by default and will be rendered during the initialization of the frame. If I
don't disable it here.

#+begin_src elisp
(unless after-init-time
  (setq-default mode-line-format nil))
#+end_src

*** maximize frame
:PROPERTIES:
:ID:       3d208962-52ad-491a-8bf4-c9248c692fc7
:END:

Emacs is the interface with which I deal with everything else. I want it to be
full screen, especially when I'm using emacs as my window manager. For the same
reasons that setting the font is efficient, this is too.

#+begin_src emacs-lisp
(push '(fullscreen . maximized) default-frame-alist)
#+end_src

** init.el
:PROPERTIES:
:ID:       44daab3a-14bd-4c47-a117-88579e89a0e2
:HEADER-ARGS: :tangle ~/.config/emacs/init.el
:END:

This is where the magic really happens. The =init.el= is the file emacs looks
for.

*** Core
:PROPERTIES:
:ID:       d68434bf-be6a-471f-ab65-e151f4f1c111
:END:

This headline contains the core abstractions in my config. In emacs, there are
several different packages, both built-in to emacs and external to it. Each
package addresses some issue or task they want to solve or improve. Sometimes
several packages need to work together. Sometimes one package can provide tools
which would be useful in configuring another. As one begins building their emacs
config they need to manage these packages and the several interactions between
emacs and eachother. In this headline I try to develop tools which will help me
deal with this web of interactions.

**** Init
:PROPERTIES:
:ID:       71dbf82e-cf4f-4e8a-b14d-df78bea5b20f
:END:

This headline is for things I need to do before anything else. The main thing I
do here is declare directory names.

***** ensure lexical binding
:PROPERTIES:
:ID:       2b8148c3-1418-4896-ba53-1673d2d82659
:END:

See my [[2b8148c3-1418-4896-ba53-1673d2d82659][previous reasoning]] on why use lexical binding.

#+begin_src emacs-lisp
;; -*- lexical-binding: t -*-
#+end_src

***** config files and directores
:PROPERTIES:
:ID:       be8993d3-c8f7-451b-8cb4-04a9138e5c4e
:END:

It's useful to store directories which I reference frequently in variables and
functions. This way I can reference the full path. Certain directories are
important; and I end up referencing them alot.

****** macro to define important directories
:PROPERTIES:
:ID:       ebdf095e-f302-45c3-aef4-a4f9a84d4e02
:END:

This macro.

#+begin_src emacs-lisp
(defmacro dir! (name value &optional docstring)
  "Macro used for declaring `xl' directories.
Declare a variable named NAME with value VALUE and docstring DOCSTRING.
VALUE should be a path to a directory (as a string). Create the directory at
path VALUE. Create a function."
  (declare (indent 2))
  `(progn
     (defconst ,name ,value ,docstring)
     (mkdir ,name t)
     (defsubst ,(intern (downcase (symbol-name name))) (&rest path)
       ,(format "Return the path for `%S'." name)
       (apply #'concat ,name path))))
#+end_src

****** important directories
:PROPERTIES:
:ID:       17fd696e-6140-4d9b-9d17-053c2dced786
:END:

#+begin_src emacs-lisp
(dir! XL-EMACS-DIR (file-truename user-emacs-directory)
  "Path to `user-emacs-directory'.")

(dir! XL-LOCAL-DIR (xl-emacs-dir ".local/")
  "Path to the directory for local Emacs files.
Files that need to exist, but I don't typically want to see go here.")

(dir! XL-DATA-DIR (xl-local-dir "data/")
  "Path to the directory where XL data files are stored.")
#+end_src

****** system directories
:PROPERTIES:
:ID:       dc011bac-1734-49b5-9c30-128063520b1c
:END:

#+begin_src emacs-lisp
(dir! XL-HOME-DIR (expand-file-name "~/"))

(dir! XL-MULTIMEDIA-DIR (xl-home-dir "Multimedia/")
  "Directory used to store multimedia.")

(dir! XL-SCREENSHOT-DIR (xl-multimedia-dir "screenshots/")
  "Directory where screenshots should go.")

(dir! XL-PACKAGES-DIR (xl-local-dir "packages/")
  "Path to the directory where packages are stored.")

(dir! XL-DOCUMENTS-DIR (xl-home-dir "Documents/")
  "Directory where documents are stored.")

(dir! XL-ORG-DIR (xl-documents-dir "org/")
  "Directory where org files should go.")

(dir! XL-DOWNLOADS-DIR (xl-home-dir "Downloads/")
  "Directory where downloads are stored.")

(dir! XL-TRASH-DIR (xl-home-dir "Trash/")
  "Directory where downloads are stored.")
#+end_src

****** important files
:PROPERTIES:
:ID:       d01a33a8-c6e8-433c-9850-6bd7ea0488f9
:END:

#+begin_src emacs-lisp
(defconst XL-INIT-FILE (concat XL-EMACS-DIR "init.el")
  "Path to the elisp file that bootstraps XL startup.")

(defconst XL-MAIN-ORG-FILE (concat XL-EMACS-DIR "config.org")
  "Path to config file used for tangling.")

(defconst XL-MAIN-ELISP-FILE (concat XL-EMACS-DIR "main.el")
  "Path to elisp file.")
#+end_src

***** debug-p
:PROPERTIES:
:ID:       39197346-c420-4518-b8f8-8ea247d6decb
:END:

[[helpvar:void-debug-p][xl-debug]] is snatched from [[https://github.com/hlissner/doom-emacs][Doom's]] [[https://github.com/hlissner/doom-emacs/blob/develop/core/core.el][doom-debug-mode]]. The point of this variable is
to serve as an indicator of whether the current Emacs instance is run for
debugging. When Emacs is set up for debugging it prints out many messages about
what its doing via [[hfn:void-log][xl-log]].

#+begin_src emacs-lisp
(defvar xl-debug-p (or (getenv "DEBUG") init-file-debug)
  "When non-nil print debug messages.
The --debug-init flag and setting the DEBUG envar will enable this at startup.")
#+end_src

**** Package Management
:PROPERTIES:
:ID:       00eaa1a5-b5fe-437d-9888-1846ea9a232b
:END:

In this headline I install the package manager and load needed packages.

***** straight.el
:PROPERTIES:
:ID:       86037015-ca61-48f9-96bf-df8fc625a35d
:END:

[[straight][straight.el]] is a package manager that installs packages by cloning their git
repositories from online and building them from source. A consequence of this is
that you have the history of every installed emacs package locally. Another
consequence is that you can completely reproduce the state of your emacs on
another machine by installing the same packages with the same versions.

****** variables
:PROPERTIES:
:ID:       9dff9894-667c-4e74-9624-8aee533f8f70
:END:

#+begin_src emacs-lisp
(setq straight-base-dir XL-PACKAGES-DIR)
(setq straight-use-package-version 'straight)
(setq straight-use-package-by-default nil)
(setq straight-check-for-modifications nil)
(setq straight-recipes-emacsmirror-use-mirror t)
#+end_src

****** don't clone everything
:PROPERTIES:
:ID:       7f06830d-764a-42e1-959e-763a808a37b4
:END:

We don't need to clone everything from the git repos. Setting the depth to one
conserves some disk space.

#+begin_src emacs-lisp
(setq straight-vc-git-default-clone-depth 1)
#+end_src

****** handle autoloads for me
:PROPERTIES:
:ID:       d3b052e4-fc7e-4b64-bd53-a6aa4b8abd16
:END:

To save startup time, we don't want to load packages unnecessarily. Many
packages have what I like to call (I just made this up :smirk-cat:) "entry-points", or
commands that are used to trigger the loading of the package. =straight=
optionally handles this for us.

#+begin_src emacs-lisp
(setq straight-disable-autoloads nil)
(setq straight-cache-autoloads t)
#+end_src

****** package integration
:PROPERTIES:
:ID:       db1f9042-5b6c-41a9-a69c-d05d0493fdb0
:END:

By "integration" this variable means that it disables =package.el='s
initialization. We don't need =straight= to do this for us because it is handled in
[[id][early-init]].

#+begin_src emacs-lisp
(setq straight-enable-package-integration nil)
#+end_src

****** straight initialization code
:PROPERTIES:
:ID:       ab38beca-2f26-4718-ab73-e4e4409f1563
:END:

#+begin_src emacs-lisp
(defun xl-init-straight ()
  "Ensure that straight is installed and load it."
  (defvar bootstrap-version)
  (let* ((straight-base-dir straight-base-dir)
	 (straight-repo-dir (concat straight-base-dir "straight/repos/"))
	 (bootstrap-file (concat straight-repo-dir "straight.el/bootstrap.el"))
	 (bootstrap-version 5)
	 (straight-commit "f6663b1de0fb5d9c64528e4f7f8bb914f49bb6d2")
	 (straight-el-link "https://github.com/raxod502/straight.el.git"))
    (unless (file-exists-p bootstrap-file)
      (make-directory straight-repo-dir t)
      (shell-command
       (format "git -C %s clone %s" straight-repo-dir straight-el-link))
      (shell-command
       (format "git -C %s checkout %s" straight-repo-dir straight-commit)))
    (load bootstrap-file nil 'nomessage)))
#+end_src

***** install packages
:PROPERTIES:
:ID:       a694267f-b37d-487b-ac68-c1da9e1fe776
:END:

Here I initialize straight and load all the packages I use for configuring
use-package and, of course, use-package itself.

#+begin_src emacs-lisp
(xl-init-straight)

(dolist (package '(dash anaphora db use-package))
  (straight-use-package package)
  (require package))
#+end_src

**** Library
:PROPERTIES:
:ID:       70af1291-6b16-4261-ba83-19bb16d0023e
:END:

This headline contains all the the helper functions and macros I defined for
customizing Emacs. The main thing that's done in an Emacs configuration is
configuring packages, both built-in packages and external packages. And in this
process, there are often packages that augment and aid in the configuration of
other packages. Additionally, if you care about startup time it's important to
make sure packages are only loaded when they need to be. The major purpose of
this library is to provide me the tools to configure these packages in a way
that is concise and efficient.

***** macro writing tools
:PROPERTIES:
:ID:       ea5d3295-d8f9-4f3a-a1f6-25811696aa29
:END:

These are tools that are specifically designed to help me write macros.

****** symbols
:PROPERTIES:
:ID: 2cdf8ab1-4e59-4128-a8a4-e5519ca0f4bf
:END:

Conversion between symbols, keywords, and strings are prevalent in
macro-writing.

******* symbol intern
:PROPERTIES:
:ID:       06bfc6f7-4c51-44e7-b32e-1434a602b55b
:END:

This is a convenience function for quickly banging out a custom symbol. It's
advantage over just plain [[helpfn:intern][intern]] is that it will coerce its arguments to a
symbol. This is useful when writing macros where it is a common occurance to
have a mix of different objects (usually strings and symbols) that you want to
put together into one symbol. This function is meant to just do what I mean.

#+begin_src emacs-lisp
(defun xl-symbol-intern (&rest args)
  "Return ARGS as a symbol."
  (declare (pure t) (side-effect-free t))
  (intern (apply #'xl-to-string args)))
#+end_src

******* keyword intern
:PROPERTIES:
:ID:       0618b8d7-e0a4-4e3e-8d89-b7d0ebe43917
:END:

Sometimes I want to create a keyword by interning a string or a symbol. This
commands saves me having to add the colon at the beginning before interning.

#+begin_src emacs-lisp
(defun xl-keyword-intern (&rest args)
  "Return ARGS as a keyword."
  (declare (pure t) (side-effect-free t))
  (apply #'xl-symbol-intern ":" args))
#+end_src

******* keyword name
:PROPERTIES:
:ID:       e853603a-851d-429f-9201-f2e93734dfaf
:END:

Calling [[helpfn:symbol-name][symbol-name]] on a keyword returns the keyword as a string. However,
sometimes we don't want the prepended colon on they keyword. This function is
for that occasion.

#+begin_src emacs-lisp
(defun xl-keyword-name (keyword)
  "Return the name of the KEYWORD without the prepended `:'."
  (declare (pure t) (side-effect-free t))
  (substring-no-properties (xl-to-string keyword) 1))
#+end_src

******* convert to string
:PROPERTIES:
:ID:       60f22f98-8204-45ae-9943-f19cdfe60459
:END:

This function is for converting something to a string, no questions
asked. Similar to [[id:06bfc6f7-4c51-44e7-b32e-1434a602b55b][xl-symbol-intern]], I use it when I don't want to be bothered
with details and just want a string.

#+begin_src emacs-lisp
(defun xl-to-string (&rest args)
  "Return ARGS as a string."
  (declare (pure t) (side-effect-free t))
  (with-output-to-string
    (-each args #'princ)))
#+end_src

******* detect emacs symbols
:PROPERTIES:
:ID:       207ed522-51f3-45e7-91ba-8afb828d950b
:END:

These headline contains functions to detect particular Emacs symbols. Certain
Emacs symbols follow a convention. For example, most hooks end with the suffics
=-hook=. It may be useful--particularly in macros--to know what kind of symbol
we're dealing with. And, it may also be useful to be able to convert a normal
symbol (by which I mean one that doesn't follow the conventions) to one of these
particular kinds.

******** hook symbol
:PROPERTIES:
:ID:       7ae3dac1-058b-4b1b-a010-aeb5b121d3f6
:END:

As I mentioned, the convention for hook symbols is that they are suffixed with
=-hook=. This function checks for such variables.

#+begin_src emacs-lisp
(defun xl-emacs-hook-p (symbol)
  "Return true if symbol is a hook symbol."
  (declare (pure t) (side-effect-free t))
  (s-matches-p ".+-hook\\'" (symbol-name symbol)))
#+end_src

******** hookify symbol
:PROPERTIES:
:ID:       b308a172-6e99-491c-a382-7ee28e9fc1ae
:END:

#+begin_src emacs-lisp
(defun xl-emacs-hookify (symbol)
  "Return SYMBOL converted to hook.
If SYMBOL is already a hook symbol, return it unchanged."
  (declare (pure t) (side-effect-free t))
  (if (xl-emacs-hook-p symbol)
      symbol
    (xl-symbol-intern symbol '-hook)))
#+end_src

******** mode symbol
:PROPERTIES:
:ID:       ec25e275-c36f-4cee-be04-1fdf8c974857
:END:

#+begin_src emacs-lisp
(defun xl-emacs-mode-p (symbol)
  "Return non-nil if symbol is a mode symbol."
  (declare (pure t) (side-effect-free t))
  (s-matches-p ".+-mode\\'" (symbol-name symbol)))
#+end_src

******** modeify symbol
:PROPERTIES:
:ID:       61fa29a7-9697-4171-8b6f-f4c0b487c02c
:END:

#+begin_src emacs-lisp
(defun xl-emacs-modeify (symbol)
  "Return SYMBOL converted to hook.
If SYMBOL is already a hook symbol, return it unchanged."
  (declare (pure t) (side-effect-free t))
  (if (xl-emacs-mode-p symbol)
      symbol
    (xl-symbol-intern symbol '-mode)))
#+end_src

******* internal XL symbol
:PROPERTIES:
:ID:       72aa71bd-186b-47b3-b30e-1bf5da6b41b1
:END:

To avoid.

#+begin_src emacs-lisp
(defun xl-internal-symbol-p (symbol)
  "Return non-nil if symbol is an internal XL symbol."
  (declare (pure t) (side-effect-free t))
  (s-matches-p "\\`xl--.+" (symbol-name symbol)))
#+end_src

****** macro keyword arguments
:PROPERTIES:
:ID:       dc7a63e6-041b-4855-b206-6d72ef732de1
:END:

Following past examples (such as that of), I initially opted for allowing
keyword arguments in the "function args" part of defun-like macros. This is fine
when there's only one keyword argument, but any more and it starts to get
crowded. It doesn't help that emacs functions tend towards longer names due to a
lack of namespaces. Therefore, I support keyword args in the function body.

#+begin_src emacs-lisp
(defun xl--keyword-macro-args (body)
  "Return list of (docstring KEYWORD-ARGS BODY)."
  (let ((docstring (when (stringp (car body)) (pop body)))
	(plist))
    (while (keywordp (car body))
      (push (pop body) plist)
      (push (pop body) plist))
    (list docstring (nreverse plist) body)))
#+end_src

****** true-list-p
:PROPERTIES:
:ID:       43089182-316b-4191-a3f1-6f2d1b1b971e
:END:

Sometimes I want to know whether something is a list and not a cons
cell. Usually, this happens when I want to know whether I can loop over
something--you can loop over a list but not a cons cell.

#+begin_src emacs-lisp
(defsubst xl-true-list-p (obj)
  "Return t if OBJ is a list and not a cons cell."
  (and (listp obj) (not (-cons-pair-p obj))))
#+end_src

****** whether a number is the number one
:PROPERTIES:
:ID:       32ef30cf-3057-404e-a7b4-23d88b3b0d2e
:END:

This might seem trivial or wasteful, but the two numbers I most often have to
check for are one and zero. Emacs already has a function for checking is a value
is zero, [[helpfn:zerop][zerop]]. But it doesn't have one for one. So here we are.

#+begin_src emacs-lisp
(defsubst xl-one-p (obj)
  "Return t if OBJ is equal to one."
  (= 1 obj))
#+end_src

****** wrapping forms
:PROPERTIES:
:ID:       48e48c0f-7bb3-45c9-b4af-2da0ce84b64e
:END:

When writing macros in lisp it is not uncommon to need to write a macro that can
nest a form within some number of other forms (for an example, see [[id][after!]]). This
macro makes this problem much easier.

The original idea for this macro came from [[https://gitlab.common-lisp.net/iterate/iterate/-/blob/master/iterate.lisp][iter's source code]].

#+begin_src emacs-lisp
(defun xl-wrap-form (wrappers form)
  "Wrap FORM with each wrapper in WRAPPERS.
WRAPPERS are a list of forms to wrap around FORM."
  (declare (pure t) (side-effect-free t))
  (setq wrappers (reverse wrappers))
  (if (consp wrappers)
      (xl-wrap-form (cdr wrappers)
                      (append (car wrappers)
                              (list form)))
    form))
#+end_src

****** anaphora
:PROPERTIES:
:ID:       9938b1e1-6c6e-4a45-a85e-1a7f2d0bf6df
:END:

Anaphora refers to the ability to refer to. I have decided it is best to use
=<>= to denote the symbol referred to by anaphoric macros because it is easy to
type (assuming parentheses completion), because such a symbol uncommon in lisp.
A key advantage to this is that there is a consistent "syntax" for anaphoric
variables as opposed to using =it=. A consequence of this is that you have more
flexibility to name variables. Additionally, I like that it looks like a slot or
placeholder.

https://en.wikipedia.org/wiki/Anaphoric_macro

******* anaphoric symbol regexp
:PROPERTIES:
:ID:       40c97bd5-dab1-44df-86f7-90274d5a8ea0
:END:

#+begin_src emacs-lisp
(defconst XL-ANAPHORIC-SYMBOL-REGEXP
  (eval-when-compile (rx "<" (group (zero-or-more (not (any white ">" "<")))) ">"))
  "Regular expression that matches an anaphoric symbol.")
#+end_src

******* anaphoric symbol
:PROPERTIES:
:ID:       db8169ba-1630-42fe-9ab7-e29c110a18c3
:END:

#+begin_src emacs-lisp
(defun xl-anaphoric-symbol-p (obj)
  "Return non-nil if OBJ is an anaphoric symbol."
  (and (symbolp obj)
       (string-match-p XL-ANAPHORIC-SYMBOL-REGEXP (symbol-name obj))))
#+end_src

******* true anaphora name
:PROPERTIES:
:ID:       2833cd75-9c85-4c0e-9523-4489d387150a
:END:

#+begin_src emacs-lisp
(defun xl-anaphoric-true-symbol (symbol)
  "Return the symbol that corresponds to the anaphoric symbol."
  (save-match-data
    (string-match XL-ANAPHORIC-SYMBOL-REGEXP (symbol-name symbol))
    (intern (match-string 1 (symbol-name symbol)))))
#+end_src

******* take symbol and return anaphoric symbol
:PROPERTIES:
:ID:       4b89588e-f3c3-49d3-8851-fdd214cee563
:END:

#+begin_src emacs-lisp
(defun xl-anaphoric-symbol (symbol)
  "Return anaphoric form of symbol."
  (xl-symbol-intern '< symbol '>))
#+end_src

******* body symbols
:PROPERTIES:
:ID:       2bae458e-404a-48e7-b57e-ce7f543f6e6d
:END:

#+begin_src emacs-lisp
(defun xl-anaphoric-symbols (body)
  "Return all the anaphoric symbols in body."
  (->> (-flatten body)
       (-filter #'xl-anaphoric-symbol-p)
       (-uniq)))
#+end_src

******* all anaphoric symbols in obj
:PROPERTIES:
:ID:       e0c0eb8c-52b3-4411-ab0b-06255490dacf
:END:

#+begin_src emacs-lisp
(defun xl-anaphoric-symbols-in-obj (obj)
  "Return a list of anaphoric symbols in OBJ."
  (s-match-strings-all XL-ANAPHORIC-SYMBOL-REGEXP (xl-to-string obj)))
#+end_src

****** const
:PROPERTIES:
:ID:       667fcf91-8939-402f-9fd1-2a6e7713633b
:END:

#+begin_src emacs-lisp
(defun xl-const-fn (atom)
  "Return a constant function from ATOM."
  `(lambda () ,atom))
#+end_src

****** eval a form in a string
:PROPERTIES:
:ID:       79cfc39a-0924-468b-9fbc-83388323a39b
:END:

Sometimes it is useful to evaluate a lisp form that's in a string. One example,
is when [[https://orgmode.org/manual/Evaluating-Code-Blocks.html#Evaluating-Code-Blocks][evaluating code in source blocks]]. In general, this comes up
whenever you have to evaluate code you've gotten from a buffer.

You may be wondering why I first wrapped the form in the string with a [[helpfn:progn][progn]]
form. The reason is that [[helpfn:read-from-string][read-from-string]] only takes reads one from from a
string at a time.

This function came from [[https://emacs.stackexchange.com/questions/19877/how-to-evaluate-elisp-code-contained-in-a-string][this stackexchange question]].

#+begin_src emacs-lisp
(defun xl-eval-from-string (string)
  "Eval from from string."
  (eval (car (read-from-string (format "(progn %s)" string)))))
#+end_src

***** custom macros
:PROPERTIES:
:ID:       cfe0d468-92ee-4a4f-9908-4ea0b1964ac4
:END:

****** after!
:PROPERTIES:
:ID:       e209d256-86e0-4e30-a7d5-78a583729b42
:END:

=after!= is yet another wrapper around == that can accept multiple features or
even a specification of features using =and= or =or=.

The reason that we check for the feature is to prevent [[hvar:eval-after-load][eval-after-load]] from
polluting the [[hvar:after-load-list][after-load-list]]. =eval-after-load= adds an entry to
=after-load-list= whether or not it has been loaded.

We intentionally avoid with-eval-after-load to prevent eager macro expansion
from pulling (or failing to pull) in autoloaded macros/features.

#+begin_src emacs-lisp
(defmacro after! (features &rest body)
  "Wrapper around `with-eval-after-load'."
  (declare (indent defun) (debug t))
  (cond ((eq 'or (car-safe features))
         (macroexp-progn
          (mapcar (fn! `(after! ,<feature> ,@body)) (cdr features))))
        ((eq 'and (car-safe features))
         (xl-wrap-form (-map (fn `(after! ,<>)) (cdr features))
                       (macroexp-progn body)))
        ((listp features)
         `(after! ,(cons 'and features) ,@body))
        ((symbolp features)
         `(if (featurep ',features)
              ,(macroexp-progn body)
            (eval-after-load! ,features ,@body)))
        (t (error "Invalid argument."))))
#+end_src

****** with-os!
:PROPERTIES:
:ID:       a3ea434a-3f70-4137-a525-5be4bc63c3a2
:END:

Emacs is for the most part operating system agnostic. Packages written in elisp
should work across operating systems. Nevertheless, there are a handful of
settings that should favors particular operating systems over others.

#+begin_src emacs-lisp
(defmacro with-os! (os &rest body)
  "If OS is current system's operating system, execute body.
OS can be either `mac', `linux' or `windows' (unquoted)."
  (declare (indent defun))
  (when (funcall (cond ((eq :not (car-safe os)) (-not #'member))
                       (t #'member))
                 (pcase system-type
                   (`darwin 'mac)
                   (`gnu/linux 'linux)
                   (`(cygwin windows-nt ms-dos) 'windows)
                   (_ nil))
                 (-list os))
    `(progn ,@body)))
#+end_src

****** eval-after-load!
:PROPERTIES:
:ID:       8d831084-539b-4072-a86a-b55afb09bf02
:END:

=eval-after-load= is a macro that evaluates a lisp form after a file or feature
has been loaded. It's syntax is a bit terse because you need to quote the
feature as well as the form to be evaluated.

Also, if an =eval-after-load= block contains an error and it is triggered by a
feature, the error will happening. I think it might be that because the form was
not successfully evaluated =eval-after-load= does not realize it should stop
loading it. To remedy this I wrap the block with [[helpfn:condition-case][condition-case]].

#+begin_src emacs-lisp
(defmacro eval-after-load! (feature &rest body)
  "A wrapper around `eval-after-load!' with error catching."
  (declare (indent defun))
  `(eval-after-load ',feature
     '(condition-case error
          (progn ,@body)
        (error
         (message "Error in `eval-after-load': %S" error)))))
#+end_src

****** set!

One "gotcha" in Emacs is the existence of custom variables. Unlike typical
variables custom variables sometimes rely on certain code being executed when
they're initialized or when their values are changed. If you just set the
variable normally with [[helpfn:setq][setq]] you'd change it's value but you wouldn't be running
it's corresponding code so the change you think would happen, might not happen
at all.

Rather than keeping track of which variables have custom setters and which do
not, I opt to just use this macro.

For this reason I use =set!= as a replacement for =setq=.

[[https://opensource.com/article/20/3/variables-emacs][This article]] provides a brilliant synopsis of emacs variables.

#+begin_src emacs-lisp
(defmacro set! (sym val)
  `(funcall (or (get ',sym 'custom-set) 'set) ',sym ,val))
#+end_src

****** set-default!
:PROPERTIES:
:ID:       bc6b7560-fb71-4fc7-a53b-98f92c657d92
:END:

=set-default= is used for.

#+begin_src emacs-lisp
(defmacro set-default! (sym val)
  `(funcall (or (get ',sym 'custom-set-default) 'set-default) ',sym ,val))
#+end_src

****** fn!
:PROPERTIES:
:ID:       0ebd39d6-0f09-4a66-a6fc-5c259cab150d
:END:

This is a macro for writing anaphoric lambdas. It is based on [[https://github.com/troyp/fn.el][fn]], the main
difference being that in a few special cases you can specify a named anaphoric
variable. Also, I don't support the alternate =fn:= syntax.

#+begin_src emacs-lisp
(defmacro fn! (&rest body)
  "Expand into an anaphoric macro with body BODY."
  (let* ((argsym (make-symbol "ARGS"))
	 (symbolic-placeholders (-uniq (xl-anaphoric-symbols body)))
	 (number-fn (lambda (it) (s-matches-p "<[[:digit:]]>" (symbol-name it))))
	 (numbers-p (-all-p number-fn symbolic-placeholders)))
    (alet (if numbers-p
	      (-sort (lambda (it other) (string-lessp (symbol-name it) (symbol-name other)))
		     symbolic-placeholders)
	    symbolic-placeholders)
      `(lambda (&rest ,argsym)
	 (-let [,it ,argsym] ,@body)))))
#+end_src

***** use-package
:PROPERTIES:
:ID:       29e1513a-e12a-4818-870e-8d5fab7fe1a0
:END:

[[https://github.com/jwiegley/use-package][use-package]] provides a uniform syntax for cross-configuring different
packages and features. It is widely used among the emacs community. In this
headline I build upon it and adapt it to my needs.

****** rename use-package
:PROPERTIES:
:ID:       33cd9485-ccbd-4173-b44b-2145def4897c
:END:

This is a stylistic thing. Maybe this isn't a good idea because this isn't a
macro I wrote. Oh well, we'll see. :shrug:

#+begin_src emacs-lisp
(defalias 'use-package! #'use-package)
#+end_src

****** differentiate built-in packages
:PROPERTIES:
:ID:       722de3ce-71ae-4315-8c39-660990ce18f5
:END:

I got the idea of this macro from [[https://github.com/raxod502/radian][Radian]]. It differentiates built-in packages
from external ones.

#+begin_src emacs-lisp
(defmacro use-feature! (package &rest body)
  "Same as `use-package!' but with :ensure set to nil by default."
  (declare (indent defun))
  `(use-package! ,package
     :ensure nil
     ,@body))
#+end_src

****** helpers
:PROPERTIES:
:ID:       c8a6f579-c4ff-4b0f-942e-f87dab208deb
:END:

When it comes to helping myself with helper functions I spare no expense.

******* inserting keywords
:PROPERTIES:
:ID:       86f9fa28-6842-4580-994a-24f5d4608ad4
:END:

=use-package= has a built-in way of inserting keywords.

******** functional =use-package= keyword insertion
:PROPERTIES:
:ID:       4968a708-05f2-4a3b-8395-850a3c119fd2
:END:

This is an implementation for inserting something into a list before or after a
particular thing in the list. It is implemented in generally and without
side-effects. That way, it's easily testable.

#+begin_src emacs-lisp
(defun use-package:insert-keyword (where place key list)
  "Insert KEY at PLACE in PLIST.
If WHERE is before, KEY is inserted before place. If WHERE is `after' it is
inserted after PLACE."
  (--splice (eq place it)
	    (funcall (if (eq where 'before) #'identity #'reverse)
		     (list key it))
	    list))
#+end_src

******** dwim insert
:PROPERTIES:
:ID:       54fc11db-534a-4b59-836c-3165cf48b61d
:END:

I insert most =use-package= keywords in the same place. I don't want to have to
specify it all the time. Additionally, I don't want to have to keep repeating
the idiom =(setq use-package-keywords...use-package-keywords)= all the time
either.

#+begin_src emacs-lisp
(defun use-package:dwim-insert (key &optional where place)
  "Convenience wrapper around `use-package:insert-keyword'.
This is the same as `use-package:insert-keyword' except WHERE and PLACE to
`before' and `:hook'."
  (let ((where (or where 'before))
	(place (or place :hook)))
    (setq use-package-keywords
	  (use-package:insert-keyword where place key use-package-keywords))))
#+end_src

******* normalize cons
:PROPERTIES:
:ID:       d5beb18f-b18c-407b-9840-bda400ef52b4
:END:

#+begin_src emacs-lisp
(defun use-package:normalize-cons (cons-pair)
  "Normalize."
  (-table-flat #'cons
	       (-list (car cons-pair))
	       (-list (cdr cons-pair))))
#+end_src

******* create autoloads
:PROPERTIES:
:ID:       ee0dc9c0-1bb3-4309-a61d-5b1c7f4c6ddf
:END:

Perhaps the most code saved with =use-package= is in it's generation of autoload
forms.

#+begin_src emacs-lisp
(defun use-package:autoload (package fn)
  "Return a form that autoloads FN from PACKAGE."
  `(unless (fboundp ',fn)
     (autoload #',fn ,(symbol-name package) nil t nil)))
#+end_src

******* generate normalizer
:PROPERTIES:
:ID:       f287aa5b-51ed-40da-bbc1-9a40586a1f83
:END:

I only use this function and [[id:495d3d70-f19f-420d-86ef-d75c49a77b66][its counterpart]] once so maybe putting this in
functions is rather overkill. But I like doing things right. And who knows?
Might be useful later. :shrug:

#+begin_src emacs-lisp
(defun use-package:normalize (key)
  "Return an appropriate normalize symbol for key."
  (xl-symbol-intern 'use-package-normalize/ key))
#+end_src

******* generate a handler
:PROPERTIES:
:ID:       495d3d70-f19f-420d-86ef-d75c49a77b66
:END:

#+begin_src emacs-lisp
(defun use-package:handler (key)
  "Return an appropriate handler symbol for key."
  (xl-symbol-intern 'use-package-handler/ key))
#+end_src

******* override keyword
:PROPERTIES:
:ID:       aff6cbbe-7657-4287-9632-31dab7310c63
:END:

I want to override some existing =use-package= keywords. Use package keywords
are defined by three things: the existence of the keyword in
[[helpvar:use-package-keywords][use-package-keywords]], the existence of a [[https://github.com/jwiegley/use-package#third-step-create-a-handler][handler]], and the existence of a
[[https://github.com/jwiegley/use-package#second-step-create-a-normalizer][normalizer]]. To overwrite an existing keyword all you have to do is
override the corresponding normalizer and handler. The purpose of this function
is to provide an easy way to do this.

#+begin_src emacs-lisp
(defun use-package:override (old new)
  "Overrides OLD with NEW.
OLD is an existing use-package keyword. NEW is the keyword to override OLD with."
  (advice-add (use-package:normalize old) :override (use-package:normalize new))
  (advice-add (use-package:handler old) :override (use-package:handler new)))
#+end_src

****** custom keywords
:PROPERTIES:
:ID:       62cec5ac-a2f9-435b-96a7-4db0d9691f25
:END:

One thing to note is that I don't allow arguments to be optionally in a
list. This makes things much more complicated and it makes.

******* general advice keywords
:PROPERTIES:
:ID:       2bdd8dac-0770-4dbb-8cef-d51bd19da250
:END:

These keywords correspond to [[id:8fb485ec-5387-46da-820e-629dcf004962][generic advices]].

******** silence
:PROPERTIES:
:ID:       c69b021f-c1eb-4f51-8de3-234c4660a0ba
:END:

Many packages print some output to the messages buffer.

#+begin_src emacs-lisp
(use-package:dwim-insert :silence)

(defun use-package-normalize/:silence (_ _ args)
  (cl-assert (-all-p #'symbolp args))
  args)

(defun use-package-handler/:silence (name _ value rest state)
  `(,@(-map (-partial #'use-package:autoload name) value)
    ,@(-map (fn! `(xl-silence-output #',<fn>)) value)
    ,@(use-package-process-keywords name rest state)))
#+end_src

******** gc-pause
:PROPERTIES:
:ID:       70dba953-1a83-4de8-9a63-43e20c50fe5a
:END:

The keyword pauses emacs gargbage collection (e.g increases the
[[helpvar:gc-cons-threshold][gc-cons-threshold]] to [[helpvar:most-positive-fixnum][most-positive-fixnum]]) for the duration of functions that
it's passed in. It should be used on particularly computationally expensive
functions that a package provides.

#+begin_src emacs-lisp
(use-package:dwim-insert :gc-pause)

(defun use-package-normalize/:gc-pause (_ _ args)
  (cl-assert (-all-p #'symbolp args))
  args)

(defun use-package-handler/:gc-pause (name _ fns rest state)
  `(,@(-map (fn! (use-package:autoload name <fn>)) fns)
    ,@(-map (fn! `(xl-pause-gc #',<fn>)) fns)
    ,@(use-package-process-keywords name rest state)))
#+end_src

******** ignore
:PROPERTIES:
:ID:       eeeaf89c-78e6-453d-bf3b-27091cc11bca
:END:

Sometimes I want to ignore certain functions.

#+begin_src emacs-lisp
(use-package:dwim-insert :ignore)

(defun use-package-normalize/:ignore (_ _ args)
  (cl-assert (-all-p #'symbolp args))
  args)

(defun use-package-handler/:ignore (name _ value rest state)
  `(,@(-map (fn! (use-package:autoload name <>)) value)
    ,@(-map (fn! `(xl-ignore #',<>)) value)
    ,@(use-package-process-keywords name rest state)))
#+end_src

******** always yes
:PROPERTIES:
:ID:       f2d89960-ed41-4a72-847f-e150db56330b
:END:

There are a number of functions in Emacs that prompt.

#+begin_src emacs-lisp
(use-package:dwim-insert :assume-yes)

(defun use-package-normalize/:assume-yes (_ _ args)
  (cl-assert (-all-p #'symbolp args))
  args)

(defun use-package-handler/:assume-yes (name _ functions rest state)
  `(,@(-map (fn! (use-package:autoload name <fn>)) functions)
    ,@(-map (fn! `(xl-assume-yes #',<fn>)) functions)
    ,@(use-package-process-keywords name rest state)))
#+end_src

******* os
:PROPERTIES:
:ID:       9d78d90a-0309-44c6-be96-82bd6608546a
:END:

This keyword provides an concise and declarative way of using [[id:a3ea434a-3f70-4137-a525-5be4bc63c3a2][with-os!]].

#+begin_src emacs-lisp
(use-package:dwim-insert :os)

(defun use-package-normalize/:os (_ _ args)
  (car args))

(defun use-package-handler/:os (name _ value rest state)
  "Wrap body form with `with-os!' macro."
  `((with-os! ,value
      ,@(use-package-process-keywords name rest state))))
#+end_src

******* hook
:PROPERTIES:
:ID:       02e42811-3b97-44f1-ad0c-d59787173ffb
:END:

Here I override the default hook keyword with my own which uses =xl-hook-add=
instead of =add-hook=.

#+begin_src emacs-lisp
(use-package:dwim-insert :xl-hook)
(use-package:override :hook :xl-hook)

(defun use-package-normalize/:xl-hook (name _ args)
  (cl-assert (-all-p (-orfn #'-cons-pair-p #'symbolp) args))
  (->> args
       (-map-when #'symbolp (fn! (cons <> (xl-emacs-modeify name))))
       (-mapcat #'use-package:normalize-cons)
       (-map (fn! (cons (xl-emacs-hookify (car <>)) (cdr <>))))))

(defun use-package-handler/:xl-hook (name _ hook-alist rest state)
  "Use `xl-hook-add' to add HOOK to FN for each (HOOK . FN) in HOOK-ALIST."
  `(,@(-map (-lambda ((hook . fn)) `(xl-hook-add ',hook ',fn)) hook-alist)
    ,@(-map (-partial #'use-package:autoload name) (-map #'cdr hook-alist))
    ,@(use-package-process-keywords name rest state)))
#+end_src

******* before-call
:PROPERTIES:
:ID:       55e66d22-b75d-4e77-9f99-dca1afbe1094
:END:

Packages don't live in an isolated enviroment. Often one package depends on one
or more packages. Sometimes, I add customizations to a package using certain
libraries and then I need to load them when that package is loaded. The purpose
of this keyword is to load a package when a certain function is called.

#+begin_src emacs-lisp
(use-package:dwim-insert :before-call)

(defun use-package-normalize/:before-call (name key args)
  (cl-assert (-all-p (-orfn #'symbolp #'listp) args))
  (->> args
       (-map-when #'symbolp (fn! (cons name <>)))
       (-mapcat #'use-package:normalize-cons)))

(defun use-package-handler/:before-call (name key alist rest state)
  `(,@(-map (fn! (use-package:autoload name <fn>))
	    (-map #'cdr alist))
    ,@(-map (-lambda ((package . fn)) `(xl-load-before-call ',package #',fn))
	    alist)
    ,@(use-package-process-keywords name rest state)))
#+end_src

******* after-call
:PROPERTIES:
:ID:       2c7dd1a8-c0ee-42cd-b76f-8a72c94be848
:END:

The.

#+begin_src emacs-lisp
(use-package:dwim-insert :after-call)

(defalias 'use-package-normalize/:after-call
  #'use-package-normalize/:before-call)

(defun use-package-handler/:after-call (name _ alist rest state)
  `(,@(-map (fn! (use-package:autoload name <fn>))
	    (-map #'cdr alist))
    ,@(-map (-lambda ((package . fn)) `(xl-load-after-call ',package #',fn))
	    alist)
    ,@(use-package-process-keywords name rest state)))
#+end_src

******* set
:PROPERTIES:
:ID:       9948a4ae-f80a-4b13-b97a-0895481021a6
:END:

I should give credit. I got this idea from the leaf macro.

#+begin_src emacs-lisp
(use-package:dwim-insert :set)

(defun use-package-normalize/:set (_ _ args)
  (cl-assert (-all-p #'listp args))
  args)

(defun use-package-handler/:set (name _ value rest state)
  `(,@(-map (-lambda ((var . val)) `(set! ,var ,val)) value)
    ,@(use-package-process-keywords name rest state)))
#+end_src

******* rule
:PROPERTIES:
:ID:       30ee0415-dccf-4742-9c31-bd33b900ab81
:END:

This keyword integrates with [[id:b3351a74-b2d0-42b8-9895-b6baad0adb0b][dbc]] (display buffer control). What it does is.

#+begin_src emacs-lisp
(use-package:dwim-insert :popup)

(defun use-package-normalize/:popup (_ _ args)
  (cl-assert (-all-p #'xl-true-list-p args))
  args)

(defun use-package-handler/:popup (name _ rules rest state)
  "Add a popup rule."
  `(,@(-map (fn! `(dbc-add-rule ,@<rule>)) rules)
    ,@(use-package-process-keywords name rest state)))
#+end_src

******* idle-require
:PROPERTIES:
:ID:       916f88bd-10e1-4030-a1d9-e42baf095492
:END:

This keyword integrates with [[0d619336-e852-4c6a-89a8-38ccbb71a077][idle-require]]. It can accept a boolean.

#+begin_src emacs-lisp
(use-package:dwim-insert :idle-require)

(defun use-package-normalize/:idle-require (name _ args)
  (cl-assert (-all-p #'symbolp args))
  (--map-when (eq t it) name args))

(defun use-package-handler/:idle-require (name _ value rest state)
  `(,@(-map (fn! `(idle-require ',<> nil t)) value)
    ,@(use-package-process-keywords name rest state)))
#+end_src

******* config
:PROPERTIES:
:ID:       fa0947a2-7f0c-447e-9b16-03edb2648ad6
:END:

#+begin_src emacs-lisp
(use-package:dwim-insert :xl-config)

(defun use-package-normalize/:xl-config (_ _ args)
  args)

(defun use-package-handler/:xl-config (name _ value rest state)
  `((after! ,name ,@value)
    ,@(use-package-process-keywords name rest state)))
#+end_src

******* alias
:PROPERTIES:
:ID:       9fe0d171-55b4-4022-82ec-abfb5e776cae
:END:

Sometimes I want to alias certain.

#+begin_src emacs-lisp
(use-package:dwim-insert :alias)

(defun use-package-normalize/:alias (_ _ args)
  (cl-assert (-all-p #'-cons-pair-p args))
  args)

(defun use-package-handler/:alias (name _ alias rest state)
  ""
  `(,@(-map #'use-package:autoload (-map #'car value))
    ,@(-map (-lambda ((sym . def)) `(defalias ',sym #',def))
	    alias)
    ,@(use-package-process-keywords name rest state)))
#+end_src

******* ensure
:PROPERTIES:
:ID:       aab32568-2c8c-4777-90ec-c4ad1bebaad8
:END:

I know, I know. I can just use the =:straight= keyword provided by
[[https://github.com/raxod502/straight.el][straight]]. :stuck-out-tongue: The reason I define my own is I will likely
want to do more complex things in the future (such as caching the load-path and
only installing the package if its path is not in the cache).

#+begin_src emacs-lisp
(push '(:ensure t t) use-package-defaults)
(use-package:override :ensure :xl-ensure)

(defun use-package-normalize/:xl-ensure (_ _ args)
  "Accept a list of."
  (cl-assert (alet (car-safe args)
	       (or (listp it) (booleanp it))))
  (car args))

(defun use-package-handler/:xl-ensure (name _ value rest state)
  "Ensure a package is installed."
  `(,@(cond ((null value)  nil)
	    ((eq t value)  `((straight-use-package ',name)))
	    ((listp value) `((straight-use-package ',(cons name value)))))
    ,@(use-package-process-keywords name rest state)))
#+end_src

******* nameless
:PROPERTIES:
:ID:       e27d6d69-6efb-49c8-8c31-e477422a3d58
:END:

This keyword provides integration with.

#+begin_src emacs-lisp
(use-package:dwim-insert :nameless)

(defun use-package-normalize/:nameless (package _ args)
  (cl-assert (-all-p (-orfn #'-cons-pair-p #'stringp #'symbolp) args))
  (-map-when (-orfn #'stringp #'symbolp)
	     (fn! (cons (xl-to-string <>) (xl-to-string package)))
	     args))

(defun use-package-handler/:nameless (name _ value rest state)
  `((after! nameless ,@(-map (fn! `(push ',<> nameless-global-aliases)) value))
    ,@(use-package-process-keywords name rest state)))
#+end_src

******* enable-on-load
:PROPERTIES:
:ID:       28635c17-129f-4d5f-99ba-dde187ce7bb0
:END:

I want to enable some packages (like [[id:8fd1bcdc-c4b3-4fee-b91b-dcdf96167582][key-chord]]) immediately upon loading them. I
could use the =:config= keyword or enabling these packages, but it happens often
enough that I consider it worth it to give this case its own keyword.

It's worth noted that this package guesses the mode name based on the package
name. So it won't work with packages that don't follow the
convention. Fortunately, most do. :smirk:

#+begin_src emacs-lisp
(use-package:dwim-insert :enable-on-load)

(defun use-package-normalize/:enable-on-load (_ _ args)
  (cl-assert (and (xl-one-p (length args))
		  (booleanp (car args))))
  (car args))

(defun use-package-handler/:enable-on-load (name _ value rest state)
  (let ((mode-name (xl-emacs-modeify name)))
    `((after! ,name
	(xl-log "Enable %s" ',mode-name)
	(,mode-name))
      ,@(use-package-process-keywords name rest state))))
#+end_src

****** init use-package
:PROPERTIES:
:ID:       8879bd2b-5c7b-43d2-b922-7bb7cd6fea48
:END:

Finally, we get to use =use-package= to configure itself! :smile: By default,
=use-package= provides its own messages and error handling. This can make the
macro expansion of a =use-package= form crowded and much more difficult to
read. Setting [[helpvar:use-package-expand-minimally][use-package-expand-minimally]] tells =use-package=.

Also, remember [[][I mentioned]] I want a fast startup
time. [[helpvar:use-package-always-defer][use-package-always-defer]] tells =use-package= not to load anything until I
say so.

#+begin_src emacs-lisp
(use-package! use-package
  :set
  (use-package-expand-minimally . t)
  (use-package-always-defer . t))
#+end_src

***** essential libraries
:PROPERTIES:
:ID:       18602d49-dcc3-47c3-8579-62f7a7b7a83a
:END:

These are packages that I use to make writing lisp code more convenient. Emacs
Lisp is a full-featured, turing-complete language. However, for some data
structures like hash-tables and alists it is missing consistently named
functions for performing operations on these data structures. This is improving
slowly with the introduction of libraries like =seq.el= and =map.el= but still
leaves much to be desired. This sounds like a complaint, but it actually
highlights the advantage of the extensibility of Emacs.

****** shut-up
:PROPERTIES:
:ID:       71681f9f-2760-4cee-95a0-4aeb71191a42
:END:

This package provides a macro named =shut-up= that as its name suggests,
silences output of any forms within it :speak-no-evil:. Emacs itself and many
emacs packages spew messages. While I can see how in certain circumstances there
messages can be useful, most of the time they are superfluous.

#+begin_src emacs-lisp
(use-package! shut-up :demand t)
#+end_src

****** dash
:PROPERTIES:
:ID:       7885c48d-0ead-4d77-8de1-e9faec58b583
:END:

Dash is rich list manipulation library. Many of the functions it have already
been found in some form or another in emacs in features such as =cl-lib= and
=seq= and =subr=, but dash has some very convenient functions and macros over
emacs (such as =-let)=. Moreover, a lot of work has been put into making it's
functions efficient; some are even more efficient than built-in cl
functions. Additionally, it's already used as a dependency of very many packages
so I'll likely end up loading it anyway.

#+begin_src emacs-lisp
(use-package! dash :demand t)
#+end_src

****** dash-functional
:PROPERTIES:
:ID:       704fc35f-0ad0-4eb3-9eb5-d8335465dbd8
:END:

=dash-functional= provides "function combinators". These are functions that take
one or more functions as arguments and return a function. One example of this is
emacs's [[helpfn:apply-partially][apply-partially]]. These functions can help.

#+begin_src emacs-lisp
(use-package! dash-functional :demand t)
#+end_src

****** s
:PROPERTIES:
:ID:       b96acb97-3963-4713-a03b-6294c65903fd
:END:

=s= is an api for strings inspired by [[id:704fc35f-0ad0-4eb3-9eb5-d8335465dbd8][dash]]. It has many useful string functions
that are not built-in to Emacs. Notably, it is functional.

#+begin_src emacs-lisp
(use-package! s :demand t)
#+end_src

****** f
:PROPERTIES:
:ID:       f44da560-dc3f-4635-926e-eec4fd6d159d
:END:

#+begin_src emacs-lisp
(use-package! f :demand t)
#+end_src

****** anaphora
:PROPERTIES:
:ID:       1c47bd8a-15f1-4b1c-9574-23547d27d968
:END:

It's common to want to refer to the thing you're operating on in lisp and in
many other languages. In lisp this often requires assigning the variable a name.
But if you're only.

#+begin_src emacs-lisp
(use-package! anaphora :demand t)
#+end_src

****** loopy
:PROPERTIES:
:ID:       da17f1ea-7b0d-4d8c-a068-792ed58c6a79
:END:

=loopy= is an alternative to =cl-loop= that preserves lisp structure. It is akin
to [[https://common-lisp.net/project/iterate/][Common Lisp's iter]]. dash's functions and macros are good for most
cases. But they are not as good in my opinion when you're dealing with a complex
loop that involves accumulating several variables or atypical control-flow (as
in, break statements or return statements). This is where =loopy= comes into
play.

#+begin_src emacs-lisp
(use-package! loopy
  :ensure (:host github :type git :repo "okamsn/loopy")
  :demand t)
#+end_src

****** noflet
:PROPERTIES:
:ID:       27f06ae0-ed4d-45ca-b451-fa05a47b8fe0
:END:

This package provides an alternative to the built-in =cl-flet= called
=noflet=. The [[][]] is that.

#+begin_src emacs-lisp
(use-package! noflet :demand t)
#+end_src

****** dbc
:PROPERTIES:
:ID:       b3351a74-b2d0-42b8-9895-b6baad0adb0b
:END:

=dbc= stands for "display-buffer-control". This package provides an interface
for working with [[helpfn:display-buffer-alist][display-buffer-alist]]. In a nutshell, =display-buffer-alist= is
a Emacs's built in way of allowing the user to customize how windows are opened.

#+begin_src emacs-lisp
(use-package! dbc
  :ensure (:host gitlab :type git :repo "matsievskiysv/display-buffer-control")
  :demand t
  :xl-config
  (alet '(display-buffer-in-side-window . ((side . bottom) (window-height . 0.5)))
    (dbc-add-ruleset "bottom" it))
  (alet '(display-buffer-in-side-window . ((side . top) (window-height . 0.4)))
    (dbc-add-ruleset "top" it))
  (alet '(display-buffer-in-side-window . ((side . left) (window-width 0.4)))
    (dbc-add-ruleset "left" it))
  (alet '(display-buffer-in-side-window . ((side . right) (window-width 0.4)))
    (dbc-add-ruleset "right" it)))
#+end_src

****** db
:PROPERTIES:
:ID:       9b79f07b-8397-4f95-b79c-5e136a9b2079
:END:

#+begin_src emacs-lisp
(use-package! db)
#+end_src

****** elog
:PROPERTIES:
:ID:       d73fd7b1-5610-4d93-8802-1aa57c8c1918
:END:

=elog= is a library for generating logging functions. I use [[][]] to generate a
function that logs to the buffer =*xl-log*=.

#+begin_src emacs-lisp
(use-package! elog
  :demand t
  :config
  (elog-open-log buffer "xl-" :buffer "*xl-log*" :fmt "XL %M")
  (defun xl-log (format-string &rest args)
    "Log to *Messages* if `xl-debug-p' is on.
Does not interrupt the minibuffer if it is in use, but still log to *Messages*.
Accept the same arguments as `message'."
    (xl--log 1 (apply #'format format-string args))))
#+end_src

****** mmt
:PROPERTIES:
:ID:       6d4d5426-a733-474f-9f87-2d18323459e0
:END:

#+begin_src emacs-lisp
(use-package! mmt)
#+end_src

***** hooks
:PROPERTIES:
:ID:       a9fb6a01-ded5-405c-83ba-c401dbc06400
:END:

One of the most common ways to customize Emacs is via [[info:elisp#Hooks][hooks]]. Hooks are variables
containing functions (which are sometimes also referred to as hooks). The
functions in hooks are run after certain events, such as starting and quitting
emacs. Their purpose is to fascillitate customization of what happens before or
after particular events.

I want hooks to be easily inspectable (if that's a word). For me this means
naming hooks in such a way that the variable they are hooked to is obvious. This
also means *always* naming hooks, no matter how small (code-wise) they may be. I
want to know exactly what's going on when I inspect hook variables.

In this headline, I strive to establish a common naming convention for hooks
that I define. I want there to be a clear destinction between hooks and regular
functions.

****** hook regexp
:PROPERTIES:
:ID:       aa93c9c5-aaaa-4732-9065-32e131e96031
:END:

The naming convention with hook functions is =HOOK-VAR@HOOK-ACTION=, where
=HOOK-VAR= is the hook variable the hook.

#+begin_src emacs-lisp
(defconst XL-HOOK-REGEXP "\\`\\(.+\\)&\\(.+\\)\\'"
  "Regexp that matches an XL hook.
This regexp contains two groups. One group one designates the hook variable
(what is before the '&') and group two designates the hook function (this is
what follows the '&').")
#+end_src

****** whether a symbol is an XL hook
:PROPERTIES:
:ID:       1995a309-e1d3-40e5-b6b1-fbcd81dda0bb
:END:

Similar to some of the functions designed in [[][]], this function will be
useful primarily in macros.

#+begin_src emacs-lisp
(defun xl-hook-fn-p (symbol)
  "Return non-nil if SYMBOL is a xl-specific hook function symbol."
  (s-matches-p XL-HOOK-REGEXP (symbol-name symbol)))
#+end_src

****** access the hook symbol
:PROPERTIES:
:ID:       77f45347-3688-438d-8674-39e6d476a2d1
:END:

A useful consequence of the hook naming convention is I can determine precisely
which hook symbol a function resides in based on looking at the name
(=emacs-startup-hook&do-something= would be a hook in =emacs-starup-hook= for
example). This proves to be useful for [[id:8506fa78-c781-4ca8-bd58-169cce23a504][expire advice]].

#+begin_src emacs-lisp
(defun xl-hook-hooked-var (xl-hook-fn)
  "Return the hook variable XL-HOOK-FN is in.
XL-HOOK-FN is a function named with Void naming conventions."
  (->> (symbol-name xl-hook-fn)
       (s-match XL-HOOK-REGEXP)
       (nth 1)
       (intern)))
#+end_src

****** hook action
:PROPERTIES:
:ID:       fa705f26-31f0-43c3-80a6-6741e74ab0ea
:END:

The "action" I speak of is the latter part of the hook. This will most often
correspond to the name of the variable attached to the hook [[][but not
always]].

#+begin_src emacs-lisp
(defun xl-hook-action (xl-hook-fn)
  "Return the function hook function that corresponds to XL-HOOK-FN."
  (->> (symbol-name xl-hook-fn)
       (s-match XL-HOOK-REGEXP)
       (nth 2)
       (intern)))
#+end_src

****** generate an XL hook
:PROPERTIES:
:ID:       3e6176f0-75dd-4dd8-a87d-2f47be7f2abf
:END:

******* produce an XL hook name
:PROPERTIES:
:ID:       6b14ea72-b8ef-493d-82e2-962f889736a2
:END:

This function determines how xl-defined hooks are named. When possible they
should be in the form of some action so that the hook name will be of the form
=hook-variable&do-something=. Having the names like this makes it so you can
actually read through hook functions like reading a todo-list. It will be
apparent what's being done.

#+begin_src emacs-lisp
(defun xl-hook-name (hook fn)
  "Produce a valid xl-hook symbol."
  (alet (cond ((xl-internal-symbol-p fn)
	       (->> (symbol-name fn)
		    (s-chop-suffix "-hook")
		    (s-chop-prefix "xl--")
		    (intern)))
	      (t
	       fn))
    (xl-symbol-intern hook '& it)))
#+end_src

******* produce hook lambda
:PROPERTIES:
:ID:       01cdecef-a345-45f0-b38e-5fe0b4939b08
:END:

When there's a bug with a function (also called a hook) added to a hook
variable, it interferes with the running of the hook variable. Evaluation stops
at the error. As a result, hooks following the bugged function aren't
evaluated. All in all, you get an unpleasant experience with partially evaluated
code. I've faced this problem numerous times, mostly when I failed to autoload
the hook for a mode and as a result get a =xl-function= error in the middle of
the mode's hook.

I would prefer an elegant failure. By this, I mean I'd like the "problem"
function to report the problem to me without short-circuiting. This is why I
wrap hook functions in a [[helpfn:condition-case][condition-case]] block.

#+begin_src emacs-lisp
(defun xl-hook-lambda (fn)
  "Return a raw hook lambda."
  `(lambda (&rest args)
     (condition-case err
	 (apply #',fn args)
       (error
	(xl-log "%s failed." ',fn)))))
#+end_src

******* produce an XL xl-hook
:PROPERTIES:
:ID:       5081274d-61d8-4adf-8646-72b08ca2f3d6
:END:

#+begin_src emacs-lisp
(defun xl-hook (hook fn)
  "Return a hook symbol based on HOOK and FN."
  (alet (xl-hook-name hook fn)
    (fset it (xl-hook-lambda fn))
    it))
#+end_src

****** add an XL hook
:PROPERTIES:
:ID:       882bc5d2-a0e2-4ea7-b9d2-ab64b3407f82
:END:

This is a replacement to [[helpfn:add-hook][add-hook]], the main difference being that.

#+begin_src emacs-lisp
(defun xl-hook-add (hook fn &optional depth local expire-fn)
  "Add an XL hook function to HOOK.
Alias FN to abide by XL hook naming conventions. Then add that alias to
HOOK. DEPTH and LOCAL are the same as in `add-hook'."
  (alet (xl-hook-name hook fn)
    (defalias it fn)
    (add-hook hook it depth local)
    (xl-log-function it)
    (xl-report-error it)
    (xl-expire it expire-fn)))
#+end_src

****** remove an XL hook
:PROPERTIES:
:ID:       99708d72-a8d4-42ba-b6ae-ba692fbafec8
:END:

A consequence of my naming scheme and, in particular, the fact that.

#+begin_src emacs-lisp
(defun xl-remove-hook (xl-hook-fn)
  "Remove an XL-HOOK-FN from its hook symbol."
  (remove-hook (xl-hook-orig-var xl-hook-fn) xl-hook-fn))
#+end_src

****** defhook!
:PROPERTIES:
:ID:       4daf2baf-ea7f-41f5-9f86-63168089149a
:END:

=defhook= provides a declarative way declare hook functions using [[helpfn:defun][defun]] syntax.

#+begin_src emacs-lisp
(defmacro defhook! (name args &rest body)
  "Define a hook function and attatch it to HOOK and HOOKS.
DEPTH and LOCAL are the same as in `add-hook'. BODY is the body of the hook
function.

\(NAME (HOOK &REST HOOKS &OPTIONAL DEPTH LOCAL) &rest BODY)"
  (declare (doc-string 3))
  (-let* ((hooks (-take-while (-not #'keywordp) args))
          (local (plist-get hooks :local))
          (depth (or (plist-get hooks :append) (plist-get hooks :depth)))
          ((docstring _ body) (xl--keyword-macro-args body))
          (hook-name (xl-symbol-intern 'xl-- name '-hook)))
    `(progn
       ,@(mapcar (lambda (hook)
                   `(aprog1 (defun ,hook-name (&rest _) ,docstring ,@body)
                      (xl-hook-add ',hook it ,depth ,local)))
                 hooks))))
#+end_src

***** advice
:PROPERTIES:
:ID:       19b9021d-f310-485b-9258-4df19423c082
:END:

I want to name advices so that they can be distinguished from other functions. I
also want to be able to deduce the function being advised from the name.

****** regexp for XL advices
:PROPERTIES:
:ID:       7a0b9669-e15c-40c1-9cf2-adc7cb27b7ab
:END:

The naming convenion for advices is similar to [[][that of hooks]] but the
symbol separating the advised function from its advice is an =@=.

#+begin_src emacs-lisp
(defconst XL-ADVICE-REGEXP "\\([^[:space:]]+\\)@\\([^[:space:]]+\\)"
  "Regexp used to match XL advices.")
#+end_src

****** whether a symbol is an XL advice
:PROPERTIES:
:ID:       0a84d983-39ad-48d1-af9d-b43589d63bcf
:END:

#+begin_src emacs-lisp
(defun xl-advice-fn-p (fn)
  "Return non-nil if FN is an XL advice."
  (s-matches-p XL-ADVICE-REGEXP (symbol-name fn)))
#+end_src

****** advised function
:PROPERTIES:
:ID:       74aee21a-3549-488b-b6f1-de9549e7e358
:END:

#+begin_src emacs-lisp
(defun xl-advice-advised-fn (xl-advice-fn)
  "Return the function that ADVICE-FN advices."
  (->> (symbol-name xl-advice-fn)
       (s-match XL-ADVICE-REGEXP)
       (nth 1)
       (intern)))
#+end_src

****** advice action
:PROPERTIES:
:ID:       f893fbe8-592b-409e-8de7-6060e936456f
:END:

Similar to hooks, the action will usually correspond to the advice but [[][there
are exceptions]]. To access the original function used for creating the advice,
[[helpfn:indirect-function][indirect-function]] should be used.

#+begin_src emacs-lisp
(defun xl-advice-action (xl-advice-fn)
  "Return the symbol."
  (->> (symbol-name xl-advice-fn)
       (s-match XL-ADVICE-REGEXP)
       (nth 2)
       (intern)))
#+end_src

****** advice name
:PROPERTIES:
:ID:       03416f82-ced7-42a0-843b-6975903f0b38
:END:

Most of the time I will.

#+begin_src emacs-lisp
(defun xl-advice-name (fn advice)
  "Return XL advice symbol for FN and ADVICE."
  (alet (cond ((xl-internal-symbol-p advice)
	       (->> (symbol-name advice)
		    (s-chop-suffix "-advice")
		    (s-chop-prefix "xl--")
		    (intern)))
	      (t
	       advice))
    (xl-symbol-intern fn '@ it)))
#+end_src

****** add XL advice
:PROPERTIES:
:ID:       3ab8947c-15f0-4fb7-bd75-f0baabc20ec1
:END:

Often, I advise functions with other existing functions (such as =#'ignore=)
instead of defining my own advices. To maintain consistency with the naming
convention I created [[helpfn:xl-advice-add][xl-add-advice]]. It will create an advice with an
appropriate name to target.

#+begin_src emacs-lisp
(defun xl-advice-add (symbol where fn &optional props expire-fn)
  "Advise SYMBOLS with ADVICES."
  (let ((advice (xl-advice-name symbol fn)))
    (defalias advice fn)
    (advice-add symbol where advice props)
    (xl-log-function advice)
    (when expire-fn
      (xl-expire advice expire-fn))))
#+end_src

****** remove XL advice
:PROPERTIES:
:ID:       3d13ea95-44aa-4261-8480-5ae9701d533d
:END:

Since we can get the advisee from the advise name, or remove advice only needs
one argument--the advice to remove.

#+begin_src emacs-lisp
(defun xl-advice-remove (xl-advice-fn)
  "Remove XL-ADVICE-FN from the function it is advising."
  (alet (xl-advice-advised-fn xl-advice-fn)
    (advice-remove it xl-advice-fn)))
#+end_src

****** generic advices
:PROPERTIES:
:ID:       8fb485ec-5387-46da-820e-629dcf004962
:END:

There are some advices that are used so often that they do not lend themselves
to =defadvice!=, which is better suited for a unique hook defined only once.

******* reporting errors
:PROPERTIES:
:ID:       ba191c78-f0e6-4edc-aac8-020eb1b6f1c8
:END:

******** catch errors
:PROPERTIES:
:ID:       3ac98fde-fe86-4221-abc7-d8bdfee4a58b
:END:

One important note here. I first wrote [[helpfn:xl--report-error-advice][xl--report-error-advice]] as an around
advice that should be added to functions. The problem here is that sometimes I
advise compiled functions; and when I do, the variable =orig-fn= is bound to a
compiled function instead of a symbol. This is why this function has to
pre-emptively insert FN. A similar situation occurs with [[][generic expiring
advice]].

#+begin_src emacs-lisp
(defun xl--report-error-advice (fn)
  "Advice that catches errors from ORIG-FN."
  `(lambda (orig-fn &rest args)
     (condition-case error
	 (apply orig-fn args)
       (error (xl-log "Failed evaluating %S because of: %S"
		      #',fn
		      (error-message-string error))))))

(defun xl-report-error (fn)
  "Advise a function to gracefully report an error."
  (let ((alias (xl-symbol-intern fn '@report-error)))
    (defalias alias (xl--report-error-advice fn))
    (xl-log-function alias)
    (advice-add fn :around alias)))
#+end_src

******* expiration
:PROPERTIES:
:ID:       c8092696-030e-4609-9485-89920eddaaec
:END:

Sometimes I am confronted with hooks or advices that either should'nt be be
called more than once. A common example is [[][loading a dependency for a
package]]. 

******** expire advice lambda
:PROPERTIES:
:ID:       c280627b-ca96-46e7-ba2d-9754afa991fc
:END:

When a function has expired, it is removed from any hooks or advices it is in,
and, additionally, it is ignored. The expire advice remains on the function.

#+begin_src emacs-lisp
(defun xl-expire-lambda (fn expire-condition)
  "Return an around advice that expires on EXPIRE-CONDITION."
  `(lambda (&rest _)
     (when (funcall #',expire-condition)
       (when (xl-advice-fn-p #',fn)
	 (xl-advice-remove #',fn))
       (when (xl-hook-fn-p #',fn)
	 (xl-hook-remove #',fn))
       (xl-log "%s has expired." #',fn))))
#+end_src

******** expire advice
:PROPERTIES:
:ID:       8506fa78-c781-4ca8-bd58-169cce23a504
:END:

Often there are functions you want to advise just once. For example, loading a
feature just before a function that needs it is called. Although it's harmless,
you don't want to keep reloading the feature everytime the function is called.
The way I handle this situation is by creating a function that generates an
=expire-advice=. When an =expire-advice= it will.

Note that this function returns must be evaluated with lexical binding to work.

#+begin_src emacs-lisp
(defun xl-expire (fn &optional expire-condition)
  "Cause FN to expire when EXPIRE-CONDITION is true.
If EXPIRE-CONDITION is nil, do nothing."
  (when expire-condition
    (let ((expire-fn (xl-symbol-intern fn '@expire))
	  (pred (if (eq t expire-condition) (xl-const-fn t) expire-condition)))
      (fset expire-fn (xl-expire-lambda fn pred))
      (xl-log-function expire-fn)
      (advice-add fn :after expire-fn))))
#+end_src

******* assume yes in prompts
:PROPERTIES:
:ID:       82960e31-b0c5-4b79-8ac4-508629bd63a4
:END:

Once in a while I come across a function that a [[helpfn:y-or-n-p][y-or-n-p]] prompt for things I
don't want to be prompted for. Or, in other words, for me the cost of the extra
second I spend typing =y= or =n= is not worth the benefit ([[helpfn:ert-delete-all-tests][ert-delete-all-tests]]
is an example).

#+begin_src emacs-lisp
(defun xl-assume-yes (fn &optional props expire-fn)
  "Ignore yes or no prompt."
  (xl-advice-add fn :around #'xl-assume-yes-advice props expire-fn))

(defun xl-assume-yes-advice (orig-fn &rest args)
  "An advice that makes `y-or-n-p' return t without prompt."
  (noflet ((y-or-n-p (prompt) t))
    (apply orig-fn args)))
#+end_src

******* silence
:PROPERTIES:
:ID:       7eddba70-8597-4af7-bc93-6ebdcc06ee6c
:END:

Many packages output to the messages buffer. Often, I either find these messages
unecessary or, as an experienced user, I get it already. In these cases I prefer
to silence the said messages.

#+begin_src emacs-lisp
(defun xl-silence-output-advice (orig-fn &rest args)
  "Around advice for silencing output."
  (shut-up (apply orig-fn args)))

(defun xl-silence-output (fn)
  "Silence output of FN."
  (let ((alias (xl-symbol-intern fn '@ 'silence)))
    (defalias alias #'xl-silence-output-advice)
    (xl-log-function alias)
    (advice-add fn :around alias)))
#+end_src

******* logging certain functions
:PROPERTIES:
:ID:       1ccfaa39-924f-4b1d-82b2-e458511cbb1b
:END:

I make distinctions between different kinds of functions such as advices, hook
functions and interactive functions. Depending on which type of function it is I
want to log it differently.

******** log message
:PROPERTIES:
:ID:       f0f4d5fd-2ce2-408c-8a4d-f55e39744132
:END:

#+begin_src emacs-lisp
(defun xl--log-message (fn)
  "Return the message logged."
  (cond ((xl-hook-fn-p fn)
	 (format "& %s -> %s"
		 (xl-hook-hooked-var fn)
		 (xl-hook-action fn)))
	((xl-advice-fn-p fn)
	 (format "@ %s -> %s"
		 (xl-advice-advised-fn fn)
		 (xl-advice-action fn)))
	(t
	 (format "%s called" fn))))
#+end_src

******** log advice
:PROPERTIES:
:ID:       25ea174f-af84-49e3-ad13-c797ef4ee6b2
:END:

Maybe it's overkill having an advice just to log a function. But it helps
maintain maximum purity and extensibility.

#+begin_src emacs-lisp
(defun xl-log-function (fn &optional after)
  "Log calls to FN.
Add a log to *xl-log* after function is called.
This function should be primarly used for side-effect but does incidentally return the
log function that is added to FN."
  (advice-add fn (if after :after :before) (xl-new-log-advice fn)))

(defun xl-new-log-advice (fn)
  "Return new log advice for FN."
  (alet (xl-symbol-intern "xl-log-" fn)
    (fset it `(lambda (&rest _) (xl-log ,(xl--log-message fn))))
    it))
#+end_src

******* reduce gc-cons-threshold
:PROPERTIES:
:ID:       41e763bd-215f-4176-95c1-f41261864671
:END:

Sometimes you come across a function that is computationally expensive. An
example is [[helpfn:helm-system-packages][helm-system-packages]], function that has to make a list of all system
packages which can contain several thousand items.

#+begin_src emacs-lisp
(defun xl-pause-gc (fn)
  "Pause garbage collection for the duration of FN."
  (let ((alias (xl-symbol-intern fn '@ 'pauce-gc)))
    (defalias alias #'xl-pause-gc-advice)
    (xl-log-function alias)
    (advice-add fn :around alias)))

(defun xl-pause-gc-advice (orig-fn &rest args)
  "An around advice that pauses `gc-cons-threshold'."
  (let ((gc-cons-threshold XL-GC-CONS-THRESHOLD-MAX))
    (apply orig-fn args)))
#+end_src

******* log
:PROPERTIES:
:ID:       843d4ca9-ea52-46ea-9d77-bfd9e7222669
:END:

#+begin_src emacs-lisp
(defun xl-message-with-xl-log (fn &rest props expire-fn)
  "Use `xl-log' instead of `message'."
  (xl-advice-add fn :around #'xl-message-xl-log-advice props expire-fn))

(defun xl-message-xl-log-advice (orig-fn &rest args)
  "An advice that makes calls to message happen with `xl-log'."
  (cl-letf (((symbol-function 'message) #'xl-log))
    (apply orig-fn args)))
#+end_src

******* ignore output
:PROPERTIES:
:ID:       5053afcc-7a44-44d4-80b6-f42c3ea87926
:END:

#+begin_src emacs-lisp
(defun xl-ignore (fn)
  "Ignore FN."
  (xl-advice-add fn :override #'ignore))
#+end_src

******* loading on call
:PROPERTIES:
:ID:       fa6583aa-5e7c-4212-be8a-b90b4c08aa31
:END:

Instead of loading all features on startup, we want to load features only when
we need them--just in time. And by "just in time" I mean at the last possible
moment or in practice just before a function that uses this feature is called.
While I could use =defadvice!= for defining these advices, doing this would
quickly become repetative because it's something that is done so often in
package configuration. The function =before-call= and =after-call= provide a fast
and convenient way to do this.

******** load-on-call
:PROPERTIES:
:ID:       324e707b-2f44-4168-a846-037f5401dedb
:END:

This is the internal function which I use to build the others. It loads a
package before or after (you specify) a particular function is called. To do
this it adds an =XL= advice that loads the feature to the function.

#+begin_src emacs-lisp
(defun xl--load-on-call (package where fn)
  "Load PACKAGE before or after FN is called."
  (alet (xl-symbol-intern 'xl--load- package '-advice)
    (fset it `(lambda (&rest _)
                (xl-log "Loading %s" ',package)
                (require ',package)))
    (xl-advice-add fn where it nil t)))
#+end_src

******** load before call
:PROPERTIES:
:ID:       cc0e92bc-cd6d-4994-82ea-eb065fc3ad89
:END:

For convenience, I provide [[helpfn:xl-load-before-call][xl-load-before-call]] and [[helpfn:xl-load-after-call][xl-load-after-call]]. It's nice
not to have to specify the advice keyword.

#+begin_src emacs-lisp
(defun xl-load-before-call (package fn)
  "Load PACKAGE before FN is called."
  (xl--load-on-call package :before fn))
#+end_src

******** load after call
:PROPERTIES:
:ID:       b0b294d0-15ac-42d9-9e4c-fd9da8a95206
:END:

#+begin_src emacs-lisp
(defun xl-load-after-call (package fn)
  "Load PACKAGE after FN is called."
  (xl--load-on-call package :after fn))
#+end_src


****** defadvice!
:PROPERTIES:
:ID:       1e0f3a27-a7d8-4e28-a359-f42ed7a16033
:END:

This section pertains to [[helpfn:defadvice!][defadvice!]], a replacement for [[helpfn:define-advice][define-advice]] that
provides a declarative way to define advices. This should be used for one-time
advices that.

******* define-advice!
:PROPERTIES:
:ID:       cc161eaf-a8fb-4e24-853f-a76a49c28dcf
:END:

The only difference between this and [[helpfn:define-advice][define-advice]] is that =NAME= and =SYMBOL= are
switched. In my opinion, the unique part of the function name being first is
more consistent with =defun=.

#+begin_src emacs-lisp
(defmacro define-advice! (name args &rest body)
  "A wrapper around `define-advice'.
The only difference is that this switches the order the arguments have to be
passed in.

\(fn ACTION (WHERE &optional ADVICE-ARGS TARGET &rest TARGETS) &rest BODY)"
  (declare (indent 2) (doc-string 3) (debug (sexp sexp body)))
  (unless (listp args)
    (signal 'wrong-type-argument (list #'listp args)))
  (-let (((where lambda-args fn props) args)
         (advice-name (intern (format "xl--%s-advice" name))))
    `(aprog1 (defun ,name ,lambda-args ,@body)
       (xl-advice-add #',fn ,where it ,props))))
#+end_src

******* anaphoric defadvice!
:PROPERTIES:
:ID:       98b2ce63-da31-4f7a-b776-1ee1747b5d57
:END:

=anaphoric-define-advice!= lets you omit the =lambda-args=. If you do omit the
arguments and you want to use them, you can do so via [[id:9938b1e1-6c6e-4a45-a85e-1a7f2d0bf6df][anaphoric variables]].

Note that [[helpfn:help-function-arglist][help-function-arglist]] returns =t= when it fails to get the function
arguments.

#+begin_src emacs-lisp
(defmacro anaphoric-define-advice! (name args &rest body)
  "A variant of `define-advice!'.
Unlike `define-advice!', this macro does not take an arglist as an argument.
Instead, arguments are accessed via anaphoric variables.

\(fn ACTION (WHERE TARGET &rest TARGETS) &rest BODY)"
  (-let* (((where target . other-args) args)
          (advice-args (if (eq where :around)
                           '(<orig-fn> &rest <args>)
                         '(&rest <args>))))
    `(define-advice! ,name (,where ,advice-args ,target ,@other-args)
       (ignore <args>)
       (cl-progv
           (->> (alet (help-function-arglist #',target t)
		  ;; kind of a hack...
		  (if (eq t it) nil it))
		(-remove (fn! (s-starts-with-p "@" (symbol-name <>))))
		(-map (fn! (intern (format "<%s>" (symbol-name <>))))))
	   <args>
	 ,@body))))
#+end_src

******* defadvice!
:PROPERTIES:
:ID:       d8773e00-1abe-4b03-82f0-07b47e93ccb4
:END:

This macro takes care of allowing multiple advices and deciding between whether
to use =defadvice!= or =anaphoric-defadvice!=.

#+begin_src emacs-lisp
(defmacro defadvice! (name args &rest body)
  "Define and advice.

\(fn ACTION (WHERE &optional ARGS-LIST TARGET &rest TARGETS) &rest BODY)"
  (-let* ((symbols-only (lambda (it) (and (symbolp it) (not (keywordp it)))))
          ((before fns after) (-partition-by symbols-only args))
          (advice-macro (if (listp (nth 1 args))
                            'define-advice!
                          'anaphoric-define-advice!)))
    `(progn
       ,@(-map (fn! `(,advice-macro ,name (,@before ,<fn> ,@after) ,@body))
               fns))))
#+end_src

**** Keybindings
:PROPERTIES:
:ID:       b0680fe6-23eb-412f-a357-bfa5e5bb7af7
:END:

***** prefix bindings
:PROPERTIES:
:ID:       d6535e9d-f55c-4281-a734-11917f9b5cdd
:END:

A popular strategy to mitigate the mental load of remembering many keybindings
is to bind them in a tree-like fashion (see [[https://github.com/syl20bnr/spacemacs][spacemacs]]).

****** leader Keys
:PROPERTIES:
:ID: 143211d6-b868-4ffb-a5d0-25a77dee401f
:END:

#+begin_src emacs-lisp
(defconst XL-LEADER-KEY "SPC"
  "The evil leader prefix key.")

(defconst XL-LEADER-ALT-KEY "M-SPC"
  "The leader prefix key used for Insert and Emacs states.")
#+end_src

****** localleader keys
:PROPERTIES:
:ID: 45941bcb-209f-4aa3-829a-dee4e3ef2464
:END:

#+begin_src emacs-lisp
(defconst XL-LOCALLEADER-KEY "SPC m"
  "The localleader prefix key for major-mode specific commands.")

(defconst XL-LOCALLEADER-ALT-KEY "C-SPC m"
  "The localleader prefix key for major-mode specific commands.")

(defconst XL-LOCALLEADER-SHORT-KEY ","
  "A shorter alternative `xl-localleader-key'.")

(defconst XL-LOCALLEADER-SHORT-ALT-KEY "M-,"
  "A short non-normal  `xl-localleader-key'.")
#+end_src

***** general
:PROPERTIES:
:ID: 706f35fc-f840-4a51-998f-abcd54c5d314
:END:

There are numerous keybinding functions in Emacs; and they all look a little
different: there's [[helpfn:global-set-key][global-set-key]], [[helpfn:local-set-key][local-set-key]], [[helpfn:define-key][define-key]] and the list goes
on. And with [[https://github.com/emacs-evil/evil.git][evil]] which [[id:73366b3e-7438-4abf-a661-ed1553b1b8df][I use]] , there's also [[helpfn:evil-global-set-key][evil-global-set-key]] and
[[helpfn:evil-define-key][evil-define-key]]. [[https://github.com/noctuid/general.el.git][general]] provides a function that you can use for all bindings
([[helpfn:general-define-key][general-define-key]]).

****** init
:PROPERTIES:
:ID:       2d0487ba-0150-47f2-a3d5-9d3c26e64c31
:END:

#+begin_src emacs-lisp
(use-package! general
  :demand t
  :xl-config (general-auto-unbind-keys))
#+end_src

****** definers
:PROPERTIES:
:ID: 6444d218-1627-48bd-9b5c-7bfffb17d912
:END:

As I've mentioned =general= uses the function =general-define-key= as a generic
do-all key binder. Sometimes though we have keys that we want to bind with
specific arguments to =general-define-key= pretty often. A typical example of
this is binding =leader= or =localleader= keys like [[https://github.com/syl20bnr/spacemacs][spacemacs]].

This form creates a macro =define-leader-key!= that.

#+begin_src emacs-lisp
(use-package! general :xl-config
  (general-create-definer define-leader-key!
    :prefix XL-LEADER-KEY
    :non-normal-prefix XL-LEADER-ALT-KEY
    :keymaps 'override
    :states '(normal motion insert emacs)))
#+end_src

****** localleader
:PROPERTIES:
:ID:       e4770eae-adf5-4216-9016-5ec4bc465e03
:END:

There's pros and cons to the =SPC m= binding. The main pro is that it's
consistent with =SPC=. With the leader and the localleader, this means that you
can reach any binding from just =SPC=. This means that you can discover all
bindings from just one root binding. This is a nice property to have. On the
other hand, bindings can get a bit long. That one extra character can really
make a difference. That's why.

#+begin_src emacs-lisp
(defmacro define-localleader-key! (&rest args)
  (declare (indent defun))
  (alet `(:keymaps 'override
	  :states '(normal motion insert emacs)
	  ,@args)
    `(progn (general-def
              :prefix XL-LOCALLEADER-KEY
              :non-normal-prefix XL-LOCALLEADER-ALT-KEY
              ,@it)
            (general-def
              :prefix XL-LOCALLEADER-SHORT-KEY
              :non-normal-prefix XL-LOCALLEADER-SHORT-ALT-KEY
              ,@it))))
#+end_src

****** aliases
:PROPERTIES:
:ID:       81031f16-179e-4da7-9d83-7da5459fbdbd
:END:

In addition to providing keybinding stuff, =general= also provides.

#+begin_src emacs-lisp
(defalias 'define-key! 'general-def)
#+end_src

***** define-key!
:PROPERTIES:
:ID:       bcac5f74-d2ce-434c-9ddc-91df64872791
:END:

This is a convenience macro I've written around general def that binds keys
according to a syntax which I think is minimal and convenient.

****** process bindings
:PROPERTIES:
:ID:       e4b87b17-f0ed-4c1e-98ac-0ad92dc9e965
:END:

**** Packages
:PROPERTIES:
:ID:       d5c0d112-319d-4271-a819-eb786a64bfc6
:END:

***** backtrace
:PROPERTIES:
:ID:       63fe8a26-512e-41c6-8b8d-a9f3ba495bc9
:END:

This built-in emacs package is opens a buffer with a list.

#+begin_src emacs-lisp
(use-feature! backtrace
  :popup ("bottom" "backtrace" :newname "\\*Backtrace\\*"))
#+end_src

***** origami
:PROPERTIES:
:ID:       ac2cc043-331f-435b-b903-39681b84fefe
:END:

=origami= is, as its name suggests, a package that handles folding.

#+begin_src emacs-lisp
(use-package! origami
  :hook prog-mode-hook)
#+end_src

***** ts

#+begin_src emacs-lisp
(use-package! ts)
#+end_src

***** vc-hook
:PROPERTIES:
:ID:       a8dcb1f6-05a0-46cb-95b5-1d0cd0ad4467
:END:

#+begin_src emacs-lisp
(use-feature! vc-hooks
  :set
  (vc-follow-symlinks . t)
  (vc-follow-link     . t))
#+end_src

***** subr-x
:PROPERTIES:
:ID:       ee3ad1b5-920a-4337-9874-79e066ed53fe
:END:

#+begin_src emacs-lisp
(use-feature! subr-x :demand t)
#+end_src

***** startup
:PROPERTIES:
:ID: 9725b7e0-54b8-4ab4-aa00-d950345d0aea
:END:

As it's name suggests, the built-in startup feature in Emacs.

If you just set [[helpvar:inhibit-startup-echo-area-message][inhibit-startup-echo-area-message]] to =t= the word =nil= is
messaged.  So it's best just to override the function entirely.

As per [[https://emacs.stackexchange.com/questions/18677/prevent-auto-save-list-directory-to-be-created][this stackoverflow question]], this prevents the =auto-save-directory= from
being created.

#+begin_src emacs-lisp
(use-feature! startup
  :ignore display-startup-echo-area-message startup-echo-area-message
  :set
  (auto-save-list-file-prefix  . nil)
  (inhibit-startup-buffer-menu . t)
  (inhibit-startup-message     . t)
  (inhibit-startup-screen      . t)
  (inhibit-default-init        . t)
  (inhibit-spash-screen        . t)
  (initial-scratch-message     . nil)
  (initial-buffer-choice       . #'startup:initial-buffer-choice)
  (initial-major-mode          . 'fundamental-mode)
  :init
  (defun startup:initial-buffer-choice ()
    "Return the initial buffer to be displayed.
This function is meant to be used as the value of `initial-buffer-choice'."
    (alet (if xl-debug-p "*xl-log*" "*scratch*")
      (get-buffer-create it))))
#+end_src

***** paren
:PROPERTIES:
:ID: 8ba80d6f-292e-4d44-acfe-d7b7ba939fa4
:END:

#+begin_src emacs-lisp
(use-feature! paren
  :hook (prog-mode . show-paren-mode)
  :set
  (show-paren-delay . 0))
#+end_src

***** clipboard
:PROPERTIES:
:ID: 60abb076-89b1-439b-8198-831b2df47782
:END:

#+begin_src emacs-lisp
(use-feature! clipboard
  :set
  (selection-coding-system . 'utf-8)
  (select-enable-clipboard . t)
  (select-enable-primary   . t)
  (x-select-request-type   . '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
#+end_src

***** simple
:PROPERTIES:
:ID: 89df102a-a2c9-4ece-9acc-ed90e8064ed8
:END:

#+begin_src emacs-lisp
(use-feature! simple
  :popup ("bottom" "messages" :newname "\\*Messages\\*")
  :set
  (delete-trailing-lines . nil)
  (blink-matching-paren  . t)
  (idle-update-delay     . 1))
#+end_src

****** loaddefs
:PROPERTIES:
:ID:       5af4faf8-47e3-4db2-9d13-47fc828b8fca
:END:

These are *extremely* important lines if you use an external program as I do
([[https://wiki.archlinux.org/index.php/Msmtp][msmtp]]) to send your email. If you don't set these variables, emacs will
think you want to use =smtp=.

#+begin_src emacs-lisp
(use-feature! loaddefs
  :set
  (disabled-command-function . nil))
#+end_src

***** backup
:PROPERTIES:
:ID:       f55fe748-209b-4450-a948-b0a7f8861dcf
:END:

#+begin_src emacs-lisp
(setq make-backup-files t)
(setq delete-by-moving-to-trash t)
(setq trash-directory (expand-file-name "~/Trash"))
#+end_src

***** files
:PROPERTIES:
:ID: 2a7862da-c863-416b-a976-4cf7840a8712
:END:

#+begin_src emacs-lisp
(use-feature! files
  :set
  (confirm-nonexistent-file-or-buffer . nil)
  (backup-by-copying-when-linked      . t)
  (backup-directory-alist             . (list (cons ".*" (xl-data-dir "backup/"))))
  (require-final-newline              . nil)
  (delete-old-versions                . t)
  (auto-mode-case-fold                . nil)
  (confirm-kill-emacs                 . #'y-or-n-p)
  (auto-save-interval                 . 300)
  (backup-by-copying                  . t)
  (auto-save-default                  . nil)
  (auto-save-timeout                  . 30)
  (make-backup-files                  . nil)
  (kept-old-versions                  . 2)
  (kept-new-versions                  . 2)
  (trash-directory                    . (expand-file-name "Trash" "~"))
  (version-control                    . nil))
#+end_src

***** ffap
:PROPERTIES:
:ID: b1229201-a5ac-45c7-91fa-7a6b39bbb879
:END:

Don't ping things that look like domain names.

#+begin_src emacs-lisp
(use-feature! ffap
  :set
  (ffap-machine-p-known . 'reject))
#+end_src

***** server
:PROPERTIES:
:ID: 3ddeb65c-9df6-4ede-9644-eb106b3ba1dd
:END:

#+begin_src emacs-lisp
(use-feature! server
  :set
  (server-auth-dir . (xl-data-dir "server/"))
  :config
  (unless (server-running-p) (server-start)))
#+end_src

***** tramp
:PROPERTIES:
:ID: 3af0a4d6-bd08-4fe2-bc5c-79b1b811fc6b
:END:

#+begin_src emacs-lisp
(use-feature! tramp
  :set
  (tramp-backup-directory-alist . backup-directory-alist)
  (tramp-persistency-file-name  . (xl-data-dir "tramp-persistency.el"))
  (tramp-auto-save-directory    . (xl-data-dir "tramp-auto-save/")))
#+end_src

***** cus-edit
:PROPERTIES:
:ID: 8bd5683d-91e1-4c1b-a8a5-3b39921e995d
:END:

#+begin_src emacs-lisp
(use-feature! cus-edit
  (custom-file            . null-device)
  (custom-theme-directory . (xl-local-dir "themes/")))
#+end_src

***** url
:PROPERTIES:
:ID: e4b5bfce-1111-48b2-bfee-da754974aa46
:END:

#+begin_src emacs-lisp
(use-feature! url
  :set
  (url-cache-directory         . (xl-data-dir "url/cache/"))
  (url-configuration-directory . (xl-data-dir "url/configuration/")))
#+end_src

***** bytecomp
:PROPERTIES:
:ID:       6b375bfb-a8c3-473c-8dbd-530e692a15ab
:END:

#+begin_src emacs-lisp
(use-feature! bytecomp
  :set
  (byte-compile-warnings . '(not free-vars unresolved noruntime lexical make-local))
  (byte-compile-verbose  . xl-debug-p))
#+end_src

***** compile
:PROPERTIES:
:ID:       913aa4f2-e42b-4b74-a2d4-e87b1738a5bd
:END:

#+begin_src emacs-lisp
(use-feature! compile
  :set
  (compilation-ask-about-save . nil)
  (compilation-scroll-output  . 'first-error)
  (compilation-always-kill    . t))
#+end_src

***** uniquify
:PROPERTIES:
:ID:       9ba2726b-3fef-4e9b-9387-a80ab09bdb7d
:END:

#+begin_src emacs-lisp
(use-feature! uniquify
  :set
  (uniquify-buffer-name-style . 'forward))
#+end_src

***** ansi-color
:PROPERTIES:
:ID:       5feaab76-e5c1-450c-94a6-8fdfb95ddb94
:END:

#+begin_src emacs-lisp
(use-feature! ansi-color
  :set
  (ansi-color-for-comint-mode . t))
#+end_src

***** image mode
:PROPERTIES:
:ID:       32e2118a-c92b-4e8d-b2db-048428462783
:END:

Non-nil means animated images loop forever, rather than playing once.

#+begin_src emacs-lisp
(use-feature! image-mode
  :set
  (image-animate-loop . t))
#+end_src

***** window
:PROPERTIES:
:ID:       af27cd7e-2096-4f6d-a749-63e4c38d136c
:END:

#+begin_src emacs-lisp
(use-feature! window
  :set
  (split-width-threshold . 160))
#+end_src

***** indent
:PROPERTIES:
:ID:       a5d97d4d-3af9-4fde-ae14-953ad4d28edd
:END:

#+begin_src emacs-lisp
(use-feature! indent
  :set
  (tab-always-indent . t))
#+end_src

***** mouse
:PROPERTIES:
:ID:       d0d6de11-50fa-4ae2-ad4b-69712f3e2c54
:END:

#+begin_src emacs-lisp
(use-feature! mouse
  :set
  (mouse-yank-at-point . t))
#+end_src

***** gv
:PROPERTIES:
:ID:       84cc5883-a303-453e-af91-644d4544e3f9
:END:

=gv= is what contains the code for the =setf= macro.
https://emacs.stackexchange.com/questions/59314/how-can-i-make-setf-work-with-plist-get

#+begin_src emacs-lisp
(use-feature! gv
  :xl-config
  (gv-define-simple-setter plist-get plist-put))
#+end_src

***** nsm
:PROPERTIES:
:ID:       0ca7fc66-5312-4c69-a87d-7607292c7a2a
:END:

#+begin_src emacs-lisp
(use-feature! nsm
  :set
  (nsm-settings-file . (xl-data-dir "network-settings.data")))
#+end_src

***** browse-url
:PROPERTIES:
:ID:       ab7cf98c-47ca-49e1-ba8c-ee52ce04debe
:END:

=browse-url= is a built-in package that provides a uniform interface for
browsing the web.

****** browse-url
:PROPERTIES:
:ID:       e59dc362-5615-45a8-8010-a111ddc5e835
:END:

=browse-url= is a built-in package that provides a useful abstraction for browsing
the web.

#+begin_src emacs-lisp
(use-feature! browse-url
  :set
  (browse-url-firefox-new-window-is-tab . nil)
  (browse-url-firefox-arguments         . nil)
  (browse-url-new-window-flag           . t)
  :xl-config
  (alet (list (cons (rx "http://www.wikipedia.org/search") #'eww)
	      (cons "." #'browse-url-firefox))
    (setq browse-url-browser-function it)))
#+end_src

***** bookmarks
:PROPERTIES:
:ID:       a4514b36-6e08-4a66-a595-cd40fc9acc0b
:END:

#+begin_src emacs-lisp
(use-feature! bookmark
  :set
  (bookmark-default-file . (xl-data-dir "bookmarks")))
#+end_src

**** Miscellaneous
:PROPERTIES:
:ID:       65edb4e7-0fe1-4e37-ae9b-027c9f15162a
:END:

This headline contains headings for which I have not yet determined a good
hierarchy.

***** delete duplicates in history
:PROPERTIES:
:ID:       1c381491-c4fa-4b5e-99de-ec6bd33df77c
:END:

This variable tells savehist not to record duplicate entries in history. Note
this is not apart of savehist technically; it is a variable defined in C source
code.

#+begin_src emacs-lisp
(set! history-delete-duplicates t)
#+end_src

***** don't echo keystrokes
:PROPERTIES:
:ID:       b8856ebe-6208-4271-ad5a-d352fabec8bb
:END:

After you type a key, emacs echoes it into the echo area. I find this
unnecessary. Additionally, this will interfere with [[https://github.com/justbur/emacs-which-key][which-key]]. The keystroke
echoing in the mode line makes the which-key prompt disappear prematurely.

#+begin_src emacs-lisp
(setq-default echo-keystrokes 0)
#+end_src

***** log the init time
:PROPERTIES:
:ID:       36e2113f-a28f-4ef2-bb90-141f82291c91
:END:

I find it convenient to be able to view the init time in the =*xl-log*=
buffer. Speed is important to me and I want to know how fast my Emacs is at
initializing. :race-car:

#+begin_src emacs-lisp
(defhook! log-init-time (emacs-startup-hook :append t)
  "Log the init time."
  (xl-log "emacs-init-time -> %s" (emacs-init-time)))
#+end_src

***** set the fill-column
:PROPERTIES:
:ID:       84d8e85a-a6a1-49cd-b46e-e5cd3f825438
:END:

Fill column refers to the column where line-wrapping will occur. The standard
value for this is =80= but historically that was because of the [[https://en.wikipedia.org/wiki/Punched_card][IBM punch
card]]. Now this is not the case so I don't think it's as much of a deal.

#+begin_src emacs-lisp
(setq-default fill-column 80)
#+end_src

***** recursive minibuffers
:PROPERTIES:
:ID:       7eb20f6d-75b4-4eec-8878-e7232c1a153d
:END:

This means that you can use the minibuffer while in the minibuffer. One
situation where I use this feature is in the command [[helpfn:eval-expression][eval-expression]]. As I'm
typing an expression, I get completion from the minibuffer.

#+begin_src emacs-lisp
(setq-default enable-recursive-minibuffers t)
#+end_src

***** use yes or no
:PROPERTIES:
:ID:       82a84315-2018-42e0-bd1a-74af7b722593
:END:

Essentially, I am telling all Emacs functions that prompt the user for a =yes=
or =no= to instead allow me to type =y= or =p=.

#+begin_src emacs-lisp
(xl-advice-add #'yes-or-no-p :override #'y-or-n-p)
#+end_src

***** utf-8 text encoding
:PROPERTIES:
:ID:       26344072-c145-40bd-9ade-8c7f2eef54c8
:END:

#+begin_src emacs-lisp
(setq-default locale-coding-system 'utf-8)
(setq-default buffer-file-coding-system 'utf-8)

(set-language-environment 'utf-8)
(setq-default locale-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
(setq-default default-file-name-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)

(setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))

;; (with-os! (:not windows)
;;   (setq selection-coding-system 'utf-8))

(when (fboundp 'set-charset-priority)
  (set-charset-priority 'unicode))
#+end_src

***** linux
:PROPERTIES:
:ID:       6572e618-e5ef-445b-90d6-14dc2c24f1a4
:END:

#+begin_src emacs-lisp
(with-os! linux
  (set! x-underline-at-descent-line t)
  (set! x-gtk-use-system-tooltips nil))
#+end_src

***** disable bi-directional text
:PROPERTIES:
:ID:       6c12f14c-75c7-4b30-9bb4-ca6e8d3cae47
:END:

Disabling bidirectional text provides a small performance boost. Bidirectional
text is useful for languages that read right to left.

#+begin_src emacs-lisp
(set-default! bidi-display-reordering 'left-to-right)
(set-default! bidi-paragraph-direction 'left-to-right)
#+end_src

***** scrolling
:PROPERTIES:
:ID:       c91bcd0f-da83-44a3-9d9e-e1f55dcdb642
:END:

#+begin_src emacs-lisp
(set-default! hscroll-margin 2)
(set-default! hscroll-step 1)
(set-default! scroll-conservatively 1001)
(set-default! scroll-margin 0)
(set-default! scroll-preserve-screen-position t)
#+end_src

***** fast scrolling
:PROPERTIES:
:ID:       964a8b3e-37b4-4d6b-9298-3a1be3cfe6aa
:END:

"More performant rapid scrolling over unfontified regions. May cause brief
spells of inaccurate fontification immediately after scrolling."

#+begin_src emacs-lisp
(set! fast-but-imprecise-scrolling t)
#+end_src

***** resize pixelwise
:PROPERTIES:
:ID:       02daff3d-e532-4cfa-a217-81e27627e7a7
:END:

;; https://github.com/baskerville/bspwm/issues/551#issuecomment-574975395

#+begin_src emacs-lisp
(set! window-resize-pixelwise t)
(set! frame-resize-pixelwise t)
#+end_src

***** disable cursor blinking
:PROPERTIES:
:ID:       fe8a259b-12e6-4e58-a324-eab831283a86
:END:

By default the cursor blinks. The point is so that it is easier to find on the
screen. Usually, however, I have no trouble finding it so I disable it.

#+begin_src emacs-lisp
(use-feature! frame
  :config
  (blink-cursor-mode -1))
#+end_src

***** stop beeping
:PROPERTIES:
:ID:       2a83cb3a-ca2e-4d9c-a296-340d33855614
:END:

#+begin_src emacs-lisp
(set-default! ring-bell-function #'ignore)
#+end_src

***** garbage collection
:PROPERTIES:
:ID: 27ad0de3-620d-48f3-aa32-dfdd0324a979
:END:

Emacs garbage collects too frequently for most modern machines. This makes emacs
less performant especially when performing a large number of calculations,
because it spends resources garbage collecting when it doesn't have to. Indeed,
increasing the value of [[helpvar:gc-cons-threshold][gc-cons-threshold]], the number of bytes of consing
between garbage collections, is known to make a notable difference in user
startup time. By default it is only 800 KB.

****** gc cons threshold
:PROPERTIES:
:ID: e15d257f-1b0f-421e-8b34-076b1d20e493
:END:

I define three levels on frequency with which emacs should perform garbage
collection.

#+begin_src emacs-lisp
(defconst XL-GC-CONS-THRESHOLD-MAX most-positive-fixnum
  "The upper limit for `gc-cons-threshold'.
When VOID is performing computationally intensive operations,
`gc-cons-threshold' is set to this value.")

(defconst XL-GC-CONS-THRESHOLD (eval-when-compile (* 16 1024 1024))
  "The default value for `gc-cons-threshold'.
This is the value of `gc-cons-threshold' that should be used in typical usages.")

(defconst XL-GC-CONS-THRESHOLD-MIN (eval-when-compile (* 4 1024 1024))
  "The value for `gc-cons-threshold'.")
#+end_src

****** gcmh
:PROPERTIES:
:ID:       86653a5a-f273-4ce4-b89b-f288d5d46d44
:END:

=gcmh= does three things. It reduces garbage collection by setting, it adds a
hook telling Emacs to gargbage collect during idle time, and it tells Emacs
to garbage collect more frequently when it's idle.

Note that I add gcmh mode hook at the end so that all the other hook commands
are done before setting the =gc-cons-threshold= back to a normal value.

#+begin_src emacs-lisp
(use-package! gcmh
  :hook emacs-startup-hook
  :set
  (gcmh-idle-delay          . 5)
  (gcmh-verbose             . xl-debug-p)
  (gcmh-high-cons-threshold . XL-GC-CONS-THRESHOLD)
  (gcmh-low-cons-threshold  . XL-GC-CONS-THRESHOLD-MIN))
#+end_src

****** minibuffer
:PROPERTIES:
:ID: 83f47b4d-a0e2-4275-9c1a-7e317fdc4e41
:END:

[[helpvar:minibuffer-setup-hook][minibuffer-setup-hook]] and [[helpvar:minibuffer-exit-hook][minibuffer-exit-hook]] are the hooks run just before
entering and exiting the minibuffer (respectively). In the minibuffer I'll be
primarily doing searches for variables and functions. There are alot of
variables and functions so this can certainly get computationally expensive. To
keep things snappy I increase boost the [[helpvar:gc-cons-threshold][gc-cons-threshold]] just before I enter
the minibuffer, and restore it to it's original value a few seconds after it's closed.

It would take me forever to guess the name =minibuffer-setup-hook= from the
variable [[helpvar:minibuffer-exit-hook][minibuffer-exit-hook]]. If I knew the name =minibuffer-exit-hook= but did not
know what the hook to enter the minibuffer was, I'd probably
=minibuffer-enter-hook= because [[https://www.wordhippo.com/what-is/the-opposite-of/exit.html]["enter" is one of the main antonyms of "exit"]].
It'd take me forever to guess =startup=. Note that the only tricky thing about
this example.

At first I thought of =entry= but after more thought I realized
hook variables use action verbs in their names not nouns. So the =exit= in
=minibuffer-exit-hook= is actually the verb =exit= not the noun.

#+begin_src emacs-lisp
(defvaralias 'minibuffer-enter-hook 'minibuffer-setup-hook)

(defhook! boost-garbage-collection (minibuffer-enter-hook)
  "Boost garbage collection settings to `XL-GC-CONS-THRESHOLD-MAX'."
  (setq gc-cons-threshold XL-GC-CONS-THRESHOLD-MAX))

(defhook! defer-garbage-collection (minibuffer-exit-hook :append t)
  "Reset garbage collection settings to `xl-gc-cons-threshold' after delay."
  (setq gc-cons-threshold XL-GC-CONS-THRESHOLD))
#+end_src

***** theme
:PROPERTIES:
:ID: 2ac7c2fe-a2ba-4e55-a467-ff4af8850331
:END:

****** don't prompt me when loading theme
:PROPERTIES:
:ID:       eaa6531c-1188-41c7-a645-a82d9f482449
:END:

If you don't enable =custom-save-themes=, emacs asks you whether you're sure you
want to load a theme for security reasons. I prefer the convenience of not being
prompted.

Loading a theme qualifies as an intensive operation as all the faces on the
screen need to be redisplayed.

#+begin_src emacs-lisp
(use-feature! custom
  :gc-pause load-theme
  :set
  (custom-safe-themes . t))
#+end_src

****** loading theme
:PROPERTIES:
:ID: 7ae02d32-4652-494c-9e14-05f60ca60395
:END:

Sometimes there are things that need tidying up after loading a theme. For
example, if I'm using evil I need to update the cursor color.

#+begin_src emacs-lisp
(defvar xl-after-load-theme-hook nil
  "Hook run after the theme is loaded with `load-theme'.")

(defadvice! run-after-load-theme-hook (:after load-theme)
  "Set up `xl-load-theme-hook' to run after `load-theme' is called."
  (setq xl-theme <theme>)
  (run-hooks 'xl-after-load-theme-hook))
#+end_src

****** disable old themes first
:PROPERTIES:
:ID: 9d2f985b-8b0f-497f-982b-6f69c62179a9
:END:

Sometimes we end up with remants of the faces of old themes when we load a new
one. For this reason, I make sure to disable any enabled themes before applying
a new theme.

#+begin_src emacs-lisp
(defadvice! disable-old-themes (:around load-theme)
  "Disable old themes before loading new ones."
  (mapc #'disable-theme custom-enabled-themes)
  (apply <orig-fn> <args>))
#+end_src

***** disable terminal initialization
:PROPERTIES:
:ID: 63e351ad-9ef6-4034-9fca-861881c74d6a
:END:

According to [[][]], when running emacs in terminal tty is *tremendously* slow.

#+begin_src emacs-lisp
(unless (display-graphic-p)
  (xl-advice-add #'tty-run-terminal-initialization :override #'ignore)
  (defhook! init-tty (window-setup-hook)
    (advice-remove #'tty-run-terminal-initialization #'ignore)
    (tty-run-terminal-initialization (selected-frame) nil t)))
#+end_src

***** prevent emacs from killing certain buffers
:PROPERTIES:
:ID:       ae935cf5-7322-499c-96d7-20209d9b6641
:END:

I never want the =*scratch*= and =*Messages*= buffer to be killed. I owe this idea
to [[https://github.com/rememberYou/.emacs.d][rememberYou's Emacs]].

#+begin_src emacs-lisp
(defhook! lock-certain-buffers (after-init-hook)
  "Prevent certain buffers from being killed."
  (-each (list "*scratch*" "*Messages*")
    (fn! (with-current-buffer <buffer> (emacs-lock-mode 'kill)))))
#+end_src

***** prefixed-core
:PROPERTIES:
:ID:       14b63dc9-1d95-4bd7-8b29-8b2b33bd1e69
:END:

This package defines numerous aliases to existing commands in an attempt to make
commands more discoverable and naming schemes more consistent. For example, it
aliases the function [[helpfn:set-frame-font][set-frame-font]] to [[helpfn:frame-set-font][frame-set-font]] because if you were
looking for function that involved the frame, the first thing you'd look for is
for functions namespaced =frame=.

#+begin_src emacs-lisp
(use-package! prefixed-core :demand t)
#+end_src

***** keyfreq
:PROPERTIES:
:ID:       626b35f7-eef1-4a75-b2dc-8600c1ac47b7
:END:

=keyfreq= records the frequency of key strokes.

#+begin_src emacs-lisp
(use-package! keyfreq
  :hook emacs-startup-hook)
#+end_src

***** idle-require
:PROPERTIES:
:ID:       0d619336-e852-4c6a-89a8-38ccbb71a077
:END:

Idle require is a tool for loading autoload functions, files or features during
idle time. The way to use this is to idle-require many small packages that
individually don't take too much time. This helps ensure that in emacs loading
of big packages like org-mode is snappy.

When emacs goes idle for [[helpvar:idle-require-idle-delay][idle-require-idle-delay]] seconds, the features will
start loading. [[helpvar:idle-require-load-break][idle-require-load-break]] is the break between features idle
require loads.

=idle-require= messages us to tell us when a package is being idle required and
when it has finished idle-requiring packages. I don't want to see the message
unless I'm debugging.

Since we're evaluating a good amount of lisp expressions, we should boost
garbage collection during this time.

#+begin_src emacs-lisp
(use-package! idle-require
  :demand t
  ;; :xl-use-xl-log idle-require-mode idle-require-load-next
  :gc-pause idle-require-load-next
  :set
  (idle-require-load-break . 2)
  (idle-require-idle-delay . 10))
#+end_src

**** Commands
:PROPERTIES:
:ID:       14fd249d-b972-472c-b57e-4e53a80b22dc
:END:

***** setting font size
:PROPERTIES:
:ID: 4bf24b65-6f23-4e42-930e-4d43f766545c
:END:

Face attribute height is a magnitude of 10 greater than what we typically
use as font sizes (eg. font-size 14 corresponds to a face-height of 140).
I want to make sure I don't input 14 thinking about font size (it's
happened before and it's a huge pain resetting the font-size when the
font is super small). Therefore, I check the code.

#+begin_src emacs-lisp
(defun xl/set-font-size ()
  "Set the font size interactively."
  (interactive)
  (let* ((old-font-size (face-attribute 'default :height))
         (prompt "The font size is %d. What do you want to change it to? ")
         (font-size (string-to-number (read-string (format prompt old-font-size))))
         (digits (+ 1 (floor (log font-size 10)))))

    ;; Make the font-size be 3 digits (Do what I mean not what I say).
    (when (< digits 3)
      (setq font-size (* font-size (expt 10 (- 3 digits)))))
    (when (> digits 3)
      (setq font-size (/ font-size (expt 10 (- digits 3)))))

    ;; If font size is still doesn't make sense, ask me to make sure it's what I want.
    (if (or (< font-size 280)
            (y-or-n-p
             (format "You're choosing a pretty large font size: %d. Is this what you intended?)"
                     font-size)))
        (progn
          (set-face-attribute 'default nil :height font-size)
          (message "Your Font Size was %s. Font size is now: %s"
                   old-font-size
                   font-size))
      (message "Font Size has been cancelled."))))
#+end_src

***** set font
:PROPERTIES:
:ID:       f24d97b6-7c74-491a-a77c-ba3ec22a2b68
:END:

#+begin_src emacs-lisp
(defun xl/set-font-face ()
  "Apply an existing xfont to all graphical frames."
  (interactive)
  (alet (completing-read "Choose font: " (x-list-fonts "*"))
    (set-frame-font it nil t)))
#+end_src

***** important buffers
:PROPERTIES:
:ID:       8d04e395-5b57-434b-b975-9ae85620631d
:END:

****** init file
:PROPERTIES:
:ID:       08a3004c-6c37-401d-b584-c2c94577102d
:END:

#+begin_src emacs-lisp
(defun xl/open-init-file ()
  "Switch to init file."
  (interactive)
  (alet (or (get-file-buffer XL-INIT-FILE)
	    (create-file-buffer XL-INIT-FILE))
    (display-buffer it)))
#+end_src

****** messages buffer
:PROPERTIES:
:ID: 7064ea0e-20e0-481c-9d07-18e4506ee3e8
:END:

In Emacs, messages. The messages buffer is where messages displayed at the bottom
of the Emacs frame are recorded after they expire.

#+begin_src emacs-lisp
(defun xl/open-messages-buffer ()
  (interactive)
  (alet (get-buffer-create "*Messages*")
    (display-buffer it)))
#+end_src

****** main todo file
:PROPERTIES:
:ID: 2accd21d-7316-4fa5-bd8f-8f40935ed621
:END:

#+begin_src emacs-lisp
(defun xl/switch-to-capture-file ()
  (interactive)
  (switch-to-buffer (find-file XL-CAPTURE-FILE)))
#+end_src

****** xl-log buffer
:PROPERTIES:
:ID:       0d696000-94bb-45af-a7af-b96f29714089
:END:

****** switch to scratch buffer
:PROPERTIES:
:ID:       7d9af4b6-7744-437f-b088-ec9397056113
:END:

#+begin_src emacs-lisp
(defun xl/open-scratch ()
  "Pop scratch."
  (interactive)
  (pop-to-buffer "*scratch*"))
#+end_src

*** Completion
:PROPERTIES:
:ID:       744ac652-aebc-4f5b-883a-4464dd7b07cd
:END:

In this headline I focus on packages that perform some sort of completion.

**** minibuffer candidate completion
:PROPERTIES:
:ID:       ec3295f0-24b9-4b35-9de6-9498c08e4f15
:END:

Candidate completion is a must in emacs. I had tried helm but it was too slow
for my needs.

***** selectrum
:PROPERTIES:
:ID:       f8a9cdba-a4a9-42aa-a505-e88ad0b4114d
:END:

Selectrum is another completion framework. It distinguishes itself from the rest
by striving to work with the built-in emacs [[helpfn:completing-read][completing-read]] instead of replacing
it like [[https://github.com/emacs-helm/helm][helm]] and [[https://github.com/emacs-helm/helm][ivy]] do. It promises to work with the existing Emacs framework
instead of replacing it as does Ivy and Helm. :recycle:

****** selectrum
:PROPERTIES:
:ID:       6e670980-7794-4505-a285-184416a5b377
:END:

In contrast, any command defined via completing-read should work consistently with
selectrum and its provided features.

Because helm and ivy replace the existing framework, it means that whenever you
want a command be capable of using all of helm or ivy's features, you need to
define it their way. Otherwise, there's no guarantee their features will work at
least any features besides the basic choosing of a single candidate. That's a
big reason why there are helm and ivy packages (there's 216 helm packages and 42
ivy packages in [[helpfn:straight-use-package][straight-use-package]] completion): many of those packages are just ivy and
helm wrappers around existing commands.

#+begin_src emacs-lisp
(use-package! selectrum
  :hook emacs-startup-hook
  :set
  (selectrum-max-window-height        . 15)
  (selectrum-num-candidates-displayed . 15)
  (selectrum-fix-minibuffer-height    . t)
  (selectrum-should-sort-p            . t)
  (selectrum-count-style              . nil)
  :init
  (general-def '(insert emacs) selectrum-minibuffer-map
    "TAB" #'selectrum-next-candidate
    "C-k" #'selectrum-previous-candidate
    "C-j" #'selectrum-next-candidate
    "C-;" #'selectrum-insert-current-candidate
    "C-l" #'selectrum/mark-candidate
    [backtab] #'selectrum-previous-candidate)
  :config
  (after! helm (selectrum-helm-mode)))
#+end_src

****** selectrum-prescient
:PROPERTIES:
:ID:       70668ed8-9c83-42d2-8dce-d8f7de923569
:END:

The variable names can get really long, no? :joy: Maybe it's better to have sort
of a =:nameless-set= keyword that implies a namespace the same as a package. :bulb:

#+begin_src emacs-lisp
(use-package! selectrum-prescient
  :hook selectrum-mode-hook
  :set
  (selectrum-preprocess-candidates-function . #'selectrum-prescient--preprocess))
#+end_src

****** advice for disable
:PROPERTIES:
:ID:       1e39a4d2-8d4a-4413-a86e-3f92547cff14
:END:

For most functions, sorting their candidates is good. But for some, it doesn't
make sense. This is advice specifically designed to disable selectrum sorting.

#+begin_src emacs-lisp
(defun selectrum:disable-sorting (fn)
  "Disable sorting for FN."
  (let ((advice (xl-symbol-intern fn '@no-selectrum-sorting)))
    (defalias advice #'selectrum:disable-selectrum-sorting-advice)
    (xl-log-function advice)
    (advice-add fn :around advice)))

(defun selectrum:disable-selectrum-sorting-advice (orig-fn &rest args)
  (if (bound-and-true-p selectrum-mode)
      (let (selectrum-should-sort-p) (apply orig-fn args))
    (apply orig-fn args)))
#+end_src

****** use-package keyword for disabling sorting
:PROPERTIES:
:ID:       a647122b-f39f-4140-8c5f-a3e14bfe37f3
:END:

#+begin_src emacs-lisp
(use-package:dwim-insert :no-sort)

(defun use-package-handler/:no-sort (name _ fns rest state)
  "Don't sort the functions with selectrum."
  `(,@(-map (fn! `(selectrum:disable-sorting #',<fn>)) fns)
    ,@(use-package-process-keywords name rest state)))

(defalias 'use-package-normalize/:no-sort 'use-package-normalize/:gc-pause)
#+end_src

****** lettered candidate index
:PROPERTIES:
:ID:       aae96baa-4acb-43cd-9d1d-0106abc762fd
:END:

When the variable [[helpvar:selectrum-show-indices][selectrum-show-indices]] is set to this function, selectrum
displays letters starting at =a= to [[helpvar:selectrum-num-candidates-displayed][selectrum-num-candidates-displayed]] times
down the alphabet. Fun fact, I actually contributed this feature to selectrum. :confetti-ball:

#+begin_src emacs-lisp
(defun selectrum:show-letter-index-fn (i)
  "Return letter corresponding to index."
  (format "%c " (+ 97 (% (1- i) selectrum-num-candidates-displayed))))
#+end_src

****** show indicators
:PROPERTIES:
:ID:       d0d61c43-88cd-49ed-bd1a-515405c2fa94
:END:

I want to select candidates efficiently. For me this means not having to press
=C-j= multiple times to reach a candidate that's lower in the list (imagine the
number of indices displayed is 15 and the candidate I want is the 14th one). To
address this I create this function. It displays letters next to the candidates.

#+begin_src emacs-lisp
(defun selectrum:select-candidate-by-letter ()
  "Choose selectrum candidate by letter."
  (interactive)
  (let ((selectrum-show-indices #'selectrum:show-letter-index-fn))
    (selectrum--update)
    (alet (read-key)
      (unless (= it 27)
	(selectrum-select-current-candidate (- (1+ it) 97))))))

(general-def '(emacs insert) selectrum-minibuffer-map
  "," #'selectrum:select-candidate-by-letter)
#+end_src

***** helm
:PROPERTIES:
:ID:       2da24557-b05d-475e-8565-6a24e23309c0
:END:

The reason I have helm installed is because (1) helm has some useful functions
that are not yet implemented for other completion frameworks and (2) selectrum
has a [[helpfn:selectrum-helm-mode][selectrum-helm-mode]] which it can use to "selectrumify" helm functions--at
least to some extent (sometimes the default action doesn't work).

It seems like I may be able to add default actions via an advice. :shrug-tone4:
We'll see. Basically, the idea would be to take reuse the code of helm commands
for presenting candidates and then make the action selection work via an advice
and, of course, add multiple actions via [[id][embark]].

Oh and in regards for using selectrum instead of helm: the main reason is simply
that helm is noticably slower with its command filtering. :turtle:

****** helm
:PROPERTIES:
:ID:       0ef7946e-629b-4a4f-8e47-7d8826d04e7e
:END:

If you're scrolling down a list of candidates, you might be suprised to
find. One "gotcha" in helm is the [[helpvar:helm-candidate-number-limit][helm-candidate-number-limit]]. By default helm
limits the amount of candidates it displays to increase performace.

Selectrum has no problem handling a large amount of candidates, particularly if
you additionally pause garbage collection for the duration of expensive
functions as I do. It handles the 16,143 candidates in [[helpfn:helm-system-packages][helm-system-packages]] on
my T400 instantaneously.

#+begin_src emacs-lisp
(use-package! helm
  :set
  (helm-candidate-number-limit . nil))
#+end_src

****** helm-system-packages
:PROPERTIES:
:ID:       3e6dd0e6-0632-454d-a496-d34ecd33b60f
:END:

#+begin_src emacs-lisp
(use-package! helm-system-packages
  :gc-pause helm-system-packages
  :no-sort helm-system-packages)
#+end_src

****** swiper-helm
:PROPERTIES:
:ID:       21a5285c-0447-452d-a7ef-e146b6bd60f0
:END:

#+begin_src emacs-lisp
(use-package! swiper-helm
  :no-sort swiper-helm
  :gc-pause swiper-helm)
#+end_src

***** prescient
:PROPERTIES:
:ID:       4445c814-9899-4d54-affe-0cee38642690
:END:

This package.

#+begin_src emacs-lisp
(use-package! prescient
  :set
  (prescient-save-file . (xl-data-dir "prescient-save-file"))
  :config
  (prescient-persist-mode))
#+end_src

***** orderless
:PROPERTIES:
:ID:       c70fae56-33b4-4b9d-9dd7-12c7a72de2ec
:END:

****** orderless
:PROPERTIES:
:ID:       9702810e-2013-4c41-ba12-0b55de6ceb38
:END:

#+begin_src emacs-lisp
(use-package! orderless
  :commands orderless-filter orderless-highlight-matches
  :set
  (selectrum-refine-candidates-function    . #'orderless-filter)
  (selectrum-highlight-candidates-function . #'orderless-highlight-matches))
#+end_src

****** stop selectrum filtering and highlight
:PROPERTIES:
:ID:       a6720cdc-9d51-463b-9ffe-f9341c6bd967
:END:

#+begin_src emacs-lisp
(defadvice! inhibit-filtering-and-highlighting (:around selectrum-prescient-mode)
  "Don't let `selectrum-prescient' filter or highlight. "
  (let ((selectrum-refine-candidates-function selectrum-refine-candidates-function)
	(selectrum-highlight-candidates-function selectrum-highlight-candidates-function))
    (apply <orig-fn> <args>)))
#+end_src

***** consult
:PROPERTIES:
:ID:       921ce22e-59ae-4de1-bef0-66a20e320df5
:END:

=consult= is a package that's akin to =counsel=. It's a library of generally
useful functions which are written in such a way that they can be work across
all the completion frameworks.

#+begin_src emacs-lisp
(use-package! consult
  :gc-pause consult-outline consult-line
  :general
  ([remap switch-to-buffer] #'consult-buffer))
#+end_src

***** marginalia
:PROPERTIES:
:ID:       0ce9957b-8805-4b2b-b5cb-52dc425a3dee
:END:

Marginalia adds descriptions to various commands.

#+begin_src emacs-lisp
(use-package! marginalia)
#+end_src

***** emark
:PROPERTIES:
:ID:       9e6a5fc3-5a7f-4067-b35e-ef9fb0605fb8
:END:

This package provides a way of adding actions (think helm) to commands. The
special thing about it is a generic way to do so.

The idea of actions is to minimize code duplication. The scenario is this: you
have an existing commands that allows you to select a candidate from a prompt
and do =X= with a candidate =c= from the set of candidates =C=. You want to
select from the same prompt, but instead you want to do =Y= with =c= not =X=. So
what do you do? You're faced with rewriting the command, copying the code for
the prompt and adding the code to do =Y= (with something like =helm= you'd
rewrite the code in terms of sources and actions). That's a lot of work!
:tired-face: And it's not scalable either you'd need to do this for any other
commands you come accross in the future. This explains why there are so many
=helm= packages.

=embark= provides a way to add actions to an existing command without having to
rewrite it.

Honestly, reading it's documentation can be a bit dizzying :dizzy-face:; not
because the it's bad but because it is hard to wrap your mind around such a
package without seeing it in action.

****** embark
:PROPERTIES:
:ID:       45768441-4ec6-475b-99c6-cfb587edb81d
:END:

As I learn more about embark I will improve this documentation over time.

#+begin_src emacs-lisp
(use-package! embark
  :init
  (general-def '(insert emacs) selectrum-minibuffer-map
    "C-a" #'embark-act))

(defhook! pause-selectrum (embark-collect-mode-hook)
  (when (eq embark-collect--kind :live)
    (with-selected-window (active-minibuffer-window)
      (shrink-window selectrum-num-candidates-displayed)
      (setq-local selectrum-num-candidates-displayed 0))))
#+end_src

***** setup
:PROPERTIES:
:ID:       5e5393d9-9f58-45be-9ecc-1bc9f0316379
:END:

#+begin_src emacs-lisp
(use-package! company
  :hook prog-mode-hook
  :set
  (company-tooltip-align-annotations . t)
  (company-minimum-prefix-length     . 1)
  (company-minimum-prefix-length     . 1)
  (company-dabbrev-downcase          . nil)
  (company-require-match             . 'never)
  (company-tooltip-limit             . 14)
  (company-show-numbers              . t)
  (company-idle-delay                . 0.15)
  (company-frontends                 . '(company-pseudo-tooltip-frontend)))
#+end_src

***** bindings
:PROPERTIES:
:ID:       ba170d95-7d86-4827-af6b-dc5fd4c1b7e5
:END:

#+begin_src emacs-lisp
(define-key! company-active-map
   [tab]     #'company-select-next
   [backtab] #'company-select-previous
   "C-k"     #'company-select-previous
   "C-j"     #'company-select-next)
#+end_src

***** backends
:PROPERTIES:
:ID:       bd47ec52-6428-4f37-80d2-3795f5a42d02
:END:

****** determining which modes are active
:PROPERTIES:
:ID:       b8603ca5-9a24-4684-a75b-e0c3845bfff0
:END:

[[https://stackoverflow.com/questions/1511737/how-do-you-list-the-active-minor-modes-in-emacs][listing active minor modes]]

#+begin_src emacs-lisp
(defun xl-active-minor-modes ()
  "Return active minor modes in current buffer."
  (-select (-andfn #'boundp #'symbol-value) minor-mode-list))
#+end_src

****** backends-alist
:PROPERTIES:
:ID:       dac0a998-e1b1-424f-8c40-e1bc19843153
:END:

#+begin_src emacs-lisp
(defvar company:backend-alist
  '((text-mode :derived (company-dabbrev company-tempo company-ispell))
    (prog-mode :derived ((:separate company-capf company-tempo))))
  "An alist modes to company backends.")
#+end_src

****** initialize backends
:PROPERTIES:
:ID:       4e82e869-b144-44aa-bc19-bb58b8c5ff2a
:END:

When the user

#+begin_src emacs-lisp
(defhook! setup-company-backends (company-mode-hook)
  "Set `company-backends' for the current buffer."
  (alet (company:backends-for-mode major-mode)
    (xl-log "Set up %S backends: %S" major-mode it)
    (set (make-local-variable 'company-backends) it)))
#+end_src

****** get backends
:PROPERTIES:
:ID:       282a2c16-ae5f-4d81-acaa-8d60fb24e762
:END:

#+begin_src emacs-lisp
(cl-defun company:backends-for-mode (&optional (current-major-mode major-mode))
  "Return a list of company backends for major-mode."
  (loopy (with (active-minor-modes (xl-active-minor-modes)))
	 ((list (mode type backends) company:backend-alist)
	  (expr derived-p (and (eq type :derived) (derived-mode-p mode)))
	  (expr mm-enabled-p (or (eq current-major-mode mode)
				 (and (boundp mode) (symbol-value mode))))
	  (expr active-minor-mode-p (member mode active-minor-modes))
	  (cond ((and (eq type :only) (or mm-enabled-p active-minor-mode-p))
		 (return backends))
		((or (or derived-p (and (eq type :exact) mm-enabled-p))
		     active-minor-mode-p)
		 (append new-backends backends))))))
#+end_src

***** company-prescient
:PROPERTIES:
:ID:       be4bc19d-a25c-4e2d-9f12-5d2946bc9931
:END:

[[https://github.com/raxod502/prescient.el][company-prescient]] is the same as =prescient= but for =company= instead of =ivy=.

#+begin_src emacs-lisp
(use-package! company-prescient
  :hook company-mode-hook)
#+end_src

***** close company on escape
:PROPERTIES:
:ID: 750cc608-865e-4f69-a7b2-826fc66a7b71
:END:

#+begin_src emacs-lisp
(defhook! close-tooltip (xl-escape-hook)
  "Close company tooltip."
  (when (and (boundp 'company-mode) (eq company-mode t))
    (company-abort)
    t))
#+end_src

**** tempo
:PROPERTIES:
:ID:       36573b5e-f880-4079-840f-625c0b39704c
:END:

Tempo is a built-in snippet package. It's advantage over =yasnippet= is that it
can define a template using a lisp form as opposed to a string. This means it's
more hackable and more expressive.

Because yasnippets are strings it makes them less friendly for storing as a lisp
form. You still could, mind you, but essentally you'd fill your config with long
template strings. I never liked storing snippets in their own directory and as
many little files. One thing is that you have to deal with making sure the files
exist and that they're in the right path. Another thing is that you need to
manage snippet file loading because it's expensive to load all the snippets at
once if you have alot.

***** init
:PROPERTIES:
:ID:       535c8572-922c-48e1-829f-e0f005c26937
:END:

#+begin_src emacs-lisp
(use-feature! tempo
  :xl-config
  (after! company (set! company-tempo-expand t)))
#+end_src

***** add completing read to tempo
:PROPERTIES:
:ID:       ef9b06b1-826f-4030-950e-1884ce546654
:END:

Making sure that tempo can completing read.

****** tempo completing read
:PROPERTIES:
:ID:       2995030d-3848-42b8-8954-3d2366db641c
:END:

#+begin_src emacs-lisp
(defun tempo:completing-read (save-name &rest args)
  (let ((insertion (apply #'completing-read args)))
    (when save-name
      (tempo-save-named save-name insertion))
    (insert insertion)))
#+end_src

****** C keyword
:PROPERTIES:
:ID:       35e24bac-7b64-4e7f-b127-59c8e870aa56
:END:

[[helpfn:tempo-completing-read+][tempo-completing-read+]] already takes care of inserting the correct value.

#+begin_src emacs-lisp
(after! tempo
  (defun tempo:C-keyword (element)
    (when (eq (car-safe element) 'C)
      (let ((tempo-interactive t))
	(apply 'tempo:completing-read (cdr element)))
      ""))
  (push #'tempo:C-keyword tempo-user-elements))
#+end_src

***** tempo-snippets
:PROPERTIES:
:ID:       fa5d20be-f873-4b64-b218-33fc0a54bea6
:END:

=tempo-snippets= is a package that adds overlays.

****** tempo-snippets

#+begin_src emacs-lisp
(use-package! tempo-snippets)
#+end_src

****** use tab and backtab
:PROPERTIES:
:ID:       7205d26c-b01b-4619-a8d4-f374be0a2006
:END:

By default the tempo-snippet uses the standard =M-n= and =M-p=
bindings. However, I prefer the more mainstream =TAB= and =BACKTAB=.

#+begin_src emacs-lisp
(general-def '(insert normal) tempo-snippets-keymap
  "TAB" #'tempo-snippets-next-field
  [backtab] #'tempo-snippets-previous-field)

(general-def tempo-snippets-keymap
  "TAB" #'tempo-snippets-next-field
  [backtab] #'tempo-snippets-previous-field)
#+end_src

****** stop template after completion
:PROPERTIES:
:ID:       7b1d005f-f743-4ce1-88f0-dd68de5fd3ee
:END:

The overlays from =tempo-snippets= don't disappear after you reach the last
mark. I need to call.

****** handle user elements
:PROPERTIES:
:ID:       c2d4ce64-636b-4b7e-b023-df17c9f82ca4
:END:

=tempo-snippets= doesn't handle [[helpvar:tempo-user-elements][tempo-user-elements]]. =tempo-user-elements= are
custom additions to the tempo syntax. The writers of =tempo-snippets= actually
have [[][a FIXME line]] where they say they haven't done this yet. So if you're
like me and defined any, they will be ignored. The purpose of this headline is
to address this problem.

The relevant function here is [[helpfn:tempo-snippets-insert-template][tempo-snippets-insert-template]]. In this function
we can see that [[helpvar:tempo-user-elements][tempo-user-elements]] is let bound to a list of just one user
element, [[helpfn:tempo-snippets-insert-form][tempo-snippets-insert-form]]. The problem is that
=tempo-snippets-insert-form= doesn't know about the other tempo user elements. The
following code injects that knowledge into =tempo-snippets-insert-form= via an
around advice. Note that if later we add more user elements, we have to update
this advice.

#+begin_src emacs-lisp
(after! tempo
  (alet `(lambda (orig-fn &rest args)
	   (let ((tempo-user-elements ',tempo-user-elements)
		 (element (car args)))
	     (alet (or (tempo-is-user-element element) element)
	       (apply orig-fn (list it)))))
    (let ((name (xl-advice-name #'tempo-snippets-insert-form 'handle-user-elements)))
      (fset name it)
      (advice-add #'tempo-snippets-insert-form :around name))))
#+end_src

****** defining snippets

******* taglist name

#+begin_src emacs-lisp
(defun tempo:taglist-name (mode)
  "Return a variable name for taglist."
  (xl-symbol-intern 'tempo: mode '-taglist))
#+end_src

******* snippet macro
:PROPERTIES:
:ID:       33550f12-c282-48cb-8737-5f4240f51121
:END:

The purpose of this macro is to provide a "defun-like" syntax for defining tempo
snippets. Additionally, it should be a uniform way to configure snippets across
several different packages.

#+begin_src emacs-lisp
(defmacro defsnippet! (name args docstring &rest body)
  "Define a `tempo' snippet for MODE.
Define a snippet via `tempo-define-snippet'. Also create a taglist variable for
MODE if one does not exist."
  (declare (indent defun))
  (-let* ((name (symbol-name name))
	  (tag (-first-item args))
	  ((mode other-modes) (-list (-second-item args)))
	  (hook (xl-symbol-intern 'set-tempo-tags-for- mode))
	  (taglist (tempo:taglist-name mode)))
    `(progn
       (defvar ,taglist nil
	 ,(format "List of `tempo' tags for `%s'" mode))
       (unless (fboundp ',hook)
	 (defhook! ,hook (,(xl-emacs-hookify mode))
	   ,(format "Set taglist to be used for `%s'." mode)
	   (require 'tempo)
	   (tempo-use-tag-list ',taglist)))
       (after! tempo
	 (tempo-define-snippet ,name ,(car body) ,tag ,docstring ',taglist))
       ,@(when other-modes
	   '((defsnippet! ,name (,tag ,other-modes) ,docstring ,body))))))
#+end_src

*** Utility

**** elfeed
:PROPERTIES:
:ID:       45a52b98-9eba-45ab-9269-e8f930499e1c
:END:

=elfeed= is a newsfeed reader to Emacs. It's used over gnus because it is
generally faster and more "modern".

***** elfeed
:PROPERTIES:
:ID:       6aa4ece0-0b94-48b6-9a99-4b85cd1f7ccd
:END:

#+begin_src emacs-lisp
(use-package! elfeed
  :popup ("right" "elfeed" :newname "\\*elfeed.+")
  :commands elfeed
  :set
  (elfeed-db-directory           . (xl-data-dir "elfeed"))
  (elfeed-search-title-max-width . 100))
#+end_src

***** elfeed-score
:PROPERTIES:
:ID:       20d1a501-4a52-43b8-b124-be1f62265b73
:END:

#+begin_src emacs-lisp
(use-package! elfeed-score)
#+end_src

***** elfeed-org
:PROPERTIES:
:ID:       f646640b-6982-478f-bd1b-babd0ee00165
:END:

#+begin_src emacs-lisp
(use-package! elfeed-org
  ;; :init
  ;; (defvar elfeed-org:public-newsfeed-file (xl-org-dir "newsfeeds.org")
  ;;   "Newsfeeds.")
  ;; :set
  ;; (rmh-elfeed-org-files . (list elfeed-org:public-newsfeed-file))
  )
#+end_src

***** newsfeeds
:PROPERTIES:
:ID:       6d64a62c-a3f7-449c-833d-0738c1e5f28a
:END:

These are my newsfeed for =elfeed-org=.

****** [[https://planet.emacslife.com/][planet emacslife]]
:PROPERTIES:
:ID:       c042350e-6c21-4c98-82b1-332ef808cba5
:END:

**** chess
:PROPERTIES:
:ID:       1197be6f-a2ff-4cf1-8b78-02ebceb43317
:END:

#+begin_src emacs-lisp
(use-package! chess)
#+end_src

**** avy
:PROPERTIES:
:ID:       78064d92-2dde-4067-8a10-208ca6e88852
:END:

#+begin_src emacs-lisp
(use-package! avy
  :set
  (avy-style . 'pre)
  (avy-keys . (number-sequence ?a ?z)))
#+end_src

**** hide-mode-line
:PROPERTIES:
:ID:       e8f53422-9d24-4119-9b0f-9b6d1e10c1b0
:END:

#+begin_src emacs-lisp
(use-package! hide-mode-line
  :commands hide-mode-line-mode)
#+end_src

**** man
:PROPERTIES:
:ID:       3982b034-90e1-4961-90d9-224e913c0b8c
:END:

#+begin_src emacs-lisp
(use-feature! man
  :popup ("left" "man" :newname "\\*man.+"))
#+end_src

**** passwords and security
:PROPERTIES:
:ID:       7ca7587e-d94b-408b-8656-c6a09d6ee8b6
:END:

I build my =mbsyncrc= and my =msmtprc= via tangling.

***** pass
:PROPERTIES:
:ID:       6f3268a1-4606-435d-9bf4-05d1c54c28a9
:END:

#+begin_src emacs-lisp
(use-package! pass)
#+end_src

***** password-store
:PROPERTIES:
:ID:       3c57590c-1507-4369-b615-795965d4b182
:END:

#+begin_src emacs-lisp
(use-package! password-store)
#+end_src

***** email accounts
:PROPERTIES:
:ID:       3a3c6778-dc5d-45cf-87d1-1c6aacbbae46
:END:

Whatever emails I may use, I'll be adding their password in my password store so
why not use this as a way to get email information?

#+begin_src emacs-lisp
(defun password-store:email-accounts ()
  "Return a list of email accounts."
  (->> (expand-file-name "email/" (password-store-dir))
       (directory-files)
       (cddr)
       (mapcar (fn! (s-chop-suffix ".gpg" <>)))))
#+end_src

**** nameless
:PROPERTIES:
:ID:       695aeb73-89d3-47f8-bee8-2721111dd2bf
:END:

=nameless= is a package that truncates namespace prefixes that you specify
in. Shortening aliases allows for more concise, easier to read, and less
redundant code.

#+begin_src emacs-lisp
(use-package! nameless
  :hook emacs-lisp-mode-hook
  :set (nameless-private-prefix . t))
#+end_src

**** fortune-cookie
:PROPERTIES:
:ID:       8105dadd-4d4a-4f57-a5f9-5cae1b14ef3a
:END:

#+begin_src emacs-lisp
(use-package! fortune-cookie
  :commands fortune-cookie)
#+end_src

**** figlet
:PROPERTIES:
:ID:       b5be9427-a814-4a91-92ab-ad393375ec41
:END:

#+begin_src emacs-lisp
(use-package! figlet :commands figlet)
#+end_src

**** grugru
:PROPERTIES:
:ID:       9d96a611-355a-4b62-bb0e-18e9d4af92c9
:END:

#+begin_src emacs-lisp
(use-package! grugru)
#+end_src

**** ht
:PROPERTIES:
:ID:       56bb0ff4-6ad1-44b7-a9a4-54abf48ed253
:END:

=ht= is a package that tries to provide a consistently named API for dealing with
hash-tables.

#+begin_src emacs-lisp
(use-package! ht)
#+end_src

**** system-packages
:PROPERTIES:
:ID:       74bd0e5a-f6b0-48eb-a91e-3932eae23516
:END:

=system-packages= provides an api for installing system packages. This api strives
to abstract package installation on different operating systems. Unfortunately,
it does not include an interactive function that uses [[helpfn:completing-read][completing-read]] to list
packages

***** init
:PROPERTIES:
:ID:       08bf0487-2a57-483d-8d22-8253ebda6d9d
:END:

#+begin_src emacs-lisp
(use-package! system-packages
  :popup ("bottom" "system-packages" :newname "\\*system-packages")
  :set (system-packages-noconfirm . t))
#+end_src

***** use yay for arch
:PROPERTIES:
:ID:       2fc48e66-83f3-4e35-8b2c-ef9113cb9b45
:END:

If we're in arch and we have yay intalled, use that.

#+begin_src emacs-lisp
(after! system-packages
  (when (and (eq system-packages-package-manager 'pacman)
             (system-packages-package-installed-p "yay"))
    (alet (alist-get 'pacman system-packages-supported-package-managers)
      (push `(yay (default-sudo . nil)
                  ,@(-map (-lambda ((action . command))
			    (cons action (s-replace "pacman" "yay" command)))
                          (cdr it)))
            system-packages-supported-package-managers))
    (setq system-packages-package-manager 'yay)))
#+end_src

**** mmt
:PROPERTIES:
:ID:       a4377985-fe0e-4980-b839-08c334bde76c
:END:

=mmt= is a library of tools for writing macros. Specifically, it provides the
quintessential =once-only= and =with-gensyms= macros which are used to prevent
variable leaking.

#+begin_src emacs-lisp
(use-package! mmt)
#+end_src

**** ellocate
:PROPERTIES:
:ID:       e3590042-52fb-47ee-a5eb-a7860a3cdb17
:END:

=ellocate= is replacement for.

#+begin_src emacs-lisp
(use-package! ellocate
  :commands ellocate
  :set
  (ellocate-scan-dirs . `(("~/" . ,(xl-data-dir "ellocate"))))
  (ellocate-gc-mem    . most-positive-fixnum))
#+end_src

**** epa
:PROPERTIES:
:ID:       ad3f6134-4fa6-492e-93a6-b94235ecad3d
:END:

Setting these variables in coordination with [[id:58a65d49-cd9f-4b5d-86d7-d43209424cf3][my gpg-agent config]] lets me enter my
gpg passphrase via emacs.

#+begin_src emacs-lisp
(use-feature! epa-config
  :set
  (epg-gpg-program   . "gpg2")
  (epa-pinentry-mode . 'loopback))
#+end_src

**** pdf-tools
:PROPERTIES:
:ID:       63343f9d-6b19-43de-8302-d1344d571949
:END:

***** init
:PROPERTIES:
:ID: 163d8880-6a7d-4479-a7e4-e333e4f930da
:END:

#+begin_src emacs-lisp
(use-package! pdf-tools
  :magic ("%PDF" . pdf-view-mode)
  :init
  (push '("\\.[pP][dD][fF]\\'" . pdf-view-mode) auto-mode-alist))
#+end_src

***** epd-pdf-info-program
:PROPERTIES:
:ID:       25826061-a4a7-4f8a-8d3b-bdd5a80f70d0
:END:

#+begin_src emacs-lisp
(defadvice! build-pdf-into-program-maybe (:before pdf-view-mode)
  "Build the pdf-info program if it hasn't already been built."
  (unless (file-executable-p pdf-info-epdfinfo-program)
    (let ((wconf (current-window-configuration)))
      (pdf-tools-install)
      (message "Building epdfinfo, this will take a moment...")
      (-each (buffer-list)
        (fn! (with-current-buffer <buffer>
	       (when (eq major-mode 'pdf-view-mode)
		 (fundamental-mode)))))
      (while compilation-in-progress
        ;; Block until `pdf-tools-install' is done
        (redisplay)
        (sleep-for 1))
      ;; HACK If pdf-tools was loaded by you opening a pdf file, once
      ;;      `pdf-tools-install' completes, `pdf-view-mode' will throw an error
      ;;      because the compilation buffer is focused, not the pdf buffer.
      ;;      Therefore, it is imperative that the window config is restored.
      (when (file-executable-p pdf-info-epdfinfo-program)
        (set-window-configuration wconf)))))
#+end_src

***** bindings
:PROPERTIES:
:ID:       506c568c-0473-4db6-82b6-cc91174b0ce4
:END:

#+begin_src emacs-lisp
(use-package! pdf-tools
  :general
  (:states 'normal :keymaps 'pdf-view-mode-map
   "j" #'pdf-view-next-line-or-next-page
   "k" #'pdf-view-previous-line-or-previous-page
   "0" #'pdf-view-first-page
   "9" #'pdf-view-last-page
   "s" #'pdf-view-fit-width-to-window))
#+end_src

**** web browsing
:PROPERTIES:
:ID:       0be0a36f-67dc-4db5-8d0a-321d19bae08a
:END:

***** engine-mode
:PROPERTIES:
:ID:       d701f44f-85eb-4849-8f2d-15423eb41a02
:END:

****** init
:PROPERTIES:
:ID:       f5a2c47b-01df-4dcf-b012-b6311cf79683
:END:

#+begin_src emacs-lisp
(use-package! engine-mode)
#+end_src

****** different engines
:PROPERTIES:
:ID:       2f5c974e-b26e-4080-a9b3-acd6406ab118
:END:

This package essentially automates the creation of an interactive web searching
functions.

#+begin_src emacs-lisp
(use-package! engine-mode :xl-config
  (defengine amazon
    "http://www.amazon.com/s/ref=nb_sb_noss?url=search-alias%3Daps&field-keywords=%s")
  (defengine duckduckgo
    "https://duckduckgo.com/?q=%s")
  (defengine qwant
    "https://www.qwant.com/?q=%s")
  (defengine wikipedia
    "http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s"))
#+end_src

***** eww
:PROPERTIES:
:ID:       77d23774-7f42-45ee-90ec-5f28efddee65
:END:

****** ability to add new windows
:PROPERTIES:
:ID:       54dc52bb-f7e5-4a86-a306-aa42482cbd6d
:END:

=eww= doesn't create new buffers by default when you do a new search. Instead, it
replaces the existing buffer. I got this code snippet from [[https://stackoverflow.com/questions/28458784/emacs-and-eww-open-links-in-new-window][this-question]].

#+begin_src emacs-lisp
(defhook! create-new-buffer (eww-after-render-hook)
  (let* ((title  (plist-get eww-data :title))
	 (url    (plist-get eww-data :url))
	 (result (concat "*eww-" (or title
				     (if (string-match "://" url)
					 (substring url (match-beginning 0))
				       url)) "*")))
    (rename-buffer result t)))
#+end_src

***** w3m
:PROPERTIES:
:ID: e5e13423-bc70-49b0-969e-94897c798d54
:END:

[[http://w3m.sourceforge.net/][w3m]] is a text-based web browser. There are many other text-based browsers out
there, but =w3m= has the benefit of having comprehensive [[https://github.com/emacs-w3m/emacs-w3m][emacs interface]]. Why
use this when you can use the GUI browser? Well, using the Emacs interface I can
view an Emacs webpage as plain text, which means I can perform searches on it
with [[https://github.com/abo-abo/swiper.git][swiper]], or any other Emacs operation on it. Another advantage is that
because the w3m interface's backend is a terminal application, it will (I'm
guessing; no benchmarks made) typically be faster than browsers at rendering
plain text webpages. Of course, the main limitation is that w3m will typically
only display text based web pages well--not ones with lots of interactive
javascript code.

**** restart-emacs
:PROPERTIES:
:ID:       7412bc2f-0db1-44e9-8ea7-0dc595a04fca
:END:

#+begin_src emacs-lisp
(use-package! restart-emacs
  :commands restart-emacs)
#+end_src

**** multimedia
:PROPERTIES:
:ID:       5675cbbc-beb1-4470-a1d2-08f253bb4535
:END:

***** screenshots
:PROPERTIES:
:ID:       26d59d00-72e3-4b8c-9845-e5d9627cd4aa
:END:

This headline contains utilities for taking screenshots. As I see it,
screenshots are vital. I use maim to take screenshots because. I will note that
when I used [[][escr]] to take screenshots, those screenshots would not show
exwm windows. =escr= used [[][]]'s import.

****** screenshot name
:PROPERTIES:
:ID:       7210e8a8-7cbc-40ec-bd70-f8cfc6a32c56
:END:

The name for the screenshot.

******* xl-screenshot-path
:PROPERTIES:
:ID:       a6a75a8c-8d00-4f26-9df0-7f24af577e87
:END:

#+begin_src emacs-lisp
(defun xl-screenshot-path (name)
  "Return the full path where screenshot named NAME should go."
  (format "%s%s.png" (xl-screenshot-dir) name))
#+end_src

******* whether to prompt for screenshots
:PROPERTIES:
:ID:       1c280e62-2a1b-41f8-8ff9-039528652fcf
:END:

#+begin_src emacs-lisp
(defvar xl-prompt-for-screenshot-name-p t
  "If non-nil, prompt for screenshot name.")
#+end_src

******* name passed into prompt
:PROPERTIES:
:ID:       e8a21618-50f6-45ba-9a38-bff5c6d0a924
:END:

#+begin_src emacs-lisp
(defun xl-prompt-screenshot-name ()
  "Prompt for screenshot name."
  (when xl-prompt-for-screenshot-name-p
    (alet (read-string "Image Name: ")
      (unless (string-empty-p it)
	(xl-screenshot-path it)))))
#+end_src

******* default screenshot name
:PROPERTIES:
:ID:       58405f4f-e891-494e-afc7-a227415ec12b
:END:

#+begin_src emacs-lisp
(defun xl-default-screenshot-name ()
  "Return the default screenshot name."
  (alet (format-time-string "%Y-%m-%d-%H%M%S" (current-time))
    (xl-screenshot-path it)))
#+end_src

****** interactive screenshot functions
:PROPERTIES:
:ID:       27089aef-5937-4a7e-9af1-794fbeb835f2
:END:

When I first implemented these functions I prompted for the name first, but this
had the side-effect of displaying the prompt in the screenshot which is not what
I want. To avoid this, I decided to create the screenshot with the default name
and then prompt to rename the file afterwards.

******* fullscreen
:PROPERTIES:
:ID:       5cb29bb2-459a-4c84-9bf8-df179d2d2e8e
:END:

Take a s

#+begin_src emacs-lisp
(defun xl/take-fullscreen-screenshot ()
  "Take a fullscreen screenshot."
  (interactive)
  (let ((name (xl-default-screenshot-name)))
    (call-process "maim" nil nil nil "-u" name)
    (awhen (xl-prompt-screenshot-name)
      (rename-file name it t))))
#+end_src

******* window
:PROPERTIES:
:ID:       1a8724bb-24be-43fd-a3f6-3a41f7380fe8
:END:

#+begin_src emacs-lisp
(defun xl/take-window-screenshot ()
  "Take a screenshot of the current Emacs window."
  (interactive)
  (-let* ((name (xl-default-screenshot-name))
	  ((x y w h) (window-pixel-edges))
	  (geometry (format "%dx%d+%d+%d" w h x y)))
    (call-process "maim" nil nil nil "-u" "--geometry" geometry name)
    (awhen (xl-prompt-screenshot-name)
      (rename-file name it t))))
#+end_src

****** bindings
:PROPERTIES:
:ID:       52ae5883-6520-49d5-8d91-04c5c11e33c3
:END:

#+begin_src emacs-lisp
(define-leader-key! "as" (list :ignore nil :wk "screenshot"))

(define-leader-key!
  :infix "as"
  "s" (list :def #'xl/take-fullscreen-screenshot :wk "screenshot")
  "w" (list :def #'xl/take-window-screenshot     :wk "window")
  "f" (list :def #'xl/take-fullscreen-screenshot :wk "fullscreen"))
#+end_src

***** gif-screencast
:PROPERTIES:
:ID:       d8553132-c244-4319-bcc9-51905a296e34
:END:

#+begin_src emacs-lisp
(use-package! gif-screencast
  :commands gif-screencast-start-or-stop
  :set 
  (gif-screencast-program . "scrot")
  (gif-screencast-args . '("--quality" "25" "--focused"))
  (gif-screencast-cropping-program . "mogrify")
  (gif-screencast-optimize-program . "gifsicle")
  (gif-screencast-capture-format . "png"))

(define-key! "<f9>" 'gif-screencast-start-or-stop)
#+end_src

***** videos
:PROPERTIES:
:ID:       a8c1f6aa-25f6-47aa-a625-2c870f322a8c
:END:

****** ytel
:PROPERTIES:
:ID:       dea17f59-bebc-426e-ae7a-56f8d8971260
:END:

******* get video
:PROPERTIES:
:ID:       2a0e30c8-7a82-4bea-a79c-6d77eca6893a
:END:

***** emms
:PROPERTIES:
:ID:       6f3eaa69-bbbb-458e-bcad-1c121a3174e9
:END:

[[https://www.gnu.org/software/emms/][emms]] is a very complete music player.

****** emms
:PROPERTIES:
:ID: 5d28b703-a87f-47ca-b320-785e7589fea6
:END:

#+begin_src emacs-lisp
(use-package! emms
  :set
  (emms-source-file-directory-tree-function . 'emms-source-file-directory-tree-find)
  (emms-source-file-default-directory       . "~/Multimedia/music")
  (emms-playlist-buffer-name                . "*EMMS-PLAYLIST*")
  (emms-seek-seconds                        . 5)
  (emms-directory                           . (xl-data-dir "emms/"))
  (emms-player-list                         . '(emms-player-mpv)))
#+end_src

****** quitting
:PROPERTIES:
:ID: 545e6534-f289-4a89-838a-2a65ac74fe72
:END:

#+begin_src emacs-lisp
(defhook! quit-emms (kill-emacs-hook)
  "Shut down EMMS."
  (when emms-player-playing-p (emms-pause))
  (emms-stop))
#+end_src

**** outorg
:PROPERTIES:
:ID:       85570385-ff5b-47ba-907b-5ef3666288bb
:END:

***** dont add overlays for blank lines
:PROPERTIES:
:ID:       5f3f3e5a-3d57-44d2-9d61-9779d7b3051d
:END:

For some reason outorg adds overlays to the outorg buffers. They make it look
like the outorg buffer has less whitespace in between headlines than it should.

#+begin_src emacs-lisp
(defadvice! dont-add-overlays-for-blanks (:around outorg-wrap-source-in-block)
  "Adding overlays for blank lines."
  (cl-letf (((symbol-function #'overlay-put) #'ignore))
    (apply <orig-fn> <args>)))
#+end_src

**** testing
:PROPERTIES:
:ID:       49fe171f-d1b9-4b90-89ab-bddd2748bbd0
:END:

***** ert
:PROPERTIES:
:ID:       5fbf293e-84ae-4f47-bdcd-850ff552465a
:END:

#+begin_src emacs-lisp
(use-feature! ert
  :popup ("bottom" "ert" :newname "\\*ert\\*")
  :assume-yes ert-delete-all-tests)
#+end_src

***** ert-expectations
:PROPERTIES:
:ID:       3062b8a4-4261-49fc-9bdb-895ba75bbd19
:END:

#+begin_src emacs-lisp
(use-package! ert-expectations)

(autoload 'expect "ert-expectations" nil nil 'macro)
(autoload 'expectations "ert-expectations" nil nil 'macro)
#+end_src

***** el-mock
:PROPERTIES:
:ID:       46df66b0-5820-4550-aa99-c913d3022fe1
:END:

#+begin_src emacs-lisp
(use-package! el-mock)
#+end_src

**** shells & terminals
:PROPERTIES:
:ID:       214edd41-3ba1-4184-b484-fe7bb256d319
:END:

***** eshell
:PROPERTIES:
:ID: 5f04a252-2985-46b4-ab0b-eb4567de5dd9
:END:

[[info:eshell#Top][eshell]] is a built-in shell written entirely in elisp. This means that it's as
portable and customizable as emacs itself. It can run elisp functions as
commands. There's a good article about it in [[https://masteringemacs.org/article/complete-guide-mastering-eshell][mastering-emacs]]. Other articles I
have like about eshell: [[https://ambrevar.xyz/emacs-eshell/][ambrevar's eshell post]], [[http://www.howardism.org/Technical/Emacs/eshell-fun.html][Howard Abram's Post]].

****** eshell
:PROPERTIES:
:ID:       b2b473c8-78d7-4f41-9be3-842b6c5acdbb
:END:

#+begin_src emacs-lisp
(use-package! eshell
  :popup ("bottom" "eshell" :newname "\\*eshell\\*")
  :set
  (eshell-directory-name             . (xl-data-dir "eshell/"))
  (eshell-history-file-name          . (concat eshell-directory-name "history"))
  (eshell-banner-message             . "")
  (eshell-prefer-lisp-functions      . nil)
  (eshell-scroll-to-bottom-on-input  . 'all)
  (eshell-scroll-to-bottom-on-output . 'all)
  (eshell-buffer-shorthand           . t)
  (eshell-kill-processes-on-exit     . t)
  (eshell-hist-ignoredups            . t)
  (eshell-input-filter               . #'eshell-input-filter-initial-space)
  (eshell-glob-case-insensitive      . t)
  (eshell-error-if-no-glob           . t))
#+end_src

****** em-hist
:PROPERTIES:
:ID:       aaea54da-bd51-4a73-9dad-fe0b49d0f617
:END:

#+begin_src emacs-lisp
(use-feature! em-hist
  :idle-require t
  :set
  (eshell-history-file-name    . (concat eshell-directory-name "history"))
  (eshell-history-size         . 2000)
  (eshell-hist-ignoredups      . nil)
  (eshell-save-history-on-exit . t))
#+end_src

****** em-term
:PROPERTIES:
:ID:       d2afb853-15c3-4d3f-b8fa-a1075f84bbac
:END:

#+begin_src emacs-lisp
(use-feature! em-term
  :idle-require t
  :config
  (-each '("tmux" "htop" "bash" "zsh" "fish" "vim" "nvim" "ncmpcpp")
    (fn! (pushnew <command> eshell-visual-commands))))
#+end_src

****** em-alias
:PROPERTIES:
:ID:       694a8c17-8318-4222-b461-abfc1d8a78ea
:END:

#+begin_src emacs-lisp
(use-feature! em-alias
  :idle-require t)
#+end_src

****** eshell-z
:PROPERTIES:
:ID: 497798a0-7b62-4779-bf15-f67500528f03
:END:

#+begin_src emacs-lisp
(use-package! eshell-z
  :commands eshell-z
  :set
  (eshell-z-freq-dir-hash-table-file-name . (expand-file-name "z" eshell-directory-name)))
#+end_src

****** eshell-up
:PROPERTIES:
:ID: 478219b9-1c6f-4907-b428-a2dfe0f45e5c
:END:

This is an Emacs package for quickly navigating to a specific parent directory
in ~eshell~ without having to repeatedly typing ~cd ..~.

#+begin_src emacs-lisp
(use-package! eshell-up
  ;; :alias
  ;; (eshell/up . eshell-up)
  ;; (eshell/peek . eshell-up-peek)
  )
#+end_src


**** file browsing
:PROPERTIES:
:ID:       324ede5f-4606-40f2-a424-1cdf0c974853
:END:

***** all-the-icons-dired
:PROPERTIES:
:ID:       8e2fe483-5da1-47c7-8d80-a8e68b21fa39
:END:

#+begin_src emacs-lisp
(use-package! all-the-icons-dired
  :hook dired-mode-hook)
#+end_src

***** dired
:PROPERTIES:
:ID:       877b66c0-7952-4b37-839a-4a9aa5af164a
:END:

****** dired
:PROPERTIES:
:ID:       8a5f8bb6-dce2-4fac-b9c4-068e39f4cfcc
:END:

If you don't set [[helpvar:dired-recursive-deletes][dired-recursive-deletes]], emacs will prompt you every time you
try to delete a directory asking you whether you want to recursively delete its
contents. If you're actually permenently deleting it this is a good idea to
prevent accidental deletion, but I set [[helpvar:delete-by-moving-to-trash][delete-by-moving-to-trash]] to =t=. So
worst case I'll accidentally move a directory to the trash folder.

#+begin_src emacs-lisp
(use-feature! dired
  :set
  (dired-recursive-copies                      . 'always)
  (dired-recursive-deletes                     . 'always)
  (dired-hide-details-hide-symlink-targets     . nil)
  (dired-clean-confirm-killing-deleted-buffers . nil))
#+end_src

****** sort directories first
:PROPERTIES:
:ID: 4b6c0ed8-dbf2-4a65-adcc-1ce326eac465
:END:

#+begin_src emacs-lisp
(defhook! dired:sort-directories-first (dired-after-readin-hook)
  "List directories first in dired buffers."
  (save-excursion
    (let (buffer-read-only)
      (forward-line 2) ;; beyond dir. header
      (sort-regexp-fields t "^.*$" "[ ]*." (point) (point-max))))
  (and (featurep 'xemacs)
       (fboundp 'dired-insert-set-properties)
       (dired-insert-set-properties (point-min) (point-max)))
  (set-buffer-modified-p nil))
#+end_src

****** create non-existent directory
:PROPERTIES:
:ID: 66981d0c-fe40-4552-9f63-2c39a7d584d2
:END:

#+begin_src emacs-lisp
(defun dired:create-non-existent-directory-h ()
  "Automatically create missing directories when creating new file."
  (let ((parent-directory (file-name-directory buffer-file-name)))
    (when (and (not (file-exists-p parent-directory))
               (y-or-n-p (format "Directory `%s' does not exist! Create it?" parent-directory)))
      (make-directory parent-directory t))))

(after! dired
  (add-to-list 'find-file-not-found-functions 'dired:create-non-existent-directory-h nil #'eq))
#+end_src

***** ranger
:PROPERTIES:
:ID: 7504cab0-ddd9-4069-b6bb-9a5f3161cace
:END:

[[github:ralesi/ranger.el][ranger]] is a file browser built on top of dired that seeks to emulate [[github:ranger/ranger][a VIM
inspired file manager]] of also called =ranger=.

****** make sure that =;= uses =M-x=
:PROPERTIES:
:ID:       c63911ca-6d26-4d7c-be76-246639fb6c7a
:END:

#+begin_src emacs-lisp
(general-def 'normal ranger-mode-map
  ";" #'execute-extended-command
  "u" #'dired-unmark)
#+end_src

****** general bindings
:PROPERTIES:
:ID:       f69d31ab-1385-498c-9423-8fb3d5e4e94e
:END:

#+begin_src emacs-lisp
(general-def 'normal ranger-mode-map
  "A" #'dired-do-find-regexp
  "C" #'dired-do-copy
  "B" #'dired-do-byte-compile
  "D" #'dired-do-delete
  "H" #'dired-do-hardlink
  "L" #'dired-do-load
  "M" #'dired-do-chmod
  "O" #'dired-do-chown
  "P" #'dired-do-print
  "Q" #'dired-do-find-regexp-and-replace
  "R" #'dired-do-rename
  "S" #'dired-do-symlink
  "T" #'dired-do-touch
  "X" #'dired-do-shell-command
  "Z" #'dired-do-compress
  "c" #'dired-do-compress-to
  "!" #'dired-do-shell-command
  "&" #'dired-do-async-shell-command)
#+end_src

****** entry
:PROPERTIES:
:ID: 2edf3f72-726f-4b31-9ff0-20e5e7d251b1
:END:

#+begin_src emacs-lisp
(use-package! ranger
  :commands deer ranger
  :silence ranger-window-check
  :set
  (ranger-override-dired-mode . t)
  (ranger-cleanup-eagerly     . t)
  (ranger-cleanup-on-disable  . t)
  (ranger-omit-regexp         . "^.DS_Store$")
  (ranger-excluded-extensions .'("mkv" "iso" "mp4"))
  (ranger-deer-show-details   . nil)
  (ranger-max-preview-size    . 10)
  (ranger-modify-header       . t)
  (ranger-hide-cursor         . t)
  (ranger-dont-show-binary    . t))
#+end_src

****** refresh contents
:PROPERTIES:
:ID:       cef37397-53aa-47e1-a519-ef56a311ae30
:END:

Ranger doesn't refresh the buffer after stuff like moving and pasting has
happend. It results in a very jarring display.

#+begin_src emacs-lisp
(defadvice! refresh-contents (:after ranger-paste dired-do-rename)
  "Refresh contents."
  (when (eq major-mode 'ranger-mode)
    (ranger-refresh)))
#+end_src

****** toggle dotfiles
:PROPERTIES:
:ID: 5b9b190c-b4a6-4834-b8c9-def16b0457ac
:END:

There's this wierd intermidiate stage between =hidden= and =format= called =prefer= in
which only some files are hidden. That's wierd, so I get rid of it.

#+begin_src emacs-lisp
(defadvice! toggle-between-two-only (:override ranger-toggle-dotfiles)
  "Show/hide dot-files."
  (interactive)
  (setq ranger-show-hidden
        (cl-case ranger-show-hidden
          (hidden 'format)
          (format 'hidden)))
  (ranger-setup))
#+end_src

****** silence window check
:PROPERTIES:
:ID: e9d83b37-1257-4d78-ae5f-863c4e7198d1
:END:

#+begin_src emacs-lisp
(xl-silence-output #'ranger-window-check)
#+end_src

**** version control
:PROPERTIES:
:ID: d99a378c-449f-4a0d-9b88-dd77d5a41bb1
:END:

***** git-auto-commit-mode
:PROPERTIES:
:ID:       00a518e9-56ae-4c0b-b2cd-518fb4c5d201
:END:

To avoid losing information. You should commit often in git--like every 10
seconds or so. Obviously doing this manually on the command line (or even on
[[id:d6088ed3-417a-44e8-822b-ce4743f497d0][magit]]) every time is a pain. This package commits your changes every time
you save your file--which for me is all the time because I use [[id:bd455e73-4035-49b9-bbdf-3d59d4906c97][super-save]].

****** settings
:PROPERTIES:
:ID:       8a46cee4-624c-4440-8b99-c6b34d356a6b
:END:

#+begin_src emacs-lisp
(use-package! git-auto-commit-mode
  :commands git-auto-commit-mode
  :set
  (gac-automatically-push-p   . nil)
  (gac-ask-for-summary        . nil)
  (gac-default-message        . #'gac:commit-message)
  (gac-commit-additional-flag . "-S")
  (gac-silent-message-p       . t))
#+end_src

****** commit message
:PROPERTIES:
:ID:       3f0297a0-5929-4217-a109-545a2a010473
:END:

Committing often as I recommend will inevitably result with commits that are
many bits and pieces of a change. The idea is to then squash together all
related commits for the "polished" result. With this function I create "smart"
commit messages that take advantage of the org headline structure. This makes it
easy to go back and group commits which are related. Note that this function
fails when you have a change that spans across multiple headlines (such as the
replacement of a name throughout a document). This is something I plan to
address later.

#+begin_src emacs-lisp
(defun gac:commit-message (file)
  "Return the commit message for changes to FILE."
  (format "Update %s" (f-base file)))
#+end_src

***** magit
:PROPERTIES:
:ID:       d6088ed3-417a-44e8-822b-ce4743f497d0
:END:

****** transient
:PROPERTIES:
:ID: baf64a0f-f9fa-4700-bebf-d996018f894f
:END:

#+begin_src emacs-lisp
(setq transient-default-level 5)
(setq transient-levels-file (xl-data-dir "transient/levels"))
(setq transient-values-file (xl-data-dir "transient/values"))
(setq transient-history-file (xl-data-dir "transient/history"))
#+end_src

****** magit
:PROPERTIES:
:ID: c8a37b6a-46c7-406e-8793-1186f14407e0
:END:

#+begin_src emacs-lisp
(use-package! magit
  :idle-require f s with-editor git-commit package eieio lv transient
  :popup ("bottom" "magit" :newname "magit: ")
  ;; :hook (magit-popup-mode-hook . hide-mode-line-hook)
  :set
  (magit-completing-read-function . #'completing-read)
  (magit-diff-refine-hunk . t)
  (magit-auto-revert-mode . t))
#+end_src

****** quitting
:PROPERTIES:
:ID: 49088c3e-6d3a-41b7-aee4-f0bb34c71a0c
:END:

#+begin_src emacs-lisp
(defun magit/quit ()
  "Clean up magit buffers after quitting `magit-status'."
  (interactive)
  (let ((buffers (magit-mode-get-buffers)))
    (magit-restore-window-configuration)
    (mapc #'kill-buffer buffers)))
#+end_src

****** evil-magit
:PROPERTIES:
:ID:       a86e7a69-4e0a-41fd-aca7-66e514332e7f
:END:

#+begin_src emacs-lisp
(use-package! evil-magit
  :silence evil-magit-init
  :before-call magit-status
  :xl-config
  (evil-magit-init)
  :set
  (evil-magit-state . 'normal))
#+end_src

***** git-gutter+
:PROPERTIES:
:ID: 96f0c876-533c-4b1a-a4c1-7b6c9bf58c03
:END:

=git-gutter= indicates which parts of a file has been modified.

#+begin_src emacs-lisp
(use-package! git-gutter+)
(set! git-gutter+-git-executable (f-full "~/.yadm-project/yadm"))

;; I get an error that this function is not defined.
(defun git-commit-mode-font-lock-keywords () nil)
#+end_src

**** persistence
:PROPERTIES:
:ID:       c73a2fc2-5c43-4f99-9336-3bb2154852b7
:END:

Packages and features that involve saving to external files.

***** saveplace
:PROPERTIES:
:ID:       41cb3357-9b4b-4205-987d-ff72f9a35df3
:END:

This package takes you to the last point you were at when you visited a file.

****** recenter cursor
:PROPERTIES:
:ID:       dda57b64-b645-4eda-be54-9dda4af35404
:END:

#+begin_src emacs-lisp
(defadvice! recenter-on-load (:after-while save-place-find-file-hook)
  "Recenter on cursor when loading a saved place."
  (when buffer-file-name (ignore-errors (recenter))))
#+end_src

****** saveplace
:PROPERTIES:
:ID:       63b04114-bcb9-4a2e-ad45-be4db8d4a269
:END:

As its name suggests, =save-place= is a built-in package that stores the buffer
location you left off at in a particular buffer. When you visit that buffer
again, you are taken to the location you left off. This is very convenient.

#+begin_src emacs-lisp
(use-feature! saveplace
  :after-call after-find-file
  :xl-config
  (save-place-mode)
  :set
  (save-place-file . (concat XL-DATA-DIR "saveplace"))
  (save-place-limit . nil))
#+end_src

***** recentf
:PROPERTIES:
:ID: f26bedb3-a172-4543-afd0-4c47f5872d15
:END:

=recentf= is a built-in program that tracks the files you've opened recently
persistently. This is a great idea because these are the files you'll likely
revisit. In practice, I look at this list of files in addition to the buffers I
already have open using a [[id:f26bedb3-a172-4543-afd0-4c47f5872d15][completion-framework]]. Because of this I rarely
have to set out to look for a file with =dired=.

#+begin_src emacs-lisp
(use-feature! recentf
  :before-call find-file
  :idle-require easymenu tree-widget timer
  ;; :advice (#'recentf-save-list before #'recentf-cleanup)
  :silence recentf-mode recentf-cleanup
  :set
  (recentf-max-menu-items    . 0)
  (recentf-max-saved-items   . 700)
  (recentf-save-file         . (concat XL-DATA-DIR "recentf"))
  (recentf-auto-cleanup      . 'never)
  (recentf-filename-handlers . '(file-truename abbreviate-file-name))
  :xl-config
  (recentf-mode 1))
#+end_src

***** savehist
:PROPERTIES:
:ID:       dd4b9da7-e54d-4d62-bb70-aa8f7f4a016f
:END:

=savehist= is a built-in feature for saving the minibuffer-history to a file--the
[[helpvar:savehist][savehist]] file. Additionally, it provides the ability to save additional
variables which may or may not be related to minibuffer history. You add the
ones you want to save to [[helpvar:savehist-additional-variables][savehist-additional-variables]].

****** init
:PROPERTIES:
:ID:       54183df6-b4f5-4b01-9ddb-4054ef0583b0
:END:

#+begin_src emacs-lisp
(use-feature! savehist
  :idle-require custom
  :hook emacs-startup-hook
  :set
  (savehist-save-minibuffer-history . t)
  (savehist-additional-variables    . '(kill-ring search-ring regexp-search-ring))
  (savehist-autosave-interval       . nil)
  (savehist-file                    . (xl-data-dir "savehist")))
#+end_src

****** unpropertize kill ring
:PROPERTIES:
:ID:       da2b6c31-d251-48aa-a6ed-8f01b9fa0b8d
:END:

#+begin_src emacs-lisp
(defhook! unpropertize-kill-ring (kill-emacs-hook :append t)
  "Remove text properties from `kill-ring'."
  (alet (-map-when #'stringp #'substring-no-properties kill-ring)
    (setq kill-ring it)))
#+end_src

**** shrink-path
:PROPERTIES:
:ID: eef8ea28-4de2-44ab-a09d-26f58c0a75ac
:END:

#+begin_src emacs-lisp
(use-package! shrink-path :commands shrink-path)
#+end_src

**** email
:PROPERTIES:
:ID:       1586e613-85fe-40f5-8e77-9a4742e4c859
:END:

***** email directory
:PROPERTIES:
:ID:       86fc564e-76f3-4023-8228-f54fd5b3d52c
:END:

#+begin_src emacs-lisp
(defconst xl-email-dir (expand-file-name "~/.mail/"))
#+end_src

***** mu4e
:PROPERTIES:
:ID:       905ba1b5-bafc-4855-b772-fa750c294327
:END:

=mu4e= is the most popular Emacs email client--and for good reason. It's fast,
tag-based, and has great documentation. One annoying quirk for me is that unlike
all other Emacs packages it does not come uncoupled from the external program it
uses. What this means is that you need to tell Emacs where the mu4e =.el= files
are :pouting-cat:. It also means it's more difficult to incorporate it with the
contribution workflow that [[][straight.el]] encourages. I haven't figured out
how to automate this across multiple OSes.

This is annoying, but minor. =mu4e= itself is a great package.

****** load-path
:PROPERTIES:
:ID:       8b4ab179-11c6-429c-9c8d-9296dfb215dc
:END:

#+begin_src emacs-lisp
(alet (cl-find-if (fn! (string-match-p (rx (1+ alnum) "-" "mu") <path>))
		  (cddr (directory-files "/gnu/store/")))
  (add-to-list 'load-path it))
#+end_src

****** maildir
:PROPERTIES:
:ID:       49debca7-6ae7-40e4-9bd0-73c3bba40539
:END:

#+begin_src emacs-lisp
(defalias 'mu4e:mail-dir 'xl-mail-dir)
#+end_src

****** list email accounts
:PROPERTIES:
:ID:       0b7dcf44-b245-4ca8-9407-3d3c043e1d96
:END:

I'm storing all my email account passwords using =pass=. I can use the encrypted
files in my pass directory to determine what my email accounts are and, in turn,
how to automate this.

#+begin_src emacs-lisp
(defalias 'mu4e:mail-acounts 'password-store:email-accounts)
#+end_src

****** add mu4e to the load-path
:PROPERTIES:
:ID:       9dccb5e4-5d8e-4da6-99ae-9f8ed3bd8a5d
:END:

#+begin_src emacs-lisp
(use-package! mu4e
  :ensure nil
  ;; :load-path (-find (fn! (s-match)))
  )
#+end_src

****** mu4e-vars
:PROPERTIES:
:ID:       25cf40b9-901b-40f4-800f-3fa577ee22c3
:END:

=mu4e-var= contains many miscellaneous variables. Some highlights.

#+begin_src emacs-lisp
(use-package! mu4e-vars
  :ensure nil
  :set
  (mu4e-completing-read-function . #'completing-read)
  (mu4e-get-mail-command         . "mbsync -a")
  (mu4e-update-interval          . nil)
  (mu4e-context-policy           . 'pick-first)
  (mu4e-use-fancy-chars          . (display-graphic-p))
  (mu4e-org-support              . t)
  (mu4e-index-cleanup            . t)
  (mu4e-split-view               . 'vertical)
  (mu4e-index-lazy-check         . nil)
  (mu4e-hide-index-messages      . t)
  (mu4e-confirm-quit             . nil))
#+end_src

******* mu4e
:PROPERTIES:
:ID: 565eff90-8626-4ec8-a576-4ff3dfb307ae
:END:

#+begin_src emacs-lisp
(setq mu4e-html2text-command
      (if (executable-find "w3m") "w3m -dump -T text/html" #'mu4e-shr2text))
#+end_src

****** mu4e-views
:PROPERTIES:
:ID:       5ebeddaa-94ae-4acc-9659-5aae8cb4a2f0
:END:

#+begin_src emacs-lisp
(use-package! mu4e-view
  :ensure nil
  :set
  (mu4e-view-show-images     . t)
  (mu4e-view-image-max-width . 800)
  (mu4e-view-show-addresses  . t)
  (mu4e-date-format          . "%c"))
#+end_src

****** mu4e-compose
:PROPERTIES:
:ID:       cd07286d-2a94-4953-99bf-8e06b3edcf15
:END:

#+begin_src emacs-lisp
(use-package! mu4e-compose
  :ensure nil
  :set
  (mu4e-compose-context-policy . 'ask-if-none))
#+end_src

****** mu4e-drafts
:PROPERTIES:
:ID:       5de3eca7-968b-4228-a1d9-ca872f18f58b
:END:

#+begin_src emacs-lisp
(use-package! mu4e-drafts
  :ensure nil
  :set
  (mu4e-compose-signature-auto-include . t)
  (mu4e-compose-format-flowed          . t))
#+end_src

****** mu4e-headers
:PROPERTIES:
:ID:       8bc93633-f3a0-494d-ae61-c05f6490cd87
:HEADER-ARGS: :tangle no
:END:

These are custom icons used to spice up the =mu4e= display.

#+begin_src emacs-lisp
(use-package! mu4e-headers
  :ensure nil
  :set
  (mu4e-headers-auto-update    . t)
  (mu4e-headers-draft-mark     . (cons "D" (all-the-icons-faicon "pencil")))
  (mu4e-headers-flagged-mark   . (cons "F" (all-the-icons-faicon "flag")))
  (mu4e-headers-new-mark       . (cons "N" (all-the-icons-material "fiber_new")))
  (mu4e-headers-passed-mark    . (cons "P" (all-the-icons-faicon "arrow-right")))
  (mu4e-headers-seen-mark      . (cons "S" (all-the-icons-faicon "eye")))
  (mu4e-headers-attach-mark    . (cons "a" (all-the-icons-material "attach_file")))
  (mu4e-headers-replied-mark   . (cons "R" (all-the-icons-faicon "reply")))
  (mu4e-headers-unread-mark    . (cons "u" (all-the-icons-faicon "eye-slash")))
  (mu4e-headers-encrypted-mark . (cons "x" (all-the-icons-octicon "lock")))
  (mu4e-headers-signed-mark    . (cons "s" (all-the-icons-faicon "certificate")))
  (mu4e-headers-trash-mark     . (cons "T" (all-the-icons-faicon "trash"))))
#+end_src

****** mu4e-org
:PROPERTIES:
:ID:       eaa1577b-bcb9-4f6e-9927-8c6d8042dda2
:END:

Mu4e's org integration lets you write emails in org mode and convert it to html
before sending--very interesting indeed :grinning:. I have yet to explore this feature but
it is definitely on my list of things to try out.

#+begin_src emacs-lisp
(use-package! mu4e-org
  :ensure nil
  :hook (mu4e-compose-mode-hook . org-mu4e-compose-org-mode)
  :set
  (mu4e-org-link-query-in-headers-mode . nil)
  (mu4e-org-convert-to-html            . t))
#+end_src

******* hook
:PROPERTIES:
:ID:       fcdbaa17-20c6-4322-baed-27df5a0ad9a2
:END:

Only render to html once. If the first send fails for whatever reason,
org-mu4e would do so each time you try again.

#+begin_src emacs-lisp
(defhook! org-mu4e-render-html-only-once (message-send-hook)
  (setq-local org-mu4e-convert-to-html nil))
#+end_src

****** initializing mu4e
:PROPERTIES:
:ID:       93cffd11-a812-4cda-b7dd-a06f70367afe
:END:

This headline attempts to automate the initialization of mu4e. The goal is for
me to do as little as possible by (by which I mean nothing :joy:) to get a
working mu4e setup. In other words, after I initialize my dotfiles and install
all my system packages, I want mu4e to /just work/. There should be no prompts
asking me to run anything or do anything at all.

The idea is to do preliminary things before the main entry point--the function
[[helpfn:mu4e][mu4e]]--is called.

******* mu4e database location
:PROPERTIES:
:ID:       fe8f10c1-3035-4a97-9657-98236f50d0a8
:END:

This is the place where the mu4e database is stored. The existence of this
database is used to determine whether we'll run =mu init= or not.

#+begin_src emacs-lisp
(defvar mu4e:mu-database-path (expand-file-name "~/.cache/mu/xapian")
  "Path where mu database should go.")
#+end_src

******* init mu4e database
:PROPERTIES:
:ID:       4d107050-db05-4d7e-ae44-4bf356a44fd0
:END:

The first time you run =mu= it needs to [initialize it's database]. This is done
with the command =mu init --maildir=~/Maildir=.

#+begin_src emacs-lisp
(defadvice! init-database-maybe (:before mu4e)
  "Initialize the mu4e database if it does not exist."
  (unless (file-exists-p mu4e:mu-database-path)
    (apply #'call-process
	   (append (list "mu" nil nil nil)
		   (list (format "--maildir=%s" (mu4e:mail-dir)))
		   (mapcar (fn! (format "--my-address=%s" <account>))
			   (mu4e:mail-accounts))))))
#+end_src

******* ensuring email directories
:PROPERTIES:
:ID:       704b7049-fac5-4fa7-b710-1bbfe50cea5f
:END:

Make sure mail directories exist. =mbsync= will fail if they don't.

#+begin_src emacs-lisp
(defadvice! ensure-mail-dirs (:before mu4e)
  "Create mail directories if they don't exist."
  (mapc (fn! (mkdir <dir> t))
	(mapcar #'mu4e:mail-dir (mu4e:mail-accounts))))
#+end_src

******* contexts
:PROPERTIES:
:ID:       0e580010-d5b2-4708-a7dc-c586908409b5
:END:

[[info:mu4e#What are contexts][Contexts]]. This headline attempts to automate context creation. Context are
probably the hardest part of setting up =mu4e= for elisp. [[https://jherrlin.github.io/posts/emacs-mu4e/][this article]]. If you
don't make contexts, =mu4e= will be confused and think that.

******** default enter and exit
:PROPERTIES:
:ID:       f2e2148b-dcab-4503-a1b1-75e48e35018f
:END:

Contexts provide the ability to specify an enter and exist function for each
context. Right now I haven't had any special idea in mind for what the enter and
leave function =mu4e= provides should do switching to a new context. So for now
all I'll do is log the entering/leaving of a context for debugging purposes.

#+begin_src emacs-lisp
(defun mu4e-context:default-switch-fn (mail-address &optional leave)
  "Return a function that enters the context of MAIL-ADDRESS."
  (let* ((to (if leave 'leave 'enter))
	 (name (xl-symbol-intern 'mu4e-context: mail-address '- to '-func))
	 (message (format "%s %s context." to mail-address))
	 (fn `(lambda () (xl-log ,message))))
    (fset name fn)
    name))
#+end_src

******** default match fn
:PROPERTIES:
:ID:       41ddf901-0ae9-4b00-bc06-b1b7b49ec8f2
:END:

The match fn take a =message= object. This is for dynamically setting the
context based on what message you're dealing with. Right now, I don't have any
special rules. The rule that I set basically uses the.

#+begin_src emacs-lisp
(defun mu4e-context:default-match-func (mail-address)
  "Return a default matcher for MAIL-ADDRESS."
  (fset (xl-symbol-intern 'mu4e-context: mail-address '-match-func)
	`(lambda (msg)
	   (when msg
	     (-any-p (fn! (mu4e-message-contact-field-matches msg <field> ,mail-address))
		     (list :to :from :cc :bcc))))))
#+end_src

******** default vars
:PROPERTIES:
:ID:       d8892b2c-7056-4d92-819b-8cb4d8c2eeb1
:END:

These are the default.

#+begin_src emacs-lisp
(defun mu4e-context:default-vars (mail-address)
  "Return default variables for MAIL-ADDRESS."
  (loopy ((list (key . fn) mu4e-context:default-var-alist)
	  (expr value (funcall fn mail-address))
	  (collect (cons key value)))))
#+end_src

******** get default values
:PROPERTIES:
:ID:       e52c3820-6ee3-4959-87fa-acf60a7ed0df
:END:

#+begin_src emacs-lisp
(defun mu4e-context:default-values ()
  "Return a list of default values for args."
  (loopy ((list key '(:enter-func :leave-func :match-fn :vars))
	  (expr keyname (xl-keyword-name key))
	  (expr fn (xl-symbol-intern 'mu4e-context: keyname))
	  (expr value (funcall fn mail-address))
	  (append (list key value)))))
#+end_src

******** make a context
:PROPERTIES:
:ID:       4e45264d-e7cc-43f7-854b-8b22d4d4151e
:END:

Create a context.

#+begin_src emacs-lisp
(defun mu4e-context:make-context (mail-address)
  "Create a new context with default values."
  (apply #'make-mu4e-context :name mail-address (mu4e:default-values mail-address)))
#+end_src

******** add a context
:PROPERTIES:
:ID:       c488a02f-743a-492c-9775-5c8216f0b2b0
:END:

#+begin_src emacs-lisp
(defun mu4e-context:add-context (mail-address)
  "Create and add context."
  (push (mu4e-context:make-context mail-address) mu4e-contexts))
#+end_src

******** init contexts
:PROPERTIES:
:ID:       e74512a7-1d1f-4241-b245-5863e7730398
:END:

After mu4e is loaded, setup contexts. In the future, perhaps add this as an
advice before [[helpfn:mu4e][mu4e]] so that I can check if the right emails are set up every
time. This could be useful if I add an email and don't want to restart Emacs.

#+begin_src emacs-lisp
(defhook! init-contexts (mu4e-after-load-hook)
  "Define a context for each email account."
  (-each (mu4e:mail-accounts) #'mu4e-context:add-context))
#+end_src

*** Window Management
:PROPERTIES:
:ID:       f8f186bd-a701-4bd4-a249-86ec4faff83b
:END:

**** workspaces
:PROPERTIES:
:ID:       c979c631-4098-4204-b067-82f58b5b9ebe
:END:

***** tab-bar-mode
:PROPERTIES:
:ID:       0a72fe9a-1948-4022-a300-18a4881da382
:END:

****** settings
:PROPERTIES:
:ID:       bb63f5b2-cc45-454b-a032-be248f801636
:END:

#+begin_src emacs-lisp
(use-feature! tab-bar-mode
  :hook (tab-bar-mode-hook . tab-bar-history-mode)
  :set
  (tab-bar-new-tab-choice . "*scratch*")
  (tab-bar-history-limit  . 25)
  (tab-bar-tab-hints      . nil)
  (tab-bar-show           . nil))
#+end_src

****** dont actually display the tabs
:PROPERTIES:
:ID:       e4cee146-f6ac-47f1-9e98-f209ae9f9bec
:END:

I want the tabs to exist as a concept, but (ironically) I don't actually want
them displayed.

#+begin_src emacs-lisp
(defadvice! inhibit-tab-display (:after tab-bar-mode make-frame)
  "Inhibit the display of tags in tab-bar-mode."
  (-each (frame-list)
    (fn! (set-frame-parameter <frame> 'tab-bar-lines 0))))
#+end_src

***** desktop
:PROPERTIES:
:ID:       902a11fc-b9aa-4875-ba92-8d2561a12a50
:END:

=desktop= is a built-in emacs package for saving window configuration setup.

****** some settings
:PROPERTIES:
:ID:       e4c30275-db62-4e6d-890c-6199b0594fd8
:END:

#+begin_src emacs-lisp
(use-feature! desktop
  :set
  (desktop-save                 . t)
  (desktop-dirname              . XL-DATA-DIR)
  (desktop-auto-save-timeout    . auto-save-timeout)
  (desktop-base-file-name       . "emacs.desktop")
  (desktop-base-lock-name       . "emacs.desktop.lock")
  (desktop-path                 . (list XL-DATA-DIR))
  (desktop-missing-file-warning . nil))
#+end_src

****** allowing desktops to go in one directory
:PROPERTIES:
:ID:       22b0be3a-ef36-47d4-8684-602f3a8c8462
:END:

These functions are all based on the =desktop+= functions. The main thing it
does is provide a directory where desktop files can be placed. This should
really have been done by =desktop.el= but oh well.

******* base directory
:PROPERTIES:
:ID:       e1ce2616-2280-435d-85c4-8d71c30c6a75
:END:

#+begin_src emacs-lisp
(defvar desktop:base-dir (concat XL-DATA-DIR "desktops/")
  "Directory where desktops should go.")
#+end_src

******* generate the base directory
:PROPERTIES:
:ID:       fa173f38-2888-465a-8de4-282233322363
:END:

#+begin_src emacs-lisp
(defun desktop:dirname (name)
  "Return the path where desktop named NAME should go."
  (require 'f)
  (f-join desktop:base-dir name))
#+end_src

******* ensure the base directory
:PROPERTIES:
:ID:       3662ceaa-aed9-4dbc-bea9-7e1878237c87
:END:

#+begin_src emacs-lisp
(defhook! ensure-desktop-directory (desktop-mode-hook)
  "Make `desktop:base-dir' if it does not exist."
  (mkdir desktop:base-dir t))
#+end_src

******* desktop names
:PROPERTIES:
:ID:       5286a22f-dc93-4e32-8a35-3bfbdfda8668
:END:

#+begin_src emacs-lisp
(defun desktop:list ()
  "Return a list of the names of all desktops."
  (-difference (directory-files desktop:base-dir)
	       (list ".." ".")))
#+end_src

******* create a desktop
:PROPERTIES:
:ID:       331367bb-a1eb-414f-89ef-386ba6fc1e60
:END:

#+begin_src emacs-lisp
(defun desktop:create-desktop (name)
  "Create a new desktop named NAME."
  (let ((desktop-dirname (desktop:dirname name)))
    (desktop-kill)
    (make-directory desktop-dirname 'parents)
    (desktop-save desktop-dirname)))
#+end_src

******* load an existing desktop
:PROPERTIES:
:ID:       691dd9bf-b207-4885-9f7c-b8791d972dc1
:END:

#+begin_src emacs-lisp
(defun desktop:load-desktop (name)
  (desktop-change-dir (desktop:dirname name)))
#+end_src

****** create desktop in new tab
:PROPERTIES:
:ID:       4bbb0f3a-bc51-4552-b91f-8404ab19cdd8
:END:

This is an integration with desktop and tab mode.

#+begin_src emacs-lisp
(defun desktop/create-desktop-in-new-tab (name)
  "Create desktop named NAME in new tab.
The tab's new name is the same as the desktop name."
  (interactive
   (list (completing-read "Create desktop:" (desktop:list))))
  (tab-bar-new-tab)
  (tab-bar-rename-tab name)
  (desktop:create-desktop name))
#+end_src

****** load desktop in a new tab
:PROPERTIES:
:ID:       391c0817-bb2f-4334-b320-f039ab23cfb7
:END:

#+begin_src emacs-lisp
(defun desktop/load-desktop-in-new-tab (name)
  "Create desktop named NAME in new tab.
The tab's new name is the same as the desktop name."
  (interactive
   (list (completing-read "Load desktop: " (desktop:list))))
  (tab-bar-new-tab)
  (tab-bar-rename-tab name)
  (desktop:load-desktop name))
#+end_src

****** desktop restore functions
:PROPERTIES:
:ID:       0f82a1dc-d28e-4875-a622-e6116c0d3843
:END:

******* helpful-buffers
:PROPERTIES:
:ID:       f7d3a8ce-7115-47d6-b0ac-2d078741a49a
:END:

#+begin_src emacs-lisp
(defun desktop:restore-helpful-buffer ()
  "Restore helpful buffer.")
#+end_src

***** workgroups2
:PROPERTIES:
:ID:       b5452102-a8fb-409f-8c36-35d404b5a5a6
:END:

There is a need to save buffers and window configurations in their own groups.
Often we'll have a group of buffers we've setup to work on a project or task and
suddenly, in the middle of that task we'll want to work on another task. It's
inconvenient to get rid of the window configuration we've set up just to have to
come back to it and set it up again. This is what workspaces, also called
workgroups, are for. You can save the window configuration you're using and
switch to a new one.

Workgroup provides a. One notable advantage of workgroups is that it does not
use emacs's built-in serialization of window configs. Usually, it is better to
use something that's built-in. However, emacs's serialization has the drawback
that it's not a lisp object; implying that it is not.

****** workgroups2
:PROPERTIES:
:ID:       890c8e5b-524d-44b6-b90e-c830436b9da8
:END:

#+begin_src emacs-lisp
(use-package! workgroups2
  :commands wg-switch-workgroup
  :ignore wg-change-modeline
  :silence wg-create-workgroup wg-switch-workgroup
  :set
  (wg-emacs-exit-save-behavior           . 'save)
  (wg-workgroups-mode-exit-save-behavior . 'save)
  (wg-flag-modified                      . nil)
  (wg-mode-line-display-on               . nil)
  (wg-load-last-workgroup                . nil)
  (wg-open-this-wg                       . nil)
  (wg-control-frames                     . nil)
  (wg-session-load-on-start              . nil)
  (wg-flag-modified                      . nil)
  (wg-session-file                       . (concat XL-DATA-DIR "wg-session")))
#+end_src

**** zoom-window
:PROPERTIES:
:ID:       d506fde5-d1bc-4807-a1d0-a8ed5c33def2
:END:

This package provides a command that temporarily makes a window occupy full
screen. And then reverts the window configuration to what it was again
afterwards.

#+begin_src emacs-lisp
(use-package! zoom-window
  :commands zoom-window)
#+end_src

**** exwm
:PROPERTIES:
:ID: dbb69880-2180-4ecc-897d-78ff72a6358b
:END:

[[https://github.com/ch11ng/exwm][EXWM]] (Emacs X-Window Manager) is a full-featured window manager in Emacs.  There
are benefits and drawbacks to making emacs your window manager. One benefit is
that you get a super consistent window management experience. One drawback is
that if Emacs hangs or crashes you need to restart your computer.

***** init
:PROPERTIES:
:ID:       7b83cab0-d599-46c4-b20c-19ff33345ae3
:END:

#+begin_src emacs-lisp
(use-package! exwm
  :os linux
  :before-call browse-url)
#+end_src

***** trigger exwm on =browse-url=
:PROPERTIES:
:ID:       581b8529-00a0-4935-9363-60dba9dbe5f4
:END:

=exwm= provides an option [[helpvar:exwm-replace][exwm-replace]] to deal with the case of an existing
window manager when exwm is initializing itself. There are three
ways. You could replace it with exwm without asking, ask whether to
replace it, or abort the initialization of exwm.

#+begin_src emacs-lisp
(defadvice! init-exwm-maybe (:before browse-url)
  "Try to initialize exwm.
If it's not possible, abort initialization gracefully."
  (require 'exwm)
  ;; Try to enable exwm.
  (let ((exwm-replace nil))
    (if (ignore-errors (exwm-init))
	;; Enable the clipboard.
	(progn (require 'exwm-systemtray)
	       (exwm-systemtray-enable))
      (xl-log "Another window manager is present (or something went wrong)."))))
#+end_src

***** exwm-evil-firefox
:PROPERTIES:
:ID:       e5463b7a-9727-43b1-aa20-831a3617308f
:END:

This package lets you use exwm to control firefox and give it evil bindings. You
can tell exwm to send "fake" keys to firefox corresponding to the key you've
pressed. The only thing I find missing here is a way to quickly select links in
an. One caveat is that mouse clicks only work in insert mode.

#+begin_src emacs-lisp
(use-package! exwm-firefox-evil
  :hook (exwm-manage-finished-hook . exwm-firefox-evil-activate-if-firefox)
  :before-call browse-url-firefox)
#+end_src

***** org capture from an exwm buffer
:PROPERTIES:
:ID:       5428bdc1-c075-4387-b3ab-080d372c478f
:END:

A common dream among many Org users is to integrate [[info:org#Capture][org-capture]] into their browser.
Indeed, the browser by nature would be a place you'd want to capture from a lot.
However, since graphical browsers are not in emacs the main way to do this was
via a hacky and difficult to set up [[https://orgmode.org/worg/org-contrib/org-protocol.html][org-protocol]].

https://www.reddit.com/r/emacs/comments/f6zzux/capturing_website_url_with_orgcapture_and_exwm/

****** exwm title
:PROPERTIES:
:ID:       ce78d409-e635-4d94-b20e-38c2034ab5e8
:END:

#+begin_src emacs-lisp
(defun exwm::title-info (title)
  "Return the webpage and the program."
  (-let [(_ webpage program) (s-match "\\([^z-a]+\\) - \\([^z-a]+\\)\\'" title)]
    (list webpage program)))
#+end_src

****** download webpage
:PROPERTIES:
:ID:       3798402c-cd8b-43e2-aec5-f54736aafdd4
:END:

#+begin_src emacs-lisp
(defun xl-download-webpage (url)
  "Download webpage at url to webpage folder."
  (call-process "weasyprint" nil nil nil url))
#+end_src

****** replacement for fake id
:PROPERTIES:
:ID:       4f0436c4-bc37-49b0-a8a3-894e212d4d13
:END:

#+begin_src emacs-lisp
(defun exwm-input::fake-key-to-id (event id)
  "Fake a key event equivalent to Emacs event EVENT and send it
 to program with x window ID."
  (let* ((keysym (xcb:keysyms:event->keysym exwm--connection event))
         keycode)
    (when (= 0 (car keysym))
      (user-error "[EXWM] Invalid key: %s" (single-key-description event)))
    (setq keycode (xcb:keysyms:keysym->keycode exwm--connection
					       (car keysym)))
    (when (/= 0 keycode)
      (dolist (class '(xcb:KeyPress xcb:KeyRelease))
        (xcb:+request exwm--connection
	    (make-instance
	     'xcb:SendEvent
	     :propagate 0 :destination id
	     :event-mask xcb:EventMask:NoEvent
	     :event
	     (xcb:marshal
	      (make-instance
	       class
	       :detail keycode :time xcb:Time:CurrentTime
	       :root exwm--root :event id :child 0 :root-x 0 :root-y 0
	       :event-x 0 :event-y 0 :state (cdr keysym) :same-screen 0)
	      exwm--connection)))))
    (xcb:flush exwm--connection)))
#+end_src

****** url from firefox
:PROPERTIES:
:ID:       f407cc8c-0bb9-47fe-adeb-4e9d27b5c5b7
:END:

Emacs simulates a keypress to firefox--specifically the keypresses to select the
current url and to add it to the kill ring.

#+begin_src emacs-lisp
(defun exwm::firefox-url ()
  "Save the current firefox url to kill ring."
  ;; We get the xwindow id of the buffer named Firefox
  (let ((fid (exwm--buffer->id (current-buffer))))
    ;; Send c-l to select url
    (exwm-input::fake-key-to-id 'C-l fid)
    ;; We sleep to avoid race conditions.
    (sleep-for 0 300)
    ;; Copy url to kill ring (note: this is not affected by simulation keys)
    (exwm-input::fake-key-to-id 'C-c fid)
    (sleep-for 0 300)
    ;; try to set the state back
    (exwm-input::fake-key-to-id 'escape fid)
    (current-kill 0)))
#+end_src

****** url from qutebrowser
:PROPERTIES:
:ID:       822cbb61-60b4-445e-9756-4bf797500375
:END:

#+begin_src emacs-lisp
(defun exwm::qutebrowser-url ()
  (interactive)
  (let ((fid (exwm--buffer->id (current-buffer))))
    (sleep-for 0 300)
    ;; if in insert state exit it.
    (exwm-input::fake-key-to-id 'escape fid)
    (sleep-for 0 300)
    (exwm-input::fake-key-to-id 'y fid)
    (sleep-for 0 300)
    (exwm-input::fake-key-to-id 'y fid)
    (sleep-for 0 300)
    (aprog1 (current-kill 0)
      (xl-log "Copied %S to the kill ring." it))))
#+end_src

***** appropriate name for exwm buffers
:PROPERTIES:
:ID: b9712cdc-2cf9-482f-8f62-b2e4f56b9c97
:END:

By default each exwm buffer is named =*EXWM*=. We want them to have
a more descriptive name.

#+begin_src emacs-lisp
(defhook! rename-buffer-to-title (exwm-update-title-hook)
  "Rename buffer to title."
  (exwm-workspace-rename-buffer exwm-title))
#+end_src

***** char mode
:PROPERTIES:
:ID: 790c7f6e-6f66-4074-b51a-56b491bcde99
:END:

=EXWM= has two modes, =line-mode= and =char-mode=. It's best for Emacs and Next to
start with =char-mode= because they both have keys that are important for their
use (like =M-x=) which conflict with Emacs (the instance that's managing the
windows).

****** list of applications
:PROPERTIES:
:ID:       d1bf0601-a995-48f7-ab80-86755ba9269a
:END:

#+begin_src emacs-lisp
(defvar exwm:char-mode-apps (list "emacs" "next" "nyxt" "qutebrowser")
  "List of applications to exwm should start in char-mode.")
#+end_src

****** to start in char mode
:PROPERTIES:
:ID: 790c7f6e-6f66-4074-b51a-56b491bcde99
:END:

#+begin_src emacs-lisp
(defhook! start-in-char-mode (exwm-manage-finish-hook)
  "Start a program in char-mode if it's in `exwm:char-mode-apps'."
  (when (--any-p (string-prefix-p it exwm-instance-name) exwm:char-mode-apps)
    (exwm-input-release-keyboard (exwm--buffer->id (window-buffer)))))
#+end_src

***** exwm-edit
:PROPERTIES:
:ID: 1a167827-b791-4a69-a90e-c2d30bd83abb
:END:

The dream is to do all text editing in Emacs. This package is a big step towards
achieving that dream. =exwm-edit= allows the user to edit text fields in
external packages with an emacs buffer. It acts a lot like =org-edit-src-code=:
it copies any text in the text field to a buffer, you edit the buffer, then
press a binding to insert the buffer text into the text field. It goes without
saying that when the text is in an emacs buffer, you can use the full-force of
Emacs's text editing capabilities on it.

Concerning the loading of exwm-edit. Ideally, I should load it after
certain applications where I'd use it need to be loaded.

#+begin_src emacs-lisp
(use-package! exwm-edit
  :commands exwm-edit
  :init
  (after! exwm
    (funcall (get 'exwm-input-global-keys 'custom-set)
	     'exwm-input-global-keys
	     `((,(kbd "C-'") . exwm-edit)))))
#+end_src

***** keybindings
:PROPERTIES:
:ID: 293bc7c5-1320-4f3f-af2b-198d56694f71
:END:

#+begin_src emacs-lisp
(after! exwm
  (funcall (get 'exwm-input-global-keys 'custom-set)
           'exwm-input-global-keys
           `((,(kbd "s-R") . exwm-reset)
             (,(kbd "s-x") . exwm-input-toggle-keyboard)
             (,(kbd "s-h") . windmove-left)
             (,(kbd "s-j") . windmove-down)
             (,(kbd "s-k") . windmove-up)
             (,(kbd "s-l") . windmove-right)
             (,(kbd "s-t") . transpose-frame)
             (,(kbd "s-D") . kill-this-buffer)
             (,(kbd "s-b") . switch-to-buffer)
             (,(kbd "s-f") . find-file)
             (,(kbd "s-O") . exwm-layout-toggle-fullscreen)
             (,(kbd "s-p") . previous-buffer)
             (,(kbd "s-n") . next-buffer)
             (,(kbd "s-q") . xl/open-qutebrowser)
             (,(kbd "s-e") . xl/open-emacs-instance)))
  (general-def
    "s-R" #'exwm-reset
    "s-x" #'exwm-input-toggle-keyboard
    "s-h" #'windmove-left
    "s-j" #'windmove-down
    "s-k" #'windmove-up
    "s-l" #'windmove-right
    "s-t" #'transpose-frame
    "s-D" #'kill-this-buffer
    "s-b" #'switch-to-buffer
    "s-f" #'find-file
    "s-O" #'exwm-layout-toggle-fullscreen
    "s-p" #'previous-buffer
    "s-n" #'next-buffer
    "s-q" #'xl/open-qutebrowser
    "s-e" #'xl/open-emacs-instance))
#+end_src

**** split-right-and-focus
:PROPERTIES:
:ID: 6cb60d94-723b-48e5-850a-3483e78f6647
:END:

#+begin_src emacs-lisp
(defun xl/window-split-right-and-focus ()
  "Split window right and select the window created with the split."
  (interactive)
  (select-window (split-window-right)))
#+end_src

**** split-below-and-focus
:PROPERTIES:
:ID: d6a4a81f-007d-4b7e-97a3-e0bba3ff97a4
:END:

#+begin_src emacs-lisp
(defun xl/window-split-below-and-focus ()
  "Split window below and select the window created with the split."
  (interactive)
  (select-window (split-window-below)))
#+end_src

**** window bindings
:PROPERTIES:
:ID:       5b4d2ce0-667f-42c8-bad4-880f371fddc4
:END:

These bindings pertain to manipulating windows.

***** set the window leader
:PROPERTIES:
:ID: 784956e2-3696-4f92-80ca-41b7e30e5b2b
:END:

Efficient window management in Emacs crucial for success. These keys all pertain
to window/workspace actions.

#+begin_src emacs-lisp
(define-leader-key!
  :infix "w"
  ""  (list :ignore nil :wk "window"))
#+end_src

***** motion
:PROPERTIES:
:ID:       ef50a2d7-deab-40b8-a654-133d9d3edd48
:END:

This headline is for bindings that involve traversing windows. The typical
bindings for moving up, down, left and right between windows. And as a bonus, a
binding to.

#+begin_src emacs-lisp
(define-leader-key!
  :infix "w"
  "h" (list :def #'windmove-left  :wk "left")
  "j" (list :def #'windmove-down  :wk "down")
  "k" (list :def #'windmove-up    :wk "up")
  "l" (list :def #'windmove-right :wk "right")
  "o" (list :def #'ace-window     :wk "other"))
#+end_src

***** splitting
:PROPERTIES:
:ID:       6c49babb-b749-4501-8699-dd2d7f885488
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "w"
  "S" (list :def #'xl/window-split-below-and-focus :wk "split below and focus")
  "V" (list :def #'xl/window-split-right-and-focus :wk "split right and focus")
  "s" (list :def #'window-split-below                :wk "split below")
  "v" (list :def #'window-split-right                :wk "split right"))
#+end_src

***** deleting
:PROPERTIES:
:ID:       218f650f-f52f-4cdf-9731-032631612ad3
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "w"
  "d" (list :def #'delete-window        :wk "delete current")
  "D" (list :def #'delete-other-windows :wk "delete others"))
#+end_src

***** resizing
:PROPERTIES:
:ID:       0aed1e9d-acff-430c-8372-23a620726bae
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "w"
  "M" (list :def #'maximize-window  :wk "maximize")
  "m" (list :def #'minimize-window  :wk "maximize")
  "b" (list :def #'window-balance   :wk "maximize")
  "z" (list :def #'zoom-window-zoom :wk "zoom"))
#+end_src

***** layout
:PROPERTIES:
:ID:       864e890f-d67c-40bc-8f72-49f4d6a21d5d
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "w"
  "x" (list :def #'ace-swap-window :wk "swap windows")
  "t" (list :def #'transpose-frame :wk "transpose"))
#+end_src

***** workgroups
:PROPERTIES:
:ID:       8cb7ee3d-6d9e-4fbf-a96a-5f7cdc2aa363
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "w"
  "w" (list :ignore t :wk "workgroup"))

(defun wg/create-workgroup ()
  (call-interactively #'wg-open-workgroup))

(define-leader-key!
  :infix "w w"
  "c" (list :def #'wg-create-workgroup          :wk "open") 
  "o" (list :def #'wg-open-workgroup            :wk "open") 
  "s" (list :def #'wg-switch-workgroup          :wk "switch") 
  "h" (list :def #'wg-switch-to-workgroup-left  :wk "left") 
  "l" (list :def #'wg-switch-to-workgroup-right :wk "right"))
#+end_src

*** Text Editing
:PROPERTIES:
:ID:       40fb1b29-b772-456f-aac6-cf4a3b5cde3f
:END:

**** separedit
:PROPERTIES:
:ID:       07021099-6cea-4016-929b-d9310ea305f8
:END:

#+begin_src emacs-lisp
(use-package! separedit :commands separedit)
#+end_src

**** edit-indirect
:PROPERTIES:
:ID:       786b11a6-561b-4793-9c6c-f7630aba3774
:END:

=edit-indirect= is a package that provides a means to edit text in an indirect
buffer. It's the same concept as org-src buffers but is not tied to org-mode.

***** init
:PROPERTIES:
:ID:       d08adcae-ab17-41f1-94c9-1d9a8cb385d7
:END:

#+begin_src emacs-lisp
(use-package! edit-indirect :commands edit-indirect)
#+end_src

***** editing org descriptions
:PROPERTIES:
:ID:       bdabe0b9-4116-423b-9fc0-049651bed58a
:END:

This headline contains customizations and extensions to =edit-indirect= so that I
can use it to edit org descriptions in the same way that we edit source blocks.

There are two cases when editing a description. There's the case of an existing
description and there's the case of a new one.

****** init

#+begin_src emacs-lisp
(use-package! org-edit-paragraph
  :ensure nil
  :nameless ("oep" . "org-edit-paragraph")
  :popup ("bottom" "org description" :newname "\\*Org Desc - .+")
  :xl-config
  (after! (evil evil-surround)
    (xl-hook-add 'org-edit-paragraph:mode-hook #'evil-surround-mode)))
#+end_src

****** set up tempo completion

#+begin_src emacs-lisp
(defhook! enable-org-tempo-templates (org-edit-paragraph:mode-hook)
  (tempo-use-tag-list 'tempo:org-mode-taglist))

(xl-hook-add 'org-edit-paragraph:mode-hook #'company-mode)

;; Add an element to the company alist.
(after! company
  (push '(org-edit-paragraph:mode :only (company-tempo)) company:backend-alist))
#+end_src

****** description bounds
:PROPERTIES:
:ID:       74367212-cbd0-4871-94d5-24980e997bd7
:END:

#+begin_src emacs-lisp
(defun org-edit-paragraph:bounds ()
  "Return the bounds of description at headline.
If there is no existing description return nil."
  (interactive)
  (let* ((parse-tree (org-ml-parse-subtree-at (point)))
	 (elements '(headline section property-drawer src-block paragraph))
	 (nodes (->> (org-element-map parse-tree elements #'identity)
		     (-split-when (fn! (eq (org-element-type <elt>) 'headline)))
		     (car))))
    (aif (car (-split-when (fn! (not (eq (org-element-type <elt>) 'paragraph))) nodes))
	(cons (org-element-property :begin (-first-item it))
	      (org-element-property :end (-last-item it)))
      (-let* ((section (-first (fn! (eq (org-element-type <elt>) 'section)) nodes))
	      ((property-drawer others) (org-element-contents section)))
	(alet (org-element-property :end (if others property-drawer section))
	  (cons it it))))))
#+end_src

****** default post blanks
:PROPERTIES:
:ID:       117478bf-3759-4a00-b738-9b1aad99ed54
:END:

It is my preference to have one blank line after a description--or any org item
for that matter. I just find it much more readable and less cluttered.

#+begin_src emacs-lisp
(defvar org-edit-paragraph:default-post-blanks 1
  "Number of blank lines that should follow a description.")
#+end_src

****** hooks
:PROPERTIES:
:ID:       6ab3a2cc-17aa-4166-aa3f-8627afe40c1a
:END:

=edit-indirect= has hooks for whenever you want to do a quick thing.

******* goto last non-white
:PROPERTIES:
:ID:       f9afdc3d-ceea-4e9e-a986-9f6bb7e860f6
:END:

Most of the time I will want to add to the end of a description. Therefore, I
want the cursor to start at the last non-whitespace character of the
description.

#+begin_src emacs-lisp
(defun org-edit-paragraph:goto-last-non-white ()
  (goto-char (point-max))
  (skip-chars-backward "\n\s"))
#+end_src

******* add newlines in the beginning
:PROPERTIES:
:ID:       46917f50-8e0b-4c29-8f9b-1aab7e0e9550
:END:

In the case where there was no existing description, we need to add newlines to
the description buffer so that if we end up committing a change the description
will be placed properly in relation to what's below it. This hook is designed to
make sure this happens.

#+begin_src emacs-lisp
(defun org-edit-paragraph:add-newlines ()
  "Add newlines."
  (save-excursion
    (--dotimes (1+ org-edit-paragraph:default-post-blanks)
      (insert "\n"))))
#+end_src

******* maybe remove newline
:PROPERTIES:
:ID:       cfa12a0f-fd23-4684-bb10-b86b2e4e5c58
:END:

When you open a description buffer and close it again, you'd expect the source
buffer to stay the same--and you should expect this. Since we add newlines to
the description buffer when there's no existing description, we could
inadvertently edit the source buffer in this case. So this hook is to remove any
newlines added in the case that nothing was changed.

#+begin_src emacs-lisp
(defun org-edit-paragraph:maybe-remove-newline ()
  "Remove newline if that's all there is."
  (when (and (seq-every-p (fn! (= 10 <>)) (buffer-string))
	     (= (1+ org-edit-paragraph:default-post-blanks) (length (buffer-string))))
    (erase-buffer)))
#+end_src

****** define a minor mode for editing descriptions
:PROPERTIES:
:ID:       8775acdc-0389-40af-a5f4-e74c78144944
:END:

The way I've set things up editing descriptions is it's own "thing". I'm going
to be adding hooks and maybe even binding keys with editing descriptions in mind.
Therefore, I think it's worthy to give it it's own mode.

#+begin_src emacs-lisp
(define-minor-mode org-edit-paragraph:mode
  "Mode for editing org descriptions.")
#+end_src

****** requirements for editing descriptions
:PROPERTIES:
:ID:       9a789e79-84b8-4415-b152-e11fca786587
:END:

The edit description function requires =org-ml= and =edit-indirect=. I don't
know if this is the best way to declare these dependencies. It certaintly is
efficient.

#+begin_src emacs-lisp
(xl-load-before-call 'org-ml #'org/dwim-edit-description)
(xl-load-before-call 'edit-indirect #'org/dwim-edit-description)
#+end_src

****** edit description
:PROPERTIES:
:ID:       3a7da5c8-f445-4592-b0c0-7fbff3be912e
:END:

It is uncough to edit the text of the buffer when we're not commit it--even
worse to have to edit it again afterwards if we don't end up committing
anything. No, instead we should work with the edit indirect buffer.

We need to make sure that we respect [[helpvar:edit-indirect-after-creation-hook][edit-indirect-after-creation-hook]] by doing
our description management stuff before anything is done in that hook. It may be
worth it to consider creating a hook specifically for org descriptions.

#+begin_src emacs-lisp
(defun org/dwim-edit-description ()
  (interactive)
  (-let* (((beg . end) (org-edit-paragraph:bounds))
	  (was-empty-p (= beg end)))
    (unless beg (user-error "No description at headline."))
    (let ((edit-indirect-after-creation-hook edit-indirect-after-creation-hook)
	  (headline (org-get-heading t t t t)))
      (when was-empty-p
	(add-hook 'edit-indirect-after-creation-hook #'org-edit-paragraph:add-newlines 0))
      (add-hook 'edit-indirect-after-creation-hook #'org-edit-paragraph:goto-last-non-white 0)
      (with-current-buffer (edit-indirect-region beg end)
	(rename-buffer (format "*Org Desc - %s*" headline) t)
	(org-edit-paragraph:mode 1)
	(add-hook 'edit-indirect-before-commit-hook
		  #'org-edit-paragraph:maybe-remove-newline nil t)
	(select-window (display-buffer (buffer-name)))))))
#+end_src

****** evil support
:PROPERTIES:
:ID:       f270092b-19ca-40ba-87aa-77b3d314c9a6
:END:

When I open a buffer for editing a description it is very likely that I'll end
up appending more commentary to the existing description. I think it will save
me more time making that common case easier than the cost for the few situations
where I don't do this.

#+begin_src emacs-lisp
(after! evil
  (xl-hook-add 'org-edit-paragraph:mode-hook #'evil-insert-state))
#+end_src

****** custom hooks
:PROPERTIES:
:ID:       240acf8a-621e-4e44-9c11-250b70a0e3dc
:END:

#+begin_src emacs-lisp
(-each (list #'auto-capitalize-mode #'aggressive-fill-paragraph-mode
	     #'org-link-minor-mode)
  (fn! (xl-hook-add 'org-edit-paragraph:mode-hook <mode>)))
#+end_src

***** bindings inside edit-indirect
:PROPERTIES:
:ID: 42992d1e-5d65-4570-ba96-02b3be31b97b
:END:

I want quick, convenient bindings I can use to abort or commit (which is
=edit-indirect= lingo for writing the contents of the buffer back into its source
file, see [[helpfn:edit-indirect-commit][edit-indirect-commit]].

#+begin_src emacs-lisp
(define-localleader-key!
  :keymaps 'edit-indirect-mode-map
  "," #'edit-indirect-commit
  "c" #'edit-indirect-commit
  "a" #'edit-indirect-abort)
#+end_src

**** expand-region
:PROPERTIES:
:ID:       7e873fba-33ea-4720-ad79-bd8d557cc4b3
:END:

[[https://github.com/magnars/expand-region.el][expand-region]] allows me to toggle a key ("v" in my case) to select progressively
larger text objects. It's saves me keystrokes.

***** init
:PROPERTIES:
:ID:       41a1cebc-8da8-4e5c-8258-2ce440f1af50
:END:

#+begin_src emacs-lisp
(use-package! expand-region
  :commands er/expand-region er/contract-region er/mark-symbol)
#+end_src

***** quit expand region
:PROPERTIES:
:ID:       639824e1-0dcf-46bc-98b4-c70b9c7cb2a6
:END:

#+begin_src emacs-lisp
(defadvice! quit-expand-region (:before evil-escape)
  "Properly abort an expand-region region."
  (when (memq last-command '(er/expand-region er/contract-region))
    (er/contract-region 0)))
#+end_src

***** expand-region
:PROPERTIES:
:ID: 417c9c53-a776-4779-9afc-1eaa35a145c6
:END:

#+begin_src emacs-lisp
(define-key! 'visual
  "V" #'er/contract-region
  "v" #'er/expand-region)
#+end_src

**** writing
:PROPERTIES:
:ID:       98b567f1-00ad-4c99-aace-0a12f4d1b353
:END:

This headline is for packages and configuration related to writing such as spell
and grammer checking.

***** plural
:PROPERTIES:
:ID:       bf2ed9b7-144c-4d4b-92ae-74c93dfc6db5
:END:

This package determines whether a noun is plural and provides a function to
convert a singular noun to a plural one. For example ~(plural-pluralize
"goose")~ returns ~"geese"~.

My intended use for this package is to help automate prompts, docstrings or the
like that concern N number of things, where N could be 1 or more things.

#+begin_src emacs-lisp
(use-package! plural
  :commands plural-make-plural
  :xl-config
  (push '("\\`is\\'" . "are") plural-knowledge)
  (push '("\\`thas\\'" . "those") plural-knowledge)
  (push '("\\`this\\'" . "these") plural-knowledge))
#+end_src

***** auto-capitalize
:PROPERTIES:
:ID:       4ddfacc1-a25e-466e-ab6b-2a5ec306f3be
:END:

[[https://github.com/emacsmirror/auto-capitalize][auto-capitalize]] automatically capitalizes the first word of a sentence for me.
It will also upcase any word I add to [[helpvar:auto-capitalize-words][auto-capitalize-words]].

#+begin_src emacs-lisp
(use-package! auto-capitalize
  :hook text-mode-hook
  :set
  (auto-capitalize-words . '("I" "English" "Emacs")))
#+end_src

***** spell-number
:PROPERTIES:
:ID:       8bf270a6-6003-4430-bb03-0b665d5a162f
:END:

#+begin_src emacs-lisp
(use-package! spell-number
  :set
  (spelln-language          . 'english-us)
  (spelln-country           . 'united-states)
  (spelln-period-character  . ?,)
  (spelln-decimal-character . ?.))
#+end_src

**** xr
:PROPERTIES:
:ID: 75c56163-9ce1-4726-969a-350fcc56395f
:END:

This package is the inverse of =rx=. It takes a regular expression and returns the
=rx= representation.

#+begin_src emacs-lisp
(use-package! xr :commands xr)
#+end_src

**** super-save
:PROPERTIES:
:ID:       684e788c-6db9-4e6e-826b-d4871c0a3f90
:END:

The default auto-saving feature in emacs saves after a certain number of
characters are typed (see [[helpvar:auto-save-interval][auto-save-interval]]). The problem is that if you're in
the middle of typing and you've just hit the number of characters that trigger a
save, you could experience a lag, particularly if you are dealing with a large
file being saved. Instead of doing this, [[https://github.com/bbatsov/super-save][super-save]] saves buffers during idle
time and after certain commands like [[helpfn:switch-to-buffer][switch-to-buffer]] (see [[helpvar:super-save-triggers][super-save-triggers]]).
Note that this is the same strategy employed by [[id:c550f82a-9608-47e6-972b-eca460015e3c][idle-require]] to load packages.
Saving files like this reduces the likelihood of user delays.

#+begin_src emacs-lisp
(use-package! super-save
  :before-call find-file
  :set
  (super-save-auto-save-when-idle . t)
  (super-save-idle-duration       . 5))
#+end_src

**** spacing & indentation
:PROPERTIES:
:ID:       ae5416cd-ffa2-456a-9c56-afcfc65a33f8
:END:

***** aggressive-fill-paragraph
:PROPERTIES:
:ID: 4f57fd49-b466-4eea-b91a-2cc8f0b07297
:END:

Emacs is very minimal by default. Most reading this will likely be used to.

#+begin_src emacs-lisp
(use-package! aggressive-fill-paragraph)
#+end_src

***** aggressive-indent
:PROPERTIES:
:ID: f1b9a36e-26e4-4305-99ae-cbcf6a90013d
:END:

[[https://github.com/Malabarba/aggressive-indent-mode][aggressive-indent]] indents portions of the text your working on as your typing
it. It's pretty smart and very convenient.

#+begin_src emacs-lisp
(use-package! aggressive-indent
  :hook emacs-lisp-mode-hook)
#+end_src

**** parentheses
:PROPERTIES:
:ID:       e82d2b4e-659e-4c7d-8071-c413b8e540f7
:END:

***** smartparens
:PROPERTIES:
:ID:       f4ffbb57-1fb6-43ab-a747-470dfcfbd0ac
:END:

****** init
:PROPERTIES:
:ID:       e26f4c55-9585-4544-bed6-9733d50823e7
:END:

#+begin_src emacs-lisp
(use-package! smartparens
  :before-call evil-expression evil-ex
  :hook ((prog-mode eshell-mode ielm-mode) . smartparens-strict-mode)
  :set
  (sp-cancel-autoskip-on-backward-movement . nil)
  (sp-highlight-wrap-tag-overlay           . nil)
  (sp-highlight-pair-overlay               . nil)
  (sp-highlight-wrap-overlay               . nil)
  (sp-show-pair-from-inside                . t)
  (sp-show-pair-delay                      . 0.1)
  (sp-max-pair-length                      . 4)
  (sp-max-prefix-length                    . 50)
  (sp-escape-quotes-after-insert           . nil))
#+end_src

****** config
:PROPERTIES:
:ID: f1c64411-ad51-4c24-8dad-b4aa7b8fc3b5
:END:

#+begin_src emacs-lisp
(defhook! init-smartparens-config (smartparens-mode-hook)
  (require 'smartparens-config)
  (sp-local-pair 'minibuffer-inactive-mode "'" nil :actions nil))
#+end_src

****** disable =smartparens-navigate-skip-match=
:PROPERTIES:
:ID: fda1875b-b3f7-4f43-83b1-873f3db3ae77
:END:

#+begin_src emacs-lisp
(use-package! smartparens :config
  (defhook! disable-smartparens-navigate-skip-match (after-change-major-mode-hook)
    "Disable smartparents skip match feature."
    (setq sp-navigate-skip-match nil)
    (setq sp-navigate-consider-sgml-tags nil)))
#+end_src

****** autopairing
:PROPERTIES:
:ID: e860ce7e-aaac-477b-a373-a8b01957481d
:END:

#+begin_src emacs-lisp
(defhook! enable-smartparens-maybe (minibuffer-setup-hook)
  "Enable `smartparens-mode' in the minibuffer."
  (when (memq this-command '(eval-expression evil-ex))
    (smartparens-mode 1)))
#+end_src

***** rainbow-delimiters
:PROPERTIES:
:ID:       5b58bb1c-5d3c-4f04-b4fb-c55f1588839e
:END:

[[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]] colors parentheses different colors based on level. This is a
great idea! It makes it really easy to see which parentheses go together.

#+begin_src emacs-lisp
(use-package! rainbow-delimiters
  :hook prog-mode-hook reb-mode-hook
  :set
  (rainbow-delimiters-max-face-count . 9))
#+end_src

**** outshine
:PROPERTIES:
:ID:       6aeccc22-2ebe-43c0-a245-5535b5bd6f6c
:END:

#+begin_src emacs-lisp
(use-package! outshine :commands outshine-mode)
#+end_src

**** modal editing
:PROPERTIES:
:ID:       175ad5b9-3f0e-445e-b0ae-da3bce144929
:END:

Modal editing is widely accepted to be more efficient than modeless editing.

***** evil - the "extensible VI layer"
:PROPERTIES:
:ID:       9639633f-ec3d-4499-9615-db0dcc9650c9
:END:

=evil= is the most complete vim emulation in existence.

****** evil
:PROPERTIES:
:ID: 3b9aaf0c-a69c-474a-b1a3-f0e748e83558
:END:

[[https://github.com/emacs-evil/evil][evil]] is an extensible vi layer for Emacs. It emulates the main features of Vim,
and provides facilities for writing custom extensions. Also see our page on
[[emacswiki:Evil][EmacsWiki]]. See a brief [[https://bytebucket.org/lyro/evil/raw/default/doc/evil.pdf][manual]]. See the [[https://github.com/noctuid/evil-guide][evil-guide]] by noctuid.

******* init
:PROPERTIES:
:ID:       af3a9791-76ac-4fd5-96fe-d361cef3b5b3
:END:

#+begin_src emacs-lisp
(use-package! evil
  :demand t
  :hook (window-setup-hook . evil-mode)
  :set
  (evil-want-visual-char-semi-exclusive . t)
  (evil-ex-search-vim-style-regexp      . t)
  (evil-respect-visual-line-mode        . t)
  (evil-insert-skip-empty-lines         . t)
  (evil-want-C-w-in-emacs-state         . nil)
  (evil-ex-substitute-global            . t)
  (evil-ex-visual-char-range            . t)
  (evil-move-beyond-eol                 . nil)
  (evil-indent-convert-tabs             . t)
  (evil-symbol-word-search              . t)
  (evil-mode-line-format                . nil)
  (evil-echo-state                      . nil)
  (evil-magic                           . t))
#+end_src

******* custom
:PROPERTIES:
:ID:       f7ece898-25e2-4b2c-94f3-e832a687114c
:END:

#+begin_src emacs-lisp
(custom-set-default 'evil-want-C-u-scroll t)
#+end_src

******* cursors
:PROPERTIES:
:ID: a5f558fb-221c-4b33-a7cd-29308ef74b0d
:END:

It's nice to have cursors change colors (and sometimes shape) depending on the
current evil state. It makes it easy to tell which state you're in. I define
some colors here. Evil has a cursor variable for each state. The cursor variable
for insert state, for example, is [[helpvar:evil-insert-state-cursor][evil-insert-state-cursor]]. Its value is of the
form: ~((CURSOR-SHAPE . CURSOR-WIDTH) COLOR)~.

******** colors and shapes
:PROPERTIES:
:ID: 3f3cd5c9-1f6d-4c3b-b73f-82c9ee00395e
:END:

Changing the cursor shape and color depending on the state is a convenient and
asthetically pleasing way of determining which state you're in. Some add some
modeline indicator for this but I find that the cursor suffices.

#+begin_src emacs-lisp
(defhook! setup-cursor (evil-mode-hook)
  "Initialize the default cursor shape and size."
  (setq evil-insert-state-cursor   '((bar . 3)   "chartreuse3"))
  (setq evil-emacs-state-cursor    '((bar . 3)   "SkyBlue2"))
  (setq evil-normal-state-cursor   '( box        "DarkGoldenrod2"))
  (setq evil-visual-state-cursor   '((hollow)    "dark gray"))
  (setq evil-operator-state-cursor '((hbar . 10) "hot pink"))
  (setq evil-replace-state-cursor  '( box        "chocolate"))
  (setq evil-motion-state-cursor   '( box        "plum3")))
#+end_src

******** updating cursors
:PROPERTIES:
:ID: ea4da6d4-4a2c-42cf-b397-cea1555781ce
:END:

After a theme is loaded, the cursor color won't automatically update. Therefore,
I add a hook in [[helpvar:xl-after-load-theme-hook][xl-after-load-theme-hook]]. Now after a new theme is loaded, the
cursor color will update.

#+begin_src emacs-lisp
(defhook! refresh-evil-cursor (xl-after-load-theme-hook)
  "Enable cursor refreshing after theme change."
  (when (bound-and-true-p evil-mode)
    (evil-refresh-cursor)))
#+end_src

******* normal state everywhere
:PROPERTIES:
:ID:       e6126bd7-94b8-4ce0-b547-0536b59437ea
:END:

Noctuid pointed out

#+begin_src emacs-lisp
(defhook! make-normal-state-default (evil-mode-hook)
  "Make normal state the default `evil-mode' state."
  (setq evil-normal-state-modes (append evil-emacs-state-modes evil-normal-state-modes))
  (setq evil-emacs-state-modes nil)
  (setq evil-motion-state-modes nil))

(defadvice! replace-motion-with-normal (:around evil-make-overriding-map)
  "Advice for `evil-make-overriding-map' that inhibits motion state."
  (-let (((keymap state copy) <args>))
    (funcall <orig-fn> keymap (if (eq state 'motion) 'normal state) copy)))

(defadvice! replace-motion-with-normal (:around evil-set-initial-state)
  (-let (((mode state) <args>))
    (funcall <orig-fn> mode (if (eq state 'motion) 'normal state))))

(xl-advice-add #'evil-motion-state :override #'evil-normal-state)
#+end_src

******* insert state in minibuffer
:PROPERTIES:
:ID: a23137c5-62a0-4e77-9e51-6a7372dac703
:END:

Before I just used ~(evil-change-state evil-previous-state)~ to revert the
state back to what it last was. But this fails with ~evil-force-normal-state~
which is what I'm currently using to exit the minibuffer because then the
last state is normal state if the minibuffer is aborted. Using a
=evil:state-before-minibuffer= ensures that the state will be reverted to
the correct one.

#+begin_src emacs-lisp
(defhook! preserve-prior-evil-state (minibuffer-enter-hook)
  "Save state before entering the minibuffer and enter insert state."
  (when (bound-and-true-p evil-mode)
    (setq evil:state-before-minibuffer evil-state)
    (evil-insert-state)))

(defhook! restore-prior-evil-state (minibuffer-exit-hook)
  "Restore state after minibuffer."
  (when (bound-and-true-p evil-mode)
    (evil-change-state evil:state-before-minibuffer)
    (setq evil:state-before-minibuffer nil)))
#+end_src

******* escape
:PROPERTIES:
:ID: ea9378de-e5c5-482c-b53b-743a81e3bc8e
:END:

We want escape to be a general "quit everything".

#+begin_src emacs-lisp
(general-def :states '(emacs insert) [escape] #'evil-force-normal-state)

(defadvice! exit-everything (:after evil-force-normal-state lispyville-normal-state)
  "Exits out of whatever is happening after escape."
  (cond ((minibuffer-window-active-p (minibuffer-window))
         (abort-recursive-edit))
        ((run-hook-with-args-until-success 'xl-escape-hook))
        ((or defining-kbd-macro executing-kbd-macro) nil)
        (t (keyboard-quit))))
#+end_src

******* text objects
:PROPERTIES:
:ID: 07366548-2960-49c6-9ab7-cb177b06ad70
:END:

To edit text efficiently Vim has the concept of [[https://blog.carbonfive.com/2011/10/17/vim-text-objects-the-definitive-guide/][text objects]]. Text objects are
structures that are seen in text. For example, a set of words followed by a
period is a sentence. A words between two closing parentheses is a sexp.

******** general delimiter text object
:PROPERTIES:
:ID: f551956d-440c-431b-8fb0-8e71c9714f11
:END:

I discovered this the =form= text object from using [[https://github.com/luxbock/evil-cleverparens][evil-cleverparens]] in the past.
The package =evil-cleverparens= was too slow for my taste; noctuid's [[https://github.com/sp3ctum/evil-lispy][evil-lispy]] is
much faster and gave me the functionality that I needed most from
=evil-cleverparens=: deleting and copying text with parentheses intelligently.
However, many of the ideas of =evil-cleverparens= were excellent. One particular
idea was to have a general =form= text object. Instead of specifying the
particular surrounding bounds when doing an evil operator command you just use a
single key for them. It's kind of like a =Do-What-I-Mean= surround operator. This
is suprisingly useful because it takes significant time to specify whether you
want =[]= or ={=}= or =()= or =""=. The main drawback you cannot distinguish between
surround characters at multiple levels--it just takes the closest one. In
practice, this is rarely an issue.

#+begin_src emacs-lisp
(after! evil
  (evil-define-text-object evil:textobj-inner-form (count &rest _)
    "Inner sexp object."
    (-if-let ((beg . end)
              (->> (list (lispy--bounds-list) (lispy--bounds-string))
                   (-non-nil)
                   (--sort (< (- (cdr it) (car it)) (- (cdr other) (car other))))
                   (car)))
        (evil-range (1+ beg) (1- end) 'inclusive :expanded t)
      (error "No surrounding form found.")))

  (evil-define-text-object evil:textobj-outer-form (count &rest _)
    "Smartparens inner sexp object."
    (-if-let ((beg . end)
              (->> (list (lispy--bounds-list) (lispy--bounds-string))
                   (-non-nil)
                   (--sort (< (- (cdr it) (car it)) (- (cdr other) (car other))))
                   (car)))
        (evil-range beg end 'inclusive :expanded t)
      (error "No surrounding form found.")))

  (general-def evil-inner-text-objects-map
    "f" #'evil:textobj-inner-form)
  (general-def evil-outer-text-objects-map
    "f" #'evil:textobj-outer-form))
#+end_src

******** fix vim/evil around =""=
:PROPERTIES:
:ID: b57bf245-3d63-4078-8bcb-2ec0b9952ab9
:END:

=Vim= and =Evil= both have the interesting (inconsistent?) behavior that doing an
outer text object operator on a comment grabs some whitespace on the left side.
Try doing =va"= to ~(progn "hello world")~ and you'll see that =\s"hello world"= is
selected instead of just "hello world".

Why not just go to the end of the ="= like any other around operator?

#+begin_src emacs-lisp
(after! evil
  (evil-define-text-object evil:textobj-a-string (count &rest _)
    "An outer comment text object as defined by `lispy--bounds-string'."
    (-if-let ((beg . end) (lispy--bounds-string))
        (evil-range beg end 'exclusive :expanded t)
      (error "Not inside a comment.")))

  (general-def evil-outer-text-objects-map
    "\"" #'evil:textobj-a-string))
#+end_src

****** evil-visualstar
:PROPERTIES:
:ID: 6ebca72d-f90a-4423-9ecd-706f9d426002
:END:

[[https://github.com/bling/evil-visualstar][evil-visualstar]]

#+begin_src emacs-lisp
(use-package! evil-visualstar
  :general
  (:keymaps 'evil-visual-state-map
   "#" #'evil-visualstar/begin-search-backward
   "*" #'evil-visualstar/begin-search-forward))
#+end_src

****** evil-lion
:PROPERTIES:
:ID:       95d248be-601e-4dbd-b318-febcd0e49d71
:END:

=evil-lion= provides a very useful way of aligning text.

#+begin_src emacs-lisp
(use-package! evil-lion
  :commands evil-lion-right evil-lion-left)

(general-def 'normal
  :infix "g"
  "l" #'evil-lion-left
  "L" #'evil-lion-right)
#+end_src

****** evil-surround
:PROPERTIES:
:ID:       9ab88644-3c33-463c-8f24-3b048209e082
:END:

#+begin_src emacs-lisp
(use-package! evil-surround
  :hook prog-mode-hook text-mode-hook)
#+end_src

*** Languages
:PROPERTIES:
:ID:       fa8dc2fc-96f4-4820-b368-4d61d1db0ee5
:END:

**** lisp
:PROPERTIES:
:ID:       2b7db121-f807-4274-9347-70c996d3c6f7
:END:

This headline is for packages and configuration which pertain to editing lisp
code.

***** lispyville
:PROPERTIES:
:ID:       120baacb-4835-4e96-a7cb-e8bb7496d7be
:END:

[[https://github.com/noctuid/lispyville][lispyville]] helps vim commands work better with lisp by providing
commands (like [[helpfn:lispyville-delete][lispyville-delete]]) which preserve parentheses.

****** initialize
:PROPERTIES:
:ID:       fad4cb7c-ff1e-485d-99d1-f55384c26402
:END:

#+begin_src emacs-lisp
(use-package! lispyville :hook emacs-lisp-mode-hook)
#+end_src

****** remappings
:PROPERTIES:
:ID: 5567b70d-60f2-4161-9a19-d6098f45cd95
:END:

#+begin_src emacs-lisp
(use-package! lispyville
  :general
  (:keymaps 'lipsyville-mode-map
   [remap evil-yank]                 #'lispyville-yank
   [remap evil-delete]               #'lispyville-delete
   [remap evil-change]               #'lispyville-change
   [remap evil-yank-line]            #'lispyville-yank-line
   [remap evil-delete-line]          #'lispyville-delete-line
   [remap evil-change-line]          #'lispyville-change-line
   [remap evil-delete-char]          #'lispyville-delete-char-or-splice
   [remap evil-delete-backward-char] #'lispyville-delete-char-or-splice-backwards
   [remap evil-substitute]           #'lispyville-substitute
   [remap evil-change-whole-line]    #'lispyville-change-whole-line
   [remap evil-join]                 #'lispyville-join))
#+end_src

****** inner text objects
:PROPERTIES:
:ID:       f9f82ebe-5749-452f-ba49-269e60526b04
:END:

#+begin_src emacs-lisp
(use-package! lispyville
  :general
  (:keymaps 'evil-inner-text-objects-map
   "a" #'lispyville-inner-atom
   "l" #'lispyville-inner-list
   "x" #'lispyville-inner-sexp
   "c" #'lispyville-inner-comment
   "s" #'lispyville-inner-string))
#+end_src

****** outer text objects
:PROPERTIES:
:ID:       9dda9a1b-c76f-4537-9554-45ad3c77977a
:END:

#+begin_src emacs-lisp
(define-key! evil-outer-text-objects-map
  "a" #'lispyville-a-atom
  "l" #'lispyville-a-list
  "x" #'lispyville-a-sexp
  "c" #'lispyville-a-comment
  "s" #'lispyville-a-string)
#+end_src

****** slurp/barf
:PROPERTIES:
:ID: 21626641-98e3-4134-958d-03227e4da6b5
:END:

#+begin_src emacs-lisp
(define-key! 'normal lispyville-mode-map
  ">" #'lispyville-slurp
  "<" #'lispyville-barf)
#+end_src

****** escape
:PROPERTIES:
:ID: b355e1a1-6242-47f5-b357-5c3f5adbd200
:END:

=lispyville= binds escape to [[helpfn:lipyville-normal-state][lispyville-normal-state]]. So for =xl-escape-hook=
to still happen on escape, I need to add [[helpfn:evil:escape-a][evil:escape-a]] as advice to
=lispyville-normal-state=.

Sometimes =evil-normal-state= enters visual state.

#+begin_src emacs-lisp
(define-key! '(emacs insert) lispyville-mode-map [escape] #'lispyville-normal-state)
#+end_src

****** additional
:PROPERTIES:
:ID: 1fbafa78-87a0-45ee-9c7c-0c703df2ac66
:END:

#+begin_src emacs-lisp
(define-key! '(emacs insert) lispyville-mode-map
  "SPC" #'lispy-space
  ";"   #'lispy-comment)

(define-key! '(normal visual) lispyville-mode-map
  "M-j" #'lispyville-drag-forward
  "M-k" #'lispyville-drag-backward
  "M-R" #'lispyville-raise-list
  "M-v" #'lispy-convolute-sexp)
#+end_src

***** highlight-quoted
:PROPERTIES:
:ID:       d0973dce-693b-45ca-88e3-27da1bb217f7
:END:

[[https://github.com/Fanael/highlight-quoted][highlight-quoted]] highlights quotes, backticks and.

#+begin_src emacs-lisp
(use-package! highlight-quoted
  :hook emacs-lisp-mode-hook)
#+end_src

***** macrostep
:PROPERTIES:
:ID:       fefc5700-3bd7-4a89-ae7b-bf68368e8bc4
:END:

#+begin_src emacs-lisp
(use-package! macrostep
  :commands macrostep-expand
  :init
  (define-localleader-key!
    :keymaps 'emacs-lisp-mode-map
    "e" (list :def #'macrostep-expand       :wk "expand")
    "c" (list :def #'macrostep-collapse     :wk "collapse")
    "C" (list :def #'macrostep-collapse-all :wk "collapse all")))
#+end_src

***** elisp

****** fix elisp indentation
:PROPERTIES:
:ID:       834eff05-1b96-4295-a46c-d14f81b43ad6
:END:

A problem with elisp indentation is indents quoted lists the way functions
should be indented. It has been discussed in at least three stackoverflow
questions [[https://emacs.stackexchange.com/questions/10230/how-to-indent-keywords-aligned/10233#10233][here]], [[https://stackoverflow.com/questions/49222433/align-symbols-in-plist][here]] and [[https://stackoverflow.com/questions/22166895/customize-elisp-plist-indentation][here]]. In all these questions the solutions have not
been satisfactory. Some of them recommend using [[helpfn:common-lisp-indent-function][common-lisp-indent-function]] as
the value of [[helpvar:lisp-indent-function][lisp-indent-function]]. This works for indenting a quoted list
properly, but at the expense of changing the way that many other elisp forms are
indented. Common Lisp's indentation is different from Elisp's. Others recommend
using [[https://github.com/Fuco1/.emacs.d/blob/af82072196564fa57726bdbabf97f1d35c43b7f7/site-lisp/redef.el#L12-L94][Fuco1's lisp indent function hack]]. This also is not ideal. For one thing it
only works for quoted lists with keywords but not generic symbols. Another thing
is that the change should really be occurring in [[helpfn:calculate-lisp-indent][calculate-lisp-indent]].
~calculate-lisp-indent~ is a function that returns what the indentation should be
for the line at point. Since Fuco1 did not modify ~calculate-lisp-indent~ the
*wrong* indentation still returned by this function and the modified
~lisp-indent-function~ just cleans up the mess. Better is just fixing the source
of the problem. You can check out a more in-depth explanation looking at my
[[https://www.reddit.com/r/emacs/comments/d7x7x8/finally_fixing_indentation_of_quoted_lists/][reddit-post]] or looking at an answer I gave to [[https://emacs.stackexchange.com/questions/10230/how-to-indent-keywords-aligned][this question]].

#+begin_src emacs-lisp
(defadvice! properly-calculate-indent (:override calculate-lisp-indent)
  "Add better indentation for quoted and backquoted lists.
The change to this function."
  (defvar calculate-lisp-indent-last-sexp)
  (save-excursion
    (beginning-of-line)
    (let ((indent-point (point))
          state
          ;; setting this to a number inhibits calling hook
          (desired-indent nil)
          (retry t)
          calculate-lisp-indent-last-sexp containing-sexp)
      (cond ((or (markerp <parse-start>) (integerp <parse-start>))
             (goto-char <parse-start>))
            ((null <parse-start>) (beginning-of-defun))
            (t (setq state <parse-start>)))
      (unless state
        ;; Find outermost containing sexp
        (while (< (point) indent-point)
          (setq state (parse-partial-sexp (point) indent-point 0))))
      ;; Find innermost containing sexp
      (while (and retry
                  state
                  (> (elt state 0) 0))
        (setq retry nil)
        (setq calculate-lisp-indent-last-sexp (elt state 2))
        (setq containing-sexp (elt state 1))
        ;; Position following last unclosed open.
        (goto-char (1+ containing-sexp))
        ;; Is there a complete sexp since then?
        (if (and calculate-lisp-indent-last-sexp
                 (> calculate-lisp-indent-last-sexp (point)))
            ;; Yes, but is there a containing sexp after that?
            (let ((peek (parse-partial-sexp calculate-lisp-indent-last-sexp
                                            indent-point 0)))
              (if (setq retry (car (cdr peek))) (setq state peek)))))
      (if retry
          nil
        ;; Innermost containing sexp found
        (goto-char (1+ containing-sexp))
        (if (not calculate-lisp-indent-last-sexp)
            ;; indent-point immediately follows open paren.
            ;; Don't call hook.
            (setq desired-indent (current-column))
          ;; Find the start of first element of containing sexp.
          (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
          (cond ((looking-at "\\s(")
                 ;; First element of containing sexp is a list.
                 ;; Indent under that list.
                 )
                ((> (save-excursion (forward-line 1) (point))
                    calculate-lisp-indent-last-sexp)
                 ;; This is the first line to start within the containing sexp.
                 ;; It's almost certainly a function call.
                 (if (or
                      (= (point) calculate-lisp-indent-last-sexp)

                      (when-let (after (char-after (1+ containing-sexp)))
                        (char-equal after ?:))

                      (when-let (point (char-before containing-sexp))
                        (char-equal point ?'))

                      (let ((quoted-p nil)
                            (point nil)
                            (positions (nreverse (butlast (elt state 9)))))
                        (while (and positions (not quoted-p))
                          (setq point (pop positions))
                          (setq quoted-p
                                (or
                                 (and (char-before point)
                                      (char-equal (char-before point) ?'))
                                 (save-excursion
                                   (goto-char (1+ point))
                                   (looking-at-p "quote[\t\n\f\s]+(")))))
                        quoted-p))
                     ;; Containing sexp has nothing before this line
                     ;; except the first element.  Indent under that element.
                     nil
                   ;; Skip the first element, find start of second (the first
                   ;; argument of the function call) and indent under.
                   (progn (forward-sexp 1)
                          (parse-partial-sexp (point)
                                              calculate-lisp-indent-last-sexp
                                              0 t)))
                 (backward-prefix-chars))
                (t
                 ;; Indent beneath first sexp on same line as
                 ;; `calculate-lisp-indent-last-sexp'.  Again, it's
                 ;; almost certainly a function call.
                 (goto-char calculate-lisp-indent-last-sexp)
                 (beginning-of-line)
                 (parse-partial-sexp (point) calculate-lisp-indent-last-sexp
                                     0 t)
                 (backward-prefix-chars)))))
      ;; Point is at the point to indent under unless we are inside a string.
      ;; Call indentation hook except when overridden by lisp-indent-offset
      ;; or if the desired indentation has already been computed.
      (let ((normal-indent (current-column)))
        (cond ((elt state 3)
               ;; Inside a string, don't change indentation.
               nil)
              ((and (integerp lisp-indent-offset) containing-sexp)
               ;; Indent by constant offset
               (goto-char containing-sexp)
               (+ (current-column) lisp-indent-offset))
              ;; in this case calculate-lisp-indent-last-sexp is not nil
              (calculate-lisp-indent-last-sexp
               (or
                ;; try to align the parameters of a known function
                (and lisp-indent-function
                     (not retry)
                     (funcall lisp-indent-function indent-point state))
                ;; If the function has no special alignment
                ;; or it does not apply to this argument,
                ;; try to align a constant-symbol under the last
                ;; preceding constant symbol, if there is such one of
                ;; the last 2 preceding symbols, in the previous
                ;; uncommented line.
                (and (save-excursion
                       (goto-char indent-point)
                       (skip-chars-forward " \t")
                       (looking-at ":"))
                     ;; The last sexp may not be at the indentation
                     ;; where it begins, so find that one, instead.
                     (save-excursion
                       (goto-char calculate-lisp-indent-last-sexp)
                       ;; Handle prefix characters and whitespace
                       ;; following an open paren.  (Bug#1012)
                       (backward-prefix-chars)
                       (while (not (or (looking-back "^[ \t]*\\|([ \t]+"
                                                     (line-beginning-position))
                                       (and containing-sexp
                                            (>= (1+ containing-sexp) (point)))))
                         (forward-sexp -1)
                         (backward-prefix-chars))
                       (setq calculate-lisp-indent-last-sexp (point)))
                     (> calculate-lisp-indent-last-sexp
                        (save-excursion
                          (goto-char (1+ containing-sexp))
                          (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
                          (point)))
                     (let ((parse-sexp-ignore-comments t)
                           indent)
                       (goto-char calculate-lisp-indent-last-sexp)
                       (or (and (looking-at ":")
                                (setq indent (current-column)))
                           (and (< (line-beginning-position)
                                   (prog2 (backward-sexp) (point)))
                                (looking-at ":")
                                (setq indent (current-column))))
                       indent))
                ;; another symbols or constants not preceded by a constant
                ;; as defined above.
                normal-indent))
              ;; in this case calculate-lisp-indent-last-sexp is nil
              (desired-indent)
              (t
               normal-indent))))))
#+end_src

****** ppp
:PROPERTIES:
:ID:       82dbb88a-4bce-4ca3-90fe-38cfbea7abc6
:END:

This is a pretty printer.

Sometimes you want to see what an object looks like represented as text so you
know what you're dealing with. For example, I've wanted to see what a straight
recipe looks like. The problem is by default [[][]] prints something on one
line. And to avoid long lines, emacs truncates the output so you can't even see
the whole thing.

#+begin_src emacs-lisp
(use-package! ppp)
#+end_src

****** elisp-demos
:PROPERTIES:
:ID:       2c419004-a7c1-4de5-bada-8420505cea90
:END:

#+begin_src emacs-lisp
(use-package! elisp-demos
  ;; :xl-advice (helpful-update :after #'elisp-demos-advice-helpful-update)
  )
#+end_src

****** elisp snippets
:PROPERTIES:
:ID:       bbb2299f-6960-43c2-bf1d-b849ef8ecff0
:END:

******* defvar
:PROPERTIES:
:ID:       bbbba4d9-a2f4-47b1-8447-082f8ea4cf86
:END:

#+begin_src emacs-lisp
(defsnippet! defvar ("dvar" emacs-lisp-mode)
  "Insert a defvar expression."
  '("(defvar " (p "var" varname) " " (p "initial-value" value)
    n> "\"" (p "docstring" docstring) "\"" ")"))
#+end_src

******* defun
:PROPERTIES:
:ID:       3fdb199e-b76e-41ea-85fb-4f62c398453d
:END:

#+begin_src emacs-lisp
(defsnippet! defun ("defn" emacs-lisp-mode)
  "Insert a defun form"
  '("(defun " (p "name" name) " " "(" (p "args" it) ")"
    n> "\"" (p "docstring" docstring) "\""
    n> (p "body" body)
    ")" (p "")))
#+end_src

******* when
:PROPERTIES:
:ID:       8eb34ddf-ae81-42dd-bf7a-4be9562ceae5
:END:

#+begin_src emacs-lisp
(defsnippet! when ("when" emacs-lisp-mode)
  "Insert a when expression"
  '("(when " (p "condition" condition) n> (r "body" body) ")" (p "" last)))
#+end_src

**** org
:PROPERTIES:
:ID:       63748940-c1b9-47ea-b1ce-d6519453ad03
:END:

=org= mode.

***** init
:PROPERTIES:
:ID:       6d08d180-5b96-4f1f-98f9-53086c13561a
:END:

****** define capture file
:PROPERTIES:
:ID:       97a3bb5a-f485-45d0-a7f4-4bdd3963a16b
:END:

#+begin_src emacs-lisp
(defun xl-capture-file ()
  "Return the file where org should capture to."
  (xl-org-dir "capture.org"))

(defun org:code-file ()
  "File where I store code I want to save in."
  (xl-org-dir "code.org"))
#+end_src

****** general settings
:PROPERTIES:
:ID:       b0aa3f0b-876a-4527-b8ba-4fdac5e7ebe8
:END:

#+begin_src emacs-lisp
(use-package! org
  :set
  (org-directory                      . (xl-org-dir))
  (org-archive-location               . (xl-org-dir "archive.org::"))
  (org-default-notes-file             . (xl-org-dir "notes.org"))
  (org-fontify-emphasized-text        . t)
  (org-hide-emphasis-markers          . t)
  (org-pretty-entities                . t)
  (org-fontify-whole-heading-line     . t)
  (org-fontify-done-headline          . t)
  (org-fontify-quote-and-verse-blocks . t)
  (org-adapt-indentation              . nil)
  (org-cycle-separator-lines          . 2)
  (outline-blank-line                 . t)
  (org-enforce-todo-dependencies      . t)
  (org-use-fast-tag-selection         . nil)
  (org-tags-column                    . -80)
  (org-tag-alist                      . nil)
  (org-log-done                       . 'time))
#+end_src

****** org-version
:PROPERTIES:
:ID:       0b2cfe2b-a75c-48ea-9470-19c92521e2cf
:END:

#+begin_src emacs-lisp
(advice-add #'org-version :override (-const "10"))
#+end_src

***** customization
:PROPERTIES:
:ID:       3f0570f0-436b-4a53-92c4-52b06ae26a15
:END:

****** bindings
:PROPERTIES:
:ID:       4ca3fe54-54b1-47ca-90f1-a14b3df1cc59
:END:

Org mode demands its own editing.

******* navigation
:PROPERTIES:
:ID:       25a91495-073d-4557-8407-49ea63f13383
:END:

#+begin_src emacs-lisp
(define-key! 'normal org-mode-map
  "j" #'org/dwim-next-line
  "k" #'org/dwim-previous-line)
#+end_src

******* org mode local bindings
:PROPERTIES:
:ID:       a950d732-b0d2-46b9-82ce-1b9a474e7d76
:END:

#+begin_src emacs-lisp
(define-localleader-key!
  :keymaps 'org-mode-map
  "o" (list :def #'outorg-edit-as-org         :wk "edit as org")
  "w" (list :def #'widen                      :wk "widen")
  "n" (list :def #'org-narrow-to-subtree      :wk "narrow")
  "k" (list :def #'org-cut-subtree            :wk "cut subtree")
  "c" (list :def #'org-copy-subtree           :wk "copy subtree")
  "r" (list :def #'org-refile                 :wk "refile")
  "j" (list :def #'org/avy-goto-headline      :wk "jump to headline")
  "E" (list :def #'org-babel-execute-subtree  :wk "execute subtree")
  "d" (list :def #'org/dwim-edit-description  :wk "edit description")
  "e" (list :def #'org/dwim-edit-src-code :wk "edit source block")
  "," (list :def #'org/dwim-edit-src-code :wk "edit source block"))
#+end_src

******* generic org bindings
:PROPERTIES:
:ID:       583bd7ac-64e0-48ea-bd75-5b6a20f2deae
:END:

Org mode just does not lend itself to typical evil bindings. These bindings are
much more useful considering the specific structure of org mode documents.

#+begin_src emacs-lisp
(general-def 'normal org-mode-map
  "E" #'org/dwim-eval-block
  "e" #'org/dwim-eval-block
  "b" #'org/dwim-insert-elisp-block
  "o" #'org/insert-heading-below
  "O" #'org/insert-heading-above
  "h" #'org-up-heading-safe
  "l" #'org-do-demote
  "H" #'org-promote-subtree
  "S" #'org-demote-subtree
  ">" #'org-shiftmetaright
  "<" #'org-shiftmetaleft
  "t" #'org-set-tags-command
  "r" #'org-capture
  "s" #'org/dwim-edit-source-block
  "R" #'org-refile
  "T" #'org-todo
  "D" #'org-cut-subtree
  "Y" #'org-copy-subtree
  "K" #'org-metaup
  "J" #'org-metadown)
#+end_src

******* bindings
:PROPERTIES:
:ID:       3f4144ee-a780-478e-a1ad-47591f181ff3
:END:

#+begin_src emacs-lisp
(define-key! '(normal) org-mode-map
  ;; Doesn't work for some reason -> "TAB" #'outline-toggle-children
  "D" #'org-cut-subtree
  "P" #'org-paste-subtree)

(define-key! [remap org-cycle] #'outline-toggle-children)
#+end_src

****** custom commands
:PROPERTIES:
:ID:       4dfeccc9-f12e-4449-a5fe-17541070b40e
:END:

******* goto start of heading
:PROPERTIES:
:ID:       0431e49f-ef6b-4edb-854c-6427479e5ee2
:END:

#+begin_src emacs-lisp
(defun org:heading-goto-start ()
  "Go to the end of headline."
  (save-match-data
    (beginning-of-line)
    (when (looking-at (rx (1+ "*")))
      (goto-char (1- (match-end 0))))))
#+end_src

******* do the right thing after jumping to headline
:PROPERTIES:
:ID:       2ca61454-a0ca-47b3-8622-91d7969653da
:END:

When I search for a headline with [[helpfn:void/goto-line][xl/goto-line]] or [[helpfn:void/goto-headline][xl/goto-headline]] or even their
counsel equivalents, the proper headlines aren't automatically revealed.

[[screenshot:][This]] is what headline structure looks after using counsel/ivy's [[helpfn:swiper][swiper]] to find
the word =xl/goto-line= in my emacs. You can see that only the headline that has
the target word is revealed but it's parents are (akwardly) hidden. I never want
headlines to be unfolded like this.

******** show branch
:PROPERTIES:
:ID:       d95fab52-7d8f-439f-9221-188490f4ad5f
:END:

This shows all headlines that make up the branch of the current headine and
their children. This is the typical behavior you would expect in any outlining
program.

#+begin_src emacs-lisp
(defun org:show-branch ()
  "Reveal the current org branch.
Show all of the current headine's parents and their children. This includes this
headline."
  (loopy (before-do (org-back-to-heading t))
         ((while (org-up-heading-safe))
          (collect points (point)))
         (finally-do
          (--each-r points
            (goto-char it)
            (outline-show-children)
            (outline-show-entry)))))
#+end_src

******** show branch after jumping to point
:PROPERTIES:
:ID:       251e5df0-0a7d-4bf9-8fd9-69991d89a074
:END:

Note that I use points to store the heading points and go back to them inreverse
order. This is important because org does not unfold headlines properly if you
start from an invisible subheading.

Notably, I do not try to conserve the return value of =xl/goto-line= or
=xl/jump-to-headline= because these functions are and should only be used for
their side-effects.

#+begin_src emacs-lisp
(defadvice! show-current-branch-in-org-mode (:after xl/goto-line org/goto-headline)
  "Properly unfold nearby headlines and reveal current headline."
  (when (eq major-mode 'org-mode)
    (org:show-branch)))
#+end_src

******* return
:PROPERTIES:
:ID:       8314f2e0-da63-4f2f-ad89-b97987ca5843
:END:

#+begin_src emacs-lisp
(defun org/dwim-return ()
  "Do what I mean."
  (interactive)
  (cond ((org-at-heading-p)
         (org/insert-heading-below))
        (t
         (call-interactively #'org-return))))
#+end_src

******** next-line
:PROPERTIES:
:ID: d8d118a7-78e8-4602-81b3-17fd1d8ab79c
:END:

#+begin_src emacs-lisp
(defun org/dwim-next-line (&optional backward)
  "Go to the start of the next heading.
If DIR is a negative integer, go the opposite direction: the start of the
  previous heading."
  (interactive)
  (outline-next-visible-heading (if backward -1 1))
  (when (org-at-heading-p)
    (org:heading-goto-start)))
#+end_src

******* navigation
:PROPERTIES:
:ID:       3d9ea885-e679-46e5-9541-dea0436d05ec
:END:

******** next-line
:PROPERTIES:
:ID: d8d118a7-78e8-4602-81b3-17fd1d8ab79c
:END:

#+begin_src emacs-lisp
(defun org/dwim-next-line (&optional backward)
  "Go to the start of the next heading.
If DIR is a negative integer, go the opposite direction: the start of the
  previous heading."
  (interactive)
  (outline-next-visible-heading (if backward -1 1))
  (when (org-at-heading-p)
    (org:heading-goto-start)))
#+end_src

******** previous-line
:PROPERTIES:
:ID: e7562921-77ca-4d90-be57-1d586ec26ee5
:END:

#+begin_src emacs-lisp
(defun org/dwim-previous-line (&optional forward)
  (interactive)
  (funcall #'org/dwim-next-line (not forward)))
#+end_src

******* inserting
:PROPERTIES:
:ID: e99abeff-328b-48e4-aebb-00db34fa98e8
:END:

In my eyes, many Org functions are unnecessarily complicated and long. Often they
need to perform a simple task (like inserting a heading) but lose their
fundamental purpose in their inclusion of numerous obscure and opinionated
options. For this reason I wrote my own insert heading functions.

******** newlines between headings
:PROPERTIES:
:ID: e0dcf718-120c-488d-9d37-96243132bf0b
:END:

#+begin_src emacs-lisp
(defvar org:newlines-between-headings "\n\n"
  "Number of newlines between headings.")
#+end_src

******** heading above
:PROPERTIES:
:ID: 6c227dea-e10b-4f86-a01b-5d223d18e3a4
:END:

#+begin_src emacs-lisp
(defun org/insert-heading-above (&optional below)
  "Insert a heading above the current heading."
  (interactive)
  (funcall #'org/insert-heading-below (not below)))
#+end_src

******** heading below
:PROPERTIES:
:ID: b059a431-e29c-4f2c-ab5e-8d2d02636405
:END:

#+begin_src emacs-lisp
(defun org/insert-heading-below (&optional above)
  "Insert heading below."
  (interactive)
  (let* ((on-heading-p (ignore-errors (org-back-to-heading)))
         (newlines org:newlines-between-headings)
         (level (or (org-current-level) 1))
         (heading (concat (make-string level ?*) "\s")))
    (cond ((not on-heading-p)
           (insert heading))
          (above
           (goto-char (line-beginning-position))
           (insert heading)
           (save-excursion (insert newlines)))
          (t ; below
           (org-end-of-subtree)
           (insert (concat newlines heading))))
    (run-hooks 'org-insert-heading-hook)))
#+end_src

******** subheading
:PROPERTIES:
:ID: cf910dcf-6250-4b6a-80d5-63ac457d4a81
:END:

#+begin_src emacs-lisp
(defun org/insert-subheading ()
  "Insert subheading below current heading."
  (interactive)
  (org/insert-heading-below)
  (org-demote))
#+end_src

******** elisp block
:PROPERTIES:
:ID:       e03149e3-500f-45d6-a4c1-b2f69947b4d5
:END:

#+begin_src emacs-lisp
(defun org/dwim-insert-elisp-block ()
  "Insert elisp block."
  (interactive)
  (save-excursion
    (unless (org-at-heading-p)
      (org-back-to-heading))
    (org-end-of-subtree)
    (goto-char (line-end-position))
    (insert (concat "\n\n"
                    "#+begin_src emacs-lisp"
                    "\n"
                    "#+end_src"))
    (forward-line -1)))
#+end_src

******* org choose tags
:PROPERTIES:
:ID:       b8b0c3a2-2cdc-424f-9cd6-ef3ad3d1512c
:END:

#+begin_src emacs-lisp
(defun org/choose-tags ()
  "Select tags to add to headline."
  (interactive)
  (let* ((current (org-get-tags (point)))
         (selected (->> (org-get-buffer-tags)
                        (completing-read-multiple "Select org tag(s): "))))
    (alet (-distinct (append (-difference current selected)
                             (-difference selected current)))
      (org-set-tags it))))
#+end_src

******* eval
:PROPERTIES:
:ID: e804805a-ba96-41d0-aa6f-6756c65e9abf
:END:

#+begin_src emacs-lisp
(defun org/dwim-eval-block ()
  "Eval block contents."
  (interactive)
  (unless (org-at-heading-p)
    (user-error "Not in source block"))
  (save-window-excursion
    (org-babel-execute-subtree)))
#+end_src

***** links
:PROPERTIES:
:ID:       f70f36ae-1ef1-4dce-ad84-e4a8430f40a5
:END:

****** link snippets
:PROPERTIES:
:ID:       fd297eb5-e7b0-4dd5-b9f4-6d76f1426ade
:END:

This headline contains various snippets that help me insert org links quickly
and painlessly.

******* helpvar
:PROPERTIES:
:ID:       cc0ae97d-4cce-42de-bea0-7e195bd6168b
:END:

#+begin_src emacs-lisp
(defsnippet! helpvar ("hvar" org-mode)
  "Help function link."
  `("[[helpvar:" (C var "variable: " ,obarray helpful--variable-p) "][" (s var) "]]"))
#+end_src

******* helpfn
:PROPERTIES:
:ID:       7bd2651e-e3f8-4e76-822c-2208b71af0c3
:END:

#+begin_src emacs-lisp
(defsnippet! helpfn ("hfn" org-mode)
  "Help function link."
  '("[[helpfn:" (C fn "function: " help--symbol-completion-table) "][" (s fn) "]]"))
#+end_src

****** org-super-links
:PROPERTIES:
:ID:       f3eed884-408f-44cb-becc-17c1431060c5
:END:

#+begin_src emacs-lisp
(use-package! org-superlinks
  :ensure
  (:host github :type git :repo "toshism/org-super-links")
  :commands org-super-links-link
  :set
  (org-super-links-backlink-prefix      . nil)
  (org-super-links-related-into-drawer  . "LINKS")
  (org-super-links-backlink-into-drawer . "LINKS"))
#+end_src

****** org-link-minor-mode
:PROPERTIES:
:ID:       25b93a1f-b105-47aa-9647-5015d23a4ac3
:END:

This is a minor mode for displaying links in non-org buffers.

#+begin_src emacs-lisp
(use-package! org-link-minor-mode
  :hook outshine-mode-hook)
#+end_src

****** functions to insert certain links
:PROPERTIES:
:ID:       bbe9bd55-5f7d-4fd4-99b6-8fab27037f3c
:END:

For far too long I've been dissatisfied with functions that insert links.

******* choose from link types
:PROPERTIES:
:ID:       28075cac-714e-4d85-a0fb-e968c42df9f0
:END:

******* select IDs
:PROPERTIES:
:ID:       eaafbfbd-0994-4abb-9d83-1e8df4fc2389
:END:

***** org-todo-keywords
:PROPERTIES:
:ID:       aaa98680-d9b4-4726-b3ba-a50b3442e8e8
:END:

I like the terms "issue" and "closed" because they are more general than the
corresponding "todo" and "done". "Issue" simply implies a problem that needs to
be fixed. When I use =todo= I feel obligated to write what I have to do and
often I don't know that. Who knows? It could even be that nothing needs to be
done.

#+begin_src emacs-lisp
(set! org-todo-keywords
      '((sequence "ISSUE" "CLOSED")
	(sequence "TODO" "DONE")))
#+end_src

***** org-ml
:PROPERTIES:
:ID:       7f3ec0ad-45f8-4100-970e-773cfb9a625b
:END:

#+begin_src emacs-lisp
(use-package! org-ml)
#+end_src

***** org-journal
:PROPERTIES:
:ID:       c3056303-5fa1-49f9-ae2d-294942e25f54
:END:

=org-journal= is a package that provides functions to maintain a simple
diary/journal using =org-mode=.

#+begin_src emacs-lisp
(use-package! org-journal
  :commands org-journal-new-entry
  :set
  (org-journal-file-type . 'yearly)
  (org-journal-find-file . 'find-file)
  (org-journal-dir       . (concat org-directory "journal/")))
#+end_src

***** org src
:PROPERTIES:
:ID:       3294bf69-c10f-4ab6-9448-3c40d902935f
:END:

****** org-src
:PROPERTIES:
:ID:       e00378a1-adcf-4e83-8533-b6b442b5f362
:END:

#+begin_src emacs-lisp
(use-feature! org-src
  :idle-require t
  :popup ("bottom" "org source" :newfile "\\*Org Src")
  :set
  (org-src-window-setup                        . 'plain)
  (org-src-ask-before-returning-to-edit-buffer . nil)
  (org-edit-src-persistent-message             . nil)
  (org-src-preserve-indentation                . t)
  (org-confirm-babel-evaluate                  . nil)
  (org-src-tab-acts-natively                   . t)
  (org-src-fontify-natively                    . t)
  (org-babel-default-header-args               . '((:session . "none")
						   (:results . "silent")
						   (:exports . "code")
						   (:cache   .   "no")
						   (:initeb  .  "no")
						   (:hlines  .  "no")
						   (:tangle  .  "yes"))))
#+end_src

******* bindings in source block
:PROPERTIES:
:ID:       df270638-f6a7-4f0e-abe7-dd0c4e7df7ce
:END:

Note that you should have bindings that are different for entering and exiting
source blocks.

#+begin_src emacs-lisp
(defhook! enable-org-exit-src-bindings (org-src-mode-hook)
  (define-localleader-key!
    "," (list :def #'org-edit-src-exit  :wk "exit source block")
    "a" (list :def #'org-edit-src-abort :wk "abort source block")
    "c" (list :def #'org-edit-src-exit  :wk "exit source block")))
#+end_src

****** init org-src bindings
:PROPERTIES:
:ID:       3e119db7-48a2-4c8e-a8df-a973433bb289
:END:

#+begin_src emacs-lisp
(defhook! init-org-src-bindings (org-src-mode-hook)
  (general-def '(normal insert) org-src-mode-map
    ))
#+end_src

****** org/dwim-edit-src-block
:PROPERTIES:
:ID:       aedcd881-8ec3-4d23-bb80-d78a2eb0b430
:END:

#+begin_src emacs-lisp
(defun org/dwim-edit-src-code ()
  "Edit source block at point or under headline."
  (interactive)
  (unless (or (org-at-block-p) (org-in-src-block-p))
    (org-next-block 1))
  (call-interactively #'org-edit-src-code))
#+end_src

***** org-capture
:PROPERTIES:
:ID:       3225bbc4-9685-4e7b-ae32-41a26780d191
:END:

=org-capture= is a feature that allows you to quickly save a thought that popped
into your head while keeing disctractions to a minimum.

****** init
:PROPERTIES:
:ID:       8fc5d248-ff21-45e4-a48b-57cecd57b7a3
:END:

#+begin_src emacs-lisp
(use-feature! org-capture
  :idle-require t
  :before-call
  (ts     . org-capture)
  (org-ml . org-capture)
  :popup ("bottom" "capture" :newname "\\`CAPTURE-.+")
  :xl-config
  (after! evil (xl-hook-add 'org-capture-mode-hook #'evil-insert-state))
  :init
  (after! org-agenda (push (xl-capture-file) org-agenda-files)))
#+end_src

****** remove capture headerline
:PROPERTIES:
:ID: 7b8a8e1d-3c72-492f-9311-56a2428a1f1d
:END:

By default org capture templates display a header line. This was the answer to [[https://emacs.stackexchange.com/questions/53648/eliminate-org-capture-message][my
question]]. I need to disable =org-capture's= header-line.

#+begin_src emacs-lisp
(defhook! disable-header-line (org-capture-mode-hook)
  "Turn of the header line message."
  (setq-local header-line-format nil))
#+end_src

****** prevent capture templates from deleting windows
:PROPERTIES:
:ID:       a13e330a-33ff-4c1e-add4-00c5db4e6cd1
:END:

=org-capture= deletes all the other windows in the frame.

#+begin_src emacs-lisp
(defadvice! dont-delete-other-windows (:around org-capture-place-template)
  "Don't delete other windows when opening a capture template."
  (cl-letf (((symbol-function #'delete-other-windows) #'ignore))
    (apply <orig-fn> <args>)))
#+end_src

****** doct
:PROPERTIES:
:ID:       fa37f618-b58c-449b-a216-9d2f80ed12c6
:END:

[[https://github.com/progfolio/doct][doct]] is a package designed to ease writing and understanding capture templates
by allowing you to write them in a declarative style (see [[helpfn:doct][doct docstring]]).
In org mode, capture templates are [[info:org#Capture templates][represented as plain lists]]. This makes
it easy to forget what a certain element meant or to accidentally omit a capture
template element as you're writing it.

******* init
:PROPERTIES:
:ID:       0118ba87-219b-4611-9743-19228accaa2c
:END:

#+begin_src emacs-lisp
(use-package! doct
  :before-call org-capture)
#+end_src

******* add to capture templates
:PROPERTIES:
:ID:       16c55272-f8c2-4798-9da1-2ab492769f44
:END:

[[helpfn:doct][doct]] returns the new value of capture templates. but it does not actually add
it. For convenience this function declare it and add it in all in one go.
Additionally, it removes any capture templates with the same key so that I can
freely re-evaluate it without cluttering my capture templates with duplicate
entries.

#+begin_src emacs-lisp
(defun doct:add-to-templates (declarations)
  "Set `org-capture-templates' to the result of (doct DECLARATIONS).
Before adding result, remove any members of `org-capture-templates' with the
same key as the one(s) being added."
  (cl-labels ((clean (templates)
                     (when templates
                       (cons (car templates)
                             (--remove (string= (caar templates) (car it))
                                       (clean (cdr templates)))))))
    (setq org-capture-templates
          (clean (-concat (doct declarations) org-capture-templates)))))
#+end_src

****** completing-read org-capture
:PROPERTIES:
:ID:       ad2cc056-edda-490a-8cf9-10b370a21dc0
:END:

Org provides it's own default interface for capturing. To be consistent with how
we complete everything else--via [[helpfn:][completing-read]], I create a function which
let's me choose the template via completing-read.

******* capture templates
:PROPERTIES:
:ID:       c4fdb186-3509-42f1-9c3e-8bf80a5e6b47
:END:

#+begin_src emacs-lisp
(defun org-capture:template-list ()
  "Return a list of capture templates."
  (thread-first org-capture-templates
    (org-capture-upgrade-templates)
    (org-contextualize-keys org-capture-templates-contexts)))
#+end_src

******* replacement for =org-capture=
:PROPERTIES:
:ID:       4dd55ff4-7e6e-41f5-82f8-0db597959a17
:END:

#+begin_src emacs-lisp
(defun org-capture/choose-template ()
  (interactive)
  (require 'org-capture)
  (let* ((read-string (-map (fn! (format "%s %s" (car <>) (cadr <>)))
			    (org-capture:template-list)))
	 (selection (completing-read "Capture template: " read-string nil :require-match))
	 (key (car (split-string selection "\s" t))))
    (org-capture nil key)))

(general-def [remap org-capture] #'org-capture/choose-template)
#+end_src

****** capture templates
:PROPERTIES:
:ID:       a2a3f682-322a-450f-91bf-169d90f040c0
:END:

******* issue
:PROPERTIES:
:ID:       ef103d28-b746-42ba-ac1a-0462a19f03cd
:END:

******** issue capture template string
:PROPERTIES:
:ID:       a58f1de7-2049-4195-abfb-daad93a6ff2a
:END:

Instead of passing in the string I use =org-ml= to print the string.

#+begin_src emacs-lisp
(defun org-capture:issue-template ()
  "Return capture template for an issue."
  (->> (org-ml-build-headline! :title-text "%?")
       (org-ml-headline-set-node-property "ID" (org-id-new))
       (org-ml-headline-set-node-property "CREATED" (ts-format))
       (org-ml-set-property :todo-keyword "ISSUE")
       (org-ml-to-trimmed-string)))
#+end_src

******** issue
:PROPERTIES:
:ID:       2682910c-9620-4cbf-ab71-371ed29e25a1
:END:

#+begin_src emacs-lisp
(after! org-capture
  (doct:add-to-templates
   (list "issue"
	 :keys "i"
	 :template #'org-capture:issue-template
	 :file (xl-capture-file)
	 :prepend t
	 :empty-lines 1)))
#+end_src

***** org-clock
:PROPERTIES:
:ID:       d378471c-89df-48c9-a755-b79880f27308
:END:

=org-clock= is a built-in package that provides time logging functions for
tracking the time you spend on a particular task.

#+begin_src emacs-lisp
(use-feature! org-clock
  :idle-require t
  :commands org-clock-in org-clock-goto
  :hook (kill-emacs-hook . org-clock-save)
  :set
  (org-clock-persist      . 'history)
  (org-clock-persist-file . (concat XL-DATA-DIR "org-clock-save.el"))
  (org-clock-in-resume    . t)
  :xl-config
  (org-clock-persistence-insinuate))
#+end_src

***** org-agenda
:PROPERTIES:
:ID:       389bcdde-e2fb-401d-b4ec-47c73c8cf545
:END:

For any todo workflow, having a way to get an overview of the essential tasks
for a certain block of time is a must. =org-agenda= is this overview.

****** org-agenda
:PROPERTIES:
:ID:       efa9d237-b055-4bfb-a1f9-86d964b5f007
:END:

#+begin_src emacs-lisp
(use-feature! org-agenda
  :idle-require t
  :popup ("top" "org agenda" :newname "\\*Org Agenda\\*")
  :gc-pause org-agenda-list
  :set
  (org-agenda-text-search-extra-files . '(agenda-archives))
  (org-agenda-skip-unavailable-files  . t)
  (org-agenda-files                   . (list (xl-capture-file)))
  (org-agenda-start-on-weekday        . 0)
  (org-agenda-timegrid-use-ampm       . nil)
  (org-agenda-time-leading-zero       . t)
  (org-agenda-dim-blocked-tasks       . t)
  (org-agenda-inhibit-startup         . t))
#+end_src

****** respect display-buffer
:PROPERTIES:
:ID:       50933d82-1208-481d-8dc7-42630f3f3b41
:END:

=org= functions are known to try to configure buffer displays themselves. This
forces agenda view to rely on [[helpvar:display-buffer-alist][display-buffer-alist]] for it's display.

#+begin_src emacs-lisp
(defadvice! use-display-buffer (:override (abuf filter-alist) org-agenda-prepare-window)
  "Use `display-buffer' to display the agenda buffer.
Unlike `org-agenda-prepare-window', this function does not store the window configuration."
  (display-buffer abuf)
  (setq org-agenda-tag-filter (cdr (assq 'tag filter-alist)))
  (setq org-agenda-category-filter (cdr (assq 'cat filter-alist)))
  (setq org-agenda-effort-filter (cdr (assq 'effort filter-alist)))
  (setq org-agenda-regexp-filter (cdr (assq 're filter-alist)))

  (unless (equal (current-buffer) abuf)
    (pop-to-buffer-same-window abuf)))
#+end_src

****** org-super-agenda
:PROPERTIES:
:ID:       d708a7e8-0c24-4b1d-b57b-7ebd91a3ae05
:END:

=org-super-agenda= provides a powerful and convenient way to organize how the
org agenda buffer is displayed.

******* org-super-agenda
:PROPERTIES:
:ID:       e1fdf658-1fe4-40d5-9dbf-626a39f7d2ae
:END:

#+begin_src emacs-lisp
(use-package! org-super-agenda
  :before-call org-agenda-list
  :enable-on-load t)
#+end_src

******* testing org-super-agenda
:PROPERTIES:
:ID:       5d1a87bd-8d37-4ec0-abe9-73088b5754e8
:END:

#+begin_src emacs-lisp
(defun org-agenda/main-function ()
  "Return main function for org agenda."
  (interactive)
  (alet (list org-super-agenda:top-five-overdue-entries
	      org-super-agenda:due-today)
    (let ((org-super-agenda-groups it))
      (org-agenda-list))))
#+end_src

******* due today
:PROPERTIES:
:ID:       d2eb5003-d8d6-4451-918c-0a5b2b609f4f
:END:

#+begin_src emacs-lisp
(defvar org-super-agenda:due-today
  '(:name "Due Today"
    :deadline today)
  "Items due today.")
#+end_src

******* top five overdue entries
:PROPERTIES:
:ID:       9c825b83-057e-4373-9256-047e3d09f693
:END:

This doesn't yet do the top five. :slight_frown:

#+begin_src emacs-lisp
(defvar org-super-agenda:top-five-overdue-entries
  '(:name "Overdue"
    :time-grid t
    :deadline past)
  "Org Agenda group for top five overdue entries.")
#+end_src

***** org-refile
:PROPERTIES:
:ID:       6dfc0415-2945-4259-a782-b569fcb397ea
:END:

=org-refile= is a built-in package that.

#+begin_src emacs-lisp
(use-feature! org-refile
  :idle-require t
  :set
  (org-refile-targets                     . `((,(org:code-file) . (:level . 1))))
  (org-refile-use-outline-path            . 'file)
  (org-refile-allow-creating-parent-nodes . t)
  (org-reverse-note-order                 . t)
  (org-outline-path-complete-in-steps     . nil))
#+end_src

***** org-id
:PROPERTIES:
:ID:       95f2a096-2cf4-4634-aa32-13f00b31ea19
:END:

=org-id= is a built-in package that creates that provides tools for creating and
storing universally unique IDs. This is primarily used to disguish and
referenance org headlines.

#+begin_src emacs-lisp
(use-feature! org-id
  :idle-require t
  :hook (org-insert-heading-hook . org-id-get-create)
  :set
  (org-id-locations-file-relative . t)
  (org-id-link-to-org-use-id      . 'create-if-interactive-and-no-custom-id)
  (org-id-locations-file          . (xl-data-dir "org-id-locations"))
  (org-id-files                   . (list XL-MAIN-ORG-FILE)))
#+end_src

***** org-superstar
:PROPERTIES:
:ID:       c4428756-a804-47e8-9586-f63b82dd1561
:END:

#+begin_src emacs-lisp
(use-package! org-superstar
  :hook org-mode-hook
  :set
  (org-superstar-leading-bullet     . ?\s)
  (org-superstar-special-todo-items . t))
#+end_src

***** org-fancy-priorities
:PROPERTIES:
:ID:       c4ff4407-774c-4028-bb9d-01412fdfc8d2
:END:

#+begin_src emacs-lisp
(use-package! org-fancy-priorities
  :hook org-mode-hook)
#+end_src

***** org-pretty-tags
:PROPERTIES:
:ID:       7f024968-89ea-4e24-90a9-63771d8342b3
:END:

#+begin_src emacs-lisp
(use-package! org-pretty-tags
  :hook org-mode-hook)
#+end_src

***** org-toc
:PROPERTIES:
:ID:       aca910e9-364f-4631-a7eb-d7d6275b6472
:END:

This package creates a table of contents for your org file at the first headline
with the tag =:TOC:= on it. As you might have guessed [[helpvar:toc-org-max-depth][toc-org-max-depth]] is the
maximum dept at which toc will make the table of contents.

#+begin_src emacs-lisp
(use-package! toc-org
  :hook org-mode-hook
  :set
  (toc-org-max-depth . 2))
#+end_src

***** org mode snippets
:PROPERTIES:
:ID:       cd25f425-a4db-4a4c-be9e-4b672116048c
:END:

****** helpvar
:PROPERTIES:
:ID:       cc0ae97d-4cce-42de-bea0-7e195bd6168b
:END:

#+begin_src emacs-lisp
(defsnippet! helpvar ("hvar" org-mode)
  "Help function link."
  `("[[helpvar:" (C var "variable: " ,obarray helpful--variable-p) "][" (s var) "]]"))
#+end_src

****** helpfn
:PROPERTIES:
:ID:       7bd2651e-e3f8-4e76-822c-2208b71af0c3
:END:

#+begin_src emacs-lisp
(defsnippet! helpfn ("hfn" org-mode)
  "Help function link."
  '("[[helpfn:" (C fn "function: " help--symbol-completion-table) "][" (s fn) "]]"))
#+end_src

****** ids
:PROPERTIES:
:ID:       532aa739-3a53-4339-8121-fb9dce2dd914
:END:

#+begin_src emacs-lisp
(defsnippet! id-link ("scrot" org-mode)
  "Id link."
  '("[[" (C fn "id: " ()) "][" "hello" "]]"))
#+end_src

****** screenshot
:PROPERTIES:
:ID:       a9efb825-33f4-43d6-8240-ac3f17f10fcf
:END:

This snippet provides me with a convenient way to add links of screenshots I
have taken.

#+begin_src emacs-lisp
(defsnippet! screenshot-link ("scrot" org-mode)
  "Screenshot link."
  '("[[" (C fn "screenshots: " (xl-screenshots)) "][" "hello" "]]"))

(defun xl-screenshots ()
  "Return a list of all screenshots."
  (cddr (directory-files (xl-screenshot-dir))))
#+end_src

*** Asthetic
:PROPERTIES:
:ID: bd21a69a-794c-4ff1-97d0-9e5911a26ad7
:END:

It's easy to underestimate how much of a difference having an asthetically
pleasing Emacs configuration can have. Ugliness really can take its toll.

**** text scaling
:PROPERTIES:
:ID:       5d242d0e-eeab-46de-bcee-ecfd79b2bffc
:END:

I change the text scale frequently because in some cases, such as viewing my
main org file, I want a birds-eye view where I can see the structure of a
document at a glance. However, when I'm doing something like editing a source
block I want to focus on a very specific thing totally; therefore, I want the
text to take up most of the screen.

***** zoom-frm
:PROPERTIES:
:ID:       15b8577e-3f98-420a-81a5-c7b91292aca3
:END:

This package increases or decreases the font of the current frame. It differs
from [[helpfn:text-scale-increase][text-scale-increase]] and [[helpfn:text-scale-decrease][text-scale-decrease]] in that it applies this
"zooming" to the whole frame instead of the current buffer.

#+begin_src emacs-lisp
(use-package! zoom-frm
  :set
  (frame-zoom-font-difference . 0.5)
  (zoom-frame/buffer          . 'buffer))
#+end_src

**** emojis
:PROPERTIES:
:ID:       d3e15439-f690-4ced-b701-0882fb911a5c
:END:

This is a package that displays emojis! :D A major focus of my config is having
the ability to express myself well--in ways that is simply impossible with mere
documentation. This includes using emojis. Also, using emojis makes
documentation *much* more fun. :joy-cat:

#+begin_src emacs-lisp
(use-package! emojify
  :hook org-mode-hook
  :set
  (emojify-emojis-dir . (xl-data-dir "emojis/")))
#+end_src

**** mini-modeline
:PROPERTIES:
:ID:       51768ba1-170f-497b-9479-541e7c6aadd6
:END:

***** setup
:PROPERTIES:
:ID:       d9acb47b-089f-4b18-8fdd-94ffefb2ef86
:END:

These variables do stuff with displaying lines and separators to make the
modeline more visible. I do that myself with =window-divider= so I don't need
this.

#+begin_src emacs-lisp
(use-package! mini-modeline
  :demand t
  :hook (emacs-startup-hook . mini-modeline-mode)
  :set
  (mini-modeline-enhance-visual . nil)
  (mini-modeline-display-gui-line . nil))
#+end_src

***** default face
:PROPERTIES:
:ID:       1aab03cd-83b2-4d3a-bf3b-71f52dc6158d
:END:

If you don't set this, mini-modeline's background color won't
update with the theme. This is probably what the default value of this
variable should be anyway.

#+begin_src emacs-lisp
(use-package! mini-modeline
  :set
  (mini-modeline-face-attr . '(:inherit default)))
#+end_src

***** left format
:PROPERTIES:
:ID:       a7d11a8b-e792-43e5-9992-10df562e17ea
:END:

#+begin_src emacs-lisp
(setq mini-modeline-l-format
      '("%e" mode-line-buffer-identification))
#+end_src

***** right format
:PROPERTIES:
:ID:       fd79e9cb-40d7-4320-9b1d-248da4330bca
:END:

#+begin_src emacs-lisp
(setq mini-modeline-r-format
      '("%e"
	(:eval (awhen (mini-modeline:display-current-workgroup)
		(concat it " ")))
	(:eval (format-time-string "%a %m/%d %T"))))
#+end_src

***** set the modeline display
:PROPERTIES:
:ID:       37f062a8-b9d9-4533-ba8e-d675a1d5f10a
:END:

#+begin_src emacs-lisp
(defun mini-modeline:display-current-workgroup ()
  "Return the name of the current workgroup."
  (awhen (and (featurep 'workgroups2)
	      (wg-workgroup-name (wg-current-workgroup)))
    it))
#+end_src

***** dont redisplay
:PROPERTIES:
:ID:       b3afd056-7b0a-485f-8691-5cc7e4765ca1
:END:

Enabling =mini-modeline-mode= triggers a call to [[helpfn:redisplay][redisplay]]. During startup, this
takes a long time and makes emacs unresponsive for a few seconds. This redisplay
does not seem to be needed (feebleline doesn't do it and it works fine).

#+begin_src emacs-lisp
(defadvice! dont-redisplay (:around mini-modeline-mode)
  (cl-letf (((symbol-function #'redisplay) #'ignore))
    (apply <orig-fn> <args>)))
#+end_src

**** info
:PROPERTIES:
:ID:       d49f83c4-ba8f-477e-beef-8156ed8b974b
:END:

This headline is for customizing info nodes.

#+begin_src emacs-lisp
(use-feature! info
  :popup ("top" "info" :newname "\\*info"))
#+end_src

**** helpful
:PROPERTIES:
:ID:       5340ddb3-92bc-42e5-bf0e-9f9650c41cd9
:END:

[[github:wilfred/helpful][helpful]] provides a complete replacement for the built-in Emacs help facility
which provides much more contextual information in a better format.

#+begin_src emacs-lisp
(use-package! helpful
  :popup ("bottom" "help" :newname "\\*help.+")
  :general
  ([remap describe-function] #'helpful-callable
   [remap describe-command]  #'helpful-command
   [remap describe-variable] #'helpful-variable
   [remap describe-key]      #'helpful-key))
#+end_src

**** which-key
:PROPERTIES:
:ID:       2ad092a3-ff63-49cd-91b9-380c91dbe9f5
:END:

Emacs is full of so many keybindings, that it can be difficult to keep track of
them. Especially when you're starting out, but even when you're an Emacs-pro,
it's easy to forget what a particular functionality is bound to. Typically,
you'll remember the first few key strokes but struggle with the rest. To address
this [[github:][which-key]] displays key binding sequences in the minibuffer as your typing
them ([[][]] and [[][]] are screenshots of this in action). By doing this
you can "discover" the commands as you go along.

***** init
:PROPERTIES:
:ID:       c4aedc23-0be3-46fe-b046-32b5f0738c6b
:END:

#+begin_src emacs-lisp
(use-package! which-key
  :hook emacs-startup-hook
  :set
  (which-key-sort-uppercase-first . nil)
  (which-key-max-display-columns  . nil)
  (which-key-add-column-padding   . 1)
  (which-key-min-display-lines    . 6)
  (which-key-side-window-slot     . -10)
  (which-key-sort-order           . #'which-key-prefix-then-key-order)
  (which-key-popup-type           . 'minibuffer)
  (which-key-idle-delay           . 0.8))
#+end_src

***** set line spacing
:PROPERTIES:
:ID:       6abb35f4-c648-4bed-b59a-5a0636857fd8
:END:

#+begin_src emacs-lisp
(defhook! set-line-spacing (which-key-init-buffer-hook)
  (setq line-spacing 3))
#+end_src

***** leader keys
:PROPERTIES:
:ID:       1df41291-32c3-44ca-89a9-f042fb2bbd6c
:END:

#+begin_src emacs-lisp
(use-package! which-key :xl-config
  (which-key-add-key-based-replacements XL-LEADER-KEY "<leader>")
  (which-key-add-key-based-replacements XL-LOCALLEADER-KEY "<localleader>"))
#+end_src

**** dashboard
:PROPERTIES:
:ID: 20926522-b78b-4bca-b70e-9ef4213c4344
:END:

[[https://github.com/emacs-dashboard/emacs-dashboard][dashboard]] is an extensible emacs startup screen. I love the idea of =dashboard=:
having an extensible, fast, nice-looking dashboard when starting emacs is
nice. It's not only nice asthetically, it's also strategic too. First, you can
use it as a launching point to get to your tasks quicker. And second, it doesn't
require any expensive modes. I've often been starting out with the scratch
buffer and I've wanted to have the scratch buffer start off with
=emacs-lisp-mode=, but I don't want it to trigger =company=, =yasnippet=, etc. on
startup. If I start my emacs with =dashboard= I can avoid this.

***** init
:PROPERTIES:
:ID:       de94c9a8-fc05-46ec-ac06-510f1014e02d
:END:

****** random logo
:PROPERTIES:
:ID:       80e5fa17-d18a-4ec0-af8d-728d77843c69
:END:

#+begin_src emacs-lisp
(defun dashboard:random-logo ()
  "Display a random logo."
  (seq-random-elt
   (append '(1 2 3) (if (display-graphic-p) '(official logo)))))
#+end_src

****** require
:PROPERTIES:
:ID:       73d00f99-4b70-44d1-8359-01bd2c94b330
:END:

#+begin_src emacs-lisp
(use-package! dashboard
  :demand t
  :hook (window-setup-hook . dashboard-insert-startupify-lists)
  :set
  (dashboard-items . nil)
  (dashboard-startup-banner . (dashboard:random-logo))
  (dashboard-center-content . t)
  (initial-buffer-choice . #'startup:initial-buffer-choice))
#+end_src

****** open dashboard at startup
:PROPERTIES:
:ID:       1bcc371e-61fa-480e-bdae-4a999d3b10c9
:END:

#+begin_src emacs-lisp
(defadvice! open-dashboard-instead (:around startup:initial-buffer-choice)
  (if xl-debug-p
      (apply <orig-fn> <args>)
    (get-buffer-create "*dashboard*")))
#+end_src

***** dashboard-init-info
:PROPERTIES:
:ID: 92c199ad-5862-4fe3-be04-44c94d4286b6
:END:

[[helpvar:xl-init-time][xl-init-time]] is more accurate than dashboard's init time measure. So I use it
instead.

#+begin_src emacs-lisp
(defadvice! show-package-load-time (:before dashboard-insert-startupify-lists)
  (setq dashboard-init-info
        (format "%d packages loaded in %.2f seconds"
                (cond ((featurep 'straight)
                       (hash-table-size straight--profile-cache))
                      ((featurep 'package) (length package-activated-list))
                      (t 0))
                (string-to-number (emacs-init-time)))))
#+end_src

***** add icons to dashboard
:PROPERTIES:
:ID:       d4714639-919c-4691-9f7f-004cfa627089
:END:

#+begin_src emacs-lisp
#+end_src

**** window divider
:PROPERTIES:
:ID:       2cdd6e24-5153-4585-8f1f-206b33445359
:END:

Emacs can add border to windows using a mode called [[helpfn:window-divider-mode][window-divider-mode]].
Often in emacs you have multiple windows displaying different buffers on the
screen. By default the border between these windows is very thin, so it can be
hard to distinguish windows sometimes. The point of adding borders to windows is
to distinguish them easily from one another.

Window dividers are useful in general so I don't get confused about when one
window ends and another begins (see [[helpfn:window-divider-mode][window-divider-mode]]). When using [[I like emacs][exwm]] it
makes emacs feel like a window manager with gaps.

***** init
:PROPERTIES:
:ID:       c3e2fda8-89c8-4f3b-951a-113e936d6206
:END:

#+begin_src emacs-lisp
(use-feature! window-divider
  :hook (window-setup-hook . window-divider-mode)
  :set
  (window-divider-default-bottom-width . 7)
  (window-divider-default-right-width  . 7)
  (window-divider-default-places       . t))
#+end_src

***** window divider face
:PROPERTIES:
:ID:       61157149-dcce-40a9-8bfa-76a6af24838a
:END:

#+begin_src emacs-lisp
(defhook! set-window-divider-face (load-theme)
  :config window-divider
  (set-face-foreground 'window-divider "black"))
#+end_src

***** update on theme change
:PROPERTIES:
:ID: 342bd557-889b-4dbd-8e76-5cd9da3b0f74
:END:

#+begin_src emacs-lisp
(defhook! update-window-divider (xl-after-load-theme-hook)
  "Ensure window divider persists after theme change."
  :config window-divider
  (unless (bound-and-true-p window-divider-mode)
    (window-divider-mode 1)))
#+end_src

***** adjust window divider gap size
:PROPERTIES:
:ID:       5485c926-fac0-4e87-ae97-f7bf25d0a55c
:END:

****** TODO increase gap size
:PROPERTIES:
:ID:       867fad5c-b4d4-4cba-929e-0dc23f007c5b
:END:

Somtimes I might want to adjust this.

#+begin_src emacs-lisp
(defun +frame-adjust-window-divider-size (amount)
  "Adjust the gap size of window-divider by AMOUNT."
  (general-setq window-divider-default-bottom-width
                (+ amount window-divider-default-bottom-width))
  (general-setq window-divider-default-right-width
                (+ amount window-divider-default-right-width)))
#+end_src

****** increase
:PROPERTIES:
:ID:       ebd6b013-6213-42a1-9e95-fefc7e7da991
:END:

#+begin_src emacs-lisp
(defun frame/increment-window-divider-size ()
  "Increase window divider size."
  (interactive)
  (+frame-adjust-window-divider-size 1))
#+end_src

****** decrease
:PROPERTIES:
:ID:       6b1eb1cd-1cfd-4b82-a413-cb61fa13e0a4
:END:

#+begin_src emacs-lisp
(defun frame/decrement-window-divider-size ()
  "Decrease window divider size."
  (interactive)
  (+frame-adjust-window-divider-size -1))
#+end_src

**** zone
:PROPERTIES:
:ID:       fe176959-3134-4b18-8abb-a962347b8df0
:END:

*** Keybindings
:PROPERTIES:
:ID:       e4605d42-4d57-40d9-8594-15b06f6196a4
:END:

**** execute extended command
:PROPERTIES:
:ID: d8071a32-e58c-41ab-8fd7-7d7732708ee8
:END:

One of the most common--if not the most common--command you use in Emacs is
[[helpfn:execute-extended-command][execute-extended-command]]. This command let's you search any other command and
upon pressing enter, then you execute the command. The fact that this command is
invoked so frequently demands it have one of the shortest, easiest to press
bindings. I chose to give it =SPC SPC= and =;=. =SPC SPC= is short and quick to
type as well as consistent with other =SPC= bindings. While =;= is super fast to
press as well and even faster than =SPC SPC=.

#+begin_src emacs-lisp
(define-leader-key! "SPC"
  (list :def #'execute-extended-command :wk "M-x"))

(general-def 'normal
  ";" #'execute-extended-command)

(general-def
  "A-x" #'execute-extended-command
  "M-x" #'execute-extended-command)
#+end_src

**** bindings that should be available everywhere
:PROPERTIES:
:ID:       cfb08f5e-9e6e-4e9f-ab85-92f9cc26f1bd
:END:

#+begin_src emacs-lisp
(define-localleader-key!
  "a" (list :def #'org-agenda         :wk "agenda")
  "s" (list :def #'xl/open-scratch  :wk "scratch")
  "f" (list :def #'xl/set-font-size :wk "font size")
  "c" (list :def #'org-capture        :wk "capture"))

(define-leader-key!
  :infix "t"
  :keymaps 'org-mode-map
  "l" (list :def #'org-toggle-link-display :wk "link display"))
#+end_src

**** space bindings
:PROPERTIES:
:ID:       8f00f10d-0ace-4531-a3f4-2508a6592e06
:END:

***** eval
:PROPERTIES:
:ID: afa6be08-a38c-45f1-867a-5620fc290aac
:END:

#+begin_src emacs-lisp
(define-leader-key! "e" (list :ignore t :wk "eval"))

(define-leader-key!
  :infix "e"
  "e" (list :def #'eval-expression :wk "expression")
  "r" (list :def #'eval-region          :wk "region")
  "d" (list :def #'eval-defun           :wk "defun")
  "l" (list :def #'eval-print-last-sexp :wk "sexp")
  "B" (list :def #'eval-buffer          :wk "buffer"))

(define-leader-key!
  :infix "e"
  :keymaps 'org-mode-map
  "b" (list :def #'org-babel-execute-src-block :wk "source block")
  "s" (list :def #'org-babel-execute-subtree :wk "subtree"))
#+end_src

***** packages
:PROPERTIES:
:ID: d3286920-ead4-4f7c-bf9d-8a6ed3d7ba46
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "p"
  ""  (list :ignore t                       :wk "package")
  "i" (list :def #'straight-use-package     :wk "install")
  "r" (list :def #'straight-rebuild-package :wk "rebuild")
  "p" (list :def #'straight-pull-package    :wk "pull")
  "s" (list :def #'straight/search-package  :wk "search"))
#+end_src

***** git
:PROPERTIES:
:ID: 87ba6613-6606-423c-84ec-f7c9ae10c9a6
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "g"
  ""  (list :ignore t           :wk "git")
  "c" (list :def #'magit-commit :wk "commit")
  "s" (list :def #'magit-status :wk "status"))
#+end_src

***** toggle
:PROPERTIES:
:ID: 10d6851b-6af6-4185-8976-0ad65b3d1d28
:END:

#+begin_src emacs-lisp
(define-leader-key! "t" (list :ignore t :wk "toggle/set"))

(define-leader-key!
  :infix "t"
  "r" (list :def #'read-only-mode        :wk "read-only")
  "t" (list :def #'load-theme            :wk "load theme")
  "c" (list :def #'caps-lock-mode        :wk "caps lock")
  "d" (list :def #'toggle-debug-on-error :wk "debug")
  "F" (list :def #'xl/set-font-face    :wk "set font")
  "f" (list :def #'xl/set-font-size    :wk "font size"))

(define-leader-key!
  :infix "t"
  :keymaps 'org-mode-map
  "l" (list :def #'org-toggle-link-display :wk "link display"))
#+end_src

***** help
:PROPERTIES:
:ID: c7f3b699-7cf9-480b-a88c-10bdae4c165e
:END:

There's a lot of documentation finding and information searching involved in
Emacs and for that we need all the help we can get.

#+begin_src emacs-lisp
(define-leader-key!
  :infix "h"
  ""  (list :ignore t                :wk "help")
  "i" (list :def #'info              :wk "info")
  "m" (list :def #'describe-mode     :wk "mode")
  "h" (list :def #'describe-function :wk "function")
  "v" (list :def #'describe-variable :wk "variable")
  "c" (list :def #'describe-char     :wk "char")
  "k" (list :def #'describe-key      :wk "key")
  "f" (list :def #'describe-function :wk "function")
  "a" (list :def #'apropos           :wk "apropos")
  "w" (list :def #'woman             :wk "woman"))
#+end_src

***** quit
:PROPERTIES:
:ID:       ae435361-79e7-41c8-b490-8ec0f8d23a59
:END:

There's many ways to quit Emacs. Sometimes I'd like to save all the buffers I
had been working on. Sometimes, when I'm testing something and I mess up
[[helpvar:kill-emacs-hook][kill-emacs-hook]] I want Emacs to just quit even if it means ignoring that hook.
Most of the time, I know what I'm doing when I quit Emacs, so I don't want a
prompt asking me if I'm sure.

#+begin_src emacs-lisp
(define-leader-key!
  :infix "q"
  ""  (list :ignore t                      :wk "quit")
  "q" (list :def #'evil-quit-all           :wk "normally")
  "s" (list :def #'xl/quit-emacs-no-prompt :wk "with no prompt")
  "Q" (list :def #'evil-save-and-quit      :wk "and save")
  "x" (list :def #'xl/kill-emacs-no-hook   :wk "with no hook")
  "e" (list :def #'xl/kill-emacs-processes :wk "emacs processes")
  "b" (list :def #'xl/kill-emacs-brutally  :wk "brutally")
  ;; "r" (list :def #'restart-emacs           :wk "and restart")
  )
#+end_src

***** buffer
:PROPERTIES:
:ID: e3eec4f8-88d8-4010-adb5-2f8e05f14677
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "b"
  ""  (list :def nil                             :wk "buffer")
  "p" (list :def #'previous-buffer               :wk "previous")
  "n" (list :def #'next-buffer                   :wk "next")
  "o" (list :def #'switch-to-buffer-other-window :wk "switch other window")
  "b" (list :def #'switch-to-buffer              :wk "switch")
  "d" (list :def #'display-buffer                :wk "display"))

(define-leader-key!
  :infix "b k"
  ""  (list :ignore t             :wk "kill")
  "c" (list #'kill-current-buffer :wk "current"))

(define-leader-key!
  :infix "b c"
  ""  (list :ignore t                  :wk "common buffers")
  "m" (list :def #'xl/open-messages  :wk "*Messages*")
  "s" (list :def #'xl/open-scratch   :wk "*scratch*")
  "i" (list :def #'xl/open-init-file :wk "init"))
#+end_src

***** code
:PROPERTIES:
:ID: 661f77fb-3435-4e4f-8adb-c4d6390ea6b8
:END:

These bindings are for generally working with code.

#+begin_src emacs-lisp
(define-leader-key! "c" (list :ignore t :wk "code"))

(define-leader-key!
  :infix "c"
  "a" (list :def #'ialign                               :wk "align")
  "l" (list :def #'lispyville-comment-or-uncomment-line :wk "toggle comment")
  "y" (list :def #'lispyvile-comment-and-cone-dwim      :wk "copy comment"))
#+end_src

***** app
:PROPERTIES:
:ID: 3f09a41a-03b8-4d5c-85c5-d7adeb7dd328
:END:

These are keybindings I use most frequently.

#+begin_src emacs-lisp
(define-leader-key! "a" (list :ignore t :wk "app"))

(define-leader-key!
  :infix "a"
  "a" (list :def #'xl/open-org-agenda        :wk "agenda")
  "m" (list :def #'mu4e                        :wk "mu4e")
  "l" (list :def #'org-store-link              :wk "store link")
  "f" (list :def #'elfeed                      :wk "elfeed")
  "d" (list :def #'deer                        :wk "deer")
  "r" (list :def #'ranger                      :wk "ranger")
  "e" (list :def #'xl/open-emacs-instance    :wk "emacs")
  "q" (list :def #'engine/search-duckduckgo    :wk "browse web")
  "j" (list :def #'org/avy-goto-headline       :wk "heading jump")
  "c" (list :def #'org-capture :wk "capture"))
#+end_src

***** search
:PROPERTIES:
:ID: b50ed0da-652d-4d20-8a4e-e0cf053548a6
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "s"
  ""  (list :ignore t                       :wk "search")
  "s" (list :def #'consult-line             :wk "jump to line")
  "w" (list :def #'engine/search-duckduckgo :wk "web")
  "h" (list :def #'consult-outline          :wk "jump to outline heading"))
#+end_src

* email
:PROPERTIES:
:ID:       cff26aaa-5e46-411f-bbca-f4a5545e8e51
:HEADER-ARGS: :tangle no
:END:

The purpose of the headline is to generate my =mbsyncrc= and my =msmtprc=.

I do this for two reasons (1) because the DSL for these configs consumes a lot
of boilerplate and (2) because I dynamically generate the config based on my
accounts.

** some notes on the config
:PROPERTIES:
:ID:       8e29608b-eb6d-4116-a25d-9060230b7c8f
:END:

*** design
:PROPERTIES:
:ID:       e3900bee-fdde-41d2-a370-4cb5e32b9c45
:END:

In terms of design im confused :confused:. I'm unsure how the control flow
between this and the other code in my config should work. I think the =mbsyncrc=
and the =msmtprc= should be created when my dotfiles are tangled. And I so that
I have a good experience with my email I should probably asyncronously download
it with Emacs.

*** newlines between certain fields are *mandatory*
:PROPERTIES:
:ID:       9674bc60-a380-42d9-afc2-af342dec8bc8
:END:

#+begin_src emacs-lisp
#+end_src

*** the mail directory and the local directories *must* exist
:PROPERTIES:
:ID:       00f647ab-7903-44af-883d-df673c95e28f
:END:

This means that just generating these files and running =mbsync -a= will not
work.

** helpers
:PROPERTIES:
:ID:       f6e1e6b2-5f16-4c28-9591-260354a055e8
:END:

*** noweb helpers
:PROPERTIES:
:ID:       80df9191-15ae-4559-a666-88869796e287
:END:

*** email accounts
:PROPERTIES:
:ID:       44e3c55d-2501-45d8-8d48-5ea92d5dac75
:END:

#+begin_src emacs-lisp
(defun dotfiles:email-accounts ()
  "Return a list of email account entries."
  (require 'password-store)
  (-filter (fn (s-matches-p "\\`email/" <>))
	   (password-store-list)))
#+end_src

*** with-pass-fields!
:PROPERTIES:
:ID:       e8f8b57d-91a7-4ae8-884d-3d8bc7484ed7
:END:

This macro lets me get all the fields and stores them into variables.

#+begin_src emacs-lisp :tangle no
(defmacro with-pass-fields! (entry &rest body)
  (declare (indent defun))
  (alet (loopy ((list symbol (xl-anaphoric-symbols body))
		(expr true-symbol (xl-to-string (xl-anaphoric-true-symbol symbol)))
		(expr field `(password-store-get-field ,entry ,true-symbol))
		(collect (list symbol field))))
    `(let ,it ,@body)))
#+end_src

*** dotfile string
:PROPERTIES:
:ID:       fb810e86-405b-4bf0-ae81-9a476b2cf19e
:END:

#+begin_src emacs-lisp
(defun dotfiles:config-string (&rest plist)
  "Convert PLIST into."
  (loopy ((list (key value) (-partition 2 plist))
	  (expr config-key (xl-keyword-name key))
	  (expr config-val (xl-to-string value))
	  (collect strings (format "%s %s" config-key config-val)))
	 (finally-return (s-join "\n" strings))))
#+end_src

** mbsync
:PROPERTIES:
:ID:       532cd56a-45c8-4cd3-819f-cd1f5fca3e5d
:END:

The. The setup for mbsync contains many repetative blocks of it's DSL which are
multiplied by the number of.

*** mbsync account setup
:PROPERTIES:
:ID:       1e503ace-8af6-46a1-9ec0-62cef1372adf
:END:

#+begin_src emacs-lisp :tangle no
(defun xl-mbsync:mbsyncrc-imap-account-setup (entry)
  "Return the account part of the."
  (with-pass-fields! entry
    (xl-mbsync:config-string
     :IMAPAccount     <account>
     :Host            <server>
     :User            <email>
     :PassCmd         (format "\"pass email/%s | head -n 1\"" <email>)
     :SSLType         'IMAPS
     :CertificateFile '/etc/ssl/certs/ca-certificates.crt
     :Port            <in-port>)))
#+end_src

*** account store
:PROPERTIES:
:ID:       855ccfb5-ae4c-441e-9c3c-dc5c9cd83d24
:END:

Note that the newlines separating the [[helpfn:xl-mbsync:config-string][dotfiles:config-string]] calls are
*mandatory*. Without them mbsync will produce an error.

#+begin_src emacs-lisp :tangle no
(defun xl-mbsync:mbsyncrc-imap-store-setup (entry)
  "Return the remote part of mbsync."
  (with-pass-fields! entry
    (concat
     (xl-mbsync:config-string
      :IMAPStore    (format "%s-remote" <account>)
      :Account      <account>)
     "\n\n"
     (xl-mbsync:config-string
      :MaildirStore (format "%s-local"         <account>)
      :Subfolders   'Verbatim
      :Path         (format "~/.mail/%s/"      <email>)
      :Inbox        (format "~/.mail/%s/Inbox" <email>)))))
#+end_src

*** sync
:PROPERTIES:
:ID:       ba6836ff-1554-4cb1-84a2-320afe38183f
:END:

#+begin_src emacs-lisp
(defun xl-mbsync:mbsyncrc-sync-all (entry)
  "Return the sync all string of the mbsync."
  (with-pass-fields! entry
    (xl-mbsync:config-string
     :Channel   <account>
     :Master    (format ":%s-remote:" <account>)
     :Slave     (format ":%s-local:"  <account>)
     :Patterns  '*
     :Create    'Both
     :SyncState '*)))
#+end_src

*** account
:PROPERTIES:
:ID:       20962e17-ddae-465f-9123-ae8918539c6a
:END:

#+begin_src emacs-lisp :tangle no
(defun xl-mbsync:mbsyncrc-account-string (entry)
  (alet (list (xl-mbsync:mbsyncrc-imap-account-setup entry)
              (xl-mbsync:mbsyncrc-imap-store-setup entry)
              (if (s-matches-p (rx "@gmail.com") entry)
                  (xl-mbsync:mbsyncrc-sync-gmail entry)
                (xl-mbsync:mbsyncrc-sync-all entry)))
    (s-join "\n\n" it)))
#+end_src

*** gmail account sync settings
:PROPERTIES:
:ID:       39b9d98f-223e-46f4-a136-a79292d96617
:END:

#+begin_src emacs-lisp :tangle no
(defun xl-mbsync:mbsyncrc-sync-gmail-section (name mailbox)
  (xl-mbsync:config-string
   :Channel (format "gmail-%s" name)
   :Master (format ":gmail-remote:\"[Gmail]/%s\"" mailbox)
   :Slave (format ":gmail-local:%s" name)
   :Create 'Slave
   :SyncState '*))

(defun xl-mbsync:mbsyncrc-sync-gmail (entry)
  (let* ((mailboxes '("All Mail" "Drafts" "Sent Mail" "Spam" "Starred" "Trash"))
         (names (--map (downcase (-first-item (s-split-words it))) mailboxes)))
    (alet (seq-map (-lambda ((n m)) (xl-mbsync:mbsyncrc-sync-gmail-section n m))
                   (seq-mapn #'list names mailboxes))
      (concat (s-join "\n\n" it)
              "\n\n"
              (s-join "\n" (cons "Group gmail" (--map (format "Channel gmail-%s" it) names)))))))
#+end_src

*** generate everything
:PROPERTIES:
:ID:       05e5b77b-20da-4185-8870-810aafb79c5d
:END:

#+begin_src emacs-lisp
(defun xl-mbsync:mbsync-contents ()
  "Return the contents of the mbsync file."
  (loopy ((list entry (xl-mbsync:email-accounts))
	  (collect contents (xl-mbsync:mbsyncrc-account-string entry)))
	 (return (s-join "\n" contents))))
#+end_src

** msmtprc
:PROPERTIES:
:ID:       881dfeda-6370-4cbd-b385-f2e49bf042c0
:HEADER-ARGS: :tangle no
:END:

The =msmtprc= is where we configure sending emails. There's a lot of boilerplate
here to process.

*** account information
:PROPERTIES:
:ID:       7f888dc8-1c41-478c-accd-6a038a96ec3c
:END:

For each email account I have will need the information.

#+begin_src emacs-lisp :tangle no
(defun xl-msmtp:account-block (entry)
  "Return account string for msmtprc."
  (with-pass-fields! entry
    (xl-msmtp:config-string
     :account      <account>
     :host         <out-host>
     :from         <email>
     :port         <out-port>
     :user         <email>
     :passwordeval (format "\"pass %s | head -n 1\"" entry))))
#+end_src

*** account-info
:PROPERTIES:
:ID:       82d845cb-685b-4f64-a194-99e840561c98
:END:

#+begin_src emacs-lisp :tangle no
(defun xl-msmtp:msmtprc-accounts ()
  (->> (xl-msmtp:email-accounts)
       (seq-map #'xl-msmtp:msmtprc-account-string)
       (s-join "\n\n")))
#+end_src

*** header
:PROPERTIES:
:ID:       f67fe959-9db1-47b5-9faf-5ebfe98bf438
:END:

#+begin_src emacs-lisp
(defun xl-msmtp:header ()
  "Header of the `msmtprc' file."
  (concat
   "defaults"
   "\n\n"
   (dotfiles:config-string
    :auth           'on
    :tls            'on
    :tls_trust_file '/etc/ssl/certs/ca-certificates.crt
    :logfile        '~/.msmtp.log)))
#+end_src

*** default
:PROPERTIES:
:ID:       a97c4dd0-07e3-4368-b116-5cc567c437fa
:END:

#+begin_src ema                                                                                             cs-lisp
(defun xl-msmtp:account-default ()
  "Return account default."
  (format "account : default luishp"))
#+end_src

*** main function
:PROPERTIES:
:ID:       9a242a5e-afdb-418f-bd8f-eaacb64363f1
:END:

#+begin_src emacs-lisp
(defun xl-msmtp:generate-msmtprc (&optional path)
  "Generate the msmtprc file."
  (xl-msmtp:header)
  (xl-msmtp:accounts)
  (xl-msmtp:default-account))
#+end_src

