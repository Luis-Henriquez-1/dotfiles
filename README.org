* About
:PROPERTIES:
:ID:       35454181-33bc-412e-a4a6-4268909d26d7
:END:

This single org file contains the contents of all my dotfiles and
configurations. Upon [[https://orgmode.org/manual/Extracting-Source-Code.html][tangling]] it will dynamically generate all of them in the
correct locations.

** why set up my dot files this way?
:PROPERTIES:
:ID:       59aa853c-1764-41f6-bee4-b01bea1733ff
:END:

It took me a long time to come to the conclusion to set up my dotfiles like
this. It's certainly unorthodox. However, I was convinced by the benefits.

*** simple file/directory structure
:PROPERTIES:
:ID:       ed3ac468-ef9b-4be5-8f2d-44fb29a6ac77
:END:

It is simpler to have everything (except a small amount of bootstrap code) in
one file as opposed to having a complex heirarchy of files and directories.

*** consistent documentation throughout
:PROPERTIES:
:ID:       4fb4fd3b-508c-4454-b831-db7e8827e035
:END:

Configuration files are often in different languages. Different languages have
different comment syntax. Having my configuration files in an org-mode files
means I can have consistent documentation that's all in the same
syntax. Moreover, the structure of an Org file does well to homogenize the
varying differences of a language.

*** more expressive documentation
:PROPERTIES:
:ID:       d55cdbb7-f2c1-4cae-a80f-0ff22652f1c4
:END:

Documentation comments are not expressive enough. Sometimes, I want to show a
picture or a gif of what I'm talking about. Other times, I want to reference
some other file or some place in a file or a link to a website. Even adding
emphasis to certain things could be useful. Comments can't do any of this, but
[[https://orgmode.org/][Org]] can.

*** dynamism
:PROPERTIES:
:ID:       f77797b8-172e-4482-87a4-5ede829b3b13
:END:

When you initialize dotfiles on different machine settings can be different.

** how it's tangled
:PROPERTIES:
:ID:       e208e820-cb37-40f5-912e-bad4abf1fd5a
:END:

I use [[https://yadm.io/][yadm]] to manage my dotfiles (more on that here). To initialize yadm you
use [[][]] to bootstrap. First =yadm clone=.

* helpers
:PROPERTIES:
:ID:       67138086-b894-43b7-8c97-1980acad52b8
:END:

** evaluation nowebs
:PROPERTIES:
:ID:       8d68503c-75a2-463b-b286-6490c9c8b97b
:END:

=nowebs= are what I mean when I say [[id:f77797b8-172e-4482-87a4-5ede829b3b13][dynamic]] generation. Typically nowebs are
used to insert a block of code somewhere else, kind of like a copy paste sort of
things. This can be useful, specifically when you want to talk about with lisp
code that is in one form such as the [[id][config.scm]].

It allows me to add the result of a lisp expression that was computed when the
org file was tangled.

One way you could insert the evaluated code is by using <<noweb()>>.

*** give =org= the ability to evaluate sexps in noweb
:PROPERTIES:
:ID:       56390470-b5a6-4bc9-a4db-349bc8377e6e
:END:

#+name: eval
#+begin_src emacs-lisp :var string=""
string
#+end_src

*** as a string
:PROPERTIES:
:ID:       b857023e-1ad5-4ad5-8d61-6e5aeef6aba5
:END:

#+name: string
#+begin_src emacs-lisp :var string=""
(format "%S" string)
#+end_src

*** function that takes an org-id
:PROPERTIES:
:ID:       ce115a7d-ab3e-4921-9f20-c34fb81241dc
:END:

I'm interested in producing side-effects when tangling.

Evaluating source blocks whose id.

#+begin_src emacs-lisp :tangle ~/.config/emacs/init.el
(require 'org-id)
#+end_src

* xinit
:PROPERTIES:
:ID:       cf328230-ca3a-48a2-8dda-b4e9e4ff1e4c
:HEADER-ARGS: :tangle ~/.xinitrc
:END:

The [[https://wiki.archlinux.org/index.php/Xinit#xinitrc][.xinitrc]] is what [[https://wiki.archlinux.org/index.php/Xorg][xorg]] uses to determine how to set up a
graphical environment.

** first remap caps lock with escape
:PROPERTIES:
:ID:       fa0904bb-1597-45bf-a944-8b48955cef0c
:END:

Coming from a vim background and currently using [[git][evil]], I've come to rely on the
escape key heavily as a "quit everything" binding. I press it much more often
than the caps-lock key--actually I think I don't ever use the caps-lock
key. Even in emacs, there's [[https://github.com/emacs-straight/caps-lock][caps-lock]], so I'm not sure if I need it at all.

#+begin_src sh
setxkbmap -option caps:swapescape
#+end_src

** the load emacs
:PROPERTIES:
:ID:       af14d611-79a0-4604-8c02-24bc608d32fb
:END:

Obviously, we load our OS. In the future, I may use a display manager so I can
easily switch between emacs, stumpwm or any other window manager of my choosing.

#+begin_src sh
exec emacs
#+end_src

* guix
:PROPERTIES:
:ID:       3bc3c0b2-a45b-4ce1-86c7-f4d88a8e69bd
:END:

My main OS currently is [[https://guix.gnu.org/][guix]].

** starting org on guix
:PROPERTIES:
:ID:       9bd14aeb-1b7d-4cdd-8c79-5e92da7606dc
:END:

I'm am not keen on paying the cost of starting a [[https://wiki.archlinux.org/index.php/Display_Manager#Console][login manager]] at startup. I
don't see a great benefit to having a graphical login manager and I prefer the
flexibility of being able to use the command line before initializing a
graphical display.

Right now, shepard is admittedly rather slow in starting up. It's even slower
when it has to begin a display manager.

#+begin_src sh :tangle ~/xinit.sh
#!/bin/sh

DIR=$HOME/.guix-profile

$DIR/bin/xinit -- $DIR/bin/Xorg :0 vt1 -keeptty \
	       -configdir $DIR/share/X11/xorg.conf.d \
	       -modulepath $DIR/lib/xorg/modules
#+end_src

** config.scm
:PROPERTIES:
:ID:       4af8c932-566c-480f-ad35-2667ae7d3cf2
:END:

The =config.scm= is the file the determines everything about the guix operating
system. If you've installed arch or another linux distro from scratch or if you
have some knowledge about OS setup you should find many of these fields familiar.

*** module declaration
:PROPERTIES:
:ID:       46a8e991-e102-44cf-9646-d52e67f41413
:END:

#+name: modules
#+begin_src emacs-lisp
(use-modules (gnu)
	     (srfi srfi-1)
	     (gnu services desktop))
#+end_src

*** miscellaneous
:PROPERTIES:
:ID:       5179b9e5-c40a-4839-85de-bd38abfd373e
:END:

#+begin_src emacs-lisp
(locale "en_US.utf8")
(timezone "America/New_York")
(keyboard-layout (keyboard-layout "us"))
(host-name "antelope")
#+end_src

*** bootloader 
:PROPERTIES:
:ID:       8ecad680-34d8-4e5c-b239-ae3767293036
:END:

The bootloader is what is repsonsible for booting your system.

#+name: bootloader
#+begin_src emacs-lisp
(bootloader
 (bootloader-configuration
  (bootloader grub-bootloader)
  (target "/dev/sda")
  (keyboard-layout keyboard-layout)))
#+end_src

*** users
:PROPERTIES:
:ID:       23bef30c-77f5-443e-acb0-cb01a2072ab0
:END:

I'm the only one who uses my computer.

#+name: users
#+begin_src emacs-lisp
(users (cons* (user-account
               (name "luis")
	       (comment "Luis")
               (group "users")
               (home-directory "/home/luis")
               (supplementary-groups
                '("wheel" "netdev" "audio" "video")))
              %base-user-accounts))
#+end_src

*** packages
:PROPERTIES:
:ID:       d33e0c8e-e1a8-4db9-aa9c-4a862616adeb
:END:

This field corresponds to the place where packages should go. In the future I
want to add package versions to these packages so that I can make my dotfiles
truly reproducable.

#+name: packages
#+begin_src emacs-lisp
(packages
 (append
  (list (specification->package "emacs")
        (specification->package "emacs-exwm")
        (specification->package "emacs-desktop-environment")
        (specification->package "nss-certs"))
  %base-packages))
#+end_src

*** services
:PROPERTIES:
:ID:       a29f1980-9af4-4bf0-a463-1897f1551cab
:END:

**** laptop lid
:PROPERTIES:
:ID:       8f8801dd-7dce-4c26-bce4-39dc9df43917
:END:

Guix uses [[][elogind]]. Elogind controls things like user login. It also
controls what happens during certain events such as laptop lid open and
close. By default elogind.

#+begin_src emacs-lisp
()
#+end_src

**** all services
:PROPERTIES:
:ID:       f85713f7-8ebf-46ca-8933-28002bef98a8
:END:

*** whole config
:PROPERTIES:
:ID:       6c44a3c0-379f-410c-918b-71f03171d514
:END:

#+begin_src emacs-lisp :tangle ~/.config/guix/config.scm
(operating-system
 <<module-declaration>>
 <<bootloader>>
 <<users>>
 <<packages>>
 <<services>>)
#+end_src

* gpg-agent
:PROPERTIES:
:ID:       58a65d49-cd9f-4b5d-86d7-d43209424cf3
:HEADER-ARGS: :tangle ~/.config/gnupg/gpg-agent.conf
:END:

Of course we want emacs to manage our pinentry. While it may be less secure I
like not being prompted for a gpg password.

#+begin_src conf
pinentry-program <<eval((executable-find "pinentry-emacs"))>>
allow-loopback-pinentry
allow-emacs-pinentry
default-cache-ttl 60000
#+end_src

* git config
:PROPERTIES:
:ID:       a4cf5803-05b1-4133-bd73-01638673d2e3
:HEADER-ARGS: ~/.config/git/config
:END:

The [[https://www.git-scm.com/book/en/v2/Customizing-Git-Git-Configuration][git-config]] contains settings you need for making a commit, such as your name
and email and optionally your public gpg key.

#+begin_src conf
[user]
	name = Luis Henriquez-Perez
	email = luis@luishp.xyz
	signingkey = C3F33DA91721A6B7365FBF668DAA027F8C199794
[commit]
	gpgsign = true
[gpg]
	program = <<eval((executable-find "gpg"))>>
#+end_src

* nyxt browser
:PROPERTIES:
:ID:       069672ed-29ad-4973-b2cd-1eb275d7e6d4
:HEADER-ARGS: :tangle ~/.config/nyxt/init.lisp
:END:

The [[https://nyxt.atlas.engineer/][nyxt browser]] is a web browser written entirely in common lisp.

** setup vim mode
:PROPERTIES:
:ID:       f505e5ac-cb88-4e50-8cbd-e9a5b5cfddbc
:END:

#+begin_src emacs-lisp
#+end_src

* stumpwm
:PROPERTIES:
:ID:       4358b82c-1736-4609-aebe-02447d9c1703
:HEADER-ARGS: :tangle ~/.config/stumpwm/stumwmrc
:END:

I have this os installed in case I want to play around or in case exwm crashes
and my emacs is in an inconvenient to fix place (although I can always go back).

* emacs
:PROPERTIES:
:ID:       8c10b42b-9317-49a8-8ce0-128a2efc8905
:END:

This heading is for Emacs.

** early-init
:PROPERTIES:
:ID:       1b29f0d7-63ab-46b8-abf4-51cb930d8be8
:HEADER-ARGS: :tangle ~/.config/emacs/early-init.el
:END:

The early-init file.

*** compute the font upon tangling
:PROPERTIES:
:ID:       62b28647-262f-4657-a57e-79e8a98c2a11
:END:

There's a chicken and egg problem with fonts. What you'd like to do to have a
robust emacs config is have a list of backup fonts that you check in order of
preference until you find the one that is available on your system. Moreover, to
be efficient, you'd like to do this check before the frame is initialized.
Problem is the functions emacs provide to check system fonts depend on the
initialization of the emacs frame.

#+name: font
#+begin_src emacs-lisp :tangle no
(defvar xl-backup-fonts (list "hermit" "mononoki" "iosevka" "anonymous-pro")
  "List of fonts that should be used.")

(defun xl-most-preferred-font-available ()
  "Return the most prefered font that's available."
  (loopy ((list font xl-backup-fonts)
	  (expr available-fonts (x-list-fonts font))
	  (when available-fonts
	    (return (-last-item available-fonts))))
	 (return nil)))

(format "%S" (xl-most-preferred-font-available))
#+end_src

*** ensure lexical binding
:PROPERTIES:
:ID:       2b8148c3-1418-4896-ba53-1673d2d82659
:END:

Emacs by default uses dynamic binding. Lexical binding is a [[https://nullprogram.com/blog/2016/12/22/][known way to boost
startup speed]]. To enable it you add the following comment on the top of your
elisp files. The comment creates [[][]].

#+begin_src emacs-lisp
;; -*- lexical-binding: t -*-
#+end_src

*** pause garbage collection
:PROPERTIES:
:ID:       33c4ed1f-9382-49ff-9706-6ce5c0fd0d7c
:END:

During computationally intensive tasks, it is better stop garbage collecting
until the task is done. Initializing emacs is such a task. Therefore, I
effectively stop garbage collection by setting the [[helpvar:gc-cons-threshold][gc-cons-threshold]] to
[[helpvar:most-positive-fixnum][most-positive-fixnum]].

#+begin_src emacs-lisp
(setq gc-cons-threshold most-positive-fixnum)
#+end_src

*** disable tool bar, menu bar, and scroll bar
:PROPERTIES:
:ID:       f439de9a-b2b1-4926-a4ae-3d94ff83d05a
:END:

By default the frame is initialized with the tool-bar, menu-bar, and
scroll-bar. Many emacs users, me included, prefer not to see these
things. Since I operate via keybindings I would never use them anyway. But
because emacs loads the init file after the initialization of the frame, it
used to be the case that it was inevitable to catch a glipse of these UI
elements during your emacs initializaition. Not is it distracting, but
rendering those things also contributed significantly to startup time.

Before the advent of the [[helpvar:early-init-file][early-init-file]], the only way to
prevent it was to set up an [[https://wiki.archlinux.org/index.php/X_resources][xresources]].

#+begin_src emacs-lisp
(push '(menu-bar-lines . 0) default-frame-alist)
(push '(tool-bar-lines . 0) default-frame-alist)
(push '(vertical-scroll-bars) default-frame-alist)
#+end_src

*** set the font
:PROPERTIES:
:ID:       54d9be27-74b3-49fd-9bdb-b6d1e024b80b
:END:

This is the most efficient way to set the font. Reason being, it's done before
the initialization of the frame and it avoids the usage of functions like
[[helpfn:set-frame-font][set-frame-font]], which more than just set the font. A caveat is that this will cause
your emacs to crash if the font you specify does not exist. And, you can't check
the existing fonts at this time either because the [[][frame hasn't been
initialized yet]] so functions like [[helpfn:font-family-list][font-family-list]] and [] will not return reliable values
(trust me, I tried).

#+begin_src emacs-lisp :noweb yes
(push (cons 'font <<font()>>) default-frame-alist)
#+end_src

*** disable fringes
:PROPERTIES:
:ID:       bb1264f6-1580-4463-9d72-d2913771ebb4
:END:

#+begin_src emacs-lisp
(push '(left-fringe  . 0) default-frame-alist)
(push '(right-fringe . 0) default-frame-alist)
#+end_src

*** stop package.el from writing in our init file
:PROPERTIES:
:ID:       c5df3859-6099-4d99-9780-8d33383c3626
:END:

In Emacs 27+, package initialization occurs before [[helpvar:user-init-file][user-init-file]] is
loaded, but after [[helpvar:early-init-file][early-init-file]].

#+begin_src emacs-lisp
(setq package-enable-at-startup nil)
(advice-add #'package--ensure-init-file :override #'ignore)
#+end_src

*** ignore x-resources
:PROPERTIES:
:ID:       51391771-ed2f-42f7-b904-3f655b86cac0
:END:

Ignore X resources; its settings would be redundant with the other settings in
this file and can conflict with later config (particularly where the cursor
color is concerned). [[][Like I said], we no longer need xresources anymore.

#+begin_src elisp
(advice-add #'x-apply-session-resources :override #'ignore)
#+end_src

*** prevent default mode line from showing
:PROPERTIES:
:ID:       0177fd1a-617d-47c6-bd03-db64439fd4cc
:END:

While the modeline is a huge point of interest among emacs users, I find it
distracting and space-consuming. The modeline is displayed in every buffer,
which means that it does not scale well with vertical splits. It will consume an
additional line for every additional window. And yet, I (and I suspect everyone
else) only ever focus on one window at a time. This is why I opt for disabling
the modeline (I use [[][mini-modeline]] instead). Similar to the gui bars it is enabled
by default and will be rendered during the initialization of the frame. If I
don't disable it here.

#+begin_src elisp
(unless after-init-time
  (setq-default mode-line-format nil))
#+end_src

*** maximize frame
:PROPERTIES:
:ID:       3d208962-52ad-491a-8bf4-c9248c692fc7
:END:

Emacs is the interface with which I deal with everything else. I want it to be
full screen, especially when I'm using emacs as my window manager. For the same
reasons that setting the font is efficient, this is too.

#+begin_src emacs-lisp
(push '(fullscreen . maximized) default-frame-alist)
#+end_src

** init.el
:PROPERTIES:
:ID:       44daab3a-14bd-4c47-a117-88579e89a0e2
:HEADER-ARGS: :tangle ~/.config/emacs/init.el
:END:

This is where the magic really happens. The =init.el= is the file emacs looks
for.

*** Core
:PROPERTIES:
:ID:       d68434bf-be6a-471f-ab65-e151f4f1c111
:END:

This headline contains the core abstractions in my config. In emacs, there are
several different packages, both built-in to emacs and external to it. Each
package addresses some issue or task they want to solve or improve. Sometimes
several packages need to work together. Sometimes one package can provide tools
which would be useful in configuring another. As one begins building their emacs
config they need to manage these packages and the several interactions between
emacs and eachother. In this headline I try to develop tools which will help me
deal with this web of interactions.

**** Initialize
:PROPERTIES:
:ID:       71dbf82e-cf4f-4e8a-b14d-df78bea5b20f
:END:

This headline is for things I need to do before anything else. The main thing I
do here is declare directory names.

***** ensure lexical binding
:PROPERTIES:
:ID:       2b8148c3-1418-4896-ba53-1673d2d82659
:END:

See my [[][previous reasoning]] on lexical binding.

#+begin_src emacs-lisp
;; -*- lexical-binding: t -*-
#+end_src

***** config files and directores
:PROPERTIES:
:ID:       be8993d3-c8f7-451b-8cb4-04a9138e5c4e
:END:

It's useful to store directories which I reference frequently in variables and
functions. This way I can reference the full path.

****** macro to define important directories
:PROPERTIES:
:ID:       ebdf095e-f302-45c3-aef4-a4f9a84d4e02
:END:

#+begin_src emacs-lisp
(defmacro dir! (name value &optional docstring)
  "Macro used for declaring `xl' directories.
Declare a variable named NAME with value VALUE and docstring DOCSTRING.
VALUE should be a path to a directory (as a string). Create the directory at
path VALUE. Create a function."
  (declare (indent 2))
  `(progn
     (defconst ,name ,value ,docstring)
     (mkdir ,name t)
     (defsubst ,(intern (downcase (symbol-name name))) (&rest path)
       ,(format "Return the path for `%S'." name)
       (apply #'concat ,name path))))
#+end_src

****** important directories
:PROPERTIES:
:ID:       17fd696e-6140-4d9b-9d17-053c2dced786
:END:

#+begin_src emacs-lisp
(dir! XL-EMACS-DIR (file-truename user-emacs-directory)
  "Path to `user-emacs-directory'.")

(dir! XL-LOCAL-DIR (xl-emacs-dir ".local/")
  "Path to the directory for local Emacs files.
Files that need to exist, but I don't typically want to see go here.")

(dir! XL-DATA-DIR (xl-local-dir "data/")
  "Path to the directory where XL data files are stored.")
#+end_src

****** system directories
:PROPERTIES:
:ID:       dc011bac-1734-49b5-9c30-128063520b1c
:END:

#+begin_src emacs-lisp
(dir! XL-HOME-DIR (expand-file-name "~/"))

(dir! XL-MULTIMEDIA-DIR (xl-home-dir "Multimedia/")
  "Directory used to store multimedia.")

(dir! XL-SCREENSHOT-DIR (xl-multimedia-dir "screenshots/")
  "Directory where screenshots should go.")

(dir! XL-PACKAGES-DIR (xl-local-dir "packages/")
  "Path to the directory where packages are stored.")

(dir! XL-DOCUMENTS-DIR (xl-home-dir "Documents/")
  "Directory where documents are stored.")

(dir! XL-ORG-DIR (xl-documents-dir "org/")
  "Directory where org files should go.")

(dir! XL-DOWNLOADS-DIR (xl-home-dir "Downloads/")
  "Directory where downloads are stored.")

(dir! XL-TRASH-DIR (xl-home-dir "Trash/")
  "Directory where downloads are stored.")
#+end_src

****** important files
:PROPERTIES:
:ID:       d01a33a8-c6e8-433c-9850-6bd7ea0488f9
:END:

#+begin_src emacs-lisp
(defconst XL-INIT-FILE (concat XL-EMACS-DIR "init.el")
  "Path to the elisp file that bootstraps XL startup.")

(defconst XL-MAIN-ORG-FILE (concat XL-EMACS-DIR "config.org")
  "Path to config file used for tangling.")

(defconst XL-MAIN-ELISP-FILE (concat XL-EMACS-DIR "main.el")
  "Path to elisp file.")
#+end_src

***** debug-p
:PROPERTIES:
:ID:       39197346-c420-4518-b8f8-8ea247d6decb
:END:

[[helpvar:void-debug-p][xl-debug]] is snatched from [[https://github.com/hlissner/doom-emacs][Doom's]] [[https://github.com/hlissner/doom-emacs/blob/develop/core/core.el][doom-debug-mode]]. The point of this variable is
to serve as an indicator of whether the current Emacs instance is run for
debugging. When Emacs is set up for debugging it prints out many messages about
what its doing via [[hfn:void-log][xl-log]].

#+begin_src emacs-lisp
(defvar xl-debug-p (or (getenv "DEBUG") init-file-debug)
  "When non-nil print debug messages.
The --debug-init flag and setting the DEBUG envar will enable this at startup.")
#+end_src

**** Package Management
:PROPERTIES:
:ID:       00eaa1a5-b5fe-437d-9888-1846ea9a232b
:END:

The purpose of this headline is to set up the package manager and install all of
my packages so the rest of the file can assume the packages are already
installed. The idea is to separate package installation and package configuration.

***** straight.el
:PROPERTIES:
:ID:       86037015-ca61-48f9-96bf-df8fc625a35d
:END:

[[straight][straight.el]] is a package manager that installs packages by cloning their git
repositories from online and building them from source. A consequence of this is
that you have the history of every installed emacs package locally. Another
consequence is that you can completely reproduce the state of your emacs on
another machine by installing the same packages with the same versions.

****** variables
:PROPERTIES:
:ID:       9dff9894-667c-4e74-9624-8aee533f8f70
:END:

#+begin_src emacs-lisp
(setq straight-vc-git-default-clone-depth 1)
(setq straight-base-dir XL-PACKAGES-DIR)
(setq straight-use-package-version 'straight)
(setq straight-use-package-by-default nil)
(setq straight-enable-package-integration t)
(setq straight-disable-autoloads nil)
(setq straight-cache-autoloads t)
(setq straight-check-for-modifications nil)
(setq straight-enable-package-integration nil)
(setq straight-recipes-emacsmirror-use-mirror t)
#+end_src

****** straight initialization code
:PROPERTIES:
:ID:       ab38beca-2f26-4718-ab73-e4e4409f1563
:END:

#+begin_src emacs-lisp
(defun xl-init-straight ()
  (defvar bootstrap-version)
  (let* ((straight-base-dir straight-base-dir)
	 (straight-repo-dir (concat straight-base-dir "straight/repos/"))
	 (bootstrap-file (concat straight-repo-dir "straight.el/bootstrap.el"))
	 (bootstrap-version 5)
	 (straight-commit "f6663b1de0fb5d9c64528e4f7f8bb914f49bb6d2")
	 (straight-el-link "https://github.com/raxod502/straight.el.git"))
    (unless (file-exists-p bootstrap-file)
      (make-directory straight-repo-dir t)
      (shell-command
       (format "git -C %s clone %s" straight-repo-dir straight-el-link))
      (shell-command
       (format "git -C %s checkout %s" straight-repo-dir straight-commit)))
    (load bootstrap-file nil 'nomessage)))
#+end_src

****** view package readme
:PROPERTIES:
:ID:       89d354fa-dc69-4b8c-b006-5fc883b834ef
:END:

Inevitably you will end up having some question about how to set up a package or
how a package is supposed to work. A few packages provide info nodes you can
look at but most don't. However, many packages do provide a README--particularly
packages written on github. Reading the readme of packages is something I do so
often, that it's worth having a function to do it for me (as opposed to having
to search for the package in straight's repo dir).

#+begin_src emacs-lisp
(defun straight:view-package-dir (package)
  "Try to open the readme of package if it has one."
  ;; goto a the package's directory.
  ()
  ;; see if there's anything named README
  ;; if there is open it
  ;; otherwise open a dired buffer to package directory
  )
#+end_src

***** install packages
:PROPERTIES:
:ID:       a694267f-b37d-487b-ac68-c1da9e1fe776
:END:

#+begin_src emacs-lisp
(xl-init-straight)

(dolist (package '(dash anaphora db use-package))
  (straight-use-package package)
  (require package))
#+end_src

**** Library
:PROPERTIES:
:ID:       70af1291-6b16-4261-ba83-19bb16d0023e
:END:

This headline contains all the the helper functions and macros I defined for
customizing emacs.

***** macro writing tools
:PROPERTIES:
:ID:       ea5d3295-d8f9-4f3a-a1f6-25811696aa29
:END:

These are tools that are specifically designed to help me write macros.

****** symbols
:PROPERTIES:
:ID: 2cdf8ab1-4e59-4128-a8a4-e5519ca0f4bf
:END:

Conversion between symbols, keywords, and strings are prevalent in
macro-writing.

******* symbol intern
:PROPERTIES:
:ID: 659e8389-84c5-4ac4-a9ba-7dd40599191d
:END:

#+begin_src emacs-lisp
(defun xl-symbol-intern (&rest args)
  "Return ARGS as a symbol."
  (declare (pure t) (side-effect-free t))
  (intern (apply #'xl-to-string args)))
#+end_src

******* keyword intern
:PROPERTIES:
:ID: f2668044-13b2-46e7-bf84-fcf998591e37
:END:

Sometimes I want to create a keyword by interning a string or a symbol. This
commands saves me having to add the colon at the beginning before interning.

#+begin_src emacs-lisp
(defun xl-keyword-intern (&rest args)
  "Return ARGS as a keyword."
  (declare (pure t) (side-effect-free t))
  (apply #'xl-symbol-intern ":" args))
#+end_src

******* keyword name
:PROPERTIES:
:ID: fb867938-d62b-42fc-bf07-092f10b64f22
:END:

Calling [[helpfn:symbol-name][symbol-name]] on a keyword returns the keyword as a string. However often we
don't want the prepended colon on they keyword. This function is for that
occasion.

#+begin_src emacs-lisp
(defun xl-keyword-name (keyword)
  "Return the name of the KEYWORD without the prepended `:'."
  (declare (pure t) (side-effect-free t))
  (substring-no-properties (xl-to-string keyword) 1))
#+end_src

******* convert to string
:PROPERTIES:
:ID: 4ef52875-4ce6-4940-8b7e-13c96bedcb3d
:END:

This function is for converting something to a string, no questions asked. I use
it when I don't want to be bothered with details and just want a string.

#+begin_src emacs-lisp
(defun xl-to-string (&rest args)
  "Return ARGS as a string."
  (declare (pure t) (side-effect-free t))
  (with-output-to-string
    (mapc #'princ args)))
#+end_src

******* hook symbol
:PROPERTIES:
:ID:       7ae3dac1-058b-4b1b-a010-aeb5b121d3f6
:END:

#+begin_src emacs-lisp
(defun xl-hook-symbol-p (symbol)
  "Return true if symbol is a hook symbol."
  (s-matches-p ".+-hook\\'" (symbol-name symbol)))
#+end_src

******* hookify symbol
:PROPERTIES:
:ID:       b308a172-6e99-491c-a382-7ee28e9fc1ae
:END:

#+begin_src emacs-lisp
(defun xl-hookify (symbol)
  "Return SYMBOL converted to hook.
If SYMBOL is already a hook symbol, return it unchanged."
  (if (xl-hook-symbol-p symbol)
      symbol
    (xl-symbol-intern symbol '-hook)))
#+end_src

******* mode symbol
:PROPERTIES:
:ID:       ec25e275-c36f-4cee-be04-1fdf8c974857
:END:

#+begin_src emacs-lisp
(defun xl-mode-symbol-p (symbol)
  "Return non-nil if symbol is a mode symbol."
  (s-matches-p ".+-mode\\'" (symbol-name symbol)))
#+end_src

******* modeify symbol
:PROPERTIES:
:ID:       61fa29a7-9697-4171-8b6f-f4c0b487c02c
:END:

#+begin_src emacs-lisp
(defun xl-modeify (symbol)
  "Return SYMBOL converted to hook.
If SYMBOL is already a hook symbol, return it unchanged."
  (if (xl-mode-symbol-p symbol)
      symbol
    (xl-symbol-intern symbol '-mode)))
#+end_src

****** true-list-p
:PROPERTIES:
:ID:       43089182-316b-4191-a3f1-6f2d1b1b971e
:END:

#+begin_src emacs-lisp
(defsubst xl-true-list-p (obj)
  "Return t if OBJ is a list and not a cons cell."
  (and (listp obj) (not (-cons-pair-p obj))))
#+end_src

****** whether a number is the number one
:PROPERTIES:
:ID:       32ef30cf-3057-404e-a7b4-23d88b3b0d2e
:END:

This might seem trivial or wasteful, but the two numbers I most often have to
check for are one and zero. Emacs already has a function for checking is a value
is zero, [[helpfn:zerop][zerop]]. But it doesn't have one for one.

#+begin_src emacs-lisp
(defsubst xl-one-p (obj)
  "Return t if OBJ is equal to one."
  (= 1 obj))
#+end_src

****** wrapping forms
:PROPERTIES:
:ID:       48e48c0f-7bb3-45c9-b4af-2da0ce84b64e
:END:

When writing macros in lisp it is not uncommon to need to write a macro that can
nest a form within some number of other forms (for an example, see [[id][after!]]). This
macro makes this problem much easier.

The original idea for this macro came from.

#+begin_src emacs-lisp
(defun xl-wrap-form (wrappers form)
  "Wrap FORM with each wrapper in WRAPPERS.
WRAPPERS are a list of forms to wrap around FORM."
  (declare (pure t) (side-effect-free t))
  (setq wrappers (reverse wrappers))
  (if (consp wrappers)
      (xl-wrap-form (cdr wrappers)
                      (append (car wrappers)
                              (list form)))
    form))
#+end_src

****** anaphora
:PROPERTIES:
:ID:       9938b1e1-6c6e-4a45-a85e-1a7f2d0bf6df
:END:

Anaphora refers to the ability to refer to. I have decided it is best to use
=<>= to denote the symbol referred to by anaphoric macros because it is easy to
type (assuming parentheses completion), because such a symbol uncommon in lisp.
A key advantage to this is that there is a consistent "syntax" for anaphoric
variables as opposed to using =it=. A consequence of this is that you have more
flexibility to name variables. Additionally, I like that it looks like a slot or
placeholder.

https://en.wikipedia.org/wiki/Anaphoric_macro

******* anaphoric symbol regexp
:PROPERTIES:
:ID:       40c97bd5-dab1-44df-86f7-90274d5a8ea0
:END:

#+begin_src emacs-lisp
(defconst XL-ANAPHORIC-SYMBOL-REGEXP
  (eval-when-compile (rx "<" (group (1+ (not (any white ">" "<")))) ">"))
  "Regular expression that matches an anaphoric symbol.")
#+end_src

******* anaphoric symbol
:PROPERTIES:
:ID:       db8169ba-1630-42fe-9ab7-e29c110a18c3
:END:

#+begin_src emacs-lisp
(defun xl-anaphoric-symbol-p (obj)
  "Return non-nil if OBJ is an anaphoric symbol."
  (and (symbolp obj)
       (string-match-p XL-ANAPHORIC-SYMBOL-REGEXP (symbol-name obj))))
#+end_src

******* true anaphora name
:PROPERTIES:
:ID:       2833cd75-9c85-4c0e-9523-4489d387150a
:END:

#+begin_src emacs-lisp
(defun xl-anaphoric-true-symbol (symbol)
  "Return the symbol that corresponds to the anaphoric symbol."
  (save-match-data
    (string-match XL-ANAPHORIC-SYMBOL-REGEXP (symbol-name symbol))
    (intern (match-string 1 (symbol-name symbol)))))
#+end_src

******* take symbol and return anaphoric symbol
:PROPERTIES:
:ID:       4b89588e-f3c3-49d3-8851-fdd214cee563
:END:

#+begin_src emacs-lisp
(defun xl-anaphoric-symbol (symbol)
  "Return anaphoric form of symbol."
  (xl-symbol-intern '< symbol '>))
#+end_src

******* body symbols
:PROPERTIES:
:ID:       2bae458e-404a-48e7-b57e-ce7f543f6e6d
:END:

#+begin_src emacs-lisp
(defun xl-anaphoric-symbols (body)
  "Return all the anaphoric symbols in body."
  (->> (-flatten body)
       (-filter #'xl-anaphoric-symbol-p)
       (-uniq)))
#+end_src

******* all anaphoric symbols in obj
:PROPERTIES:
:ID:       e0c0eb8c-52b3-4411-ab0b-06255490dacf
:END:

#+begin_src emacs-lisp
(defun xl-anaphoric-symbols-in-obj (obj)
  "Return a list of anaphoric symbols in OBJ."
  (s-match-strings-all XL-ANAPHORIC-SYMBOL-REGEXP (xl-to-string obj)))
#+end_src

***** custom macros
:PROPERTIES:
:ID:       cfe0d468-92ee-4a4f-9908-4ea0b1964ac4
:END:

****** after!
:PROPERTIES:
:ID:       e209d256-86e0-4e30-a7d5-78a583729b42
:END:

=after!= is yet another wrapper around == that can accept multiple features or
even a specification of features using =and= or =or=.

The reason that we check for the feature is to prevent [[hvar:eval-after-load][eval-after-load]] from polluting the
[[hvar:after-load-list][after-load-list]]. =eval-after-load= adds an entry to =after-load-list= whether or not it has
been loaded.

We intentionally avoid with-eval-after-load to prevent eager macro expansion
from pulling (or failing to pull) in autoloaded macros/features.

#+begin_src emacs-lisp
(defmacro after! (features &rest body)
  "Wrapper around `with-eval-after-load'."
  (declare (indent defun) (debug t))
  (cond ((eq 'or (car-safe features))
         (macroexp-progn
          (--map `(after! ,it ,@body) (cdr features))))
        ((eq 'and (car-safe features))
         (xl-wrap-form (--map `(after! ,it) (cdr features))
                         (macroexp-progn body)))
        ((listp features)
         `(after! ,(cons 'and features) ,@body))
        ((symbolp features)
         `(if (featurep ',features)
              ,(macroexp-progn body)
            (eval-after-load! ,features ,@body)))
        (t (error "Invalid argument."))))
#+end_src

****** with-os!
:PROPERTIES:
:ID:       a3ea434a-3f70-4137-a525-5be4bc63c3a2
:END:

Emacs is for the most part operating system agnostic. Packages written in elisp
should work across operating systems. Nevertheless, there are a handful of
settings that should favors particular operating systems over others.

#+begin_src emacs-lisp
(defmacro with-os! (os &rest body)
  "If OS is current system's operating system, execute body.
OS can be either `mac', `linux' or `windows'(unquoted)."
  (declare (indent defun))
  (when (funcall (cond ((eq :not (car-safe os)) (-not #'member))
                       (t #'member))
                 (pcase system-type
                   (`darwin 'mac)
                   (`gnu/linux 'linux)
                   (`(cygwin windows-nt ms-dos) 'windows)
                   (_ nil))
                 (-list os))
    `(progn ,@body)))
#+end_src

****** ignore!
:PROPERTIES:
:ID:       e0173863-5b27-4afc-879a-17a6dce7ecd0
:END:

#+begin_src emacs-lisp
(defmacro ignore! (&rest _)
  "Do nothing and return nil."
  nil)
#+end_src

****** eval-after-load!
:PROPERTIES:
:ID:       8d831084-539b-4072-a86a-b55afb09bf02
:END:

=eval-after-load= is a macro that evaluates a lisp form after a file or feature
has been loaded. It's syntax is a bit terse because you need to quote the
feature as well as the form to be evaluated.

Also, if an =eval-after-load= block contains an error and it is triggered by a
feature, the error will happening. I think it might be that because the form was
not successfully evaluated =eval-after-load= does not realize it should stop
loading it. To remedy this I wrap the block with [[][condition-case]].

#+begin_src emacs-lisp
(defmacro eval-after-load! (feature &rest body)
  "A wrapper around `eval-after-load!' with error catching."
  (declare (indent defun))
  `(eval-after-load ',feature
     '(condition-case error
          (progn ,@body)
        (error
         (message "Error in `eval-after-load': %S" error)))))
#+end_src

****** list mutation
:PROPERTIES:
:ID:       d9f77404-5c29-4305-ae53-e409e1b06b99
:END:

******** append!
:PROPERTIES:
:ID: f314672c-f9f3-4630-9402-a9a65215c153
:END:

#+begin_src emacs-lisp
(defmacro append! (sym &rest lists)
  "Append LISTS to SYM.
SYM is a symbol that stores a list."
  (declare (indent 1))
  `(setq ,sym (append ,sym ,@lists)))
#+end_src

******** prepend!
:PROPERTIES:
:ID: 3395dec3-0915-49cd-9445-d3db2b1ffe7f
:END:

#+begin_src emacs-lisp
(defmacro prepend! (sym &rest lists)
  (declare (indent defun))
  `(setq ,sym (append ,@lists ,sym)))
#+end_src

******** nconc!
:PROPERTIES:
:ID: b24d1d8f-f3e1-4dca-afdb-8fb73d5299c3
:END:

#+begin_src emacs-lisp
(defmacro nconc! (sym &rest lists)
  "Append LISTS to SYM by altering them in place."
  (declare (indent 1))
  `(setq ,sym (nconc ,sym ,@lists)))
#+end_src

****** set!

Some variables in emacs have [[][custom setters]]. I don't want to have to figure out
which ones do and do not have these setters. This macro sets the custom setter
of there is any.

There's also the issue of global versus buffer-local variables. In general, when
I set a variable I want it enabled globally. When there comes a case in which I
don't want that I'll use [[helpfn:setq][setq]].

For this reason I use =setq= as a replacement for =setq=.

[[https://opensource.com/article/20/3/variables-emacs][This article]] provides
a brilliant synopsis of emacs variables.

#+begin_src emacs-lisp
(defmacro set! (sym val)
  `(funcall (or (get ',sym 'custom-set) 'set) ',sym ,val))
#+end_src

****** set-default!
:PROPERTIES:
:ID:       bc6b7560-fb71-4fc7-a53b-98f92c657d92
:END:

#+begin_src emacs-lisp
(defmacro set-default! (sym val)
  `(funcall (or (get ',sym 'custom-set-default) 'set-default) ',sym ,val))
#+end_src

***** use-package
:PROPERTIES:
:ID:       29e1513a-e12a-4818-870e-8d5fab7fe1a0
:END:

****** different name for =use-package=
:PROPERTIES:
:ID:       33cd9485-ccbd-4173-b44b-2145def4897c
:END:

Essentially, it provides a uniform syntax for cross configuring different
packages. So you can say it configures packages. And therefore, I choose to call
the macro =use-package!=.

#+begin_src emacs-lisp
(defalias 'use-package! #'use-package)

(defmacro use-feature! (package &rest body)
  "Same as `use-package!' but with :ensure set to nil by default."
  (declare (indent defun))
  `(use-package! ,package
     :xl-ensure nil
     ,@body))
#+end_src

****** initialize use-package
:PROPERTIES:
:ID:       8879bd2b-5c7b-43d2-b922-7bb7cd6fea48
:END:

#+begin_src emacs-lisp
(use-package! use-package
  :init
  (push '(:xl-ensure t t) use-package-defaults)
  (setq use-package-expand-minimally t)
  (setq use-package-always-defer t))
#+end_src

****** save the original keywords
:PROPERTIES:
:ID:       e317d512-cab1-41a8-9dfa-522d5b32a4f1
:END:

#+begin_src emacs-lisp
(defvar use-package:orig-keywords use-package-keywords)
#+end_src

****** miscellaneous
:PROPERTIES:
:ID:       4968a708-05f2-4a3b-8395-850a3c119fd2
:END:

#+begin_src emacs-lisp
(defun use-package:insert-keyword (where place key)
  (--splice (eq place it)
	    (funcall (if (eq where 'before) #'identity #'reverse) (list key it))
	    use-package-keywords))
#+end_src

****** create autoloads
:PROPERTIES:
:ID:       ee0dc9c0-1bb3-4309-a61d-5b1c7f4c6ddf
:END:

#+begin_src emacs-lisp
(defun use-package:autoload (package fn)
  "Return form for FN."
  `(unless (fboundp ',fn)
     (autoload #',fn ,(symbol-name package) nil t nil)))
#+end_src

****** helper macros
:PROPERTIES:
:ID:       244ebd30-dfc8-45c9-b504-5f2dd8c0f12e
:END:

******* default insertion
:PROPERTIES:
:ID:       e0b3a061-f4c3-43df-8d71-1337d7eadf53
:END:

#+begin_src emacs-lisp
(defvar use-package:default-place '(after :init)
  "Place where keywords should be inserted by default.")
#+end_src

******* handler arguments
:PROPERTIES:
:ID:       03ba5359-010d-4442-897f-a1a7354d7b9b
:END:

#+begin_src emacs-lisp
(defvar use-package:handler-args '(name key value rest state)
  "Args passed into handler functions.")
#+end_src

******* handler
:PROPERTIES:
:ID:       1cfacfde-621e-4d4d-b55a-8bb24c5bb220
:END:

#+begin_src emacs-lisp
(defmacro use-package:defhander! (name args &rest body)
  "Define a `use-package' handler."
  (declare (indent defun))
  (let ((handler-name (xl-symbol-intern 'use-package-handler/: name))
	(docstring (when (stringp (car body)) (pop body))))
    `(defun ,handler-name (,@(-map #'xl-anaphoric-symbol use-package:handler-args))
       ,docstring
       (let ((<body> (use-package-process-keywords <name> <rest> <state>)))
	 ,@body))))
#+end_src

******* normalize arguments
:PROPERTIES:
:ID:       254c2e3a-7b33-4412-91d1-8c6910e60635
:END:

#+begin_src emacs-lisp
(defvar use-package:normalize-args '(name key args)
  "Args passed into normalize functions.")
#+end_src

******* normalize
:PROPERTIES:
:ID:       1a9bef3e-be39-48ce-a19b-7c6e66d448d5
:END:

#+begin_src emacs-lisp
(defmacro use-package:defnormalize! (key args &rest body)
  "Define a `use-package' normalizer."
  (declare (indent defun))
  (let* ((prefix 'use-package-normalize/:)
	 (name (xl-symbol-intern prefix key)))
    `(defun ,name (,@(-map #'xl-anaphoric-symbol use-package:normalize-args))
       ,@body)))
#+end_src

****** custom keywords
:PROPERTIES:
:ID:       62cec5ac-a2f9-435b-96a7-4db0d9691f25
:END:

One thing to note is that I don't allow arguments to be optionally in a
list. This makes things much more complicated and it makes.

******* hook
:PROPERTIES:
:ID:       02e42811-3b97-44f1-ad0c-d59787173ffb
:END:

Here I override the default hook keyword with my own which uses =xl-add-hook=
instead of =add-hook=.

#+begin_src emacs-lisp
(defun use-package:normalize-cons (cons-pair)
  (-table-flat #'cons
	       (-list (car cons-pair))
	       (-list (cdr cons-pair))))

(setq use-package-keywords
      (use-package:insert-keyword 'before :hook :xl-hook))

(use-package:defnormalize! xl-hook ()
  (cl-assert (-all-p (-orfn #'-cons-pair-p #'symbolp) <args>))
  (->> <args>
       (--map-when (symbolp it) (cons it (xl-modeify <name>)))
       (-mapcat #'use-package:normalize-cons)
       (--map (cons (xl-hookify (car it)) (cdr it)))))

(use-package:defhander! xl-hook ()
  "Expect an alist of (HOOK FN)."
  `(,@(-map (-lambda ((hook . fn)) `(xl-add-hook ',hook ',fn)) <value>)
    ,@(-map (-partial #'use-package:autoload <name>) (-map #'cdr <value>))
    ,@<body>))
#+end_src

******* before-call
:PROPERTIES:
:ID:       55e66d22-b75d-4e77-9f99-dca1afbe1094
:END:

Packages don't live in an isolated enviroment. Often one package depends on one
or more packages. Sometimes, I add customizations to a package using certain
libraries and then I need to load them when that package is loaded. The purpose
of this keyword is to load a package when a certain function is called.

#+begin_src emacs-lisp
(setq use-package-keywords
      (use-package:insert-keyword 'before :hook :xl-before-call))

(use-package:defnormalize! xl-before-call ()
  (cl-assert (-all-p (-orfn #'symbolp #'listp) <args>))
  (->> <args>
       (--map-when (symbolp it) (cons <name> it))
       (-mapcat #'use-package:normalize-cons)))

(use-package:defhander! xl-before-call ()
  `(,@(-map (-partial #'use-package:autoload <name>)
	    (-map #'cdr <value>))
    ,@(-map (-lambda ((package . fn)) `(xl-load-before-call ',package #',fn))
	    <value>)
    ,@<body>))
#+end_src

******* after-call
:PROPERTIES:
:ID:       2c7dd1a8-c0ee-42cd-b76f-8a72c94be848
:END:

#+begin_src emacs-lisp
(setq use-package-keywords
      (use-package:insert-keyword 'after :hook :xl-after-call))

(use-package:defnormalize! xl-after-call ()
  (cl-assert (-all-p (-orfn #'symbolp #'listp) <args>))
  (->> <args>
       (--map-when (symbolp it) (cons <name> it))
       (-mapcat #'use-package:normalize-cons)))

(use-package:defhander! xl-after-call ()
  `(,@(-map (-partial #'use-package:autoload <name>)
	    (-map #'cdr <value>))
    ,@(-map (-lambda ((package . fn)) `(xl-load-after-call ',package #',fn))
	    <value>)
    ,@<body>))
#+end_src

******* silence
:PROPERTIES:
:ID:       c69b021f-c1eb-4f51-8de3-234c4660a0ba
:END:

Many packages print some output to the messages buffer.

#+begin_src emacs-lisp
(setq use-package-keywords
      (use-package:insert-keyword 'before :hook :xl-silence))

(use-package:defnormalize! xl-silence ()
  (cl-assert (-all-p #'symbolp <args>))
  <args>)

(use-package:defhander! xl-silence ()
  `(,@(-map (-partial #'use-package:autoload <name>) <value>)
    ,@(--map `(xl-silence-output #',it) <value>)
    ,@<body>))
#+end_src

******* ignore
:PROPERTIES:
:ID:       eeeaf89c-78e6-453d-bf3b-27091cc11bca
:END:

#+begin_src emacs-lisp
(setq use-package-keywords
      (use-package:insert-keyword 'before :hook :xl-ignore))

(use-package:defnormalize! xl-ignore ()
  (cl-assert (-all-p #'symbolp <args>))
  <args>)

(use-package:defhander! xl-ignore ()
  `(,@(-map (-partial #'use-package:autoload <name>) <value>)
    ,@(--map `(xl-ignore #',it) <value>)
    ,@<body>))
#+end_src

******* set
:PROPERTIES:
:ID:       9948a4ae-f80a-4b13-b97a-0895481021a6
:END:

#+begin_src emacs-lisp
(setq use-package-keywords
      (use-package:insert-keyword 'before :hook :xl-set))

(use-package:defnormalize! xl-set ()
  (cl-assert (-all-p #'listp <args>))
  <args>)

(use-package:defhander! xl-set ()
  `(,@(-map (-lambda ((var . val)) `(set! ,var ,val)) <value>)
    ,@<body>))
#+end_src

******* rule
:PROPERTIES:
:ID:       30ee0415-dccf-4742-9c31-bd33b900ab81
:END:

This keyword integrates with [[][dbc]] (display buffer control).

#+begin_src emacs-lisp
(setq use-package-keywords
      (use-package:insert-keyword 'before :hook :xl-rule))

(use-package:defnormalize! xl-rule ()
  (cl-assert (-all-p #'xl-true-list-p <args>))
  <args>)

(use-package:defhander! xl-rule ()
  `(,@(--map `(dbc-add-rule ,@it) <value>)
    ,@<body>))
#+end_src

******* idle-require
:PROPERTIES:
:ID:       916f88bd-10e1-4030-a1d9-e42baf095492
:END:

This keyword integrates with [[][idle-require]].

#+begin_src emacs-lisp
(setq use-package-keywords
      (use-package:insert-keyword 'before :hook :xl-idle-require))

(use-package:defnormalize! xl-idle-require ()
  (cl-assert (-all-p #'symbolp <args>))
  (--map-when (eq t it) <name> <args>))

(use-package:defhander! xl-idle-require ()
  `(,@(--map `(idle-require ',it nil t) <value>)
    ,@<body>))
#+end_src

******* config
:PROPERTIES:
:ID:       fa0947a2-7f0c-447e-9b16-03edb2648ad6
:END:

#+begin_src emacs-lisp
(setq use-package-keywords
      (use-package:insert-keyword 'before :hook :xl-config))

(use-package:defnormalize! xl-config ()
  <args>)

(use-package:defhander! xl-config ()
  `((after! ,<name> ,@<value>)
    ,@<body>))
#+end_src

******* alias 
:PROPERTIES:
:ID:       9fe0d171-55b4-4022-82ec-abfb5e776cae
:END:

#+begin_src emacs-lisp
(setq use-package-keywords
      (use-package:insert-keyword 'before :hook :xl-alias))

(use-package:defnormalize! xl-alias ()
  <args>)

(use-package:defhander! xl-alias ()
  `(,@(-map #'use-package:autoload (-map #'car <value>))
    ,@(--map (-lambda ((sym . def)) `(defalias ',sym #',def))
	     <value>)
    ,@<body>))
#+end_src

******* ensure
:PROPERTIES:
:ID:       aab32568-2c8c-4777-90ec-c4ad1bebaad8
:END:

#+begin_src emacs-lisp
(setq use-package-keywords
      (use-package:insert-keyword 'before :ensure :xl-ensure))

(use-package:defnormalize! xl-ensure ()
  (cl-assert (alet (car-safe <args>)
	       (or (listp it) (booleanp it))))
  (car <args>))

(use-package:defhander! xl-ensure ()
  `(,@(cond ((null <value>) nil)
	    ((eq t <value>) `((straight-use-package ',<name>)))
	    ((listp <value>) `((straight-use-package ',(cons <name> <value>)))))
    ,@<body>))
#+end_src

******* gc-pause
:PROPERTIES:
:ID:       70dba953-1a83-4de8-9a63-43e20c50fe5a
:END:

The keyword pauses emacs gargbage collection (e.g increases the
[[helpvar:gc-cons-threshold][gc-cons-threshold]] to [[helpvar:most-positive-fixnum][most-positive-fixnum]]) for the duration of functions that
it's passed in. It should be used on particularly computationally expensive
functions that a package provides.

#+begin_src emacs-lisp
(setq use-package-keywords
      (use-package:insert-keyword 'before :hook :xl-gc-pause))

(use-package:defnormalize! xl-gc-pause ()
  (cl-assert (-all-p #'symbolp <args>))
  <args>)

(use-package:defhander! xl-gc-pause ()
  `(,@(--map (use-package:autoload <name> it) <value>)
    ,@(--map `(xl-pause-garbage-collection #',it) <value>)
    ,@<body>))
#+end_src

******* nameless
:PROPERTIES:
:ID:       e27d6d69-6efb-49c8-8c31-e477422a3d58
:END:

This keyword provides integration with.

#+begin_src emacs-lisp
(setq use-package-keywords
      (use-package:insert-keyword 'before :hook :xl-nameless))

(use-package:defnormalize! xl-nameless ()
  (cl-assert (-all-p (-orfn #'-cons-pair-p #'stringp #'symbolp) <args>))
  (--map-when (or (stringp it) (symbolp it))
	      (cons (xl-to-string it) (xl-to-string <package>))
	      <args>))

(use-package:defhander! xl-nameless ()
  `((after! nameless ,@(--map `(push ',it nameless-global-aliases) <value>))
    ,@<body>))
#+end_src

***** essential libraries
:PROPERTIES:
:ID:       18602d49-dcc3-47c3-8579-62f7a7b7a83a
:END:

These are packages that I use to make writing lisp code more convenient. Emacs
Lisp is a full-featured, turing-complete language. However, for some data
structures like hash-tables and alists it is missing consistently named
functions for performing operations on these data structures. This is improving
slowly with the introduction of libraries like =seq.el= and =map.el= but still
leaves much to be desired.

****** shut-up
:PROPERTIES:
:ID:       71681f9f-2760-4cee-95a0-4aeb71191a42
:END:

This package provides a macro named =shut-up= that as its name suggests,
silences output of any forms within it. Emacs itself and many emacs packages
spew messages. While I can see how in certain circumstances there messages can
be useful, most of the time they are superfluous.

#+begin_src emacs-lisp
(use-package! shut-up :demand t)
#+end_src

****** dash
:PROPERTIES:
:ID:       7885c48d-0ead-4d77-8de1-e9faec58b583
:END:

Dash is rich list manipulation library. Many of the functions it have already been
found in some form or another in emacs in features such as =cl-lib= and =seq=
and =subr=, but dash has some very convenient functions and macros over emacs
(such as =-let)=. Moreover, a lot of work has been put into making it's
functions efficient; some are even more efficient than built-in cl
functions. Additionally, it's already used as a dependency of very many packages
so I'll likely end up loading it anyway.

#+begin_src emacs-lisp
(use-package! dash
  :demand t)
#+end_src

****** dash-functional
:PROPERTIES:
:ID:       704fc35f-0ad0-4eb3-9eb5-d8335465dbd8
:END:

=dash-functional= provides "function combinators". These are functions that take
one or more functions as arguments and return a function. One example of this is
emacs's [[helpfn:apply-partially][apply-partially]]. These functions can help.

#+begin_src emacs-lisp
(use-package! dash-functional
  :demand t)
#+end_src

****** s
:PROPERTIES:
:ID: 4b82deb0-bbe1-452c-8b60-ef734efb86d8
:END:

=s= is an api for strings inspired by [[id:704fc35f-0ad0-4eb3-9eb5-d8335465dbd8][dash]].

#+begin_src emacs-lisp
(use-package! s
  :demand t)
#+end_src

****** anaphora
:PROPERTIES:
:ID:       1c47bd8a-15f1-4b1c-9574-23547d27d968
:END:

It's common to want to refer to the thing you're operating on in lisp and in
many other languages. In lisp this often requires assigning the variable a name.
But if you're only.

#+begin_src emacs-lisp
(use-package! anaphora
  :demand t)
#+end_src

****** loopy
:PROPERTIES:
:ID:       da17f1ea-7b0d-4d8c-a068-792ed58c6a79
:END:

=loopy= is an alternative to =cl-loop= that preserves lisp structure. It is akin to
[[][Common Lisp's iter]]. dash's functions and macros are good for most
cases. But they are not as good in my opinion when you're dealing with a complex loop
that involves accumulating several variables or atypical control-flow (as in, break
statements or return statements).

******* init
:PROPERTIES:
:ID:       3102adee-0474-4cf4-847a-011c2f8f48cd
:END:

#+begin_src emacs-lisp
(use-package! loopy
  :xl-ensure (:host github :type git :repo "okamsn/loopy")
  :demand t)
#+end_src

****** noflet
:PROPERTIES:
:ID:       27f06ae0-ed4d-45ca-b451-fa05a47b8fe0
:END:

#+begin_src emacs-lisp
(use-package! noflet
  :demand t)
#+end_src

****** dbc
:PROPERTIES:
:ID:       b3351a74-b2d0-42b8-9895-b6baad0adb0b
:END:

=dbc= stands for "display-buffer-control". This package provides an interface for
working with [[helpfn:display-buffer-alist][display-buffer-alist]].

For now, I haven't found a buffer I'd like to display in any place other than
the bottom. I don't like it when buffer text is cutt off or truncated on the
side windows.

#+begin_src emacs-lisp
(use-package! dbc
  :xl-ensure (:host gitlab :type git :repo "matsievskiysv/display-buffer-control")
  :demand t
  :xl-config
  (alet '(display-buffer-in-side-window . ((side . bottom) (window-height . 0.5)))
    (dbc-add-ruleset "bottom" it))
  (alet '(display-buffer-in-side-window . ((side . top) (window-height . 0.4)))
    (dbc-add-ruleset "top" it))
  (alet '(display-buffer-in-side-window . ((side . left) (window-width 0.4)))
    (dbc-add-ruleset "left" it))
  (alet '(display-buffer-in-side-window . ((side . right) (window-width 0.4)))
    (dbc-add-ruleset "right" it)))
#+end_src

****** db
:PROPERTIES:
:ID:       9b79f07b-8397-4f95-b79c-5e136a9b2079
:END:

#+begin_src emacs-lisp
(use-package! db)
#+end_src

****** elog
:PROPERTIES:
:ID:       d73fd7b1-5610-4d93-8802-1aa57c8c1918
:END:

=elog= is a library for generating logging functions. I use [[][]] to generate a
function that logs to the buffer =*xl-log*=.

#+begin_src emacs-lisp
(use-package! elog
  :demand t
  :xl-config
  (elog-open-log buffer "xl-" :buffer "*xl-log*" :fmt "XL %M")
  (defun xl-log (format-string &rest args)
    "Log to *Messages* if `xl-debug-p' is on.
Does not interrupt the minibuffer if it is in use, but still log to *Messages*.
Accept the same arguments as `message'."
    (xl--log 1 (apply #'format format-string args))))
#+end_src

***** hooks
:PROPERTIES:
:ID:       a9fb6a01-ded5-405c-83ba-c401dbc06400
:END:

One of the most common ways to customize Emacs is via [[info:elisp#Hooks][hooks]]. Hooks are variables
containing functions (which are sometimes also referred to as hooks). The
functions in hooks are run after certain events, such as starting and quitting
emacs. Their purpose is to fascillitate customization of what happens before or
after particular events.

In this headline, I strive to establish a common naming convention for hooks
that I define. I want there to be a clear destinction between hooks and regular
functions.

****** hook regexp
:PROPERTIES:
:ID:       aa93c9c5-aaaa-4732-9065-32e131e96031
:END:

#+begin_src emacs-lisp
(defconst XL-HOOK-REGEXP (rx bos (group (1+ nonl)) "&" (group (1+ nonl)) eos)
  "Regexp that matches an XL hook.
This regexp contains two groups. One group one designates the hook variable
(what is before the '&') and group two designates the hook function (this is
what follows the '&').")
#+end_src

****** whether a symbol is an XL hook
:PROPERTIES:
:ID:       1995a309-e1d3-40e5-b6b1-fbcd81dda0bb
:END:

#+begin_src emacs-lisp
(defun xl-hook-fn-p (symbol)
  "Return non-nil if SYMBOL is a xl-specific hook function symbol."
  (s-matches-p XL-HOOK-REGEXP (symbol-name symbol)))
#+end_src

****** access the hook symbol
:PROPERTIES:
:ID:       77f45347-3688-438d-8674-39e6d476a2d1
:END:

A useful consequence of the hook naming convention is I can determine precisely
which hook symbol a function resides in based on looking at the name
(=emacs-startup-hook&do-something= would be a hook in =emacs-starup-hook= for
example). This proves to be useful for [[id:8506fa78-c781-4ca8-bd58-169cce23a504][expire advice]].

#+begin_src emacs-lisp
(defun xl-hook-hooked-var (xl-hook-fn)
  "Return the hook variable XL-HOOK-FN is in.
XL-HOOK-FN is a function named with Void naming conventions."
  (->> (symbol-name xl-hook-fn)
       (s-match XL-HOOK-REGEXP)
       (nth 1)
       (intern)))
#+end_src

****** access the original hook function
:PROPERTIES:
:ID:       fa705f26-31f0-43c3-80a6-6741e74ab0ea
:END:

#+begin_src emacs-lisp
(defun xl-hook-orig-fn (xl-hook-fn)
  "Return the function hook function that corresponds to XL-HOOK-FN."
  (->> (symbol-name xl-hook)
       (s-match XL-HOOK-REGEXP)
       (nth 2)
       (intern)))
#+end_src

****** generate an XL hook
:PROPERTIES:
:ID:       3e6176f0-75dd-4dd8-a87d-2f47be7f2abf
:END:

******* produce an XL hook name
:PROPERTIES:
:ID:       6b14ea72-b8ef-493d-82e2-962f889736a2
:END:

This function determines how xl-defined hooks are named. When possible they
should be in the form of some action so that the hook name will be of the form
=hook-variable&do-something=. Having the names like this makes it so you can
actually read through hook functions like reading a todo-list. It will be
apparent what's being done.

#+begin_src emacs-lisp
(defun xl-hook-name (hook function)
  "Produce a valid xl-hook symbol."
  (xl-symbol-intern hook '& function))
#+end_src

******* produce hook lambda
:PROPERTIES:
:ID:       01cdecef-a345-45f0-b38e-5fe0b4939b08
:END:

When there's a bug with a function (also called a hook) added to a hook
variable, it interferes with the running of the hook variable. Evaluation stops
at the error. As a result, hooks following the bugged function aren't
evaluated. All in all, you get an unpleasant experience with partially evaluated
code. I've faced this problem numerous times, mostly when I failed to autoload
the hook for a mode and as a result get a =xl-function= error in the middle of
the mode's hook.

I would prefer an elegant failure. By this, I mean I'd like the "problem"
function to report the problem to me without short-circuiting. This is why I
wrap hook functions in a [[helpfn:condition-case][condition-case]] block.

#+begin_src emacs-lisp
(defun xl-gen-hook-lambda (function)
  "Return a raw lambda."
  `(lambda (&rest args)
     (condition-case err
	 (apply #',function args)
       (error
	(xl-log "%s failed." ',function)))))
#+end_src

******* produce an XL xl-hook
:PROPERTIES:
:ID:       5081274d-61d8-4adf-8646-72b08ca2f3d6
:END:

#+begin_src emacs-lisp
(defun xl-hook (hook fn)
  "Return a hook symbol based on HOOK and FN."
  (alet (xl-gen-hook-symbol hook fn)
    (fset it (xl-gen-hook-lambda fn))
    it))
#+end_src

****** add an XL hook
:PROPERTIES:
:ID:       882bc5d2-a0e2-4ea7-b9d2-ab64b3407f82
:END:

#+begin_src emacs-lisp
(defun xl-add-hook (hook fn &optional depth local expire-fn)
  "Add an xl-hook-function to HOOK."
  (let ((hook-fn (xl-gen-hook hook fn)))
    (add-hook hook hook-fn depth local)
    (xl-log-function hook-fn)
    (when expire-fn
      (alet (xl-expire-advice hook-fn expire-fn t)
	(advice-add hook-fn :around it)))))
#+end_src

****** remove an XL hook
:PROPERTIES:
:ID:       99708d72-a8d4-42ba-b6ae-ba692fbafec8
:END:

#+begin_src emacs-lisp
(defun xl-remove-hook (xl-hook-fn)
  "Remove an XL-HOOK-FN from its hook symbol."
  (remove-hook (xl-hook-orig-var xl-hook-fn) xl-hook-fn))
#+end_src

****** defhook!
:PROPERTIES:
:ID:       4daf2baf-ea7f-41f5-9f86-63168089149a
:END:

=defhook= provides a declarative way declare hook functions using [[helpfn:defun][defun]] syntax.

#+begin_src emacs-lisp
(defmacro defhook! (name args &rest body)
  "Define a hook function and attatch it to HOOK and HOOKS.
DEPTH and LOCAL are the same as in `add-hook'. BODY is the body of the hook
function.

\(NAME (HOOK &REST HOOKS &OPTIONAL DEPTH LOCAL) &rest BODY)"
  (declare (doc-string 3))
  (-let* ((hooks (-take-while (-not #'keywordp) args))
          (local (plist-get hooks :local))
          (depth (or (plist-get hooks :append) (plist-get hooks :depth)))
          ((docstring _ body) (xl--keyword-macro-args body))
          (hook-name (xl-symbol-intern 'xl-- name '-hook)))
    `(progn
       ,@(mapcar (lambda (hook)
                   `(aprog1 (defun ,hook-name (&rest _) ,docstring ,@body)
                      (xl-add-hook ',hook it ,depth ,local)))
                 hooks))))
#+end_src

***** advice
:PROPERTIES:
:ID:       19b9021d-f310-485b-9258-4df19423c082
:END:

I want to name advices so that they can be distinguished from other functions. I
also want to be able to deduce the function being advised from the name.

****** regexp for XL advices
:PROPERTIES:
:ID:       7a0b9669-e15c-40c1-9cf2-adc7cb27b7ab
:END:

#+begin_src emacs-lisp
(defconst XL-ADVICE-REGEXP (rx (1+ (not white)) "@" (1+ (not white)))
  "Regexp used to match XL advices.")
#+end_src

****** whether a symbol is an XL advice
:PROPERTIES:
:ID:       0a84d983-39ad-48d1-af9d-b43589d63bcf
:END:

#+begin_src emacs-lisp
(defun xl-advice-fn-p (fn)
  "Return non-nil if FN is an XL advice."
  (s-matches-p XL-ADVICE-REGEXP (symbol-name fn)))
#+end_src

****** access the adviced function
:PROPERTIES:
:ID:       74aee21a-3549-488b-b6f1-de9549e7e358
:END:

#+begin_src emacs-lisp
(defun xl-advice-advised-fn (xl-advice-fn)
  "Return the function that ADVICE-FN advices."
  (->> (symbol-name xl-advice-fn)
       (s-match XL-ADVICE-REGEXP)
       (nth 1)
       (intern)))
#+end_src

****** access the original advice
:PROPERTIES:
:ID:       f893fbe8-592b-409e-8de7-6060e936456f
:END:

It's easy to find which functions are advising a given function using
[[helpfn:advice-mapc][advice-mapc]]. However, it's not as easy to go the other way around--to determine
what which function a given advice is advising. Another complicaiton is that
it's possible for a given advice to advise multiple functions. With the naming
system I provide, doing this is trivial.

#+begin_src emacs-lisp
(defun xl-advice-orig-advice (xl-advice-fn)
  "Return the symbol."
  (->> (symbol-name fn)
       (s-match XL-ADVICE-REGEXP)
       (nth 1)
       (intern)))
#+end_src

****** generate an advice name
:PROPERTIES:
:ID:       03416f82-ced7-42a0-843b-6975903f0b38
:END:

#+begin_src emacs-lisp
(defun xl-advice-name (fn advice)
  "Return XL advice symbol for FN and ADVICE"
  (xl-symbol-intern fn '@ advice))
#+end_src

****** add XL advice
:PROPERTIES:
:ID:       3ab8947c-15f0-4fb7-bd75-f0baabc20ec1
:END:

Since adding an advice to multiple functions is done frequently.

Often, I advise functions with other existing functions (such as =#'ignore=)
instead of defining my own advices. To maintain consistency with the naming
convention I created [[helpfn:xl-add-advice][xl-add-advice]]. It will create an advice with an
appropriate name to target.

#+begin_src emacs-lisp
(defun xl-add-advice (symbol where fn &optional props expire-fn)
  "Advise SYMBOLS with ADVICES."
  (let ((advice (xl-advice-name symbol fn)))
    (defalias advice fn)
    (advice-add symbol where advice props)
    (xl-log-function advice)
    (when expire-fn
      (alet (xl-expire-advice advice expire-fn t)
	(advice-add advice :around it)))))
#+end_src

****** remove XL advice
:PROPERTIES:
:ID:       3d13ea95-44aa-4261-8480-5ae9701d533d
:END:

Since we can get the advisee from the advise name, or remove advice only needs
one argument--the advice to remove.

#+begin_src emacs-lisp
(defun xl-remove-advice (xl-advice-fn)
  "Remove XL-ADVICE-FN from the function it is advising."
  (alet (xl-advice-orig-var xl-advice-fn)
    (advice-remove it xl-advice-fn)))
#+end_src

****** generic advices
:PROPERTIES:
:ID:       8fb485ec-5387-46da-820e-629dcf004962
:END:

There are some advices that are used so often that they do not lend themselves
to =defadvice!=, which is better suited for a unique hook defined only once.

******* around-advice macro
:PROPERTIES:
:ID:       f4f8e545-5ea1-4e94-8b6d-56a65131e6db
:END:

#+begin_src emacs-lisp
(defmacro around-advice! (&rest body)
  (declare (indent defun))
  `(lambda (orig-fn &rest args) ,@body))
#+end_src

******* expiration
:PROPERTIES:
:ID:       c8092696-030e-4609-9485-89920eddaaec
:END:

Sometimes I am confronted with hooks or advices that either should'nt be or
don't need to be called more than once. A common example is [[][loading a
dependency for a package]].

******** expire advice lambda
:PROPERTIES:
:ID:       c280627b-ca96-46e7-ba2d-9754afa991fc
:END:

When a function has expired, it is removed from any hooks or advices it is in,
and, additionally, it is ignored. The expire advice remains on the function.

#+begin_src emacs-lisp
(defun xl-gen-expire-advice (expire-condition)
  "Return an around advice that expires on EXPIRE-CONDITION."
  (lambda (orig-fn &rest args)
    (aprog1 (apply orig-fn args)
      (when (funcall #',expire-condition)
	(when (xl-advice-fn-p orig-fn)
	  (xl-advice-remove orig-fn))
	(when (xl-hook-fn-p orig-fn)
	  (xl-hook-remove orig-fn))
	(xl-log "%s has expired." orig-fn)))))
#+end_src

******** expire advice
:PROPERTIES:
:ID:       8506fa78-c781-4ca8-bd58-169cce23a504
:END:

Often there are functions you want to advise just once. For example, loading a
feature just before a function that needs it is called. Although it's harmless,
you don't want to keep reloading the feature everytime the function is called.
The way I handle this situation is by creating a function that generates an
=expire-advice=. When an =expire-advice= it will.

Note that this function returns must be evaluated with lexical binding to work.

#+begin_src emacs-lisp
(defun xl-expire-advice (fn &optional expire-condition)
  "Return an advice that causes FN to expire when EXPIRE-FN returns true.
FN is a function. EXPIRE-FN is a function that returns true when FN
should expire."
  (alet (xl-expire-advice fn (or expire-condition (-const t)))
    (fset name it)
    (xl-advice-add fn :around expire-fn)))
#+end_src

******* silence
:PROPERTIES:
:ID:       7eddba70-8597-4af7-bc93-6ebdcc06ee6c
:END:

Many packages output to the messages buffer. Often, I either find these messages
unecessary or, as an experienced user, I get it already. In these cases I prefer
to silence the said messages.

#+begin_src emacs-lisp
(defun xl-silence-output (fn &optional props expire-fn)
  "Silence output of FN."
  (alet (xl-advice-name fn 'silence-output)
    (fset it (around-advice! (shut-up (apply orig-fn args))))
    (xl-advice-add fn :around it)))
#+end_src

******* logging certain functions
:PROPERTIES:
:ID:       1ccfaa39-924f-4b1d-82b2-e458511cbb1b
:END:

I make distinctions between different kinds of functions such as advices, hook
functions and interactive functions. Depending on which type of function it is I
want to log it differently.

******** log message
:PROPERTIES:
:ID:       f0f4d5fd-2ce2-408c-8a4d-f55e39744132
:END:

#+begin_src emacs-lisp
(defun xl--log-message (fn)
  "Return the message logged."
  (pcase fn
    ((pred xl-hook-p)
     (format "& %s -> %s"
	     (xl-hook-variable fn)
	     (xl-hook-function fn)))
    ((pred xl-advice-p)
     (format "@ %s -> %s"
	     (xl-advice-symbol fn)
	     (xl-advice-function fn)))
    (_
     (format "%s called" fn))))
#+end_src

******** log advice
:PROPERTIES:
:ID:       25ea174f-af84-49e3-ad13-c797ef4ee6b2
:END:

Maybe it's overkill having an advice just to log a function. But it helps
maintain maximum purity and extensibility.

#+begin_src emacs-lisp
(defun xl-log-function (fn &optional after)
  "Log calls to FN.
Add a log to *xl-log* after function is called.
This function should be primarly used for side-effect but does incidentally return the
log function that is added to FN."
  (aprog1 (xl-symbol-intern fn '@ 'log)
    (fset it `(lambda (&rest _) (xl-log ,(xl--log-message fn))))
    (advice-add fn (if after :after :before) it)))
#+end_src

******* reduce gc-cons-threshold
:PROPERTIES:
:ID:       41e763bd-215f-4176-95c1-f41261864671
:END:

Once in a while you come across a function that is computationally expensive,
such as [[][helm-system-packages]].

#+begin_src emacs-lisp
(defun xl-pause-garbage-collection (fn &optional props expire-fn)
  "Pause garbage collection for the duration of FN."
  (around-advice!
    (let ((gc-cons-threshold XL-GC-CONS-THRESHOLD-MAX))
      (apply orign-fn args)))
  (xl-add-advice fn :around it props expire-fn))
#+end_src

******* log
:PROPERTIES:
:ID:       843d4ca9-ea52-46ea-9d77-bfd9e7222669
:END:

#+begin_src emacs-lisp
(defun xl-message-with-xl-log (fn &rest props expire-fn)
  "Use `xl-log' instead of `message'."
  (alet (around-advice!
	  (cl-letf (((symbol-function 'message) #'xl-log))
	    (apply orig-fn args)))
    (xl-add-advice fn :around it props expire-fn)))
#+end_src

******* ignore output
:PROPERTIES:
:ID:       5053afcc-7a44-44d4-80b6-f42c3ea87926
:END:

#+begin_src emacs-lisp
(defun xl-ignore (fn &rest props expire-fn)
  "Ignore FN."
  (xl-add-advice fn :override #'ignore props expire-fn))
#+end_src

****** defadvice!
:PROPERTIES:
:ID:       1e0f3a27-a7d8-4e28-a359-f42ed7a16033
:END:

This section pertains to [[helpfn:defadvice!][defadvice!]], a replacement for [[helpfn:define-advice][define-advice]] that
provides a declarative way to define advices. This should be used for one-time
advices that.

******* define-advice!
:PROPERTIES:
:ID:       cc161eaf-a8fb-4e24-853f-a76a49c28dcf
:END:

The only difference between this and [[helpfn:define-advice][define-advice]] is that =NAME= and =SYMBOL= are
switched. In my opinion, the unique part of the function name being first is
more consistent with =defun=.

#+begin_src emacs-lisp
(defmacro define-advice! (name args &rest body)
  "A wrapper around `define-advice'.
The only difference is that this switches the order the arguments have to be
passed in.

\(fn ACTION (WHERE &optional ADVICE-ARGS TARGET &rest TARGETS) &rest BODY)"
  (declare (indent 2) (doc-string 3) (debug (sexp sexp body)))
  (unless (listp args)
    (signal 'wrong-type-argument (list #'listp args)))
  (-let (((where lambda-args fn props) args)
         (advice-name (intern (format "xl--%s-advice" name))))
    `(aprog1 (defun ,name ,lambda-args ,@body)
       (xl-add-advice #',fn ,where it ,props))))
#+end_src

******* anaphoric defadvice!
:PROPERTIES:
:ID:       98b2ce63-da31-4f7a-b776-1ee1747b5d57
:END:

=anaphoric-define-advice!= lets you omit the =lambda-args=. If you do omit the
arguments and you want to use them, you can do so via [[id:9938b1e1-6c6e-4a45-a85e-1a7f2d0bf6df][anaphoric variables]].

Note that [[helpfn:help-function-arglist][help-function-arglist]] returns =t= when it fails to get the function
arguments.

#+begin_src emacs-lisp
(defmacro anaphoric-define-advice! (name args &rest body)
  "A variant of `define-advice!'.
Unlike `define-advice!', this macro does not take an arglist as an argument.
Instead, arguments are accessed via anaphoric variables.

\(fn ACTION (WHERE TARGET &rest TARGETS) &rest BODY)"
  (-let* (((where target . other-args) args)
          (advice-args (if (eq where :around)
                           '(<orig-fn> &rest <args>)
                         '(&rest <args>))))
    `(define-advice! ,name (,where ,advice-args ,target ,@other-args)
       (ignore <args>)
       (cl-progv
           (->> (alet (help-function-arglist #',target t)
		  ;; kind of a hack...
		  (if (eq t it) nil it))
		(--remove (s-starts-with-p "@" (symbol-name it)))
		(--map (intern (format "<%s>" (symbol-name it)))))
	   <args>
	 ,@body))))
#+end_src

******* defadvice!
:PROPERTIES:
:ID:       d8773e00-1abe-4b03-82f0-07b47e93ccb4
:END:

This macro takes care of allowing multiple advices and deciding between whether
to use =defadvice!= or =anaphoric-defadvice!=.

#+begin_src emacs-lisp
(defmacro defadvice! (name args &rest body)
  "Define and advice.

\(fn ACTION (WHERE &optional ARGS-LIST TARGET &rest TARGETS) &rest BODY)"
  (-let* ((symbols-only (lambda (it) (and (symbolp it) (not (keywordp it)))))
          ((before fns after) (-partition-by symbols-only args))
          (advice-macro (if (listp (nth 1 args))
                            'define-advice!
                          'anaphoric-define-advice!)))
    `(progn
       ,@(--map `(,advice-macro ,name (,@before ,it ,@after) ,@body)
                fns))))
#+end_src

***** loading on call
:PROPERTIES:
:ID:       fa6583aa-5e7c-4212-be8a-b90b4c08aa31
:END:

Instead of loading all features on startup, we want to load features only when
we need them--just in time. And by "just in time" I mean at the last possible
moment or in practice just before a function that uses this feature is called.
While I could use =defadvice!= for defining these advices, doing this would
quickly become repetative because it's something that is done so often in
package configuration. The function =before-call= and =after-call= provide a fast
and convenient way to do this.

****** load-on-call
:PROPERTIES:
:ID:       324e707b-2f44-4168-a846-037f5401dedb
:END:

#+begin_src emacs-lisp
(defun xl--load-on-call (package where functions)
  "Load packages FUNCTIONS are called."
  (alet (xl-symbol-intern 'xl--load- package '-advice)
    (fset it `(lambda (&rest _)
                (xl-log "Loading %s" ',package)
                (require ',package)))
    (xl-add-advice functions where it nil t)))
#+end_src

****** load before call
:PROPERTIES:
:ID:       cc0e92bc-cd6d-4994-82ea-eb065fc3ad89
:END:

#+begin_src emacs-lisp
(defun xl-load-before-call (package functions)
  (xl--load-on-call package :before functions))
#+end_src

****** load after call
:PROPERTIES:
:ID:       b0b294d0-15ac-42d9-9e4c-fd9da8a95206
:END:

#+begin_src emacs-lisp
(defun xl-load-after-call (package functions)
  (xl--load-on-call package :after functions))
#+end_src


**** Keybindings
:PROPERTIES:
:ID:       b0680fe6-23eb-412f-a357-bfa5e5bb7af7
:END:

***** prefix bindings
:PROPERTIES:
:ID: b0b5b51c-155e-46fc-a80a-0d45a32440ba
:END:

A popular strategy to mitigate the mental load of remembering many keybindings
is to bind them in a tree-like fashion (see [[https://github.com/syl20bnr/spacemacs][spacemacs]]).

****** leader Keys
:PROPERTIES:
:ID: 143211d6-b868-4ffb-a5d0-25a77dee401f
:END:

#+begin_src emacs-lisp
(defconst XL-LEADER-KEY "SPC"
  "The evil leader prefix key.")

(defconst XL-LEADER-ALT-KEY "M-SPC"
  "The leader prefix key used for Insert and Emacs states.")
#+end_src

****** localleader keys
:PROPERTIES:
:ID: 45941bcb-209f-4aa3-829a-dee4e3ef2464
:END:

#+begin_src emacs-lisp
(defconst XL-LOCALLEADER-KEY "SPC m"
  "The localleader prefix key for major-mode specific commands.")

(defconst XL-LOCALLEADER-ALT-KEY "C-SPC m"
  "The localleader prefix key for major-mode specific commands.")

(defconst XL-LOCALLEADER-SHORT-KEY ","
  "A shorter alternative `xl-localleader-key'.")

(defconst XL-LOCALLEADER-SHORT-ALT-KEY "M-,"
  "A short non-normal  `xl-localleader-key'.")
#+end_src

***** general
:PROPERTIES:
:ID: 706f35fc-f840-4a51-998f-abcd54c5d314
:END:

There are numerous keybinding functions in Emacs; and they all look a little
different: there's [[helpfn:global-set-key][global-set-key]], [[helpfn:local-set-key][local-set-key]], [[helpfn:define-key][define-key]] and the list goes
on. And with [[https://github.com/emacs-evil/evil.git][evil]] which [[id:73366b3e-7438-4abf-a661-ed1553b1b8df][I use]] , there's also [[helpfn:evil-global-set-key][evil-global-set-key]] and
[[helpfn:evil-define-key][evil-define-key]]. [[https://github.com/noctuid/general.el.git][general]] provides a function that you can use for all bindings
([[helpfn:general-define-key][general-define-key]]).

****** init
:PROPERTIES:
:ID:       2d0487ba-0150-47f2-a3d5-9d3c26e64c31
:END:

#+begin_src emacs-lisp
(use-package! general
  :demand t
  :xl-config (general-auto-unbind-keys))
#+end_src

****** definers
:PROPERTIES:
:ID: 6444d218-1627-48bd-9b5c-7bfffb17d912
:END:

As I've mentioned =general= uses the function =general-define-key= as a generic
do-all key binder. Sometimes though we have keys that we want to bind with
specific arguments to =general-define-key= pretty often. A typical example of
this is binding =leader= or =localleader= keys like [[https://github.com/syl20bnr/spacemacs][spacemacs]].

This form creates a macro =define-leader-key!= that.

#+begin_src emacs-lisp
(use-package! general :xl-config
  (general-create-definer define-leader-key!
    :prefix XL-LEADER-KEY
    :non-normal-prefix XL-LEADER-ALT-KEY
    :keymaps 'override
    :states '(normal motion insert emacs)))
#+end_src

****** localleader
:PROPERTIES:
:ID:       e4770eae-adf5-4216-9016-5ec4bc465e03
:END:

There's pros and cons to the =SPC m= binding. The main pro is that it's
consistent with =SPC=. With the leader and the localleader, this means that you
can reach any binding from just =SPC=. This means that you can discover all
bindings from just one root binding. This is a nice property to have. On the
other hand, bindings can get a bit long. That one extra character can really
make a difference. That's why.

#+begin_src emacs-lisp
(defmacro define-localleader-key! (&rest args)
  (declare (indent defun))
  (alet `(:keymaps 'override
	  :states '(normal motion insert emacs)
	  ,@args)
    `(progn (general-def
              :prefix XL-LOCALLEADER-KEY
              :non-normal-prefix XL-LOCALLEADER-ALT-KEY
              ,@it)
            (general-def
              :prefix XL-LOCALLEADER-SHORT-KEY
              :non-normal-prefix XL-LOCALLEADER-SHORT-ALT-KEY
              ,@it))))
#+end_src

****** aliases
:PROPERTIES:
:ID:       81031f16-179e-4da7-9d83-7da5459fbdbd
:END:

In addition to providing keybinding stuff, =general= also provides.

#+begin_src emacs-lisp
(defalias 'define-key! 'general-def)
#+end_src

**** Packages
:PROPERTIES:
:ID:       d5c0d112-319d-4271-a819-eb786a64bfc6
:END:

***** backtrace
:PROPERTIES:
:ID:       63fe8a26-512e-41c6-8b8d-a9f3ba495bc9
:END:

This built-in emacs package is opens a buffer with a list.

#+begin_src emacs-lisp
(use-feature! backtrace
  :xl-rule ("bottom" "backtrace" :newname "\\*Backtrace\\*"))
#+end_src

***** origami
:PROPERTIES:
:ID:       ac2cc043-331f-435b-b903-39681b84fefe
:END:

#+begin_src emacs-lisp
(use-package! origami
  :xl-hook prog-mode-hook)
#+end_src

***** ts

#+begin_src emacs-lisp
(use-package! ts)
#+end_src

***** hideshow
:PROPERTIES:
:ID:       2b253cbb-43c8-44de-9526-8d9fb5d0e226
:END:

#+begin_src emacs-lisp
(use-feature! hideshow)
#+end_src

***** vc-hook
:PROPERTIES:
:ID:       a8dcb1f6-05a0-46cb-95b5-1d0cd0ad4467
:END:

#+begin_src emacs-lisp
(use-feature! vc-hooks
  :xl-set
  (vc-follow-symlinks . t)
  (vc-follow-link     . t))
#+end_src

***** subr-x
:PROPERTIES:
:ID:       ee3ad1b5-920a-4337-9874-79e066ed53fe
:END:

#+begin_src emacs-lisp
(use-feature! subr-x :demand t)
#+end_src

***** startup
:PROPERTIES:
:ID: 9725b7e0-54b8-4ab4-aa00-d950345d0aea
:END:

If you just set [[helpvar:inhibit-startup-echo-area-message][inhibit-startup-echo-area-message]] to =t= the word =nil= is messaged.
So it's best just to override the function entirely.

As per [[https://emacs.stackexchange.com/questions/18677/prevent-auto-save-list-directory-to-be-created][this stackoverflow question]], this prevents the =auto-save-directory= from
being created.

#+begin_src emacs-lisp
(use-feature! startup
  :xl-ignore display-startup-echo-area-message startup-echo-area-message
  :xl-set
  (auto-save-list-file-prefix  . nil)
  (inhibit-startup-buffer-menu . t)
  (inhibit-startup-message     . t)
  (inhibit-startup-screen      . t)
  (inhibit-default-init        . t)
  (inhibit-spash-screen        . t)
  (initial-scratch-message     . nil)
  (initial-buffer-choice       . #'xl-initial-buffer-choice)
  (initial-major-mode          . 'fundamental-mode)
  :init
  (defun xl-initial-buffer-choice ()
    "Return the initial buffer to be displayed.
This function is meant to be used as the value of `initial-buffer-choice'."
    (alet (if xl-debug-p "*xl-log*" "*scratch*")
      (get-buffer-create it))))
#+end_src

***** paren
:PROPERTIES:
:ID: 8ba80d6f-292e-4d44-acfe-d7b7ba939fa4
:END:

#+begin_src emacs-lisp
(use-feature! paren
  :xl-hook (prog-mode . show-paren-mode)
  :xl-set
  (show-paren-delay . 0))
#+end_src

***** clipboard
:PROPERTIES:
:ID: 60abb076-89b1-439b-8198-831b2df47782
:END:

#+begin_src emacs-lisp
(use-feature! clipboard
  :xl-set
  (selection-coding-system . 'utf-8)
  (select-enable-clipboard . t)
  (select-enable-primary   . t)
  (x-select-request-type   . '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
#+end_src

***** simple
:PROPERTIES:
:ID: 89df102a-a2c9-4ece-9acc-ed90e8064ed8
:END:

#+begin_src emacs-lisp
(use-feature! simple
  :xl-rule ("bottom" "messages" :newname "\\*Messages\\*")
  :xl-set
  (delete-trailing-lines . nil)
  (blink-matching-paren  . t)
  (idle-update-delay     . 1))
#+end_src

****** loaddefs
:PROPERTIES:
:ID:       5af4faf8-47e3-4db2-9d13-47fc828b8fca
:END:

These are *extremely* important lines if you use an external program as I do
([[https://wiki.archlinux.org/index.php/Msmtp][msmtp]]) to send your email. If you don't set these variables, emacs will
think you want to use =smtp=.

#+begin_src emacs-lisp
(use-feature! loaddefs
  :xl-set
  (disabled-command-function . nil))
#+end_src

***** backup
:PROPERTIES:
:ID:       f55fe748-209b-4450-a948-b0a7f8861dcf
:END:

#+begin_src emacs-lisp
(setq make-backup-files t)
(setq delete-by-moving-to-trash t)
(setq trash-directory (expand-file-name "~/Trash"))
#+end_src

***** files
:PROPERTIES:
:ID: 2a7862da-c863-416b-a976-4cf7840a8712
:END:

#+begin_src emacs-lisp
(use-feature! files
  :xl-set
  (confirm-nonexistent-file-or-buffer . nil)
  (backup-by-copying-when-linked      . t)
  (backup-directory-alist             . (list (cons ".*" (xl-data-dir "backup/"))))
  (require-final-newline              . nil)
  (delete-old-versions                . t)
  (auto-mode-case-fold                . nil)
  (confirm-kill-emacs                 . #'y-or-n-p)
  (auto-save-interval                 . 300)
  (backup-by-copying                  . t)
  (auto-save-default                  . nil)
  (auto-save-timeout                  . 30)
  (make-backup-files                  . nil)
  (kept-old-versions                  . 2)
  (kept-new-versions                  . 2)
  (trash-directory                    . (expand-file-name "Trash" "~"))
  (version-control                    . nil))
#+end_src

***** ffap
:PROPERTIES:
:ID: b1229201-a5ac-45c7-91fa-7a6b39bbb879
:END:

Don't ping things that look like domain names.

#+begin_src emacs-lisp
(use-feature! ffap
  :xl-set
  (ffap-machine-p-known . 'reject))
#+end_src

***** server
:PROPERTIES:
:ID: 3ddeb65c-9df6-4ede-9644-eb106b3ba1dd
:END:

#+begin_src emacs-lisp
(use-feature! server
  :xl-set
  (server-auth-dir . (xl-data-dir "server/")))
#+end_src

***** tramp
:PROPERTIES:
:ID: 3af0a4d6-bd08-4fe2-bc5c-79b1b811fc6b
:END:

#+begin_src emacs-lisp
(use-feature! tramp
  :xl-set
  (tramp-backup-directory-alist . backup-directory-alist)
  (tramp-persistency-file-name  . (xl-data-dir "tramp-persistency.el"))
  (tramp-auto-save-directory    . (xl-data-dir "tramp-auto-save/")))
#+end_src

***** cus-edit
:PROPERTIES:
:ID: 8bd5683d-91e1-4c1b-a8a5-3b39921e995d
:END:

#+begin_src emacs-lisp
(use-feature! cus-edit
  (custom-file            . null-device)
  (custom-theme-directory . (xl-local-dir "themes/")))
#+end_src

***** url
:PROPERTIES:
:ID: e4b5bfce-1111-48b2-bfee-da754974aa46
:END:

#+begin_src emacs-lisp
(use-feature! url
  :xl-set
  (url-cache-directory         . (xl-data-dir "url/cache/"))
  (url-configuration-directory . (xl-data-dir "url/configuration/")))
#+end_src

***** bytecomp
:PROPERTIES:
:ID:       6b375bfb-a8c3-473c-8dbd-530e692a15ab
:END:

#+begin_src emacs-lisp
(use-feature! bytecomp
  :xl-set
  (byte-compile-warnings . '(not free-vars unresolved noruntime lexical make-local))
  (byte-compile-verbose  . xl-debug-p))
#+end_src

***** compile
:PROPERTIES:
:ID:       913aa4f2-e42b-4b74-a2d4-e87b1738a5bd
:END:

#+begin_src emacs-lisp
(use-feature! compile
  :xl-set
  (compilation-ask-about-save . nil)
  (compilation-scroll-output  . 'first-error)
  (compilation-always-kill    . t))
#+end_src

***** uniquify
:PROPERTIES:
:ID:       9ba2726b-3fef-4e9b-9387-a80ab09bdb7d
:END:

#+begin_src emacs-lisp
(use-feature! uniquify
  :xl-set
  (uniquify-buffer-name-style . 'forward))
#+end_src

***** ansi-color
:PROPERTIES:
:ID:       5feaab76-e5c1-450c-94a6-8fdfb95ddb94
:END:

#+begin_src emacs-lisp
(use-feature! ansi-color
  :xl-set
  (ansi-color-for-comint-mode . t))
#+end_src

***** image mode
:PROPERTIES:
:ID:       32e2118a-c92b-4e8d-b2db-048428462783
:END:

Non-nil means animated images loop forever, rather than playing once.

#+begin_src emacs-lisp
(use-feature! image-mode
  :xl-set
  (image-animate-loop . t))
#+end_src

***** window
:PROPERTIES:
:ID:       af27cd7e-2096-4f6d-a749-63e4c38d136c
:END:

#+begin_src emacs-lisp
(use-feature! window
  :xl-set
  (split-width-threshold . 160))
#+end_src

***** indent
:PROPERTIES:
:ID:       a5d97d4d-3af9-4fde-ae14-953ad4d28edd
:END:

#+begin_src emacs-lisp
(use-feature! indent
  :xl-set
  (tab-always-indent . t))
#+end_src

***** mouse
:PROPERTIES:
:ID:       d0d6de11-50fa-4ae2-ad4b-69712f3e2c54
:END:

#+begin_src emacs-lisp
(use-feature! mouse
  :xl-set
  (mouse-yank-at-point . t))
#+end_src

***** calendar
;; :PROPERTIES:
;; :ID:       4ad7e704-f490-40e4-b2bc-8a30a10a7bb7
;; :END:

(setq diary-file (xl-data-dir "diary"))

(after! calendar
  (require 'f)
  (unless (f-exists-p diary-file)
    (f-touch diary-file)))

***** mule-cmds
:PROPERTIES:
:ID:       e48e925e-1f1e-4c79-8652-c92aafe06290
:END:

(setq prefer-coding-system XL-DEFAULT-CODING-SYSTEM)

***** gv
:PROPERTIES:
:ID:       84cc5883-a303-453e-af91-644d4544e3f9
:END:

=gv= is what contains the code for the =setf= macro.
https://emacs.stackexchange.com/questions/59314/how-can-i-make-setf-work-with-plist-get

#+begin_src emacs-lisp
(use-feature! gv
  :xl-config
  (gv-define-simple-setter plist-get plist-put))
#+end_src

***** nsm
:PROPERTIES:
:ID:       0ca7fc66-5312-4c69-a87d-7607292c7a2a
:END:

#+begin_src emacs-lisp
(use-feature! nsm
  :xl-set
  (nsm-settings-file . (xl-data-dir "network-settings.data")))
#+end_src

***** browse-url
:PROPERTIES:
:ID:       e59dc362-5615-45a8-8010-a111ddc5e835
:END:

=browse-url= is a built-in package that provides a useful abstraction for browsing
the web.

#+begin_src emacs-lisp
(use-feature! browse-url
  :xl-set
  (browse-url-firefox-new-window-is-tab . nil)
  (browse-url-firefox-arguments         . nil)
  (browse-url-new-window-flag           . t)
  :xl-config
  (alet (list (cons (rx "http://www.wikipedia.org/search") #'eww)
	      (cons "." #'browse-url-firefox))
    (setq browse-url-browser-function it)))
#+end_src

***** bookmarks
:PROPERTIES:
:ID:       a4514b36-6e08-4a66-a595-cd40fc9acc0b
:END:

#+begin_src emacs-lisp
(use-feature! bookmark
  :xl-set
  (bookmark-default-file . (xl-data-dir "bookmarks")))
#+end_src

**** Miscellaneous
:PROPERTIES:
:ID:       65edb4e7-0fe1-4e37-ae9b-027c9f15162a
:END:

This headline contains headings for which I have not yet determined a good
hierarchy.

***** delete duplicates in history
:PROPERTIES:
:ID:       1c381491-c4fa-4b5e-99de-ec6bd33df77c
:END:

This variable tells savehist not to record duplicate entries in history. Note
this is not apart of savehist technically; it is a variable defined in C source
code.

#+begin_src emacs-lisp
(set! history-delete-duplicates t)
#+end_src

***** don't echo keystrokes
:PROPERTIES:
:ID:       b8856ebe-6208-4271-ad5a-d352fabec8bb
:END:

After you type a key, emacs echoes it into the echo area. I find this
unnecessary. Additionally, if you use [[https://github.com/justbur/emacs-which-key][which-key]] this interferes with.

#+begin_src emacs-lisp
(setq-default echo-keystrokes 0)
#+end_src

***** log the init time
:PROPERTIES:
:ID:       36e2113f-a28f-4ef2-bb90-141f82291c91
:END:

I find it convenient to be able to view the init time in the =*xl-log*= buffer.

#+begin_src emacs-lisp
(defhook! log-init-time (emacs-startup-hook :append t)
  "Log the init time."
  (xl-log "emacs-init-time -> %s" (emacs-init-time)))
#+end_src

***** set the fill-column
:PROPERTIES:
:ID:       84d8e85a-a6a1-49cd-b46e-e5cd3f825438
:END:

Fill column refers to the column where line-wrapping will occur.

#+begin_src emacs-lisp
(setq-default fill-column 80)
#+end_src

***** recursive minibuffers
:PROPERTIES:
:ID:       7eb20f6d-75b4-4eec-8878-e7232c1a153d
:END:

This means that you can use the minibuffer while in the minibuffer. One
situation where I use this feature is in the command [[helpfn:eval-expression][eval-expression]]. As I'm
typing an expression, I get completion from the minibuffer.

#+begin_src emacs-lisp
(setq-default enable-recursive-minibuffers t)
#+end_src

***** use yes or no
:PROPERTIES:
:ID:       82a84315-2018-42e0-bd1a-74af7b722593
:END:

It suffices typing =y= or =n= as opposed to =yes= or =no=.

#+begin_src emacs-lisp
(xl-add-advice #'yes-or-no-p :override #'y-or-n-p)
#+end_src

***** utf-8 text encoding
:PROPERTIES:
:ID:       26344072-c145-40bd-9ade-8c7f2eef54c8
:END:

#+begin_src emacs-lisp
(setq-default locale-coding-system 'utf-8)
(setq-default buffer-file-coding-system 'utf-8)

(set-language-environment 'utf-8)
(setq-default locale-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
(setq-default default-file-name-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)

(setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
;; (unless IS-WINDOWS
;;   (setq selection-coding-system 'utf-8))

(when (fboundp 'set-charset-priority)
  (set-charset-priority 'unicode))
#+end_src

***** linux
:PROPERTIES:
:ID:       6572e618-e5ef-445b-90d6-14dc2c24f1a4
:END:

#+begin_src emacs-lisp
(with-os! linux
  (set! x-underline-at-descent-line t)
  (set! x-gtk-use-system-tooltips nil))
#+end_src

***** disable bi-directional text
:PROPERTIES:
:ID:       6c12f14c-75c7-4b30-9bb4-ca6e8d3cae47
:END:

Disabling bidirectional text provides a small performance boost. Bidirectional
text is useful for languages that read right to left.

#+begin_src emacs-lisp
(set-default! bidi-display-reordering 'left-to-right)
(set-default! bidi-paragraph-direction 'left-to-right)
#+end_src

***** scrolling
:PROPERTIES:
:ID:       c91bcd0f-da83-44a3-9d9e-e1f55dcdb642
:END:

#+begin_src emacs-lisp
(set-default! hscroll-margin 2)
(set-default! hscroll-step 1)
(set-default! scroll-conservatively 1001)
(set-default! scroll-margin 0)
(set-default! scroll-preserve-screen-position t)
#+end_src

***** fast scrolling
:PROPERTIES:
:ID:       964a8b3e-37b4-4d6b-9298-3a1be3cfe6aa
:END:

"More performant rapid scrolling over unfontified regions. May cause brief
spells of inaccurate fontification immediately after scrolling."

#+begin_src emacs-lisp
(set! fast-but-imprecise-scrolling t)
#+end_src

***** resize pixelwise
:PROPERTIES:
:ID:       02daff3d-e532-4cfa-a217-81e27627e7a7
:END:

;; https://github.com/baskerville/bspwm/issues/551#issuecomment-574975395

#+begin_src emacs-lisp
(set! window-resize-pixelwise t)
(set! frame-resize-pixelwise t)
#+end_src

***** disable cursor blinking
:PROPERTIES:
:ID:       fe8a259b-12e6-4e58-a324-eab831283a86
:END:

By default the cursor blinks. The point is so that it is easier to find on the
screen. Usually, however, I have no trouble finding it so I disable it.

#+begin_src emacs-lisp
(use-feature! frame
  :config
  (blink-cursor-mode -1))
#+end_src

***** stop beeping
:PROPERTIES:
:ID:       2a83cb3a-ca2e-4d9c-a296-340d33855614
:END:

#+begin_src emacs-lisp
(set-default! ring-bell-function #'ignore)
#+end_src

***** garbage collection
:PROPERTIES:
:ID: 27ad0de3-620d-48f3-aa32-dfdd0324a979
:END:

Emacs garbage collects too frequently for most modern machines. This makes emacs
less performant especially when performing a large number of calculations,
because it spends resources garbage collecting when it doesn't have to. Indeed,
increasing the value of [[helpvar:gc-cons-threshold][gc-cons-threshold]], the number of bytes of consing
between garbage collections, is known to make a notable difference in user
startup time. By default it is only 800 KB.

****** gc cons threshold
:PROPERTIES:
:ID: e15d257f-1b0f-421e-8b34-076b1d20e493
:END:

I define three levels on frequency with which emacs should perform garbage
collection.

#+begin_src emacs-lisp
(defconst XL-GC-CONS-THRESHOLD-MAX most-positive-fixnum
  "The upper limit for `gc-cons-threshold'.
When VOID is performing computationally intensive operations,
`gc-cons-threshold' is set to this value.")

(defconst XL-GC-CONS-THRESHOLD (eval-when-compile (* 16 1024 1024))
  "The default value for `gc-cons-threshold'.
This is the value of `gc-cons-threshold' that should be used in typical usages.")

(defconst XL-GC-CONS-THRESHOLD-MIN (eval-when-compile (* 4 1024 1024))
  "The value for `gc-cons-threshold'.")
#+end_src

****** gcmh
:PROPERTIES:
:ID:       86653a5a-f273-4ce4-b89b-f288d5d46d44
:END:

=gcmh= does three things. It reduces garbage collection by setting, it adds a
hook telling Emacs to gargbage collect during idle time, and it tells Emacs
to garbage collect more frequently when it's idle.

Note that I add gcmh mode hook at the end so that all the other hook commands
are done before setting the =gc-cons-threshold= back to a normal value.

#+begin_src emacs-lisp
(use-package! gcmh
  :xl-hook emacs-startup-hook
  :xl-set
  (gcmh-idle-delay . 5)
  (gcmh-verbose . xl-debug-p)
  (gcmh-high-cons-threshold . XL-GC-CONS-THRESHOLD)
  (gcmh-low-cons-threshold . XL-GC-CONS-THRESHOLD-MIN))
#+end_src

****** minibuffer
:PROPERTIES:
:ID: 83f47b4d-a0e2-4275-9c1a-7e317fdc4e41
:END:

[[helpvar:minibuffer-setup-hook][minibuffer-setup-hook]] and [[helpvar:minibuffer-exit-hook][minibuffer-exit-hook]] are the hooks run just before
entering and exiting the minibuffer (respectively). In the minibuffer I'll be
primarily doing searches for variables and functions. There are alot of
variables and functions so this can certainly get computationally expensive. To
keep things snappy I increase boost the [[helpvar:gc-cons-threshold][gc-cons-threshold]] just before I enter
the minibuffer, and restore it to it's original value a few seconds after it's closed.

It would take me forever to guess the name =minibuffer-setup-hook= from the
variable [[helpvar:minibuffer-exit-hook][minibuffer-exit-hook]]. If I knew the name =minibuffer-exit-hook= but did not
know what the hook to enter the minibuffer was, I'd probably
=minibuffer-enter-hook= because [[https://www.wordhippo.com/what-is/the-opposite-of/exit.html]["enter" is one of the main antonyms of "exit"]].
It'd take me forever to guess =startup=. Note that the only tricky thing about
this example.

At first I thought of =entry= but after more thought I realized
hook variables use action verbs in their names not nouns. So the =exit= in
=minibuffer-exit-hook= is actually the verb =exit= not the noun.

#+begin_src emacs-lisp
(defvaralias 'minibuffer-enter-hook 'minibuffer-setup-hook)

(defhook! boost-garbage-collection (minibuffer-enter-hook)
  "Boost garbage collection settings to `XL-GC-CONS-THRESHOLD-MAX'."
  (setq gc-cons-threshold XL-GC-CONS-THRESHOLD-MAX))

(defhook! defer-garbage-collection (minibuffer-exit-hook :append t)
  "Reset garbage collection settings to `xl-gc-cons-threshold' after delay."
  (setq gc-cons-threshold XL-GC-CONS-THRESHOLD))
#+end_src

***** theme
:PROPERTIES:
:ID: 2ac7c2fe-a2ba-4e55-a467-ff4af8850331
:END:

****** don't prompt me when loading theme
:PROPERTIES:
:ID:       eaa6531c-1188-41c7-a645-a82d9f482449
:END:

If you don't enable =custom-save-themes=, emacs asks you whether you're sure you
want to load a theme for security reasons. I prefer the convenience of not being
prompted.

Loading a theme qualifies as an intensive operation as all the faces on the
screen need to be redisplayed.

#+begin_src emacs-lisp
(use-feature! custom
  :xl-gc-pause load-theme
  :xl-set
  (custom-safe-themes . t))
#+end_src

****** loading theme
:PROPERTIES:
:ID: 7ae02d32-4652-494c-9e14-05f60ca60395
:END:

Sometimes there are things that need tidying up after loading a theme. For
example, if I'm using evil I need to update the cursor color.

#+begin_src emacs-lisp
(defvar xl-after-load-theme-hook nil
  "Hook run after the theme is loaded with `load-theme'.")

(defadvice! run-after-load-theme-hook (:after load-theme)
  "Set up `xl-load-theme-hook' to run after `load-theme' is called."
  (setq xl-theme <theme>)
  (run-hooks 'xl-after-load-theme-hook))
#+end_src

****** disable old themes first
:PROPERTIES:
:ID: 9d2f985b-8b0f-497f-982b-6f69c62179a9
:END:

Sometimes we end up with remants of the faces of old themes when we load a new
one. For this reason, I make sure to disable any enabled themes before applying
a new theme.

#+begin_src emacs-lisp
(defadvice! disable-old-themes (:around load-theme)
  "Disable old themes before loading new ones."
  (mapc #'disable-theme custom-enabled-themes)
  (apply <orig-fn> <args>))
#+end_src

***** disable terminal initialization
:PROPERTIES:
:ID: 63e351ad-9ef6-4034-9fca-861881c74d6a
:END:

When running emacs in terminal tty is *tremendously* slow.

#+begin_src emacs-lisp
(unless (display-graphic-p)
  (xl-add-advice #'tty-run-terminal-initialization :override #'ignore)
  (defhook! init-tty (window-setup-hook)
    (advice-remove #'tty-run-terminal-initialization #'ignore)
    (tty-run-terminal-initialization (selected-frame) nil t)))
#+end_src

***** prevent emacs from killing certain buffers
:PROPERTIES:
:ID:       ae935cf5-7322-499c-96d7-20209d9b6641
:END:

I never want the =*scratch*= and =*Messages*= buffer to be killed. I owe this idea
to [[https://github.com/rememberYou/.emacs.d][rememberYou's Emacs]].

#+begin_src emacs-lisp
(defhook! lock-certain-buffers (after-init-hook)
  "Prevent certain buffers from being killed."
  (--each (list "*scratch*" "*Messages*")
    (with-current-buffer it
      (emacs-lock-mode 'kill))))
#+end_src

***** prefixed-core
:PROPERTIES:
:ID:       14b63dc9-1d95-4bd7-8b29-8b2b33bd1e69
:END:

This package defines numerous aliases to existing commands in an attempt to make
commands more discoverable and naming schemes more consistent.

#+begin_src emacs-lisp
(use-package! prefixed-core
  :demand t)
#+end_src

***** keyfreq
:PROPERTIES:
:ID:       626b35f7-eef1-4a75-b2dc-8600c1ac47b7
:END:

=keyfreq= records the frequency of key strokes.

#+begin_src emacs-lisp
(use-package! keyfreq
  :xl-hook emacs-startup-hook)
#+end_src

***** idle-require
:PROPERTIES:
:ID:       0d619336-e852-4c6a-89a8-38ccbb71a077
:END:

Idle require is a tool for loading autoload functions, files or features during
idle time. The way to use this is to idle-require many small packages that
individually don't take too much time. This helps ensure that in emacs loading
of big packages like org-mode is snappy.

When emacs goes idle for [[helpvar:xl-idle-require-idle-delay][idle-require-idle-delay]] seconds, the features will
start loading. [[helpvar:xl-idle-require-load-break][idle-require-load-break]] is the break between features idle
require loads.

=idle-require= messages us to tell us when a package is being idle required and
when it has finished idle-requiring packages. I don't want to see the message
unless I'm debugging.

Since we're evaluating a good amount of lisp expressions, we should boost
garbage collection during this time.

#+begin_src emacs-lisp
(use-package! idle-require
  :demand t
  ;; :xl-use-xl-log idle-require-mode idle-require-load-next
  :xl-gc-pause idle-require-load-next
  :xl-set
  (idle-require-load-break . 2)
  (idle-require-idle-delay . 10))
#+end_src

**** Commands
:PROPERTIES:
:ID:       14fd249d-b972-472c-b57e-4e53a80b22dc
:END:

***** consult
:PROPERTIES:
:ID:       44120178-95c3-44f1-a3a2-bd69b0d03e70
:END:

Consult is a package that provides several generic utility functions.

****** don't preview anything

Many consult consult commands have a preview by default. Typically previews are
expensive. This is especially true for [[helpfn:consult-theme][consult-theme]], which switches the theme
every time you move from one candidate to another. If a preview is helpful and
its benefit is not outweighed by the performance cost of previewing, then I
favor using it.

#+begin_src emacs-lisp
(use-package! consult
  :xl-before-call
  (recentf . (consult-buffer-other-window consult-buffer))
  :xl-set
  (consult-preview-theme   . nil)
  (consult-preview-outline . t)
  (consult-preview-buffer  . nil)
  (consult-preview-line    . t))
#+end_src

****** autoload commands
:PROPERTIES:
:ID:       f78a7e71-b70a-4067-b821-f581cf76fb84
:END:

#+begin_src emacs-lisp
;; (use-package! consult)

;; (use-package! consult
;;   :general
;;   (:n "d" #'consult-theme)
;;   ()
;;   )

;; :commands
;; (list #'consult-theme   #'consult-line    #'consult-yank-pop
;; 	#'consult-outline #'consult-apropos #'consult-buffer
;; 	#'consult-buffer-other-window)
#+end_src

****** make sure commands display correctly
:PROPERTIES:
:ID:       a8d49e11-b173-4aea-ba43-08ec7bea4379
:END:

This headline addresses some inconveniences with the way =consult-line= and
=consult-outline=.

******* revealing folds
:PROPERTIES:
:ID:       e7c56a70-0772-41c3-a8a6-261e64ee3f36
:END:

When you have a folded outline structure (which will be true about 99% of the
time) and the point you select for your search is in folded text, consult does
not unfold it for you. This is annoying. The purpose of this headline is to
address this problem.

******** make sure commands work in folds
:PROPERTIES:
:ID:       6e442764-a323-4242-8dfd-818a82ea802b
:END:

This function is designed to reveal the current outline branch hierarchy so that
you can see the point where consult takes you.

#+begin_src emacs-lisp
(defun +outline-show-branch-maybe ()
  "Reveal the current outline branch.
Show all of the current headine's parents and their children. This includes this
headline."
  (when (outline-invisible-p (line-end-position))
    (let (points)
      (save-excursion
        (when (ignore-errors (outline-back-to-heading :invisible-ok))
          (push (point) points)
          (while (ignore-errors (outline-up-heading 1 :invisible-ok))
            (push (point) points))
          (dolist (point points)
            (goto-char point)
            (outline-show-children)
            (outline-show-entry)))))))
#+end_src

******** advise =consult-outline= and =consult-line=
:PROPERTIES:
:ID:       1b502b03-3aa8-428e-ae93-ffb6769490ff
:END:

#+begin_src emacs-lisp
(alet (list #'consult-outline #'consult-line)
  (xl-add-advice it :after #'+outline-show-branch-maybe))
#+end_src

******* window display
:PROPERTIES:
:ID:       b1049ef3-ab14-4b41-b759-eb3699107e71
:END:

Another rough edge with searching via consult is that sometimes the heading
won't be placed perfectly in a window. This headline is for addressing this
problem.

******** display children in window
:PROPERTIES:
:ID: f7a9c5e7-fcf8-434a-a9b3-dbe4eadead78
:END:

By default when you search a subtree with consult, you end up.

#+begin_src emacs-lisp
(defun +outline-display-children-in-window ()
  "Scroll up window to maximize view of unfolded subtree.
If the subtree is unfolded and the end of the current subtree is outside of the
visible window, scroll up until the whole subtree is visible. If the whole
subtree can't fit on the visible window, only scroll up until the top of the
subtree is on the first line of the window (in other words, the beginning of
th subtree should always be visible)."
  ;; Don't use `window-beg' and `window-end' because their values are
  ;; unreliable.
  (let ((subtree-beg (save-excursion (outline-back-to-heading)
				     (line-beginning-position)))
        (subtree-end (save-excursion (outline-end-of-subtree)
				     (line-end-position))))
    (while (and (pos-visible-in-window-p subtree-beg)
                (not (pos-visible-in-window-p subtree-end)))
      (scroll-up 1))
    ;; Sometimes the line at the end is not fully visible. So I try to
    ;; scroll down an extra line.
    (unless (pos-visible-in-window-p subtree-beg)
      (scroll-down 1))))
#+end_src

******** advise
:PROPERTIES:
:ID:       9ac87847-c116-4a0b-b2ab-544c1f02cdcf
:END:

#+begin_src emacs-lisp
(alet (list #'consult-outline #'consult-line)
  (xl-add-advice it :after #'+outline-display-children-in-window))
#+end_src

****** bindings
:PROPERTIES:
:ID:       c08a6f82-0408-4899-8e91-e1c5a062a7b2
:END:

#+begin_src emacs-lisp
(define-key!
  [remap switch-to-buffer]              #'consult-buffer
  [remap switch-to-buffer-other-window] #'consult-buffer-other-window
  [remap apropos]                       #'consult-apropos
  [remap load-theme]                    #'consult-theme)
#+end_src

***** setting font size
:PROPERTIES:
:ID: 4bf24b65-6f23-4e42-930e-4d43f766545c
:END:

Face attribute height is a magnitude of 10 greater than what we typically
use as font sizes (eg. font-size 14 corresponds to a face-height of 140).
I want to make sure I don't input 14 thinking about font size (it's
happened before and it's a huge pain resetting the font-size when the
font is super small). Therefore, I check the code.

#+begin_src emacs-lisp
(defun xl/set-font-size ()
  "Set the font size interactively."
  (interactive)
  (let* ((old-font-size (face-attribute 'default :height))
         (prompt "The font size is %d. What do you want to change it to? ")
         (font-size (string-to-number (read-string (format prompt old-font-size))))
         (digits (+ 1 (floor (log font-size 10)))))

    ;; Make the font-size be 3 digits (Do what I mean not what I say).
    (when (< digits 3)
      (setq font-size (* font-size (expt 10 (- 3 digits)))))
    (when (> digits 3)
      (setq font-size (/ font-size (expt 10 (- digits 3)))))

    ;; If font size is still doesn't make sense, ask me to make sure it's what I want.
    (if (or (< font-size 280)
            (y-or-n-p
             (format "You're choosing a pretty large font size: %d. Is this what you intended?)"
                     font-size)))
        (progn
          (set-face-attribute 'default nil :height font-size)
          (message "Your Font Size was %s. Font size is now: %s"
                   old-font-size
                   font-size))
      (message "Font Size has been cancelled."))))
#+end_src

***** set font
:PROPERTIES:
:ID:       f24d97b6-7c74-491a-a77c-ba3ec22a2b68
:END:

#+begin_src emacs-lisp
(defun xl/set-font-face ()
  "Apply an existing xfont to all graphical frames."
  (interactive)
  (alet (completing-read "Choose font: " (x-list-fonts "*"))
    (set-frame-font it nil t)))
#+end_src

***** important buffers
:PROPERTIES:
:ID:       8d04e395-5b57-434b-b975-9ae85620631d
:END:

****** init file
:PROPERTIES:
:ID:       08a3004c-6c37-401d-b584-c2c94577102d
:END:

#+begin_src emacs-lisp
(defun xl/open-init-file ()
  "Switch to init file."
  (interactive)
  (alet (or (get-file-buffer XL-INIT-FILE)
	    (create-file-buffer XL-INIT-FILE))
    (display-buffer it)))
#+end_src

****** messages buffer
:PROPERTIES:
:ID: 7064ea0e-20e0-481c-9d07-18e4506ee3e8
:END:

In Emacs, messages. The messages buffer is where messages displayed at the bottom
of the Emacs frame are recorded after they expire.

#+begin_src emacs-lisp
(defun xl/open-messages-buffer ()
  (interactive)
  (alet (get-buffer-create "*Messages*")
    (display-buffer it)))
#+end_src

****** main todo file
:PROPERTIES:
:ID: 2accd21d-7316-4fa5-bd8f-8f40935ed621
:END:

#+begin_src emacs-lisp
(defun xl/switch-to-capture-file ()
  (interactive)
  (switch-to-buffer (find-file XL-CAPTURE-FILE)))
#+end_src

****** xl-log buffer
:PROPERTIES:
:ID:       0d696000-94bb-45af-a7af-b96f29714089
:END:

****** switch to scratch buffer
:PROPERTIES:
:ID:       7d9af4b6-7744-437f-b088-ec9397056113
:END:

#+begin_src emacs-lisp
(defun xl/open-scratch ()
  "Pop scratch."
  (interactive)
  (pop-to-buffer "*scratch*"))
#+end_src

***** void specific funtions
:PROPERTIES:
:ID: 1b49e07a-466f-41da-8b31-18c28421cf62
:END:

****** all
:PROPERTIES:
:ID: e97267e8-fca8-4bf2-9899-7ec694e8a767
:END:

******* quit emacs without hook
:PROPERTIES:
:ID: b82f721c-39f5-4d41-bb0f-d4c391238eb4
:END:

Sometimes something goes wrong with [[helpvar:kill-emacs-hook][kill-emacs-hook]] and because of that I can't
close emacs. For that reason, I have this function.

#+begin_src emacs-lisp
(defun xl/kill-emacs-no-hook ()
  "Kill emacs, ignoring `kill-emacs-hook'."
  (interactive)
  (when (yes-or-no-p "Quit without `kill-emacs-hook'?")
    (let (kill-emacs-hook) (kill-emacs))))
#+end_src

******* quit emacs brutally
:PROPERTIES:
:ID: 8753217c-4722-4183-bbb3-049707a37e54
:END:

I've never had to use this. But better be safe than sorry.

#+begin_src emacs-lisp
(defun xl/kill-emacs-brutally ()
  "Tell an external process to kill emacs."
  (interactive)
  (when (yes-or-no-p "Do you want to BRUTALLY kill emacs?")
    (call-process "kill" nil nil nil "-9" (number-to-string (emacs-pid)))))
#+end_src

******* new emacs instance
:PROPERTIES:
:ID: eaf80ec3-2bd4-4f05-8a9c-fa525894a6fe
:END:

#+begin_src emacs-lisp
(defun xl/open-emacs-instance ()
  "Open a new emacs instance in debug-mode."
  (interactive)

  (cond ((eq system-type 'darwin)
         (start-process-shell-command
          "emacs"
          nil "open -n /Applications/Emacs.app --args --debug-init"))
        ((eq system-type 'gnu/linux)
         (start-process "emacs" nil "emacs" "--debug-init"))))
#+end_src

******* kill all process of program
:PROPERTIES:
:ID: 913952e2-3727-4b38-aefc-4618c2771730
:END:

#+begin_src emacs-lisp
(defun xl/kill-emacs-processes ()
  (interactive)
  (let ((count 1) (process "emacs"))
    (kill-process process)
    (while (ignore-errors (kill-process process))
      (setq process (format "emacs<%d>" count))
      (cl-incf count))
    (message "killed %d processes" count)))
#+end_src

****** turn on debug-mode
:PROPERTIES:
:ID: c1ac481a-6ebd-49ce-a930-3b0593283aee
:END:

#+begin_src emacs-lisp
(defun xl/enable-debug-mode ()
  (interactive)
  (setq xl-debug-p t))
#+end_src

****** quit emacs no prompt
:PROPERTIES:
:ID: d530718a-2b42-4e9b-8d7d-7813e0ae6381
:END:

#+begin_src emacs-lisp
(defun xl/quit-emacs-no-prompt ()
  "Quit emacs without prompting."
  (interactive)
  (let (confirm-kill-emacs)
    (kill-emacs)))
#+end_src

*** Completion
:PROPERTIES:
:ID:       744ac652-aebc-4f5b-883a-4464dd7b07cd
:END:

Completion has certainly become an integral part of any efficient workflow. One
commonality among things like searching emails, code-completing a word, surfing
the web is that in one way or another all of these things involve the suggestion
of likely candidates from a population that is too time consuming to look
through on our own. It's not much different in Emacs. We're constantly sifting
though files, buffers, commands, words--all to try to get through to the subset
of things that we actually want at this moment.

**** helm
:PROPERTIES:
:ID:       4123691d-216b-4ba5-8d3d-b09f83143f60
:END:

Helm is the most popular emacs completion framework. It is full-featured and
extremely customizable. I haven't found an official manual for it but I often
see people reference [[http://tuhdo.github.io/helm-intro.html][this helm intro]] that showcase many useful helm
commands. Among the advatages helm has are the breath of support and it's
maturity. I also like that it uses the buffer instead of the minibuffer. The
biggest complaint heard about Helm is that it's too bloated and slow.

***** helm-core
:PROPERTIES:
:ID:       19d42b82-03ec-4458-9771-d992ad25cd6b
:END:

#+begin_src emacs-lisp
(use-package! helm
  :commands helm-M-x
  :xl-hook emacs-startup-hook
  :xl-ignore helm-display-mode-line
  :xl-rule ("bottom" "helm" :newname "\\*Helm.+")
  :xl-set
  (helm-default-display-buffer-functions . nil)
  ;; (helm-display-buffer-height            . 0.6)
  ;; (helm-display-buffer-default-height    . 0.6)
  (helm-candidate-number-limit           . 50)
  (helm-display-header-line              . nil)
  (helm-mode-line-string                 . nil))
#+end_src

***** helm-mode
:PROPERTIES:
:ID:       5659f309-43ec-4718-959b-a161e837fb92
:END:

#+begin_src emacs-lisp
(use-package! helm-files
  :xl-ensure nil
  :xl-set
  (helm-ff-auto-update-initial-value . nil)
  (helm-ff-lynx-style-map            . nil)
  (helm-find-files-doc-header        . nil)
  :bind
  ([remap man]                       . helm-man-woman)
  ([remap info]                      . helm-info)
  ([remap apropos]                   . helm-apropos)
  ([remap find-library]              . helm-locate-library)
  ([remap execute-extended-command]  . helm-M-x)
  ([remap find-file]                 . helm-find-files)
  ([remap locate]                    . helm-locate)
  ([remap imenu]                     . helm-semantic-or-imenu)
  ([remap noop-show-kill-ring]       . helm-show-kill-ring)
  ([remap recentf]                   . helm-recentf)
  ([remap switch-to-buffer]          . helm-mini))
#+end_src

***** helm descbinds
:PROPERTIES:
:ID:       8f42e055-50f6-42dd-b850-5e6eb09d6da2
:END:

#+begin_src emacs-lisp
(use-package! helm-descbinds
  :xl-hook (helm-mode-hook . helm-descbinds-mode))
#+end_src

***** helm-map
:PROPERTIES:
:ID:       cb8b2bc0-9956-4e79-a7b0-b0463807eea0
:END:

#+begin_src emacs-lisp
(general-def '(emacs insert) helm-map
  "C-o"     #'helm-toggle-visible-mark-forward
  "C-j"     #'helm-next-line
  "C-k"     #'helm-previous-line
  "C-n"     #'helm-next-page
  "C-a"     #'helm-select-action
  "TAB"     #'helm-next-line
  "C-l"     #'helm-execute-persistent-action
  [backtab] #'helm-previous-line
  "<RET>"   #'helm-maybe-exit-minibuffer)
#+end_src

***** helm-system-packages
:PROPERTIES:
:ID:       72e73fd5-4c63-4b96-98d7-2dd123e62436
:END:

[[https://github.com/emacs-helm/helm-system-packages][helm-system-packages]] incorporates helm with your operating system's package manager.

#+begin_src emacs-lisp
(use-package! helm-system-packages
  :xl-gc-pause helm-system-packages
  :xl-set
  (helm-system-packages-cache-file . (xl-data-dir "helm-system-packages-cache")))
#+end_src

***** helm-dash
:PROPERTIES:
:ID:       6dd9a08b-382d-4bb7-baa5-d65d0e136869
:END:

#+begin_src emacs-lisp
(use-package! helm-dash
  :commands helm-dash
  :xl-set
  (helm-dash-docsets-path . (xl-data-dir "/dash-docsets"))
  (helm-dash-browser-func . (if (executable-find "w3m") #'w3m #'browse-url)))
#+end_src

***** helm-org-rifle
:PROPERTIES:
:ID:       232e2ec6-c66a-410c-bc6a-11e3300b14cf
:END:

#+begin_src emacs-lisp
(use-package! helm-org-rifle)
#+end_src

***** helm-org
:PROPERTIES:
:ID:       1e19a081-d107-4593-8af4-e72c84bbaeff
:END:

#+begin_src emacs-lisp
(use-package! helm-org
  :xl-before-call (org-capture . helm-org-capture-templates)
  :init
  (general-def [remap org-capture] #'helm-org-capture-templates))
#+end_src

***** helm-themes
:PROPERTIES:
:ID:       6681a9ff-a51c-42ce-a6a6-570e8ef5ecfe
:END:

#+begin_src emacs-lisp
(use-package helm-themes
  :bind
  ([remap load-theme] . helm-themes))
#+end_src

***** helm-xref
:PROPERTIES:
:ID:       fc1c71e1-775d-44a3-bd82-dedbca1e2ba6
:END:

#+begin_src emacs-lisp
(use-package! helm-xref)
#+end_src

***** swiper-helm
:PROPERTIES:
:ID:       b63c7612-5e2c-4431-83c3-3c6dd7926cbd
:END:

#+begin_src emacs-lisp
(use-package! swiper-helm
  :xl-gc-pause swiper-helm)
#+end_src

***** ace-helm-jump-line
:PROPERTIES:
:ID:       e74e6b9b-cdd7-4d6b-888f-0e9ec9584b32
:END:

[[https://github.com/cute-jumper/ace-jump-helm-line/issues][ace-jump-helm-line]] is a package that provides a fast way to choose a candidates
in a helm window. Specifically it uses [[https://github.com/abo-abo/avy][avy]] to letter the candidates. You can
then enter call [[helpfn:ace-jump-helm-line][ace-jump-helm-line]] by pressing a key (I bound it to =C-'= and =,=),
press the key corresponding to the candidate you want. It saves me from pressing
=C-j= multiple times to scroll down the the candidate I want.

#+begin_src emacs-lisp
(use-package! ace-jump-helm-line
  :init
  (general-def '(insert emacs) helm-map
    "C-'" #'ace-jump-helm-line
    ","   #'ace-jump-helm-line)
  :xl-set
  (ace-jump-helm-line-idle-delay     . 0)
  (ace-jump-helm-line-default-action . 'select)
  (ace-jump-helm-line-style          . 'pre)
  (ace-jump-helm-line-select-key     . ?e)
  (ace-jump-helm-line-move-only-key  . ?o)
  (ace-jump-helm-line-persistent-key . ?p)
  :xl-config
  (after! helm
    (require 'ace-jump-helm-line)
    (ace-jump-helm-line-autoshow-mode)))
#+end_src

#+end_src

**** company
:PROPERTIES:
:ID:       5c0ed97e-da66-42ab-a033-381ac9dd8972
:END:

***** setup
:PROPERTIES:
:ID:       5e5393d9-9f58-45be-9ecc-1bc9f0316379
:END:

#+begin_src emacs-lisp
(use-package! company
  :xl-hook prog-mode-hook
  :xl-set
  (company-tooltip-align-annotations . t)
  (company-minimum-prefix-length     . 1)
  (company-minimum-prefix-length     . 1)
  (company-dabbrev-downcase          . nil)
  (company-require-match             . 'never)
  (company-tooltip-limit             . 14)
  (company-show-numbers              . t)
  (company-idle-delay                . 0.15)
  (company-frontends                 . '(company-pseudo-tooltip-frontend)))
#+end_src

***** bindings
:PROPERTIES:
:ID:       ba170d95-7d86-4827-af6b-dc5fd4c1b7e5
:END:

#+begin_src emacs-lisp
(define-key! company-active-map
   [tab]     #'company-select-next
   [backtab] #'company-select-previous
   "C-k"     #'company-select-previous
   "C-j"     #'company-select-next)
#+end_src

***** backends
:PROPERTIES:
:ID:       bd47ec52-6428-4f37-80d2-3795f5a42d02
:END:

****** determining which modes are active
:PROPERTIES:
:ID:       b8603ca5-9a24-4684-a75b-e0c3845bfff0
:END:

[[https://stackoverflow.com/questions/1511737/how-do-you-list-the-active-minor-modes-in-emacs][listing active minor modes]]

#+begin_src emacs-lisp
(defun xl-active-minor-modes ()
  "Return active minor modes in current buffer."
  (--select (and (boundp it) (symbol-value it)) minor-mode-list))
#+end_src

****** backends-alist
:PROPERTIES:
:ID:       dac0a998-e1b1-424f-8c40-e1bc19843153
:END:

#+begin_src emacs-lisp
(defvar company:backend-alist
  '((text-mode :derived (company-dabbrev company-tempo company-ispell))
    (prog-mode :derived ((:separate company-capf company-tempo))))
  "An alist modes to company backends.")
#+end_src

****** initialize backends
:PROPERTIES:
:ID:       4e82e869-b144-44aa-bc19-bb58b8c5ff2a
:END:

When the user

#+begin_src emacs-lisp
(defhook! setup-company-backends (company-mode-hook)
  "Set `company-backends' for the current buffer."
  (alet (company:backends-for-mode major-mode)
    (xl-log "Set up %S backends: %S" major-mode it)
    (set (make-local-variable 'company-backends) it)))
#+end_src

****** get backends
:PROPERTIES:
:ID:       282a2c16-ae5f-4d81-acaa-8d60fb24e762
:END:

#+begin_src emacs-lisp
(cl-defun company:backends-for-mode (&optional (current-major-mode major-mode))
  "Return a list of company backends for major-mode."
  (loopy (with (active-minor-modes (xl-active-minor-modes)))
	 ((list (mode type backends) company:backend-alist)
	  (expr derived-p (and (eq type :derived) (derived-mode-p mode)))
	  (expr mm-enabled-p (or (eq current-major-mode mode)
				 (and (boundp mode) (symbol-value mode))))
	  (expr active-minor-mode-p (member mode active-minor-modes))
	  (cond ((and (eq type :only) (or mm-enabled-p active-minor-mode-p))
		 (return backends))
		((or (or derived-p (and (eq type :exact) mm-enabled-p))
		     active-minor-mode-p)
		 (append new-backends backends))))))
#+end_src

***** company-prescient
:PROPERTIES:
:ID:       be4bc19d-a25c-4e2d-9f12-5d2946bc9931
:END:

[[https://github.com/raxod502/prescient.el][company-prescient]] is the same as =prescient= but for =company= instead of =ivy=.

#+begin_src emacs-lisp
(use-package! company-prescient
  :xl-hook company-mode-hook)
#+end_src

***** close company on escape
:PROPERTIES:
:ID: 750cc608-865e-4f69-a7b2-826fc66a7b71
:END:

#+begin_src emacs-lisp
(defhook! close-tooltip (xl-escape-hook)
  "Close company tooltip."
  (when (and (boundp 'company-mode) (eq company-mode t))
    (company-abort)
    t))
#+end_src

**** tempo
:PROPERTIES:
:ID:       36573b5e-f880-4079-840f-625c0b39704c
:END:

Tempo is a built-in snippet package. It's advantage over =yasnippet= is that it
can define a template using a lisp form as opposed to a string. This means it's
more hackable and more expressive.

Because yasnippets are strings it makes them less friendly for storing as a lisp
form. You still could, mind you, but essentally you'd fill your config with long
template strings. I never liked storing snippets in their own directory and as
many little files. One thing is that you have to deal with making sure the files
exist and that they're in the right path. Another thing is that you need to
manage snippet file loading because it's expensive to load all the snippets at
once if you have alot.

***** init
:PROPERTIES:
:ID:       535c8572-922c-48e1-829f-e0f005c26937
:END:

#+begin_src emacs-lisp
(use-feature! tempo
  :xl-config
  (after! company (set! company-tempo-expand t)))
#+end_src

***** add completing read to tempo
:PROPERTIES:
:ID:       ef9b06b1-826f-4030-950e-1884ce546654
:END:

Making sure that tempo can completing read.

****** tempo completing read
:PROPERTIES:
:ID:       2995030d-3848-42b8-8954-3d2366db641c
:END:

#+begin_src emacs-lisp
(defun tempo:completing-read (save-name &rest args)
  (let ((insertion (apply #'completing-read args)))
    (when save-name
      (tempo-save-named save-name insertion))
    (insert insertion)))
#+end_src

****** C keyword
:PROPERTIES:
:ID:       35e24bac-7b64-4e7f-b127-59c8e870aa56
:END:

[[helpfn:tempo-completing-read+][tempo-completing-read+]] already takes care of inserting the correct value.

#+begin_src emacs-lisp
(after! tempo
  (defun tempo:C-keyword (element)
    (when (eq (car-safe element) 'C)
      (let ((tempo-interactive t))
	(apply 'tempo:completing-read (cdr element)))
      ""))
  (push #'tempo:C-keyword tempo-user-elements))
#+end_src

***** tempo-snippets
:PROPERTIES:
:ID:       fa5d20be-f873-4b64-b218-33fc0a54bea6
:END:

=tempo-snippets= is a package that adds overlays.

****** tempo-snippets

#+begin_src emacs-lisp
(use-package! tempo-snippets)
#+end_src

****** use tab and backtab
:PROPERTIES:
:ID:       7205d26c-b01b-4619-a8d4-f374be0a2006
:END:

By default the tempo-snippet uses the standard =M-n= and =M-p=
bindings. However, I prefer the more mainstream =TAB= and =BACKTAB=.

#+begin_src emacs-lisp
(general-def '(insert normal) tempo-snippets-keymap
  "TAB" #'tempo-snippets-next-field
  [backtab] #'tempo-snippets-previous-field)

(general-def tempo-snippets-keymap
  "TAB" #'tempo-snippets-next-field
  [backtab] #'tempo-snippets-previous-field)
#+end_src

****** stop template after completion
:PROPERTIES:
:ID:       7b1d005f-f743-4ce1-88f0-dd68de5fd3ee
:END:

The overlays from =tempo-snippets= don't disappear after you reach the last
mark. I need to call.

****** handle user elements
:PROPERTIES:
:ID:       c2d4ce64-636b-4b7e-b023-df17c9f82ca4
:END:

=tempo-snippets= doesn't handle [[helpvar:tempo-user-elements][tempo-user-elements]]. =tempo-user-elements= are
custom additions to the tempo syntax. The writers of =tempo-snippets= actually
have [[][a FIXME line]] where they say they haven't done this yet. So if you're
like me and defined any, they will be ignored. The purpose of this headline is
to address this problem.

The relevant function here is [[helpfn:tempo-snippets-insert-template][tempo-snippets-insert-template]]. In this function
we can see that [[helpvar:tempo-user-elements][tempo-user-elements]] is let bound to a list of just one user
element, [[helpfn:tempo-snippets-insert-form][tempo-snippets-insert-form]]. The problem is that
=tempo-snippets-insert-form= doesn't know about the other tempo user elements. The
following code injects that knowledge into =tempo-snippets-insert-form= via an
around advice. Note that if later we add more user elements, we have to update
this advice.

#+begin_src emacs-lisp
(after! tempo
  (alet `(lambda (orig-fn &rest args)
	   (let ((tempo-user-elements ',tempo-user-elements)
		 (element (car args)))
	     (alet (or (tempo-is-user-element element) element)
	       (apply orig-fn (list it)))))
    (let ((name (xl-advice-name #'tempo-snippets-insert-form 'handle-user-elements)))
      (fset name it)
      (advice-add #'tempo-snippets-insert-form :around name))))
#+end_src

****** defining snippets

******* taglist name

#+begin_src emacs-lisp
(defun tempo:taglist-name (mode)
  "Return a variable name for taglist."
  (xl-symbol-intern 'tempo: mode '-taglist))
#+end_src

******* snippet macro
:PROPERTIES:
:ID:       33550f12-c282-48cb-8737-5f4240f51121
:END:

The purpose of this macro is to provide a "defun-like" syntax for defining tempo
snippets. Additionally, it should be a uniform way to configure snippets across
several different packages.

#+begin_src emacs-lisp
(defmacro defsnippet! (name args docstring &rest body)
  "Define a `tempo' snippet for MODE.
Define a snippet via `tempo-define-snippet'. Also create a taglist variable for
MODE if one does not exist."
  (declare (indent defun))
  (-let* ((name (symbol-name name))
	  (tag (-first-item args))
	  ((mode other-modes) (-list (-second-item args)))
	  (hook (xl-symbol-intern 'set-tempo-tags-for- mode))
	  (taglist (tempo:taglist-name mode)))
    `(progn
       (defvar ,taglist nil
	 ,(format "List of `tempo' tags for `%s'" mode))
       (unless (fboundp ',hook)
	 (defhook! ,hook (,(xl-hookify mode))
	   ,(format "Set taglist to be used for `%s'." mode)
	   (require 'tempo)
	   (tempo-use-tag-list ',taglist)))
       (after! tempo
	 (tempo-define-snippet ,name ,(car body) ,tag ,docstring ',taglist))
       ,@(when other-modes
	   '((defsnippet! ,name (,tag ,other-modes) ,docstring ,body))))))
#+end_src

*** Utility

**** elfeed
:PROPERTIES:
:ID:       6aa4ece0-0b94-48b6-9a99-4b85cd1f7ccd
:END:

#+begin_src emacs-lisp
(use-package! elfeed)
#+end_src

**** chess
:PROPERTIES:
:ID:       1197be6f-a2ff-4cf1-8b78-02ebceb43317
:END:

#+begin_src emacs-lisp
(use-package! chess)
#+end_src

**** avy
:PROPERTIES:
:ID:       78064d92-2dde-4067-8a10-208ca6e88852
:END:

#+begin_src emacs-lisp
(use-package! avy
  :xl-set
  (avy-style . 'pre)
  (avy-keys . (number-sequence ?a ?z)))
#+end_src

**** hide-mode-line
:PROPERTIES:
:ID:       e8f53422-9d24-4119-9b0f-9b6d1e10c1b0
:END:

#+begin_src emacs-lisp
(use-package! hide-mode-line
  :commands hide-mode-line-mode)
#+end_src

**** man
:PROPERTIES:
:ID:       3982b034-90e1-4961-90d9-224e913c0b8c
:END:

#+begin_src emacs-lisp
(use-feature! man
  :xl-rule ("left" "man" :newname "\\*man.+"))
#+end_src

**** passwords and security
:PROPERTIES:
:ID:       7ca7587e-d94b-408b-8656-c6a09d6ee8b6
:END:

***** pass
:PROPERTIES:
:ID:       6f3268a1-4606-435d-9bf4-05d1c54c28a9
:END:

#+begin_src emacs-lisp
(use-package! pass)
#+end_src

***** password-store
:PROPERTIES:
:ID:       3c57590c-1507-4369-b615-795965d4b182
:END:

#+begin_src emacs-lisp
(use-package! password-store)
#+end_src

**** nameless
:PROPERTIES:
:ID:       695aeb73-89d3-47f8-bee8-2721111dd2bf
:END:

=nameless= is a package that truncates namespace prefixes that you specify
in. Shortening aliases allows for more concise, easier to read, and less
redundant code.

#+begin_src emacs-lisp
(use-package! nameless
  :xl-hook emacs-lisp-mode-hook
  :xl-set (nameless-private-prefix . t))
#+end_src

**** fortune-cookie
:PROPERTIES:
:ID:       8105dadd-4d4a-4f57-a5f9-5cae1b14ef3a
:END:

#+begin_src emacs-lisp
(use-package! fortune-cookie
  :commands fortune-cookie)
#+end_src

**** figlet
:PROPERTIES:
:ID:       b5be9427-a814-4a91-92ab-ad393375ec41
:END:

#+begin_src emacs-lisp
(use-package! figlet :commands figlet)
#+end_src

**** grugru
:PROPERTIES:
:ID:       9d96a611-355a-4b62-bb0e-18e9d4af92c9
:END:

#+begin_src emacs-lisp
(use-package! grugru)
#+end_src

**** ht
:PROPERTIES:
:ID:       56bb0ff4-6ad1-44b7-a9a4-54abf48ed253
:END:

=ht= is a package that tries to provide a consistently named API for dealing with
hash-tables.

#+begin_src emacs-lisp
(use-package! ht)
#+end_src

**** system-packages
:PROPERTIES:
:ID:       74bd0e5a-f6b0-48eb-a91e-3932eae23516
:END:

=system-packages= provides an api for installing system packages. This api strives
to abstract package installation on different operating systems. Unfortunately,
it does not include an interactive function that uses [[helpfn:completing-read][completing-read]] to list
packages

***** init
:PROPERTIES:
:ID:       08bf0487-2a57-483d-8d22-8253ebda6d9d
:END:

#+begin_src emacs-lisp
(use-package! system-packages
  :xl-rule ("bottom" "system-packages" :newname "\\*system-packages")
  :xl-set (system-packages-noconfirm . t))
#+end_src

***** use yay for arch
:PROPERTIES:
:ID:       2fc48e66-83f3-4e35-8b2c-ef9113cb9b45
:END:

If we're in arch and we have yay intalled, use that.

#+begin_src emacs-lisp
(after! system-packages
  (when (and (eq system-packages-package-manager 'pacman)
             (system-packages-package-installed-p "yay"))
    (alet (alist-get 'pacman system-packages-supported-package-managers)
      (push `(yay (default-sudo . nil)
                  ,@(-map (-lambda ((action . command))
			    (cons action (s-replace "pacman" "yay" command)))
                          (cdr it)))
            system-packages-supported-package-managers))
    (setq system-packages-package-manager 'yay)))
#+end_src

**** mmt
:PROPERTIES:
:ID:       a4377985-fe0e-4980-b839-08c334bde76c
:END:

=mmt= is a library of tools for writing macros. Specifically, it provides the
quintessential =once-only= and =with-gensyms= macros which are used to prevent
variable leaking.

#+begin_src emacs-lisp
(use-package! mmt)
#+end_src

**** ellocate
:PROPERTIES:
:ID:       e3590042-52fb-47ee-a5eb-a7860a3cdb17
:END:

#+begin_src emacs-lisp
(use-package! ellocate
  :commands ellocate
  :xl-set
  (ellocate-scan-dirs . `(("~/" . ,(xl-data-dir "ellocate"))))
  (ellocate-gc-mem . most-positive-fixnum))
#+end_src

**** epa
:PROPERTIES:
:ID:       ad3f6134-4fa6-492e-93a6-b94235ecad3d
:END:

Setting these variables in coordination with configuring =gpgconf= lets me enter
my gpg passphrase via emacs.

#+begin_src emacs-lisp
(use-feature! epa-config
  :xl-set
  (epg-gpg-program . "gpg2")
  (epa-pinentry-mode . 'loopback))
#+end_src

**** pdf-tools
:PROPERTIES:
:ID:       63343f9d-6b19-43de-8302-d1344d571949
:END:

***** init
:PROPERTIES:
:ID: 163d8880-6a7d-4479-a7e4-e333e4f930da
:END:

#+begin_src emacs-lisp
(use-package! pdf-tools
  :magic ("%PDF" . pdf-view-mode)
  :init
  (push '("\\.[pP][dD][fF]\\'" . pdf-view-mode) auto-mode-alist))
#+end_src

***** epd-pdf-info-program
:PROPERTIES:
:ID:       25826061-a4a7-4f8a-8d3b-bdd5a80f70d0
:END:

#+begin_src emacs-lisp
(defadvice! build-pdf-into-program-maybe (:before pdf-view-mode)
  "Build the pdf-info program if it hasn't already been built."
  (unless (file-executable-p pdf-info-epdfinfo-program)
    (let ((wconf (current-window-configuration)))
      (pdf-tools-install)
      (message "Building epdfinfo, this will take a moment...")
      (--each (buffer-list)
        (with-current-buffer it
          (when (eq major-mode 'pdf-view-mode)
            (fundamental-mode))))
      (while compilation-in-progress
        ;; Block until `pdf-tools-install' is done
        (redisplay)
        (sleep-for 1))
      ;; HACK If pdf-tools was loaded by you opening a pdf file, once
      ;;      `pdf-tools-install' completes, `pdf-view-mode' will throw an error
      ;;      because the compilation buffer is focused, not the pdf buffer.
      ;;      Therefore, it is imperative that the window config is restored.
      (when (file-executable-p pdf-info-epdfinfo-program)
        (set-window-configuration wconf)))))
#+end_src

***** bindings
:PROPERTIES:
:ID:       506c568c-0473-4db6-82b6-cc91174b0ce4
:END:

#+begin_src emacs-lisp
(use-package! pdf-tools
  :general
  (:states 'normal :keymaps 'pdf-view-mode-map
   "j" #'pdf-view-next-line-or-next-page
   "k" #'pdf-view-previous-line-or-previous-page
   "0" #'pdf-view-first-page
   "9" #'pdf-view-last-page
   "s" #'pdf-view-fit-width-to-window))
#+end_src

**** web browsing
:PROPERTIES:
:ID:       0be0a36f-67dc-4db5-8d0a-321d19bae08a
:END:

***** engine-mode
:PROPERTIES:
:ID:       d701f44f-85eb-4849-8f2d-15423eb41a02
:END:

****** init
:PROPERTIES:
:ID:       f5a2c47b-01df-4dcf-b012-b6311cf79683
:END:

#+begin_src emacs-lisp
(use-package! engine-mode)
#+end_src

****** different engines
:PROPERTIES:
:ID:       2f5c974e-b26e-4080-a9b3-acd6406ab118
:END:

This package essentially automates the creation of an interactive web searching
functions.

#+begin_src emacs-lisp
(use-package! engine-mode :xl-config
  (defengine amazon
    "http://www.amazon.com/s/ref=nb_sb_noss?url=search-alias%3Daps&field-keywords=%s")
  (defengine duckduckgo
    "https://duckduckgo.com/?q=%s")
  (defengine qwant
    "https://www.qwant.com/?q=%s")
  (defengine wikipedia
    "http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s"))
#+end_src

***** eww
:PROPERTIES:
:ID:       77d23774-7f42-45ee-90ec-5f28efddee65
:END:

****** ability to add new windows
:PROPERTIES:
:ID:       54dc52bb-f7e5-4a86-a306-aa42482cbd6d
:END:

=eww= doesn't create new buffers by default when you do a new search. Instead, it
replaces the existing buffer. I got this code snippet from [[https://stackoverflow.com/questions/28458784/emacs-and-eww-open-links-in-new-window][this-question]].

#+begin_src emacs-lisp
(defhook! create-new-buffer (eww-after-render-hook)
  (let* ((title  (plist-get eww-data :title))
	 (url    (plist-get eww-data :url))
	 (result (concat "*eww-" (or title
				     (if (string-match "://" url)
					 (substring url (match-beginning 0))
				       url)) "*")))
    (rename-buffer result t)))
#+end_src

***** w3m
:PROPERTIES:
:ID: e5e13423-bc70-49b0-969e-94897c798d54
:END:

[[http://w3m.sourceforge.net/][w3m]] is a text-based web browser. There are many other text-based browsers out
there, but =w3m= has the benefit of having comprehensive [[https://github.com/emacs-w3m/emacs-w3m][emacs interface]]. Why
use this when you can use the GUI browser? Well, using the Emacs interface I can
view an Emacs webpage as plain text, which means I can perform searches on it
with [[https://github.com/abo-abo/swiper.git][swiper]], or any other Emacs operation on it. Another advantage is that
because the w3m interface's backend is a terminal application, it will (I'm
guessing; no benchmarks made) typically be faster than browsers at rendering
plain text webpages. Of course, the main limitation is that w3m will typically
only display text based web pages well--not ones with lots of interactive
javascript code.

**** restart-emacs
:PROPERTIES:
:ID:       7412bc2f-0db1-44e9-8ea7-0dc595a04fca
:END:

#+begin_src emacs-lisp
(use-package! restart-emacs
  :commands restart-emacs)
#+end_src

**** multimedia
:PROPERTIES:
:ID:       5675cbbc-beb1-4470-a1d2-08f253bb4535
:END:

***** screenshots
:PROPERTIES:
:ID:       26d59d00-72e3-4b8c-9845-e5d9627cd4aa
:END:

This headline contains utilities for taking screenshots. As I see it,
screenshots are vital. I use maim to take screenshots because. I will note that
when I used [[][escr]] to take screenshots, those screenshots would not show
exwm windows. =escr= used [[][]]'s import.

****** screenshot name
:PROPERTIES:
:ID:       7210e8a8-7cbc-40ec-bd70-f8cfc6a32c56
:END:

The name for the screenshot.

******* xl-screenshot-path
:PROPERTIES:
:ID:       a6a75a8c-8d00-4f26-9df0-7f24af577e87
:END:

#+begin_src emacs-lisp
(defun xl-screenshot-path (name)
  "Return the full path where screenshot named NAME should go."
  (format "%s%s.png" (xl-screenshot-dir) name))
#+end_src

******* whether to prompt for screenshots
:PROPERTIES:
:ID:       1c280e62-2a1b-41f8-8ff9-039528652fcf
:END:

#+begin_src emacs-lisp
(defvar xl-prompt-for-screenshot-name-p t
  "If non-nil, prompt for screenshot name.")
#+end_src

******* name passed into prompt
:PROPERTIES:
:ID:       e8a21618-50f6-45ba-9a38-bff5c6d0a924
:END:

#+begin_src emacs-lisp
(defun xl-prompt-screenshot-name ()
  "Prompt for screenshot name."
  (when xl-prompt-for-screenshot-name-p
    (alet (read-string "Image Name: ")
      (unless (string-empty-p it)
	(xl-screenshot-path it)))))
#+end_src

******* default screenshot name
:PROPERTIES:
:ID:       58405f4f-e891-494e-afc7-a227415ec12b
:END:

#+begin_src emacs-lisp
(defun xl-default-screenshot-name ()
  "Return the default screenshot name."
  (alet (format-time-string "%Y-%m-%d-%H%M%S" (current-time))
    (xl-screenshot-path it)))
#+end_src

****** interactive screenshot functions
:PROPERTIES:
:ID:       27089aef-5937-4a7e-9af1-794fbeb835f2
:END:

When I first implemented these functions I prompted for the name first, but this
had the side-effect of displaying the prompt in the screenshot which is not what
I want. To avoid this, I decided to create the screenshot with the default name
and then prompt to rename the file afterwards.

******* fullscreen
:PROPERTIES:
:ID:       5cb29bb2-459a-4c84-9bf8-df179d2d2e8e
:END:

Take a s

#+begin_src emacs-lisp
(defun xl/take-fullscreen-screenshot ()
  "Take a fullscreen screenshot."
  (interactive)
  (let ((name (xl-default-screenshot-name)))
    (call-process "maim" nil nil nil "-u" name)
    (awhen (xl-prompt-screenshot-name)
      (rename-file name it t))))
#+end_src

******* window
:PROPERTIES:
:ID:       1a8724bb-24be-43fd-a3f6-3a41f7380fe8
:END:

#+begin_src emacs-lisp
(defun xl/take-window-screenshot ()
  "Take a screenshot of the current Emacs window."
  (interactive)
  (-let* ((name (xl-default-screenshot-name))
	  ((x y w h) (window-pixel-edges))
	  (geometry (format "%dx%d+%d+%d" w h x y)))
    (call-process "maim" nil nil nil "-u" "--geometry" geometry name)
    (awhen (xl-prompt-screenshot-name)
      (rename-file name it t))))
#+end_src

****** bindings
:PROPERTIES:
:ID:       52ae5883-6520-49d5-8d91-04c5c11e33c3
:END:

#+begin_src emacs-lisp
(define-leader-key! "as" (list :ignore nil :wk "screenshot"))

(define-leader-key!
  :infix "as"
  "s" (list :def #'xl/take-fullscreen-screenshot :wk "screenshot")
  "w" (list :def #'xl/take-window-screenshot     :wk "window")
  "f" (list :def #'xl/take-fullscreen-screenshot :wk "fullscreen"))
#+end_src

***** gif-screencast
:PROPERTIES:
:ID:       d8553132-c244-4319-bcc9-51905a296e34
:END:

#+begin_src emacs-lisp
(use-package! gif-screencast
  :commands gif-screencast-start-or-stop
  :xl-set 
  (gif-screencast-program . "scrot")
  (gif-screencast-args . '("--quality" "25" "--focused"))
  (gif-screencast-cropping-program . "mogrify")
  (gif-screencast-optimize-program . "gifsicle")
  (gif-screencast-capture-format . "png"))

(define-key! "<f9>" 'gif-screencast-start-or-stop)
#+end_src

***** videos
:PROPERTIES:
:ID:       a8c1f6aa-25f6-47aa-a625-2c870f322a8c
:END:

****** ytel
:PROPERTIES:
:ID:       dea17f59-bebc-426e-ae7a-56f8d8971260
:END:

******* get video
:PROPERTIES:
:ID:       2a0e30c8-7a82-4bea-a79c-6d77eca6893a
:END:

***** emms
:PROPERTIES:
:ID:       6f3eaa69-bbbb-458e-bcad-1c121a3174e9
:END:

[[https://www.gnu.org/software/emms/][emms]] is a very complete music player.

****** emms
:PROPERTIES:
:ID: 5d28b703-a87f-47ca-b320-785e7589fea6
:END:

#+begin_src emacs-lisp
(use-package! emms
  :xl-set
  (emms-source-file-directory-tree-function . 'emms-source-file-directory-tree-find)
  (emms-source-file-default-directory       . "~/Multimedia/music")
  (emms-playlist-buffer-name                . "*EMMS-PLAYLIST*")
  (emms-seek-seconds                        . 5)
  (emms-directory                           . (xl-data-dir "emms/"))
  (emms-player-list                         . '(emms-player-mpv)))
#+end_src

****** quitting
:PROPERTIES:
:ID: 545e6534-f289-4a89-838a-2a65ac74fe72
:END:

#+begin_src emacs-lisp
(defhook! quit-emms (kill-emacs-hook)
  "Shut down EMMS."
  (when emms-player-playing-p (emms-pause))
  (emms-stop))
#+end_src

**** outorg
:PROPERTIES:
:ID:       85570385-ff5b-47ba-907b-5ef3666288bb
:END:

***** dont add overlays for blank lines
:PROPERTIES:
:ID:       5f3f3e5a-3d57-44d2-9d61-9779d7b3051d
:END:

For some reason outorg adds overlays to the outorg buffers. They make it look
like the outorg buffer has less whitespace in between headlines than it should.

#+begin_src emacs-lisp
(defadvice! dont-add-overlays-for-blanks (:around outorg-wrap-source-in-block)
  "Adding overlays for blank lines."
  (cl-letf (((symbol-function #'overlay-put) #'ignore))
    (apply <orig-fn> <args>)))
#+end_src

**** testing
:PROPERTIES:
:ID:       49fe171f-d1b9-4b90-89ab-bddd2748bbd0
:END:

***** ert
:PROPERTIES:
:ID:       5fbf293e-84ae-4f47-bdcd-850ff552465a
:END:

#+begin_src emacs-lisp
(use-feature! ert
  :xl-rule ("bottom" "ert" :newname "\\*ert\\*"))
#+end_src

***** ert-expectations
:PROPERTIES:
:ID:       3062b8a4-4261-49fc-9bdb-895ba75bbd19
:END:

#+begin_src emacs-lisp
(use-package! ert-expectations)

(autoload 'expect "ert-expectations" nil nil 'macro)
(autoload 'expectations "ert-expectations" nil nil 'macro)
#+end_src

***** el-mock
:PROPERTIES:
:ID:       46df66b0-5820-4550-aa99-c913d3022fe1
:END:

#+begin_src emacs-lisp
(use-package! el-mock)
#+end_src

**** email
:PROPERTIES:
:ID: b31fc41c-135d-45d9-9c05-5889d21d1cd4
:END:

In today's world communication is largely done via emails. Whether at work or at
school it's common to receive emails every day. In fact, you hear of people that
have 20,000+ emails in a particular account. Unsurprisingly, when we're getting
so many emails, it's easy to become overwhelmed. Fortunately, there are numerous
ways to read and send emails in Emacs.

***** built-in settings
:PROPERTIES:
:ID:       f2f187ab-caef-4fa6-85e7-628f76e3da41
:END:

****** sendmail
:PROPERTIES:
:ID:       48c3332f-975d-4f22-94a8-4ccd394ca82a
:END:

#+begin_src emacs-lisp
(set! send-mail-function #'sendmail-send-it)
(set! sendmail-program (executable-find "msmtp"))
(set! mail-specify-envelope-from t)
#+end_src

****** smtpmail
:PROPERTIES:
:ID: 4dc1e0a6-5441-4b3e-8b75-ed3626a59154
:END:

#+begin_src emacs-lisp
(set! smtp-default-mail-server "mail.example.com")
(set! smtp-smtp-server "mail.example.com")
(set! smtpmail-smtp-service 587)
(set! smtpmail-debug-info t)
#+end_src

****** message
:PROPERTIES:
:ID:       4cf38804-18d6-470c-a9c3-e3327f2bebf9
:END:

#+begin_src emacs-lisp
(use-feature! message
  :xl-set
  (message-signature . user-full-name)
  (message-sendmail-envelope-from . 'header)
  (message-send-mail-function . #'sendmail-send-it)
  (message-kill-buffer-on-exit . t))
#+end_src

***** mu4e
:PROPERTIES:
:ID:       905ba1b5-bafc-4855-b772-fa750c294327
:END:

The most popular emacs mail client is =mu4e=. And, there is good reason why. =mu4e=
has many juicy features. Overall, =mu4e= is definitely a great mail client.
However, it's not all roses and rainbows; it does have a few annoying quicks.
One is that unlike virtually all other emacs packages it does not come decoupled
from =mu=. Another is that it is hard to set up multiple accounts properly despite
it's [[explicit support]] for multiple accounts. =mu4e= comes bundled with =mu=. A
significant advantage of using it is it's the most popular option and,
therefore, has the most support (in the form of setup blogs and packages).

****** init
:PROPERTIES:
:ID:       36b63d9a-a830-46de-b829-e4a6972af235
:END:

******* init
:PROPERTIES:
:ID:       bcd9b479-1ed6-48cb-bd2e-35a46cf614e2
:END:

#+begin_src emacs-lisp
(defconst XL-EMAIL-DIR "~/.mail/")

(autoload #'mu4e "mu4e" nil t nil)
#+end_src

******* settings
:PROPERTIES:
:ID:       11a37383-0316-49fa-900e-c06f830c0e3f
:END:

#+begin_src emacs-lisp
(setq mu4e-completing-read-function #'completing-read)
(setq mu4e-view-show-addresses t)
(setq mu4e-view-show-images t)
(setq mu4e-view-image-max-width 800)
(setq mu4e-compose-signature-auto-include t)
(setq mu4e-compose-format-flowed t)
(setq mu4e-get-mail-command "mbsync -a")
(setq mu4e-context-policy 'pick-first)
(setq mu4e-compose-context-policy 'ask-if-none)
(setq mu4e-confirm-quit nil)
#+end_src

******* indexing
:PROPERTIES:
:ID:       002f7170-60bf-425c-be60-39262a84d0a3
:END:

I don't want mu4e to handle indexing. I can do it myself.

#+begin_src emacs-lisp
(setq mu4e-index-cleanup t)
(setq mu4e-index-lazy-check nil)
(setq mu4e-update-interval nil)
(setq mu4e-headers-auto-update t)
#+end_src

******* mu4e
:PROPERTIES:
:ID: 565eff90-8626-4ec8-a576-4ff3dfb307ae
:END:

#+begin_src emacs-lisp
(setq mu4e-header-fields '((:human-date . 12)
                           (:flags . 4)
                           (:from . 25)
                           (:subject)))

(setq mu4e-html2text-command
      (if (executable-find "w3m") "w3m -dump -T text/html" #'mu4e-shr2text))
#+end_src

******* setup mu4e
:PROPERTIES:
:ID:       8ed2fe81-eda9-4343-a6e1-0a6a725866a4
:END:

#+begin_src emacs-lisp
(defun mu4e/init ()
  "Initialize mu4e."
  (interactive)
  (require 'password-store)
  (let* ((XL-EMAIL-DIR (expand-file-name "~/.mail/"))
	 (email-dirs (--map (concat XL-EMAIL-DIR it) (+pass-email-list))))
    (when (or (not (-all-p #'f-exists-p email-dirs))
              (-some-p #'f-empty-p email-dirs))
      (message "creating directories that don't exist.")
      (--each email-dirs (mkdir it t))
      (shell-command (format "mu init -m %s" XL-EMAIL-DIR))
      (message "Updating mail...")
      (mu4e-update-mail-and-index t))))
#+end_src

******* mu4e headers
:PROPERTIES:
:ID:       8bc93633-f3a0-494d-ae61-c05f6490cd87
:END:

#+begin_src emacs-lisp
(after! (mu4e all-the-icons)
  (setq mu4e-use-fancy-chars t)
  (setq mu4e-headers-draft-mark     (cons "D" (all-the-icons-faicon "pencil")))
  (setq mu4e-headers-flagged-mark   (cons "F" (all-the-icons-faicon "flag")))
  (setq mu4e-headers-new-mark       (cons "N" (all-the-icons-material "fiber_new")))
  (setq mu4e-headers-passed-mark    (cons "P" (all-the-icons-faicon "arrow-right")))
  (setq mu4e-headers-seen-mark      (cons "S" (all-the-icons-faicon "eye")))
  (setq mu4e-headers-attach-mark    (cons "a" (all-the-icons-material "attach_file")))
  (setq mu4e-headers-replied-mark   (cons "R" (all-the-icons-faicon "reply")))
  (setq mu4e-headers-unread-mark    (cons "u" (all-the-icons-faicon "eye-slash")))
  (setq mu4e-headers-encrypted-mark (cons "x" (all-the-icons-octicon "lock")))
  (setq mu4e-headers-signed-mark    (cons "s" (all-the-icons-faicon "certificate")))
  (setq mu4e-headers-trash-mark     (cons "T" (all-the-icons-faicon "trash"))))
#+end_src

****** org-mu4e
:PROPERTIES:
:ID:       eaa1577b-bcb9-4f6e-9927-8c6d8042dda2
:END:

Mu4e's org integration lets you write emails in org mode and convert it to html
before sending--very interesting indeed. I have yet to explore this feature but
it is definitely on my list of things to try out.

******* init
:PROPERTIES:
:ID:       47c8d5d8-575f-4b73-9247-38f32cb706fd
:END:

#+begin_src emacs-lisp
(use-package! org-mu4e
  :xl-ensure nil
  :xl-hook (mu4e-compose-mode-hook . org-mu4e-compose-org-mode)
  :xl-set
  (org-mu4e-link-query-in-headers-mode . nil)
  (org-mu4e-convert-to-html . t))
#+end_src

******* hook
:PROPERTIES:
:ID:       fcdbaa17-20c6-4322-baed-27df5a0ad9a2
:END:

Only render to html once. If the first send fails for whatever reason,
org-mu4e would do so each time you try again.

#+begin_src emacs-lisp
(defhook! org-mu4e-render-html-only-once (message-send-hook)
  (setq-local org-mu4e-convert-to-html nil))
#+end_src

****** multiple accounts
:PROPERTIES:
:ID: ad6de3a4-674c-490f-841e-19b8f891cd65
:END:

Mu4e certainly gave me some trouble setting up multiple accounts despite [its
attempt] to make this easy. I have one directory =~/.mail= where which stores all
my mail. The subdirectories of =~/.mail= correspond to my individual email
accounts. Until I set multiple accounts correctly it keeps prompting me to
create folders (such as =sent/=) in the =~/.mail= directory. I think part of the
reason I spent so much time setting this up is because.

******* return the list of emails with credentials
:PROPERTIES:
:ID:       3f7b1728-b855-447f-9f15-43bd79a94c14
:END:

#+begin_src emacs-lisp
(defun +pass-email-list ()
  "Return a list of emails."
  (->> (password-store-list)
       (--map (elt (s-match "email/\\(.*\\)" it) 1))
       (-non-nil)))
#+end_src

******* return the stuff as a plist
:PROPERTIES:
:ID:       8129ca16-8641-4f2f-a4b6-03477d5b78f3
:END:

#+begin_src emacs-lisp
(defun +pass-email-account-plist (email)
  "Return a plist of the relevant values of an email."
  (shut-up
    (->> (cdr (password-store-parse-entry email))
         (mapcar #'car)
         (--mapcat (list (intern it)
                         (password-store-get-field (concat "email/" email) it))))))
#+end_src

******* mu4e folder name alist
:PROPERTIES:
:ID:       2ef07842-e321-4fff-ae73-f19c41d263a4
:END:

Mu4e keeps prompting you for the sent, trash, and drafts directory if you do not
assign the corresponding mu4e variables. The way certain email servers name
their directories varies. For example, outlook names its sent directory as =Sent
Items=.

#+begin_src emacs-lisp
(defun +mu4e-guess-folder (base-dir possible-name &rest other-possible-names)
  "Return the first file in BASE-DIR that matches POSSIBLE-NAME or any POSSIBLE-NAMES.
If there is no match, return POSSIBLE-NAME."
  (alet (or (--first (-some-p (-cut s-contains-p <> it t)
                              (cons possible-name other-possible-names))
                     (cddr (directory-files base-dir)))
            possible-name)
    (format "/%s/%s" (f-filename base-dir) it)))
#+end_src

******* set up contexts for single account
:PROPERTIES:
:ID:       66d460d7-9647-4c29-8348-eb7b3d571630
:END:

#+begin_src emacs-lisp
(defun +mu4e--account-context (email)
  "Return an mu4e account context for specified EMAIL."
  (let* ((base-dir (concat XL-EMAIL-DIR email "/"))
         (name (cl-second (s-match ".*@\\([^.]*\\)" email)))
         (account (+pass-email-account-plist email))
         (out-host (plist-get 'out-host account))
         (out-port (plist-get 'out-port account)))
    (alet `((mu4e-sent-folder      . ,(+mu4e-guess-folder base-dir "sent"))
            (mu4e-drafts-folder    . ,(+mu4e-guess-folder base-dir "draft"))
            (mu4e-trash-folder     . ,(+mu4e-guess-folder base-dir "trash" "delete" "junk"))
            (user-email-address    . ,email)
            (smtpmail-smtp-server  . ,out-host)
            (smtpmail-smtp-user    . ,base-dir)
            (smtpmail-smtp-service . ,out-port))
      (make-mu4e-context :name name :vars it))))
#+end_src

******* multiple contexts
:PROPERTIES:
:ID: e56b64ac-ed36-4689-b8f4-8711c1f4f79f
:END:

#+begin_src emacs-lisp
(defadvice! setup-contexts (:before mu4e)
  "Initiaize context for each email account."
  (require 'password-store)
  (--each (-map #'+mu4e--account-context (+pass-email-list))
    (cl-pushnew it mu4e-contexts)))
#+end_src

****** truncate lines in messages
;; :PROPERTIES:
;; :ID: e6addd49-6aa4-4b9e-8e50-4f0ea43aedb7
;; :END:

(defhook! wrap-text-in-message (mu4e-view-mode-hook)
  (setq-local truncate-lines nil))

**** shells & terminals
:PROPERTIES:
:ID:       214edd41-3ba1-4184-b484-fe7bb256d319
:END:

***** eshell
:PROPERTIES:
:ID: 5f04a252-2985-46b4-ab0b-eb4567de5dd9
:END:

[[info:eshell#Top][eshell]] is a built-in shell written entirely in elisp. This means that it's as
portable and customizable as emacs itself. It can run elisp functions as
commands. There's a good article about it in [[https://masteringemacs.org/article/complete-guide-mastering-eshell][mastering-emacs]]. Other articles I
have like about eshell: [[https://ambrevar.xyz/emacs-eshell/][ambrevar's eshell post]], [[http://www.howardism.org/Technical/Emacs/eshell-fun.html][Howard Abram's Post]].

****** eshell
:PROPERTIES:
:ID:       b2b473c8-78d7-4f41-9be3-842b6c5acdbb
:END:

#+begin_src emacs-lisp
(use-package! eshell
  :xl-rule ("bottom" "eshell" :newname "\\*eshell\\*")
  :xl-set
  (eshell-directory-name             . (xl-data-dir "eshell/"))
  (eshell-history-file-name          . (concat eshell-directory-name "history"))
  (eshell-banner-message             . "")
  (eshell-prefer-lisp-functions      . nil)
  (eshell-scroll-to-bottom-on-input  . 'all)
  (eshell-scroll-to-bottom-on-output . 'all)
  (eshell-buffer-shorthand           . t)
  (eshell-kill-processes-on-exit     . t)
  (eshell-hist-ignoredups            . t)
  (eshell-input-filter               . #'eshell-input-filter-initial-space)
  (eshell-glob-case-insensitive      . t)
  (eshell-error-if-no-glob           . t))
#+end_src

****** em-hist
:PROPERTIES:
:ID:       aaea54da-bd51-4a73-9dad-fe0b49d0f617
:END:

#+begin_src emacs-lisp
(use-feature! em-hist
  :xl-idle-require t
  :xl-set
  (eshell-history-file-name    . (concat eshell-directory-name "history"))
  (eshell-history-size         . 2000)
  (eshell-hist-ignoredups      . nil)
  (eshell-save-history-on-exit . t))
#+end_src

****** em-term
:PROPERTIES:
:ID:       d2afb853-15c3-4d3f-b8fa-a1075f84bbac
:END:

#+begin_src emacs-lisp
(use-feature! em-term
  :xl-idle-require t
  :xl-config
  (--each '("tmux" "htop" "bash" "zsh" "fish" "vim" "nvim" "ncmpcpp")
    (add-to-list 'eshell-visual-commands it)))
#+end_src

****** em-alias
:PROPERTIES:
:ID:       694a8c17-8318-4222-b461-abfc1d8a78ea
:END:

#+begin_src emacs-lisp
(use-feature! em-alias
  :xl-idle-require t)
#+end_src

****** eshell-z
:PROPERTIES:
:ID: 497798a0-7b62-4779-bf15-f67500528f03
:END:

#+begin_src emacs-lisp
(use-package! eshell-z
  :commands eshell-z
  :xl-set
  (eshell-z-freq-dir-hash-table-file-name . (expand-file-name "z" eshell-directory-name)))
#+end_src

****** eshell-up
:PROPERTIES:
:ID: 478219b9-1c6f-4907-b428-a2dfe0f45e5c
:END:

This is an Emacs package for quickly navigating to a specific parent directory
in ~eshell~ without having to repeatedly typing ~cd ..~.

#+begin_src emacs-lisp
(use-package! eshell-up
  ;; :xl-alias
  ;; (eshell/up . eshell-up)
  ;; (eshell/peek . eshell-up-peek)
  )
#+end_src


**** file browsing
:PROPERTIES:
:ID:       324ede5f-4606-40f2-a424-1cdf0c974853
:END:

***** all-the-icons-dired
:PROPERTIES:
:ID:       8e2fe483-5da1-47c7-8d80-a8e68b21fa39
:END:

#+begin_src emacs-lisp
(use-package! all-the-icons-dired
  :xl-hook dired-mode-hook)
#+end_src

***** dired
:PROPERTIES:
:ID:       877b66c0-7952-4b37-839a-4a9aa5af164a
:END:

****** dired
:PROPERTIES:
:ID:       8a5f8bb6-dce2-4fac-b9c4-068e39f4cfcc
:END:

If you don't set [[helpvar:dired-recursive-deletes][dired-recursive-deletes]], emacs will prompt you every time you
try to delete a directory asking you whether you want to recursively delete its
contents. If you're actually permenently deleting it this is a good idea to
prevent accidental deletion, but I set [[helpvar:delete-by-moving-to-trash][delete-by-moving-to-trash]] to =t=. So
worst case I'll accidentally move a directory to the trash folder.

#+begin_src emacs-lisp
(use-feature! dired
  :xl-set
  (dired-recursive-copies                      . 'always)
  (dired-recursive-deletes                     . 'always)
  (dired-hide-details-hide-symlink-targets     . nil)
  (dired-clean-confirm-killing-deleted-buffers . nil))
#+end_src

****** sort directories first
:PROPERTIES:
:ID: 4b6c0ed8-dbf2-4a65-adcc-1ce326eac465
:END:

#+begin_src emacs-lisp
(defhook! dired:sort-directories-first (dired-after-readin-hook)
  "List directories first in dired buffers."
  (save-excursion
    (let (buffer-read-only)
      (forward-line 2) ;; beyond dir. header
      (sort-regexp-fields t "^.*$" "[ ]*." (point) (point-max))))
  (and (featurep 'xemacs)
       (fboundp 'dired-insert-set-properties)
       (dired-insert-set-properties (point-min) (point-max)))
  (set-buffer-modified-p nil))
#+end_src

****** create non-existent directory
:PROPERTIES:
:ID: 66981d0c-fe40-4552-9f63-2c39a7d584d2
:END:

#+begin_src emacs-lisp
(defun dired:create-non-existent-directory-h ()
  "Automatically create missing directories when creating new file."
  (let ((parent-directory (file-name-directory buffer-file-name)))
    (when (and (not (file-exists-p parent-directory))
               (y-or-n-p (format "Directory `%s' does not exist! Create it?" parent-directory)))
      (make-directory parent-directory t))))

(after! dired
  (add-to-list 'find-file-not-found-functions 'dired:create-non-existent-directory-h nil #'eq))
#+end_src

***** ranger
:PROPERTIES:
:ID: 7504cab0-ddd9-4069-b6bb-9a5f3161cace
:END:

[[github:ralesi/ranger.el][ranger]] is a file browser built on top of dired that seeks to emulate [[github:ranger/ranger][a VIM
inspired file manager]] of also called =ranger=.

****** make sure that =;= uses =M-x=
:PROPERTIES:
:ID:       c63911ca-6d26-4d7c-be76-246639fb6c7a
:END:

#+begin_src emacs-lisp
(general-def 'normal ranger-mode-map
  ";" #'execute-extended-command
  "u" #'dired-unmark)
#+end_src

****** general bindings
:PROPERTIES:
:ID:       f69d31ab-1385-498c-9423-8fb3d5e4e94e
:END:

#+begin_src emacs-lisp
(general-def 'normal ranger-mode-map
  "A" #'dired-do-find-regexp
  "C" #'dired-do-copy
  "B" #'dired-do-byte-compile
  "D" #'dired-do-delete
  "H" #'dired-do-hardlink
  "L" #'dired-do-load
  "M" #'dired-do-chmod
  "O" #'dired-do-chown
  "P" #'dired-do-print
  "Q" #'dired-do-find-regexp-and-replace
  "R" #'dired-do-rename
  "S" #'dired-do-symlink
  "T" #'dired-do-touch
  "X" #'dired-do-shell-command
  "Z" #'dired-do-compress
  "c" #'dired-do-compress-to
  "!" #'dired-do-shell-command
  "&" #'dired-do-async-shell-command)
#+end_src

****** entry
:PROPERTIES:
:ID: 2edf3f72-726f-4b31-9ff0-20e5e7d251b1
:END:

#+begin_src emacs-lisp
(use-package! ranger
  :commands deer ranger
  :xl-silence ranger-window-check
  :xl-set
  (ranger-override-dired-mode . t)
  (ranger-cleanup-eagerly     . t)
  (ranger-cleanup-on-disable  . t)
  (ranger-omit-regexp         . "^.DS_Store$")
  (ranger-excluded-extensions .'("mkv" "iso" "mp4"))
  (ranger-deer-show-details   . nil)
  (ranger-max-preview-size    . 10)
  (ranger-modify-header       . t)
  (ranger-hide-cursor         . t)
  (ranger-dont-show-binary    . t))
#+end_src

****** refresh contents
:PROPERTIES:
:ID:       cef37397-53aa-47e1-a519-ef56a311ae30
:END:

Ranger doesn't refresh the buffer after stuff like moving and pasting has
happend. It results in a very jarring display.

#+begin_src emacs-lisp
(defadvice! refresh-contents (:after ranger-paste dired-do-rename)
  "Refresh contents."
  (when (eq major-mode 'ranger-mode)
    (ranger-refresh)))
#+end_src

****** toggle dotfiles
:PROPERTIES:
:ID: 5b9b190c-b4a6-4834-b8c9-def16b0457ac
:END:

There's this wierd intermidiate stage between =hidden= and =format= called =prefer= in
which only some files are hidden. That's wierd, so I get rid of it.

#+begin_src emacs-lisp
(defadvice! toggle-between-two-only (:override ranger-toggle-dotfiles)
  "Show/hide dot-files."
  (interactive)
  (setq ranger-show-hidden
        (cl-case ranger-show-hidden
          (hidden 'format)
          (format 'hidden)))
  (ranger-setup))
#+end_src

****** silence window check
:PROPERTIES:
:ID: e9d83b37-1257-4d78-ae5f-863c4e7198d1
:END:

#+begin_src emacs-lisp
(xl-silence-output #'ranger-window-check)
#+end_src

**** version control
:PROPERTIES:
:ID: d99a378c-449f-4a0d-9b88-dd77d5a41bb1
:END:

***** git-auto-commit-mode
:PROPERTIES:
:ID:       00a518e9-56ae-4c0b-b2cd-518fb4c5d201
:END:

To avoid losing information. You should commit often in git--like every 10
seconds or so. Obviously doing this manually on the command line (or even on
[[id:d6088ed3-417a-44e8-822b-ce4743f497d0][magit]]) every time is a pain. This package commits your changes every time
you save your file--which for me is all the time because I use [[id:bd455e73-4035-49b9-bbdf-3d59d4906c97][super-save]].

****** settings
:PROPERTIES:
:ID:       8a46cee4-624c-4440-8b99-c6b34d356a6b
:END:

#+begin_src emacs-lisp
(use-package! git-auto-commit-mode
  :commands git-auto-commit-mode
  :xl-set
  (gac-automatically-push-p   . nil)
  (gac-ask-for-summary        . nil)
  (gac-default-message        . #'gac:commit-message)
  (gac-commit-additional-flag . "-S")
  (gac-silent-message-p       . t))
#+end_src

****** commit message
:PROPERTIES:
:ID:       3f0297a0-5929-4217-a109-545a2a010473
:END:

Committing often as I recommend will inevitably result with commits that are
many bits and pieces of a change. The idea is to then squash together all
related commits for the "polished" result. With this function I create "smart"
commit messages that take advantage of the org headline structure. This makes it
easy to go back and group commits which are related. Note that this function
fails when you have a change that spans across multiple headlines (such as the
replacement of a name throughout a document). This is something I plan to
address later.

#+begin_src emacs-lisp
(defun gac:commit-message (file)
  "Return the commit message for changes to FILE."
  (format "Update %s" (f-base file)))
#+end_src

***** magit
:PROPERTIES:
:ID:       d6088ed3-417a-44e8-822b-ce4743f497d0
:END:

****** transient
:PROPERTIES:
:ID: baf64a0f-f9fa-4700-bebf-d996018f894f
:END:

#+begin_src emacs-lisp
(setq transient-default-level 5)
(setq transient-levels-file (xl-data-dir "transient/levels"))
(setq transient-values-file (xl-data-dir "transient/values"))
(setq transient-history-file (xl-data-dir "transient/history"))
#+end_src

****** magit
:PROPERTIES:
:ID: c8a37b6a-46c7-406e-8793-1186f14407e0
:END:

#+begin_src emacs-lisp
(use-package! magit
  :xl-idle-require f s with-editor git-commit package eieio lv transient
  :xl-rule ("bottom" "magit" :newname "magit: ")
  ;; :xl-hook (magit-popup-mode-hook . hide-mode-line-hook)
  :xl-set
  (magit-completing-read-function . #'completing-read)
  (magit-diff-refine-hunk . t)
  (magit-auto-revert-mode . t))
#+end_src

****** quitting
:PROPERTIES:
:ID: 49088c3e-6d3a-41b7-aee4-f0bb34c71a0c
:END:

#+begin_src emacs-lisp
(defun magit/quit ()
  "Clean up magit buffers after quitting `magit-status'."
  (interactive)
  (let ((buffers (magit-mode-get-buffers)))
    (magit-restore-window-configuration)
    (mapc #'kill-buffer buffers)))
#+end_src

****** evil-magit
:PROPERTIES:
:ID:       a86e7a69-4e0a-41fd-aca7-66e514332e7f
:END:

#+begin_src emacs-lisp
(use-package! evil-magit
  :xl-silence evil-magit-init
  :xl-before-call magit-status
  :xl-config
  (evil-magit-init)
  :xl-set
  (evil-magit-state . 'normal))
#+end_src


***** git-gutter
:PROPERTIES:
:ID: 96f0c876-533c-4b1a-a4c1-7b6c9bf58c03
:END:

#+begin_src emacs-lisp
(use-package! git-gutter
  :commands git-gutter-mode)
#+end_src

**** persistence
:PROPERTIES:
:ID:       c73a2fc2-5c43-4f99-9336-3bb2154852b7
:END:

Packages and features that involve saving to external files.

***** saveplace
:PROPERTIES:
:ID:       41cb3357-9b4b-4205-987d-ff72f9a35df3
:END:

This package takes you to the last point you were at when you visited a file.

****** recenter cursor
:PROPERTIES:
:ID:       dda57b64-b645-4eda-be54-9dda4af35404
:END:

#+begin_src emacs-lisp
(defadvice! recenter-on-load (:after-while save-place-find-file-hook)
  "Recenter on cursor when loading a saved place."
  (when buffer-file-name (ignore-errors (recenter))))
#+end_src

****** saveplace
:PROPERTIES:
:ID:       63b04114-bcb9-4a2e-ad45-be4db8d4a269
:END:

As its name suggests, =save-place= is a built-in package that stores the buffer
location you left off at in a particular buffer. When you visit that buffer
again, you are taken to the location you left off. This is very convenient.

#+begin_src emacs-lisp
(use-feature! saveplace
  :xl-after-call after-find-file
  :xl-config
  (save-place-mode)
  :xl-set
  (save-place-file . (concat XL-DATA-DIR "saveplace"))
  (save-place-limit . nil))
#+end_src

***** recentf
:PROPERTIES:
:ID: f26bedb3-a172-4543-afd0-4c47f5872d15
:END:

=recentf= is a built-in program that tracks the files you've opened recently
persistently. This is a great idea because these are the files you'll likely
revisit. In practice, I look at this list of files in addition to the buffers I
already have open using a [[id:f26bedb3-a172-4543-afd0-4c47f5872d15][completion-framework]]. Because of this I rarely
have to set out to look for a file with =dired=.

#+begin_src emacs-lisp
(use-feature! recentf
  :xl-before-call find-file
  :xl-idle-require easymenu tree-widget timer
  ;; :advice (#'recentf-save-list before #'recentf-cleanup)
  :xl-silence recentf-mode recentf-cleanup
  :xl-set
  (recentf-max-menu-items    . 0)
  (recentf-max-saved-items   . 700)
  (recentf-save-file         . (concat XL-DATA-DIR "recentf"))
  (recentf-auto-cleanup      . 'never)
  (recentf-filename-handlers . '(file-truename abbreviate-file-name))
  :xl-config
  (recentf-mode 1))
#+end_src

***** savehist
:PROPERTIES:
:ID:       dd4b9da7-e54d-4d62-bb70-aa8f7f4a016f
:END:

=savehist= is a built-in feature for saving the minibuffer-history to a file--the
[[helpvar:savehist][savehist]] file. Additionally, it provides the ability to save additional
variables which may or may not be related to minibuffer history. You add the
ones you want to save to [[helpvar:savehist-additional-variables][savehist-additional-variables]].

****** init
:PROPERTIES:
:ID:       54183df6-b4f5-4b01-9ddb-4054ef0583b0
:END:

#+begin_src emacs-lisp
(use-feature! savehist
  :xl-idle-require custom
  :xl-hook emacs-startup-hook
  :xl-set
  (savehist-file . (concat XL-DATA-DIR "savehist"))
  (savehist-additional-variables . '(kill-ring search-ring regexp-search-ring))
  (savehist-save-minibuffer-history . t)
  (savehist-autosave-interval . nil))
#+end_src

****** unpropertize kill ring
:PROPERTIES:
:ID:       da2b6c31-d251-48aa-a6ed-8f01b9fa0b8d
:END:

#+begin_src emacs-lisp
(defhook! unpropertize-kill-ring (kill-emacs-hook :append t)
  "Remove text properties from `kill-ring'."
  (setq kill-ring
        (--map (when (stringp it) (substring-no-properties it))
               (-non-nil kill-ring))))
#+end_src

**** shrink-path
:PROPERTIES:
:ID: eef8ea28-4de2-44ab-a09d-26f58c0a75ac
:END:

#+begin_src emacs-lisp
(use-package! shrink-path
  :commands shrink-path)
#+end_src

*** Window Management
:PROPERTIES:
:ID:       f8f186bd-a701-4bd4-a249-86ec4faff83b
:END:

**** workspaces
:PROPERTIES:
:ID:       c979c631-4098-4204-b067-82f58b5b9ebe
:END:

***** tab-bar-mode
:PROPERTIES:
:ID:       0a72fe9a-1948-4022-a300-18a4881da382
:END:

****** settings
:PROPERTIES:
:ID:       bb63f5b2-cc45-454b-a032-be248f801636
:END:

#+begin_src emacs-lisp
(use-feature! tab-bar-mode
  :xl-hook (tab-bar-mode-hook . tab-bar-history-mode)
  :xl-set
  (tab-bar-new-tab-choice . "*scratch*")
  (tab-bar-history-limit  . 25)
  (tab-bar-tab-hints      . nil)
  (tab-bar-show           . nil))
#+end_src

****** dont actually display the tabs
:PROPERTIES:
:ID:       e4cee146-f6ac-47f1-9e98-f209ae9f9bec
:END:

I want the tabs to exist as a concept, but (ironically) I don't actually want
them displayed.

#+begin_src emacs-lisp
(defadvice! inhibit-tab-display (:after tab-bar-mode make-frame)
  "Inhibit the display of tags in tab-bar-mode."
  (--each (frame-list)
    (set-frame-parameter it 'tab-bar-lines 0)))
#+end_src

***** desktop
:PROPERTIES:
:ID:       902a11fc-b9aa-4875-ba92-8d2561a12a50
:END:

=desktop= is a built-in emacs package for saving window configuration setup.

****** some settings
:PROPERTIES:
:ID:       e4c30275-db62-4e6d-890c-6199b0594fd8
:END:

#+begin_src emacs-lisp
(use-feature! desktop
  :xl-set
  (desktop-save                 . t)
  (desktop-dirname              . XL-DATA-DIR)
  (desktop-auto-save-timeout    . auto-save-timeout)
  (desktop-base-file-name       . "emacs.desktop")
  (desktop-base-lock-name       . "emacs.desktop.lock")
  (desktop-path                 . (list XL-DATA-DIR))
  (desktop-missing-file-warning . nil))
#+end_src

****** allowing desktops to go in one directory
:PROPERTIES:
:ID:       22b0be3a-ef36-47d4-8684-602f3a8c8462
:END:

These functions are all based on the =desktop+= functions. The main thing it
does is provide a directory where desktop files can be placed. This should
really have been done by =desktop.el= but oh well.

******* base directory
:PROPERTIES:
:ID:       e1ce2616-2280-435d-85c4-8d71c30c6a75
:END:

#+begin_src emacs-lisp
(defvar desktop:base-dir (concat XL-DATA-DIR "desktops/")
  "Directory where desktops should go.")
#+end_src

******* generate the base directory
:PROPERTIES:
:ID:       fa173f38-2888-465a-8de4-282233322363
:END:

#+begin_src emacs-lisp
(defun desktop:dirname (name)
  "Return the path where desktop named NAME should go."
  (require 'f)
  (f-join desktop:base-dir name))
#+end_src

******* ensure the base directory
:PROPERTIES:
:ID:       3662ceaa-aed9-4dbc-bea9-7e1878237c87
:END:

#+begin_src emacs-lisp
(defhook! ensure-desktop-directory (desktop-mode-hook)
  "Make `desktop:base-dir' if it does not exist."
  (mkdir desktop:base-dir t))
#+end_src

******* desktop names
:PROPERTIES:
:ID:       5286a22f-dc93-4e32-8a35-3bfbdfda8668
:END:

#+begin_src emacs-lisp
(defun desktop:list ()
  "Return a list of the names of all desktops."
  (-difference (directory-files desktop:base-dir)
	       (list ".." ".")))
#+end_src

******* create a desktop
:PROPERTIES:
:ID:       331367bb-a1eb-414f-89ef-386ba6fc1e60
:END:

#+begin_src emacs-lisp
(defun desktop:create-desktop (name)
  "Create a new desktop named NAME."
  (let ((desktop-dirname (desktop:dirname name)))
    (desktop-kill)
    (make-directory desktop-dirname 'parents)
    (desktop-save desktop-dirname)))
#+end_src

******* load an existing desktop
:PROPERTIES:
:ID:       691dd9bf-b207-4885-9f7c-b8791d972dc1
:END:

#+begin_src emacs-lisp
(defun desktop:load-desktop (name)
  (desktop-change-dir (desktop:dirname name)))
#+end_src

****** create desktop in new tab
:PROPERTIES:
:ID:       4bbb0f3a-bc51-4552-b91f-8404ab19cdd8
:END:

This is an integration with desktop and tab mode.

#+begin_src emacs-lisp
(defun desktop/create-desktop-in-new-tab (name)
  "Create desktop named NAME in new tab.
The tab's new name is the same as the desktop name."
  (interactive
   (list (completing-read "Create desktop:" (desktop:list))))
  (tab-bar-new-tab)
  (tab-bar-rename-tab name)
  (desktop:create-desktop name))
#+end_src

****** load desktop in a new tab
:PROPERTIES:
:ID:       391c0817-bb2f-4334-b320-f039ab23cfb7
:END:

#+begin_src emacs-lisp
(defun desktop/load-desktop-in-new-tab (name)
  "Create desktop named NAME in new tab.
The tab's new name is the same as the desktop name."
  (interactive
   (list (completing-read "Load desktop: " (desktop:list))))
  (tab-bar-new-tab)
  (tab-bar-rename-tab name)
  (desktop:load-desktop name))
#+end_src

****** desktop restore functions
:PROPERTIES:
:ID:       0f82a1dc-d28e-4875-a622-e6116c0d3843
:END:

******* helpful-buffers
:PROPERTIES:
:ID:       f7d3a8ce-7115-47d6-b0ac-2d078741a49a
:END:

#+begin_src emacs-lisp
(defun desktop:restore-helpful-buffer ()
  "Restore helpful buffer.")
#+end_src

***** workgroups2
:PROPERTIES:
:ID:       890c8e5b-524d-44b6-b90e-c830436b9da8
:END:

There is a need to save buffers and window configurations in their own groups.
Often we'll have a group of buffers we've setup to work on a project or task and
suddenly, in the middle of that task we'll want to work on another task. It's
inconvenient to get rid of the window configuration we've set up just to have to
come back to it and set it up again. This is what workspaces, also called
workgroups, are for. You can save the window configuration you're using and
switch to a new one.

Workgroup provides a. One notable advantage of workgroups is that it does not
use emacs's built-in serialization of window configs. Usually, it is better to
use something that's built-in. However, emacs's serialization has the drawback
that it's not a lisp object; implying that it is not.

#+begin_src emacs-lisp
(use-package! workgroups2
  :commands wg-switch-workgroup
  :xl-ignore wg-change-modeline
  :xl-silence wg-create-workgroup wg-switch-workgroup
  :xl-set
  (wg-emacs-exit-save-behavior           . 'save)
  (wg-workgroups-mode-exit-save-behavior . 'save)
  (wg-flag-modified                      . nil)
  (wg-mode-line-display-on               . nil)
  (wg-load-last-workgroup                . nil)
  (wg-open-this-wg                       . nil)
  (wg-control-frames                     . nil)
  (wg-session-load-on-start              . nil)
  (wg-flag-modified                      . nil)
  (wg-session-file                       . (concat XL-DATA-DIR "wg-session")))
#+end_src

**** zoom-window
:PROPERTIES:
:ID:       d506fde5-d1bc-4807-a1d0-a8ed5c33def2
:END:

This package provides a command that temporarily makes a window occupy full
screen. And then reverts the window configuration to what it was again
afterwards.

#+begin_src emacs-lisp
(use-package! zoom-window
  :commands zoom-window)
#+end_src

**** exwm
:PROPERTIES:
:ID: dbb69880-2180-4ecc-897d-78ff72a6358b
:END:

[[https://github.com/ch11ng/exwm][EXWM]] (Emacs X-Window Manager) is a full-featured window manager in Emacs.
There are benefits and drawbacks to making emacs your window manager. One
benefit is that you get a super consistent window management experience. If you
use a typical window manager, you have to.

***** init
:PROPERTIES:
:ID:       7b83cab0-d599-46c4-b20c-19ff33345ae3
:END:

#+begin_src emacs-lisp
(use-package! exwm
  :xl-before-call browse-url)
#+end_src

***** init
:PROPERTIES:
:ID:       581b8529-00a0-4935-9363-60dba9dbe5f4
:END:

This isn't precise, I want exwm to trigger itself when I try to open
any external application but right now I'm not sure of how to do that
so I deal with my most often case--opening the browser. This assumes
[[helpfn:browse-url][browse-url]] will be used to open an external browser, which might not
be the case. I'll address this in time.

=exwm= provides an option [[helpvar:exwm-replace][exwm-replace]] to deal with the case of an existing
window manager when exwm is initializing itself. There are three
ways. You could replace it with exwm without asking, ask whether to
replace it, or abort the initialization of exwm.

I always want exwm to assume that if I'm using another window manager,
I don't want to use exwm. Only problem is =exwm= aborts with an annoying
=user-error=.

#+begin_src emacs-lisp
(alet #'xl--load-and-initialize-exwm-maybe-advice
  (xl-add-advice #'browse-url :before it nil t))

(defun xl--load-and-initialize-exwm-maybe-advice (&rest _)
  "Try to initialize exwm.
If it's not possible, abort initialization gracefully."
  (with-os! linux
    (require 'exwm)
    ;; Try to enable exwm.
    (let ((exwm-replace nil))
      (if (ignore-errors (exwm-init))
	  ;; Enable the clipboard.
	  (progn (require 'exwm-systemtray)
		 (exwm-systemtray-enable))
	(xl-log "Another window manager is present (or something went wrong).")))))
#+end_src

***** org capture from an exwm buffer
:PROPERTIES:
:ID:       5428bdc1-c075-4387-b3ab-080d372c478f
:END:

A common dream among many Org users is to integrate [[info:org#Capture][org-capture]] into their browser.
Indeed, the browser by nature would be a place you'd want to capture from a lot.
However, since graphical browsers are not in emacs the main way to do this was
via a hacky and difficult to set up [[https://orgmode.org/worg/org-contrib/org-protocol.html][org-protocol]].

https://www.reddit.com/r/emacs/comments/f6zzux/capturing_website_url_with_orgcapture_and_exwm/

****** exwm title
:PROPERTIES:
:ID:       ce78d409-e635-4d94-b20e-38c2034ab5e8
:END:

#+begin_src emacs-lisp
(defun +exwm--title-info (title)
  "Return the webpage and the program."
  (-let [(_ webpage program) (s-match "\\([^z-a]+\\) - \\([^z-a]+\\)\\'" title)]
    (list webpage program)))
#+end_src

****** download webpage as pdf
:PROPERTIES:
:ID:       bd7165df-9dae-4954-b153-96335678e296
:END:

Storing the links is better, but not good enough. Webpages die. They can be
taken off by a third-party or removed by the owner themselves. Even if they
aren't though, they can be modified so that what you originally found isn't
there anymore. As a solution for this I came upon [[https://wkhtmltopdf.org/][wkhtmltopdf]], a command that
downloads a given webpage as pdf. A consequence of doing this is that you will
have access to all the webpages you used for research offline.

#+begin_src emacs-lisp
(defun xl-download-webpage-as-pdf (url webpage-title)
  "Save the webpage at URL to `XL-SCREENSHOT-DIR'."
  (let* ((program "wkhtmltopdf")
         (process-name (format "%s - %s" program (ts-format)))
         (webpage-title (s-replace "/" "~" webpage-title))
         (pdf-path (format "%s%s.pdf" XL-SCREENSHOT-DIR webpage-title))
         (fn `(lambda (&rest _)
                (if (file-exists-p ,pdf-path)
                    (message "Webpage saved succesfully.")
                  (warn "Failed to save webpage %s to %s." ,url ,pdf-path)))))
    (message "%s <-- %s" (f-abbrev pdf-path) url)
    (async-start-process process-name "firejail" fn program url pdf-path)))
#+end_src

****** replacement for fake id
:PROPERTIES:
:ID:       4f0436c4-bc37-49b0-a8a3-894e212d4d13
:END:

#+begin_src emacs-lisp
(defun exwm-input::fake-key-to-id (event id)
  "Fake a key event equivalent to Emacs event EVENT and send it
 to program with x window ID."
  (let* ((keysym (xcb:keysyms:event->keysym exwm--connection event))
         keycode)
    (when (= 0 (car keysym))
      (user-error "[EXWM] Invalid key: %s" (single-key-description event)))
    (setq keycode (xcb:keysyms:keysym->keycode exwm--connection
					       (car keysym)))
    (when (/= 0 keycode)
      (dolist (class '(xcb:KeyPress xcb:KeyRelease))
        (xcb:+request exwm--connection
	    (make-instance
	     'xcb:SendEvent
	     :propagate 0 :destination id
	     :event-mask xcb:EventMask:NoEvent
	     :event
	     (xcb:marshal
	      (make-instance
	       class
	       :detail keycode :time xcb:Time:CurrentTime
	       :root exwm--root :event id :child 0 :root-x 0 :root-y 0
	       :event-x 0 :event-y 0 :state (cdr keysym) :same-screen 0)
	      exwm--connection)))))
    (xcb:flush exwm--connection)))
#+end_src

****** url from firefox
:PROPERTIES:
:ID:       f407cc8c-0bb9-47fe-adeb-4e9d27b5c5b7
:END:

Emacs simulates a keypress to firefox--specifically the keypresses to select the
current url and to add it to the kill ring.

#+begin_src emacs-lisp
(defun +exwm--firefox-url ()
  "Save the current firefox url to kill ring."
  ;; We get the xwindow id of the buffer named Firefox
  (let ((fid (exwm--buffer->id (current-buffer))))
    ;; Send c-l to select url
    (exwm-input::fake-key-to-id 'C-l fid)
    ;; We sleep to avoid race conditions.
    (sleep-for 0 300)
    ;; Copy url to kill ring (note: this is not affected by simulation keys)
    (exwm-input::fake-key-to-id 'C-c fid)
    (sleep-for 0 300)
    ;; try to set the state back
    (exwm-input::fake-key-to-id 'escape fid)
    (current-kill 0)))
#+end_src

****** url from qutebrowser
:PROPERTIES:
:ID:       822cbb61-60b4-445e-9756-4bf797500375
:END:

#+begin_src emacs-lisp
(defun +exwm--qutebrowser-url ()
  (interactive)
  (let ((fid (exwm--buffer->id (current-buffer))))
    (sleep-for 0 300)
    ;; if in insert state exit it.
    (exwm-input::fake-key-to-id 'escape fid)
    (sleep-for 0 300)
    (exwm-input::fake-key-to-id 'y fid)
    (sleep-for 0 300)
    (exwm-input::fake-key-to-id 'y fid)
    (sleep-for 0 300)
    (aprog1 (current-kill 0)
      (xl-log "Copied %S to the kill ring." it))))
#+end_src

***** appropriate name for exwm buffers
:PROPERTIES:
:ID: b9712cdc-2cf9-482f-8f62-b2e4f56b9c97
:END:

By default each exwm buffer is named =*EXWM*=. We want them to have
a more descriptive name.

#+begin_src emacs-lisp
(defhook! rename-buffer-to-title (exwm-update-title-hook)
  "Rename buffer to title."
  (exwm-workspace-rename-buffer exwm-title))
#+end_src

***** popup rules for exwm buffers
:PROPERTIES:
:ID:       0ecf05ce-4a76-4130-855e-e8d0d7390df1
:END:

***** to start in char mode
:PROPERTIES:
:ID: 790c7f6e-6f66-4074-b51a-56b491bcde99
:END:

=EXWM= has two modes, =line-mode= and =char-mode=. It's best for Emacs and Next to
start with =char-mode= because they both have keys that are important for their
use (like =M-x=) which conflict with Emacs (the instance that's managing the
windows).

****** list of applications
:PROPERTIES:
:ID:       d1bf0601-a995-48f7-ab80-86755ba9269a
:END:

#+begin_src emacs-lisp
(defvar +exwm-char-mode-apps (list "emacs" "next" "nyxt" "qutebrowser")
  "List of applications to exwm should start in char-mode.")
#+end_src

****** to start in char mode
:PROPERTIES:
:ID: 790c7f6e-6f66-4074-b51a-56b491bcde99
:END:

#+begin_src emacs-lisp
(defhook! start-in-char-mode (exwm-manage-finish-hook)
  "Start a program in char-mode if it's in `+exwm-char-mode-apps'."
  (when (--any-p (string-prefix-p it exwm-instance-name) +exwm-char-mode-apps)
    (exwm-input-release-keyboard (exwm--buffer->id (window-buffer)))))
#+end_src

***** exwm-edit
:PROPERTIES:
:ID: 1a167827-b791-4a69-a90e-c2d30bd83abb
:END:

The dream is to do all text editing in Emacs. This package is a big step towards
achieving that dream. =exwm-edit= allows the user to edit text fields in
external packages with an emacs buffer. It acts a lot like =org-edit-src-code=:
it copies any text in the text field to a buffer, you edit the buffer, then
press a binding to insert the buffer text into the text field. It goes without
saying that when the text is in an emacs buffer, you can use the full-force of
Emacs's text editing capabilities on it.

Concerning the loading of exwm-edit. Ideally, I should load it after
certain applications where I'd use it need to be loaded.

#+begin_src emacs-lisp
(use-package! exwm-edit
  :commands exwm-edit
  :xl-config
  (funcall (get 'exwm-input-global-keys 'custom-set)
	   'exwm-input-global-keys
	   `((,(kbd "C-'") . exwm-edit))))
#+end_src

***** keybindings
:PROPERTIES:
:ID: 293bc7c5-1320-4f3f-af2b-198d56694f71
:END:

#+begin_src emacs-lisp
(after! exwm
  (funcall (get 'exwm-input-global-keys 'custom-set)
           'exwm-input-global-keys
           `((,(kbd "s-R") . exwm-reset)
             (,(kbd "s-x") . exwm-input-toggle-keyboard)
             (,(kbd "s-h") . windmove-left)
             (,(kbd "s-j") . windmove-down)
             (,(kbd "s-k") . windmove-up)
             (,(kbd "s-l") . windmove-right)
             (,(kbd "s-t") . transpose-frame)
             (,(kbd "s-D") . kill-this-buffer)
             (,(kbd "s-b") . switch-to-buffer)
             (,(kbd "s-f") . find-file)
             (,(kbd "s-O") . exwm-layout-toggle-fullscreen)
             (,(kbd "s-p") . previous-buffer)
             (,(kbd "s-n") . next-buffer)
             (,(kbd "s-q") . xl/open-qutebrowser)
             (,(kbd "s-e") . xl/open-emacs-instance)))
  (general-def
    "s-R" #'exwm-reset
    "s-x" #'exwm-input-toggle-keyboard
    "s-h" #'windmove-left
    "s-j" #'windmove-down
    "s-k" #'windmove-up
    "s-l" #'windmove-right
    "s-t" #'transpose-frame
    "s-D" #'kill-this-buffer
    "s-b" #'switch-to-buffer
    "s-f" #'find-file
    "s-O" #'exwm-layout-toggle-fullscreen
    "s-p" #'previous-buffer
    "s-n" #'next-buffer
    "s-q" #'xl/open-qutebrowser
    "s-e" #'xl/open-emacs-instance))
#+end_src

**** split-right-and-focus
:PROPERTIES:
:ID: 6cb60d94-723b-48e5-850a-3483e78f6647
:END:

#+begin_src emacs-lisp
(defun xl/window-split-right-and-focus ()
  "Split window right and select the window created with the split."
  (interactive)
  (select-window (split-window-right)))
#+end_src

**** split-below-and-focus
:PROPERTIES:
:ID: d6a4a81f-007d-4b7e-97a3-e0bba3ff97a4
:END:

#+begin_src emacs-lisp
(defun xl/window-split-below-and-focus ()
  "Split window below and select the window created with the split."
  (interactive)
  (select-window (split-window-below)))
#+end_src

**** window bindings
:PROPERTIES:
:ID:       5b4d2ce0-667f-42c8-bad4-880f371fddc4
:END:

These bindings pertain to manipulating windows.

***** set the window leader
:PROPERTIES:
:ID: 784956e2-3696-4f92-80ca-41b7e30e5b2b
:END:

Efficient window management in Emacs crucial for success. These keys all pertain
to window/workspace actions.

#+begin_src emacs-lisp
(define-leader-key!
  :infix "w"
  ""  (list :ignore nil :wk "window"))
#+end_src

***** motion
:PROPERTIES:
:ID:       ef50a2d7-deab-40b8-a654-133d9d3edd48
:END:

This headline is for bindings that involve traversing windows. The typical
bindings for moving up, down, left and right between windows. And as a bonus, a
binding to.

#+begin_src emacs-lisp
(define-leader-key!
  :infix "w"
  "h" (list :def #'windmove-left  :wk "left")
  "j" (list :def #'windmove-down  :wk "down")
  "k" (list :def #'windmove-up    :wk "up")
  "l" (list :def #'windmove-right :wk "right")
  "o" (list :def #'ace-window     :wk "other"))
#+end_src

***** splitting
:PROPERTIES:
:ID:       6c49babb-b749-4501-8699-dd2d7f885488
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "w"
  "S" (list :def #'xl/window-split-below-and-focus :wk "split below and focus")
  "V" (list :def #'xl/window-split-right-and-focus :wk "split right and focus")
  "s" (list :def #'window-split-below                :wk "split below")
  "v" (list :def #'window-split-right                :wk "split right"))
#+end_src

***** deleting
:PROPERTIES:
:ID:       218f650f-f52f-4cdf-9731-032631612ad3
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "w"
  "d" (list :def #'delete-window        :wk "delete current")
  "D" (list :def #'delete-other-windows :wk "delete others"))
#+end_src

***** resizing
:PROPERTIES:
:ID:       0aed1e9d-acff-430c-8372-23a620726bae
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "w"
  "M" (list :def #'maximize-window  :wk "maximize")
  "m" (list :def #'minimize-window  :wk "maximize")
  "b" (list :def #'window-balance   :wk "maximize")
  "z" (list :def #'zoom-window-zoom :wk "zoom"))
#+end_src

***** layout
:PROPERTIES:
:ID:       864e890f-d67c-40bc-8f72-49f4d6a21d5d
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "w"
  "x" (list :def #'ace-swap-window :wk "swap windows")
  "t" (list :def #'transpose-frame :wk "transpose"))
#+end_src

***** workgroups
:PROPERTIES:
:ID:       8cb7ee3d-6d9e-4fbf-a96a-5f7cdc2aa363
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "w"
  "w" (list :ignore t :wk "workgroup"))

(defun wg/create-workgroup ()
  (call-interactively #'wg-open-workgroup))

(define-leader-key!
  :infix "w w"
  "c" (list :def #'wg-create-workgroup          :wk "open") 
  "o" (list :def #'wg-open-workgroup            :wk "open") 
  "s" (list :def #'wg-switch-workgroup          :wk "switch") 
  "h" (list :def #'wg-switch-to-workgroup-left  :wk "left") 
  "l" (list :def #'wg-switch-to-workgroup-right :wk "right"))
#+end_src

*** Text Editing
:PROPERTIES:
:ID:       40fb1b29-b772-456f-aac6-cf4a3b5cde3f
:END:

**** separedit
:PROPERTIES:
:ID:       07021099-6cea-4016-929b-d9310ea305f8
:END:

#+begin_src emacs-lisp
(use-package! separedit
  :commands separedit)
#+end_src

**** edit-indirect
:PROPERTIES:
:ID:       786b11a6-561b-4793-9c6c-f7630aba3774
:END:

=edit-indirect= is a package that provides a means to edit text in an indirect
buffer. It's the same concept as org-src buffers but is not tied to org-mode.

***** init
:PROPERTIES:
:ID:       d08adcae-ab17-41f1-94c9-1d9a8cb385d7
:END:

#+begin_src emacs-lisp
(use-package! edit-indirect
  :commands edit-indirect)
#+end_src

***** editing org descriptions
:PROPERTIES:
:ID:       bdabe0b9-4116-423b-9fc0-049651bed58a
:END:

This headline contains customizations and extensions to =edit-indirect= so that I
can use it to edit org descriptions in the same way that we edit source blocks.

There are two cases when editing a description. There's the case of an existing
description and there's the case of a new one.

****** init

#+begin_src emacs-lisp
(use-package! org-edit-paragraph
  :xl-ensure nil
  :xl-nameless ("oep" . "org-edit-paragraph")
  :xl-rule ("bottom" "org description" :newname "\\*Org Desc - .+")
  ;; :xl-before-call ()
  :xl-config
  (after! (evil evil-surround)
    (xl-add-hook 'org-edit-paragraph:mode-hook #'evil-surround-mode)))
#+end_src

****** set up tempo completion

#+begin_src emacs-lisp
(defhook! enable-org-tempo-templates (org-edit-paragraph:mode-hook)
  (tempo-use-tag-list 'tempo:org-mode-taglist))

(xl-add-hook 'org-edit-paragraph:mode-hook #'company-mode)

;; Add an element to the company alist.
(after! company
  (push '(org-edit-paragraph:mode :only (company-tempo)) company:backend-alist))
#+end_src

****** description bounds
:PROPERTIES:
:ID:       74367212-cbd0-4871-94d5-24980e997bd7
:END:

#+begin_src emacs-lisp
(defun org-edit-paragraph:bounds ()
  "Return the bounds of description at headline.
If there is no existing description return nil."
  (interactive)
  (let* ((parse-tree (org-ml-parse-subtree-at (point)))
	 (elements '(headline section property-drawer src-block paragraph))
	 (nodes (->> (org-element-map parse-tree elements #'identity)
		     (--split-when (eq (org-element-type it) 'headline))
		     (car))))
    (aif (car (--split-when (not (eq (org-element-type it) 'paragraph)) nodes))
	(cons (org-element-property :begin (-first-item it))
	      (org-element-property :end (-last-item it)))
      (-let* ((section (--first (eq (org-element-type it) 'section) nodes))
	      ((property-drawer others) (org-element-contents section)))
	(alet (org-element-property :end (if others property-drawer section))
	  (cons it it))))))
#+end_src

****** default post blanks
:PROPERTIES:
:ID:       117478bf-3759-4a00-b738-9b1aad99ed54
:END:

It is my preference to have one blank line after a description--or any org item
for that matter. I just find it much more readable and less cluttered.

#+begin_src emacs-lisp
(defvar org-edit-paragraph:default-post-blanks 1
  "Number of blank lines that should follow a description.")
#+end_src

****** hooks
:PROPERTIES:
:ID:       6ab3a2cc-17aa-4166-aa3f-8627afe40c1a
:END:

=edit-indirect= has hooks for whenever you want to do a quick thing.

******* goto last non-white
:PROPERTIES:
:ID:       f9afdc3d-ceea-4e9e-a986-9f6bb7e860f6
:END:

Most of the time I will want to add to the end of a description. Therefore, I
want the cursor to start at the last non-whitespace character of the
description.

#+begin_src emacs-lisp
(defun org-edit-paragraph:goto-last-non-white ()
  (goto-char (point-max))
  (skip-chars-backward "\n\s"))
#+end_src

******* add newlines in the beginning
:PROPERTIES:
:ID:       46917f50-8e0b-4c29-8f9b-1aab7e0e9550
:END:

In the case where there was no existing description, we need to add newlines to
the description buffer so that if we end up committing a change the description
will be placed properly in relation to what's below it. This hook is designed to
make sure this happens.

#+begin_src emacs-lisp
(defun org-edit-paragraph:add-newlines ()
  "Add newlines."
  (save-excursion
    (--dotimes (1+ org-edit-paragraph:default-post-blanks)
      (insert "\n"))))
#+end_src

******* maybe remove newline
:PROPERTIES:
:ID:       cfa12a0f-fd23-4684-bb10-b86b2e4e5c58
:END:

When you open a description buffer and close it again, you'd expect the source
buffer to stay the same--and you should expect this. Since we add newlines to
the description buffer when there's no existing description, we could
inadvertently edit the source buffer in this case. So this hook is to remove any
newlines added in the case that nothing was changed.

#+begin_src emacs-lisp
(defun org-edit-paragraph:maybe-remove-newline ()
  "Remove newline if that's all there is."
  (alet (buffer-string)
    (when (and (seq-every-p (lambda (char) (= 10 char)) it)
	       (= (1+ org-edit-paragraph:default-post-blanks) (length it)))
      (erase-buffer))))
#+end_src

****** define a minor mode for editing descriptions
:PROPERTIES:
:ID:       8775acdc-0389-40af-a5f4-e74c78144944
:END:

The way I've set things up editing descriptions is it's own "thing". I'm going
to be adding hooks and maybe even binding keys with editing descriptions in mind.
Therefore, I think it's worthy to give it it's own mode.

#+begin_src emacs-lisp
(define-minor-mode org-edit-paragraph:mode
  "Mode for editing org descriptions.")
#+end_src

****** requirements for editing descriptions
:PROPERTIES:
:ID:       9a789e79-84b8-4415-b152-e11fca786587
:END:

The edit description function requires =org-ml= and =edit-indirect=. I don't
know if this is the best way to declare these dependencies. It certaintly is
efficient.

#+begin_src emacs-lisp
(xl-load-before-call 'org-ml #'org/dwim-edit-description)
(xl-load-before-call 'edit-indirect #'org/dwim-edit-description)
#+end_src

****** edit description
:PROPERTIES:
:ID:       3a7da5c8-f445-4592-b0c0-7fbff3be912e
:END:

It is uncough to edit the text of the buffer when we're not commit it--even
worse to have to edit it again afterwards if we don't end up committing
anything. No, instead we should work with the edit indirect buffer.

We need to make sure that we respect [[helpvar:edit-indirect-after-creation-hook][edit-indirect-after-creation-hook]] by doing
our description management stuff before anything is done in that hook. It may be
worth it to consider creating a hook specifically for org descriptions.

#+begin_src emacs-lisp
(defun org/dwim-edit-description ()
  (interactive)
  (-let* (((beg . end) (org-edit-paragraph:bounds))
	  (was-empty-p (= beg end)))
    (unless beg (user-error "No description at headline."))
    (let ((edit-indirect-after-creation-hook edit-indirect-after-creation-hook)
	  (headline (org-get-heading t t t t)))
      (when was-empty-p
	(add-hook 'edit-indirect-after-creation-hook #'org-edit-paragraph:add-newlines 0))
      (add-hook 'edit-indirect-after-creation-hook #'org-edit-paragraph:goto-last-non-white 0)
      (with-current-buffer (edit-indirect-region beg end)
	(rename-buffer (format "*Org Desc - %s*" headline) t)
	(org-edit-paragraph:mode 1)
	(add-hook 'edit-indirect-before-commit-hook
		  #'org-edit-paragraph:maybe-remove-newline nil t)
	(select-window (display-buffer (buffer-name)))))))
#+end_src

****** evil support
:PROPERTIES:
:ID:       f270092b-19ca-40ba-87aa-77b3d314c9a6
:END:

When I open a buffer for editing a description it is very likely that I'll end
up appending more commentary to the existing description. I think it will save
me more time making that common case easier than the cost for the few situations
where I don't do this.

#+begin_src emacs-lisp
(after! evil
  (xl-add-hook 'org-edit-paragraph:mode-hook #'evil-insert-state))
#+end_src

****** custom hooks
:PROPERTIES:
:ID:       240acf8a-621e-4e44-9c11-250b70a0e3dc
:END:

#+begin_src emacs-lisp
(alet (list #'auto-capitalize-mode #'aggressive-fill-paragraph-mode
	    #'org-link-minor-mode)
  (xl-add-hook 'org-edit-paragraph:mode-hook it))
#+end_src

***** editing org source blocks
:PROPERTIES:
:ID:       5d7edceb-9934-4bfe-a556-cdc0512288e0
:END:

Why reinvent the wheel? While we can already edit source blocks with org
built-in [[helpfn:org-edit-src-code][org-edit-src-code]], I value consistency. Instead of using two different
implementations for editing in an indirect buffer, I'd rather just use
one. =edit-indirect= is simpler, more general and more customizable than the
source block editing tools used by org mode.

****** init
:PROPERTIES:
:ID:       e0ed611a-e3ec-4d7b-9768-3d7e947d9c9e
:END:

#+begin_src emacs-lisp
(use-package! org-source
  :xl-rule ("bottom" "org source blocks" :newname "\\*Org[[:space:]]\\(?:S\\(?:ource\\|rc\\)\\).+")
  :xl-before-call
  :xl-ensure nil)
#+end_src

****** before load
:PROPERTIES:
:ID:       2605fd28-b61f-46b7-a212-6291e5fd0b0a
:END:

#+begin_src emacs-lisp
(alet (list #'org/dwim-edit-source-block #'org/dwim-edit-description)
  (xl-load-before-call 'org-ml it)
  (xl-load-before-call 'edit-indirect it))
#+end_src

****** minor mode for org source buffers
:PROPERTIES:
:ID:       9e55d8ab-23d8-4b40-beac-ab0fb151f02f
:END:

#+begin_src emacs-lisp
(define-minor-mode org-source:mode ())
#+end_src

****** hooks
:PROPERTIES:
:ID:       84daf376-561e-4b12-a134-b3d50ec14efe
:END:

******* add newlines
:PROPERTIES:
:ID:       adc49d00-604c-47c7-b8fd-df3a30eb243a
:END:

#+begin_src emacs-lisp
(defun org-source:remove-if-only-newline ()
  (when (string= (buffer-string) "\n")
    (erase-buffer)))
#+end_src

****** default post blanks
:PROPERTIES:
:ID:       117478bf-3759-4a00-b738-9b1aad99ed54
:END:

It is my preference to have one blank line after a description--or any org item
for that matter. I just find it much more readable and less cluttered.

#+begin_src emacs-lisp
(defvar org-source:default-post-blanks 1
  "Number of blank lines that should follow a description.")
#+end_src

****** main function for editing source block
:PROPERTIES:
:ID:       519013b5-258b-48e1-801b-84bda1175101
:END:

When editing a source block we face a similar problem to descriptions--namely,
the case when the org source buffer is empty. In this case we need to add a
newline and only commit if the user has added content to the source block.

The style in which I wrote this function is different from the last because it
was inconvenient to get the start and end points of the source block contents. I
have not finished with this source block.

#+begin_src emacs-lisp
(defun org/dwim-edit-source-block ()
  "Edit org source block."
  (interactive)
  (alet (-> (org-ml-parse-subtree-at (point))
	    (org-element-map '(headline src-block) #'identity nil))
    (-let* ((headline (car-safe (org-element-property :title (car it))))
	    (source-block (--first (eq 'src-block (org-element-type it)) it))
	    (edit-indirect-after-creation-hook edit-indirect-after-creation-hook)
	    (lang (org-element-property :language source-block))
	    ((beg end) (org-src--contents-area source-block)))
      (with-current-buffer (edit-indirect-region beg end)
	(rename-buffer (format "*Org Source - %s*" headline) t)
	(funcall (org-src-get-lang-mode lang))
	(when (= beg end)
	  (goto-char (point-max))
	  (insert "\n")
	  (alet #'org-source:remove-if-only-newline
	    (add-hook 'edit-indirect-before-commit-hook it nil t)))
	(goto-char (point-min))
	(select-window (display-buffer (buffer-name)))))))
#+end_src

****** trim any trailing whitespace
:PROPERTIES:
:ID:       3a3d2ddb-7f80-4627-9733-986f4af1d2d7
:END:

A common annoyance is dealing accidentally leaving trailing whitespace in the
source buffer and then finding out when you see it written to the org file. With
this I never have to think about this again.

#+begin_src emacs-lisp
(xl-add-hook 'org-edit-source-mode-hook #'delete-trailing-whitespace)
#+end_src

***** bindings inside edit-indirect
:PROPERTIES:
:ID: 42992d1e-5d65-4570-ba96-02b3be31b97b
:END:

I want quick, convenient bindings I can use to abort or commit (which is
=edit-indirect= lingo for writing the contents of the buffer back into its source
file, see [[helpfn:edit-indirect-commit][edit-indirect-commit]].

#+begin_src emacs-lisp
(define-localleader-key!
  :keymaps 'edit-indirect-mode-map
  "," #'edit-indirect-commit
  "c" #'edit-indirect-commit
  "a" #'edit-indirect-abort)
#+end_src

**** expand-region
:PROPERTIES:
:ID:       7e873fba-33ea-4720-ad79-bd8d557cc4b3
:END:

[[https://github.com/magnars/expand-region.el][expand-region]] allows me to toggle a key ("v" in my case) to select progressively
larger text objects. It's saves me keystrokes.

***** init
:PROPERTIES:
:ID:       41a1cebc-8da8-4e5c-8258-2ce440f1af50
:END:

#+begin_src emacs-lisp
(use-package! expand-region
  :commands er/expand-region er/contract-region er/mark-symbol)
#+end_src

***** quit expand region
:PROPERTIES:
:ID:       639824e1-0dcf-46bc-98b4-c70b9c7cb2a6
:END:

#+begin_src emacs-lisp
(defadvice! quit-expand-region (:before evil-escape)
  "Properly abort an expand-region region."
  (when (memq last-command '(er/expand-region er/contract-region))
    (er/contract-region 0)))
#+end_src

***** expand-region
:PROPERTIES:
:ID: 417c9c53-a776-4779-9afc-1eaa35a145c6
:END:

#+begin_src emacs-lisp
(define-key! 'visual
  "V" #'er/contract-region
  "v" #'er/expand-region)
#+end_src

**** writing
:PROPERTIES:
:ID:       98b567f1-00ad-4c99-aace-0a12f4d1b353
:END:

This headline is for packages and configuration related to writing such as spell
and grammer checking.

***** plural
:PROPERTIES:
:ID:       bf2ed9b7-144c-4d4b-92ae-74c93dfc6db5
:END:

This package determines whether a noun is plural and provides a function to
convert a singular noun to a plural one. For example ~(plural-pluralize
"goose")~ returns ~"geese"~.

My intended use for this package is to help automate prompts, docstrings or the
like that concern N number of things, where N could be 1 or more things.

#+begin_src emacs-lisp
(use-package! plural
  :commands plural-make-plural
  :xl-config
  (push '("\\`is\\'" . "are") plural-knowledge)
  (push '("\\`thas\\'" . "those") plural-knowledge)
  (push '("\\`this\\'" . "these") plural-knowledge))
#+end_src

***** auto-capitalize
:PROPERTIES:
:ID:       4ddfacc1-a25e-466e-ab6b-2a5ec306f3be
:END:

[[https://github.com/emacsmirror/auto-capitalize][auto-capitalize]] automatically capitalizes the first word of a sentence for me.
It will also upcase any word I add to [[helpvar:auto-capitalize-words][auto-capitalize-words]].

#+begin_src emacs-lisp
(use-package! auto-capitalize
  :xl-hook text-mode-hook
  :xl-set
  (auto-capitalize-words . '("I" "English")))
#+end_src

***** spell-number
:PROPERTIES:
:ID:       8bf270a6-6003-4430-bb03-0b665d5a162f
:END:

#+begin_src emacs-lisp
(use-package! spell-number
  :xl-set
  (spelln-language          . 'english-us)
  (spelln-country           . 'united-states)
  (spelln-period-character  . ?,)
  (spelln-decimal-character . ?.))
#+end_src

**** xr
:PROPERTIES:
:ID: 75c56163-9ce1-4726-969a-350fcc56395f
:END:

This package is the inverse of =rx=. It takes a regular expression and returns the
=rx= representation.

#+begin_src emacs-lisp
(use-package! xr :commands xr)
#+end_src

**** saving & backups
:PROPERTIES:
:ID:       58228a67-3f7f-4654-8452-81194e75da07
:END:

***** super-save
:PROPERTIES:
:ID:       684e788c-6db9-4e6e-826b-d4871c0a3f90
:END:

The default auto-saving feature in emacs saves after a certain number of
characters are typed (see [[helpvar:auto-save-interval][auto-save-interval]]). The problem is that if you're in
the middle of typing and you've just hit the number of characters that trigger a
save, you could experience a lag, particularly if you are dealing with a large
file being saved. Instead of doing this, [[https://github.com/bbatsov/super-save][super-save]] saves buffers during idle
time and after certain commands like [[helpfn:switch-to-buffer][switch-to-buffer]] (see [[helpvar:super-save-triggers][super-save-triggers]]).
Note that this is the same strategy employed by [[id:c550f82a-9608-47e6-972b-eca460015e3c][idle-require]] to load packages.
Saving files like this reduces the likelihood of user delays.

#+begin_src emacs-lisp
(use-package! super-save
  :xl-before-call find-file
  :xl-set
  (super-save-auto-save-when-idle . t)
  (super-save-idle-duration       . 5))
#+end_src

**** spacing & indentation
:PROPERTIES:
:ID:       ae5416cd-ffa2-456a-9c56-afcfc65a33f8
:END:

***** aggressive-fill-paragraph
:PROPERTIES:
:ID: 4f57fd49-b466-4eea-b91a-2cc8f0b07297
:END:

#+begin_src emacs-lisp
(use-package! aggressive-fill-paragraph)
#+end_src

***** aggressive-indent
:PROPERTIES:
:ID: f1b9a36e-26e4-4305-99ae-cbcf6a90013d
:END:

[[https://github.com/Malabarba/aggressive-indent-mode][aggressive-indent]] indents portions of the text your working on as your typing
it. It's pretty smart and very convenient.

#+begin_src emacs-lisp
(use-package! aggressive-indent
  :xl-hook emacs-lisp-mode-hook)
#+end_src

**** parentheses
:PROPERTIES:
:ID:       e82d2b4e-659e-4c7d-8071-c413b8e540f7
:END:

***** smartparens
:PROPERTIES:
:ID:       f4ffbb57-1fb6-43ab-a747-470dfcfbd0ac
:END:

****** init
:PROPERTIES:
:ID:       e26f4c55-9585-4544-bed6-9733d50823e7
:END:

#+begin_src emacs-lisp
(use-package! smartparens
  :xl-before-call evil-expression evil-ex
  :xl-hook ((prog-mode eshell-mode ielm-mode) . smartparens-strict-mode)
  :xl-set
  (sp-highlight-pair-overlay . nil)
  (sp-highlight-wrap-overlay . nil)
  (sp-highlight-wrap-tag-overlay . nil)
  (sp-show-pair-from-inside . t)
  (sp-cancel-autoskip-on-backward-movement . nil)
  (sp-show-pair-delay . 0.1)
  (sp-max-pair-length . 4)
  (sp-max-prefix-length . 50)
  (sp-escape-quotes-after-insert . nil))
#+end_src

****** config
:PROPERTIES:
:ID: f1c64411-ad51-4c24-8dad-b4aa7b8fc3b5
:END:

#+begin_src emacs-lisp
(use-package! smartparens :config
  (defhook! init-smartparens-config (smartparens-mode-hook)
    (require 'smartparens-config)
    (sp-local-pair 'minibuffer-inactive-mode "'" nil :actions nil)))
#+end_src

****** disable =smartparens-navigate-skip-match=
:PROPERTIES:
:ID: fda1875b-b3f7-4f43-83b1-873f3db3ae77
:END:

#+begin_src emacs-lisp
(use-package! smartparens :config
  (defhook! disable-smartparens-navigate-skip-match (after-change-major-mode-hook)
    "Disable smartparents skip match feature."
    (setq sp-navigate-skip-match nil)
    (setq sp-navigate-consider-sgml-tags nil)))
#+end_src

****** autopairing
:PROPERTIES:
:ID: e860ce7e-aaac-477b-a373-a8b01957481d
:END:

#+begin_src emacs-lisp
(defhook! enable-smartparens-maybe (minibuffer-setup-hook)
  "Enable `smartparens-mode' in the minibuffer."
  (when (memq this-command '(eval-expression evil-ex))
    (smartparens-mode 1)))
#+end_src

***** rainbow-delimiters
:PROPERTIES:
:ID:       5b58bb1c-5d3c-4f04-b4fb-c55f1588839e
:END:

[[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]] colors parentheses different colors based on level. This is a
great idea! It makes it really easy to see which parentheses go together.

#+begin_src emacs-lisp
(use-package! rainbow-delimiters
  :xl-hook prog-mode-hook reb-mode-hook
  :xl-set
  (rainbow-delimiters-max-face-count . 9))
#+end_src

**** outshine
:PROPERTIES:
:ID:       6aeccc22-2ebe-43c0-a245-5535b5bd6f6c
:END:

#+begin_src emacs-lisp
(use-package! outshine :commands outshine-mode)
#+end_src

**** modal editing
:PROPERTIES:
:ID:       175ad5b9-3f0e-445e-b0ae-da3bce144929
:END:

Modal editing is widely accepted to be more efficient than modeless editing.

***** evil - the "extensible VI layer"
:PROPERTIES:
:ID:       9639633f-ec3d-4499-9615-db0dcc9650c9
:END:

=evil= is the most complete vim emulation in existence.

****** text objects
:PROPERTIES:
:ID: 07366548-2960-49c6-9ab7-cb177b06ad70
:END:

To edit text efficiently Vim has the concept of [[https://blog.carbonfive.com/2011/10/17/vim-text-objects-the-definitive-guide/][text objects]]. Text objects are
structures that are seen in text. For example, a set of words followed by a
period is a sentence. A words between two closing parentheses is a sexp.

******* general delimiter text object
:PROPERTIES:
:ID: f551956d-440c-431b-8fb0-8e71c9714f11
:END:

I discovered this the =form= text object from using [[https://github.com/luxbock/evil-cleverparens][evil-cleverparens]] in the past.
The package =evil-cleverparens= was too slow for my taste; noctuid's [[https://github.com/sp3ctum/evil-lispy][evil-lispy]] is
much faster and gave me the functionality that I needed most from
=evil-cleverparens=: deleting and copying text with parentheses intelligently.
However, many of the ideas of =evil-cleverparens= were excellent. One particular
idea was to have a general =form= text object. Instead of specifying the
particular surrounding bounds when doing an evil operator command you just use a
single key for them. It's kind of like a =Do-What-I-Mean= surround operator. This
is suprisingly useful because it takes significant time to specify whether you
want =[]= or ={=}= or =()= or =""=. The main drawback you cannot distinguish between
surround characters at multiple levels--it just takes the closest one. In
practice, this is rarely an issue.

#+begin_src emacs-lisp
(after! evil
  (evil-define-text-object evil:textobj-inner-form (count &rest _)
    "Inner sexp object."
    (-if-let ((beg . end)
              (->> (list (lispy--bounds-list) (lispy--bounds-string))
                   (-non-nil)
                   (--sort (< (- (cdr it) (car it)) (- (cdr other) (car other))))
                   (car)))
        (evil-range (1+ beg) (1- end) 'inclusive :expanded t)
      (error "No surrounding form found.")))

  (evil-define-text-object evil:textobj-outer-form (count &rest _)
    "Smartparens inner sexp object."
    (-if-let ((beg . end)
              (->> (list (lispy--bounds-list) (lispy--bounds-string))
                   (-non-nil)
                   (--sort (< (- (cdr it) (car it)) (- (cdr other) (car other))))
                   (car)))
        (evil-range beg end 'inclusive :expanded t)
      (error "No surrounding form found.")))

  (general-def evil-inner-text-objects-map
    "f" #'evil:textobj-inner-form)
  (general-def evil-outer-text-objects-map
    "f" #'evil:textobj-outer-form))
#+end_src

******* fix vim/evil around =""=
:PROPERTIES:
:ID: b57bf245-3d63-4078-8bcb-2ec0b9952ab9
:END:

=Vim= and =Evil= both have the interesting (inconsistent?) behavior that doing an
outer text object operator on a comment grabs some whitespace on the left side.
Try doing =va"= to ~(progn "hello world")~ and you'll see that =\s"hello world"= is
selected instead of just "hello world".

Why not just go to the end of the ="= like any other around operator?

#+begin_src emacs-lisp
(after! evil
  (evil-define-text-object evil:textobj-a-string (count &rest _)
    "An outer comment text object as defined by `lispy--bounds-string'."
    (-if-let ((beg . end) (lispy--bounds-string))
        (evil-range beg end 'exclusive :expanded t)
      (error "Not inside a comment.")))

  (general-def evil-outer-text-objects-map
    "\"" #'evil:textobj-a-string))
#+end_src

****** evil-lion
:PROPERTIES:
:ID:       95d248be-601e-4dbd-b318-febcd0e49d71
:END:

=evil-lion= provides a very useful way of aligning text.

#+begin_src emacs-lisp
(use-package! evil-lion
  :commands evil-lion-right evil-lion-left)

(general-def 'normal
  :infix "g"
  "l" #'evil-lion-left
  "L" #'evil-lion-right)
#+end_src

****** evil-visualstar
:PROPERTIES:
:ID: 6ebca72d-f90a-4423-9ecd-706f9d426002
:END:

[[https://github.com/bling/evil-visualstar][evil-visualstar]]

#+begin_src emacs-lisp
(use-package! evil-visualstar
  :general
  (:keymaps 'evil-visual-state-map
   "#" #'evil-visualstar/begin-search-backward
   "*" #'evil-visualstar/begin-search-forward))
#+end_src

****** evil-surround
:PROPERTIES:
:ID:       9ab88644-3c33-463c-8f24-3b048209e082
:END:

#+begin_src emacs-lisp
(use-package! evil-surround
  :xl-hook prog-mode-hook text-mode-hook)
#+end_src

****** evil
:PROPERTIES:
:ID: 3b9aaf0c-a69c-474a-b1a3-f0e748e83558
:END:

[[https://github.com/emacs-evil/evil][evil]] is an extensible vi layer for Emacs. It emulates the main features of Vim,
and provides facilities for writing custom extensions. Also see our page on
[[emacswiki:Evil][EmacsWiki]]. See a brief [[https://bytebucket.org/lyro/evil/raw/default/doc/evil.pdf][manual]]. See the [[https://github.com/noctuid/evil-guide][evil-guide]] by noctuid.

******* init
:PROPERTIES:
:ID:       af3a9791-76ac-4fd5-96fe-d361cef3b5b3
:END:

#+begin_src emacs-lisp
(use-package! evil
  :demand t
  :xl-hook (window-setup-hook . evil-mode))
#+end_src

******* custom
:PROPERTIES:
:ID:       f7ece898-25e2-4b2c-94f3-e832a687114c
:END:

#+begin_src emacs-lisp
(custom-set-default 'evil-want-C-u-scroll t)
#+end_src

******* settings
:PROPERTIES:
:ID:       9f184a21-ef04-4b3d-a1b7-88a16eaa7b97
:END:

#+begin_src emacs-lisp
(use-package! evil
  :xl-set
  (evil-want-visual-char-semi-exclusive . t)
  (evil-ex-search-vim-style-regexp      . t)
  (evil-respect-visual-line-mode        . t)
  (evil-insert-skip-empty-lines         . t)
  (evil-want-C-w-in-emacs-state         . nil)
  (evil-ex-substitute-global            . t)
  (evil-ex-visual-char-range            . t)
  (evil-move-beyond-eol                 . nil)
  (evil-indent-convert-tabs             . t)
  (evil-symbol-word-search              . t)
  (evil-mode-line-format                . nil)
  (evil-echo-state                      . nil)
  (evil-magic                           . t))
#+end_src

******* cursors
:PROPERTIES:
:ID: a5f558fb-221c-4b33-a7cd-29308ef74b0d
:END:

It's nice to have cursors change colors (and sometimes shape) depending on the
current evil state. It makes it easy to tell which state you're in. I define
some colors here. Evil has a cursor variable for each state. The cursor variable
for insert state, for example, is [[helpvar:evil-insert-state-cursor][evil-insert-state-cursor]]. Its value is of the
form: ~((CURSOR-SHAPE . CURSOR-WIDTH) COLOR)~.

******** colors and shapes
:PROPERTIES:
:ID: 3f3cd5c9-1f6d-4c3b-b73f-82c9ee00395e
:END:

Changing the cursor shape and color depending on the state is a convenient and
asthetically pleasing way of determining which state you're in. Some add some
modeline indicator for this but I find that the cursor suffices.

#+begin_src emacs-lisp
(defhook! setup-cursor (evil-mode-hook)
  "Initialize the default cursor shape and size."
  (setq evil-insert-state-cursor   '((bar . 3)   "chartreuse3"))
  (setq evil-emacs-state-cursor    '((bar . 3)   "SkyBlue2"))
  (setq evil-normal-state-cursor   '( box        "DarkGoldenrod2"))
  (setq evil-visual-state-cursor   '((hollow)    "dark gray"))
  (setq evil-operator-state-cursor '((hbar . 10) "hot pink"))
  (setq evil-replace-state-cursor  '( box        "chocolate"))
  (setq evil-motion-state-cursor   '( box        "plum3")))
#+end_src

******** updating cursors
:PROPERTIES:
:ID: ea4da6d4-4a2c-42cf-b397-cea1555781ce
:END:

After a theme is loaded, the cursor color won't automatically update. Therefore,
I add a hook in [[helpvar:xl-after-load-theme-hook][xl-after-load-theme-hook]]. Now after a new theme is loaded, the
cursor color will update.

#+begin_src emacs-lisp
(defhook! refresh-evil-cursor (xl-after-load-theme-hook)
  "Enable cursor refreshing after theme change."
  (when (bound-and-true-p evil-mode)
    (evil-refresh-cursor)))
#+end_src

******* normal state everywhere
:PROPERTIES:
:ID:       e6126bd7-94b8-4ce0-b547-0536b59437ea
:END:

Noctuid pointed out

#+begin_src emacs-lisp
(defhook! make-normal-state-default (evil-mode-hook)
  "Make normal state the default `evil-mode' state."
  (setq evil-normal-state-modes (append evil-emacs-state-modes evil-normal-state-modes))
  (setq evil-emacs-state-modes nil)
  (setq evil-motion-state-modes nil))

(defadvice! replace-motion-with-normal (:around evil-make-overriding-map)
  "Advice for `evil-make-overriding-map' that inhibits motion state."
  (-let (((keymap state copy) <args>))
    (funcall <orig-fn> keymap (if (eq state 'motion) 'normal state) copy)))

(defadvice! replace-motion-with-normal (:around evil-set-initial-state)
  (-let (((mode state) <args>))
    (funcall <orig-fn> mode (if (eq state 'motion) 'normal state))))

(xl-add-advice #'evil-motion-state :override #'evil-normal-state)
#+end_src

******* insert state in minibuffer
:PROPERTIES:
:ID: a23137c5-62a0-4e77-9e51-6a7372dac703
:END:

Before I just used ~(evil-change-state evil-previous-state)~ to revert the
state back to what it last was. But this fails with ~evil-force-normal-state~
which is what I'm currently using to exit the minibuffer because then the
last state is normal state if the minibuffer is aborted. Using a
=evil:state-before-minibuffer= ensures that the state will be reverted to
the correct one.

#+begin_src emacs-lisp
(defhook! preserve-prior-evil-state (minibuffer-enter-hook)
  "Save state before entering the minibuffer and enter insert state."
  (when (bound-and-true-p evil-mode)
    (setq evil:state-before-minibuffer evil-state)
    (evil-insert-state)))

(defhook! restore-prior-evil-state (minibuffer-exit-hook)
  "Restore state after minibuffer."
  (when (bound-and-true-p evil-mode)
    (evil-change-state evil:state-before-minibuffer)
    (setq evil:state-before-minibuffer nil)))
#+end_src

******* escape
:PROPERTIES:
:ID:       e4b9d33d-c64d-47ef-9bff-baa80d1b34b2
:END:

******** escape
:PROPERTIES:
:ID: ea9378de-e5c5-482c-b53b-743a81e3bc8e
:END:

We want escape to be a general "quit everything".

#+begin_src emacs-lisp
(general-def :states '(emacs insert) [escape] #'evil-force-normal-state)

(defadvice! exit-everything (:after evil-force-normal-state lispyville-normal-state)
  "Exits out of whatever is happening after escape."
  (cond ((minibuffer-window-active-p (minibuffer-window))
         (abort-recursive-edit))
        ((run-hook-with-args-until-success 'xl-escape-hook))
        ((or defining-kbd-macro executing-kbd-macro) nil)
        (t (keyboard-quit))))
#+end_src

******** key-chord
:PROPERTIES:
:ID:       8fd1bcdc-c4b3-4fee-b91b-dcdf96167582
:END:

Sometimes we don't have access to a convenient escape key--I mean that caps-lock
is not bound to escape. Or, perhaps, we might find it faster or preferable to
press =jk= really quickly to invoke escape.

This is better than evil escape as it only binds in insert.

#+begin_src emacs-lisp
(use-package! key-chord
  :xl-silence key-chord-mode
  :xl-before-call evil-insert-state evil-emacs-state
  :xl-config
  (key-chord-mode 1)
  :general
  (:states '(visual insert)
   (general-chord "jk") 'evil-force-normal-state
   (general-chord "kj") 'evil-force-normal-state))
#+end_src

*** Languages
:PROPERTIES:
:ID:       fa8dc2fc-96f4-4820-b368-4d61d1db0ee5
:END:

**** lisp
:PROPERTIES:
:ID:       2b7db121-f807-4274-9347-70c996d3c6f7
:END:

This headline is for packages and configuration which pertain to editing lisp
code.

***** lispyville
:PROPERTIES:
:ID: 9d22714a-086d-49a1-9f8b-66da3b646110
:END:

[[https://github.com/noctuid/lispyville][lispyville]] helps vim commands work better with lisp by providing
commands (like [[helpfn:lispyville-delete][lispyville-delete]]) which preserve parentheses.

****** initialize
:PROPERTIES:
:ID:       fad4cb7c-ff1e-485d-99d1-f55384c26402
:END:

#+begin_src emacs-lisp
(use-package! lispyville :xl-hook emacs-lisp-mode-hook)
#+end_src

****** remappings
:PROPERTIES:
:ID: 5567b70d-60f2-4161-9a19-d6098f45cd95
:END:

#+begin_src emacs-lisp
(use-package! lispyville
  :general
  (:keymaps 'lipsyville-mode-map
   [remap evil-yank]                 #'lispyville-yank
   [remap evil-delete]               #'lispyville-delete
   [remap evil-change]               #'lispyville-change
   [remap evil-yank-line]            #'lispyville-yank-line
   [remap evil-delete-line]          #'lispyville-delete-line
   [remap evil-change-line]          #'lispyville-change-line
   [remap evil-delete-char]          #'lispyville-delete-char-or-splice
   [remap evil-delete-backward-char] #'lispyville-delete-char-or-splice-backwards
   [remap evil-substitute]           #'lispyville-substitute
   [remap evil-change-whole-line]    #'lispyville-change-whole-line
   [remap evil-join]                 #'lispyville-join))
#+end_src

****** inner text objects
:PROPERTIES:
:ID:       f9f82ebe-5749-452f-ba49-269e60526b04
:END:

#+begin_src emacs-lisp
(use-package! lispyville
  :general
  (:keymaps 'evil-inner-text-objects-map
   "a" #'lispyville-inner-atom
   "l" #'lispyville-inner-list
   "x" #'lispyville-inner-sexp
   "c" #'lispyville-inner-comment
   "s" #'lispyville-inner-string))
#+end_src

****** outer text objects
:PROPERTIES:
:ID:       9dda9a1b-c76f-4537-9554-45ad3c77977a
:END:

#+begin_src emacs-lisp
(define-key! evil-outer-text-objects-map
  "a" #'lispyville-a-atom
  "l" #'lispyville-a-list
  "x" #'lispyville-a-sexp
  "c" #'lispyville-a-comment
  "s" #'lispyville-a-string)
#+end_src

****** slurp/barf
:PROPERTIES:
:ID: 21626641-98e3-4134-958d-03227e4da6b5
:END:

#+begin_src emacs-lisp
(define-key! 'normal lispyville-mode-map
  ">" #'lispyville-slurp
  "<" #'lispyville-barf)
#+end_src

****** escape
:PROPERTIES:
:ID: b355e1a1-6242-47f5-b357-5c3f5adbd200
:END:

=lispyville= binds escape to [[helpfn:lipyville-normal-state][lispyville-normal-state]]. So for =xl-escape-hook=
to still happen on escape, I need to add [[helpfn:evil:escape-a][evil:escape-a]] as advice to
=lispyville-normal-state=.

Sometimes =evil-normal-state= enters visual state.

#+begin_src emacs-lisp
(define-key! '(emacs insert) lispyville-mode-map [escape] #'lispyville-normal-state)
#+end_src

****** additional
:PROPERTIES:
:ID: 1fbafa78-87a0-45ee-9c7c-0c703df2ac66
:END:

#+begin_src emacs-lisp
(define-key! '(emacs insert) lispyville-mode-map
  "SPC" #'lispy-space
  ";"   #'lispy-comment)

(define-key! '(normal visual) lispyville-mode-map
  "M-j" #'lispyville-drag-forward
  "M-k" #'lispyville-drag-backward
  "M-R" #'lispyville-raise-list
  "M-v" #'lispy-convolute-sexp)
#+end_src

***** lispy
:PROPERTIES:
:ID:       47f19607-13a7-4857-bb1a-33760f95cb7e
:END:

For learning how to use lispy. [[https://github.com/abo-abo/lispy][the README]] and the [[http://oremacs.com/lispy/#lispy-different][lispy function reference]] were
very useful to me.

****** hook
:PROPERTIES:
:ID:       37bd49d1-3e34-4579-87d2-e791278be017
:END:

#+begin_src emacs-lisp
(use-package! lispy
  :xl-hook (emacs-lisp-mode-hook . lispy-mode))
#+end_src

****** settings
:PROPERTIES:
:ID:       20d99206-ddc4-42db-b4c1-8721decbaf8d
:END:

#+begin_src emacs-lisp
(setq lispy-avy-style-paren 'at-full)
(setq lispy-eval-display-style 'overlay)
(setq lispy-safe-delete t)
(setq lispy-safe-copy t)
(setq lispy-safe-paste t)
(setq lispy-safe-actions-no-pull-delimiters-into-comments t)
(setq lispy-delete-sexp-from-within t)
(setq lispy-parens-only-left-in-string-or-comment nil)
(setq lispy-safe-threshold 5000)
(setq lispy-use-sly t)
;; allow space before asterisk for headings (e.g. ";; *")
(setq lispy-outline "^;;\\(?:;[^#]\\|[[:space:]]*\\*+\\)")
(setq lispy-key-theme nil)
#+end_src

****** enter lispy state via =H= and =L=
:PROPERTIES:
:ID:       55955252-d35f-493f-bb2c-73a2363ca1c6
:END:

#+begin_src emacs-lisp
(define-key! 'normal evil-lispy-mode-map
  "H" #'evil-lispy/enter-state-left
  "L" #'evil-lispy/enter-state-right)
#+end_src

****** key-theme
:PROPERTIES:
:ID:       8977fd1e-5603-4acc-b3d7-c767f6b913fe
:END:

Key themes are keybinding themes used for.

#+begin_src emacs-lisp
(after! lispy (lispy-set-key-theme '(special)))
#+end_src

****** eros
:PROPERTIES:
:ID:       265b3b87-012e-452e-aa1f-c7c8e3308a73
:END:

****** avoid void variable error
:PROPERTIES:
:ID:       a73ff9be-1a3d-4007-ad40-5a34c38767f6
:END:

You'll get void variable if you don't do this.

#+begin_src emacs-lisp
(after! (avy lispy) (setq lispy-avy-keys avy-keys))
#+end_src

***** evil-lispy
:PROPERTIES:
:ID:       f79c2035-ce79-491a-acf6-5e80f72cffe9
:END:

****** lispy state cursor
:PROPERTIES:
:ID:       c44cf8dc-e80c-4be6-9c11-221b446cc87b
:END:

#+begin_src emacs-lisp
(set! evil-lispy-state-cursor  '((bar . 4) "red"))
#+end_src

****** run after lispy
:PROPERTIES:
:ID:       18173a29-7442-473e-a851-f46182f56447
:END:

#+begin_src emacs-lisp
(use-package! evil-lispy
  :hook lispy-mode-hook)
#+end_src

***** highlight-quoted
:PROPERTIES:
:ID:       d0973dce-693b-45ca-88e3-27da1bb217f7
:END:

[[https://github.com/Fanael/highlight-quoted][highlight-quoted]] highlights quotes, backticks and.

#+begin_src emacs-lisp
(use-package! highlight-quoted
  :xl-hook emacs-lisp-mode-hook)
#+end_src

***** macrostep
:PROPERTIES:
:ID:       fefc5700-3bd7-4a89-ae7b-bf68368e8bc4
:END:

#+begin_src emacs-lisp
(use-package! macrostep
  :commands macrostep-expand
  :init
  (define-localleader-key!
    :keymaps 'emacs-lisp-mode-map
    "e" (list :def #'macrostep-expand       :wk "expand")
    "c" (list :def #'macrostep-collapse     :wk "collapse")
    "C" (list :def #'macrostep-collapse-all :wk "collapse all")))
#+end_src

***** elisp

****** fix elisp indentation
:PROPERTIES:
:ID: aa7f846f-8802-4c75-88d8-a438e2f63ccd
:END:

A problem with elisp indentation is indents quoted lists the way functions
should be indented. It has been discussed in at least three stackoverflow
questions [[https://emacs.stackexchange.com/questions/10230/how-to-indent-keywords-aligned/10233#10233][here]], [[https://stackoverflow.com/questions/49222433/align-symbols-in-plist][here]] and [[https://stackoverflow.com/questions/22166895/customize-elisp-plist-indentation][here]]. In all these questions the solutions have not
been satisfactory. Some of them recommend using [[helpfn:common-lisp-indent-function][common-lisp-indent-function]] as
the value of [[helpvar:lisp-indent-function][lisp-indent-function]]. This works for indenting a quoted list
properly, but at the expense of changing the way that many other elisp forms are
indented. Common Lisp's indentation is different from Elisp's. Others recommend
using [[https://github.com/Fuco1/.emacs.d/blob/af82072196564fa57726bdbabf97f1d35c43b7f7/site-lisp/redef.el#L12-L94][Fuco1's lisp indent function hack]]. This also is not ideal. For one thing it
only works for quoted lists with keywords but not generic symbols. Another thing
is that the change should really be occurring in [[helpfn:calculate-lisp-indent][calculate-lisp-indent]].
~calculate-lisp-indent~ is a function that returns what the indentation should be
for the line at point. Since Fuco1 did not modify ~calculate-lisp-indent~ the
*wrong* indentation still returned by this function and the modified
~lisp-indent-function~ just cleans up the mess. Better is just fixing the source
of the problem. You can check out a more in-depth explanation looking at my
[[https://www.reddit.com/r/emacs/comments/d7x7x8/finally_fixing_indentation_of_quoted_lists/][reddit-post]] or looking at an answer I gave to [[https://emacs.stackexchange.com/questions/10230/how-to-indent-keywords-aligned][this question]].

#+begin_src emacs-lisp
(defadvice! properly-calculate-indent (:override calculate-lisp-indent)
  "Add better indentation for quoted and backquoted lists.
The change to this function."
  (defvar calculate-lisp-indent-last-sexp)
  (save-excursion
    (beginning-of-line)
    (let ((indent-point (point))
          state
          ;; setting this to a number inhibits calling hook
          (desired-indent nil)
          (retry t)
          calculate-lisp-indent-last-sexp containing-sexp)
      (cond ((or (markerp <parse-start>) (integerp <parse-start>))
             (goto-char <parse-start>))
            ((null <parse-start>) (beginning-of-defun))
            (t (setq state <parse-start>)))
      (unless state
        ;; Find outermost containing sexp
        (while (< (point) indent-point)
          (setq state (parse-partial-sexp (point) indent-point 0))))
      ;; Find innermost containing sexp
      (while (and retry
                  state
                  (> (elt state 0) 0))
        (setq retry nil)
        (setq calculate-lisp-indent-last-sexp (elt state 2))
        (setq containing-sexp (elt state 1))
        ;; Position following last unclosed open.
        (goto-char (1+ containing-sexp))
        ;; Is there a complete sexp since then?
        (if (and calculate-lisp-indent-last-sexp
                 (> calculate-lisp-indent-last-sexp (point)))
            ;; Yes, but is there a containing sexp after that?
            (let ((peek (parse-partial-sexp calculate-lisp-indent-last-sexp
                                            indent-point 0)))
              (if (setq retry (car (cdr peek))) (setq state peek)))))
      (if retry
          nil
        ;; Innermost containing sexp found
        (goto-char (1+ containing-sexp))
        (if (not calculate-lisp-indent-last-sexp)
            ;; indent-point immediately follows open paren.
            ;; Don't call hook.
            (setq desired-indent (current-column))
          ;; Find the start of first element of containing sexp.
          (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
          (cond ((looking-at "\\s(")
                 ;; First element of containing sexp is a list.
                 ;; Indent under that list.
                 )
                ((> (save-excursion (forward-line 1) (point))
                    calculate-lisp-indent-last-sexp)
                 ;; This is the first line to start within the containing sexp.
                 ;; It's almost certainly a function call.
                 (if (or
                      (= (point) calculate-lisp-indent-last-sexp)

                      (when-let (after (char-after (1+ containing-sexp)))
                        (char-equal after ?:))

                      (when-let (point (char-before containing-sexp))
                        (char-equal point ?'))

                      (let ((quoted-p nil)
                            (point nil)
                            (positions (nreverse (butlast (elt state 9)))))
                        (while (and positions (not quoted-p))
                          (setq point (pop positions))
                          (setq quoted-p
                                (or
                                 (and (char-before point)
                                      (char-equal (char-before point) ?'))
                                 (save-excursion
                                   (goto-char (1+ point))
                                   (looking-at-p "quote[\t\n\f\s]+(")))))
                        quoted-p))
                     ;; Containing sexp has nothing before this line
                     ;; except the first element.  Indent under that element.
                     nil
                   ;; Skip the first element, find start of second (the first
                   ;; argument of the function call) and indent under.
                   (progn (forward-sexp 1)
                          (parse-partial-sexp (point)
                                              calculate-lisp-indent-last-sexp
                                              0 t)))
                 (backward-prefix-chars))
                (t
                 ;; Indent beneath first sexp on same line as
                 ;; `calculate-lisp-indent-last-sexp'.  Again, it's
                 ;; almost certainly a function call.
                 (goto-char calculate-lisp-indent-last-sexp)
                 (beginning-of-line)
                 (parse-partial-sexp (point) calculate-lisp-indent-last-sexp
                                     0 t)
                 (backward-prefix-chars)))))
      ;; Point is at the point to indent under unless we are inside a string.
      ;; Call indentation hook except when overridden by lisp-indent-offset
      ;; or if the desired indentation has already been computed.
      (let ((normal-indent (current-column)))
        (cond ((elt state 3)
               ;; Inside a string, don't change indentation.
               nil)
              ((and (integerp lisp-indent-offset) containing-sexp)
               ;; Indent by constant offset
               (goto-char containing-sexp)
               (+ (current-column) lisp-indent-offset))
              ;; in this case calculate-lisp-indent-last-sexp is not nil
              (calculate-lisp-indent-last-sexp
               (or
                ;; try to align the parameters of a known function
                (and lisp-indent-function
                     (not retry)
                     (funcall lisp-indent-function indent-point state))
                ;; If the function has no special alignment
                ;; or it does not apply to this argument,
                ;; try to align a constant-symbol under the last
                ;; preceding constant symbol, if there is such one of
                ;; the last 2 preceding symbols, in the previous
                ;; uncommented line.
                (and (save-excursion
                       (goto-char indent-point)
                       (skip-chars-forward " \t")
                       (looking-at ":"))
                     ;; The last sexp may not be at the indentation
                     ;; where it begins, so find that one, instead.
                     (save-excursion
                       (goto-char calculate-lisp-indent-last-sexp)
                       ;; Handle prefix characters and whitespace
                       ;; following an open paren.  (Bug#1012)
                       (backward-prefix-chars)
                       (while (not (or (looking-back "^[ \t]*\\|([ \t]+"
                                                     (line-beginning-position))
                                       (and containing-sexp
                                            (>= (1+ containing-sexp) (point)))))
                         (forward-sexp -1)
                         (backward-prefix-chars))
                       (setq calculate-lisp-indent-last-sexp (point)))
                     (> calculate-lisp-indent-last-sexp
                        (save-excursion
                          (goto-char (1+ containing-sexp))
                          (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
                          (point)))
                     (let ((parse-sexp-ignore-comments t)
                           indent)
                       (goto-char calculate-lisp-indent-last-sexp)
                       (or (and (looking-at ":")
                                (setq indent (current-column)))
                           (and (< (line-beginning-position)
                                   (prog2 (backward-sexp) (point)))
                                (looking-at ":")
                                (setq indent (current-column))))
                       indent))
                ;; another symbols or constants not preceded by a constant
                ;; as defined above.
                normal-indent))
              ;; in this case calculate-lisp-indent-last-sexp is nil
              (desired-indent)
              (t
               normal-indent))))))
#+end_src

****** ppp
:PROPERTIES:
:ID:       82dbb88a-4bce-4ca3-90fe-38cfbea7abc6
:END:

This is a pretty printer.

Sometimes you want to see what an object looks like represented as text so you
know what you're dealing with. For example, I've wanted to see what a straight
recipe looks like. The problem is by default [[][]] prints something on one
line. And to avoid long lines, emacs truncates the output so you can't even see
the whole thing.

#+begin_src emacs-lisp
(use-package! ppp)
#+end_src

****** elisp-demos
:PROPERTIES:
:ID:       2c419004-a7c1-4de5-bada-8420505cea90
:END:

#+begin_src emacs-lisp
(use-package! elisp-demos
  ;; :xl-advice (helpful-update :after #'elisp-demos-advice-helpful-update)
  )
#+end_src

****** elisp snippets
:PROPERTIES:
:ID:       bbb2299f-6960-43c2-bf1d-b849ef8ecff0
:END:

******* defvar
:PROPERTIES:
:ID:       bbbba4d9-a2f4-47b1-8447-082f8ea4cf86
:END:

#+begin_src emacs-lisp
(defsnippet! defvar ("dvar" emacs-lisp-mode)
  "Insert a defvar expression."
  '("(defvar " (p "var" varname) " " (p "initial-value" value)
    n> "\"" (p "docstring" docstring) "\"" ")"))
#+end_src

******* defun
:PROPERTIES:
:ID:       3fdb199e-b76e-41ea-85fb-4f62c398453d
:END:

#+begin_src emacs-lisp
(defsnippet! defun ("defn" emacs-lisp-mode)
  "Insert a defun form"
  '("(defun " (p "name" name) " " "(" (p "args" it) ")"
    n> "\"" (p "docstring" docstring) "\""
    n> (p "body" body)
    ")" (p "")))
#+end_src

******* when
:PROPERTIES:
:ID:       8eb34ddf-ae81-42dd-bf7a-4be9562ceae5
:END:

#+begin_src emacs-lisp
(defsnippet! when ("when" emacs-lisp-mode)
  "Insert a when expression"
  '("(when " (p "condition" condition) n> (r "body" body) ")" (p "" last)))
#+end_src

**** org
:PROPERTIES:
:ID:       63748940-c1b9-47ea-b1ce-d6519453ad03
:END:

***** init
:PROPERTIES:
:ID:       6d08d180-5b96-4f1f-98f9-53086c13561a
:END:

****** define capture file
:PROPERTIES:
:ID:       97a3bb5a-f485-45d0-a7f4-4bdd3963a16b
:END:

#+begin_src emacs-lisp
(defun xl-capture-file ()
  "Return the file where org should capture to."
  (xl-org-dir "capture.org"))
#+end_src

****** general settings
:PROPERTIES:
:ID:       b0aa3f0b-876a-4527-b8ba-4fdac5e7ebe8
:END:

#+begin_src emacs-lisp
(use-package! org
  :xl-set
  (org-directory                      . (xl-org-dir))
  (org-archive-location               . (xl-org-dir "archive.org::"))
  (org-default-notes-file             . (xl-org-dir "notes.org"))
  (org-fontify-emphasized-text        . t)
  (org-hide-emphasis-markers          . t)
  (org-pretty-entities                . t)
  (org-fontify-whole-heading-line     . t)
  (org-fontify-done-headline          . t)
  (org-fontify-quote-and-verse-blocks . t)
  (org-adapt-indentation              . nil)
  (org-cycle-separator-lines          . 2)
  (outline-blank-line                 . t)
  (org-enforce-todo-dependencies      . t)
  (org-use-fast-tag-selection         . nil)
  (org-tags-column                    . -80)
  (org-tag-alist                      . nil)
  (org-log-done                       . 'time))
#+end_src

****** org-version
:PROPERTIES:
:ID:       0b2cfe2b-a75c-48ea-9470-19c92521e2cf
:END:

#+begin_src emacs-lisp
(advice-add #'org-version :override (-const "10"))
#+end_src

***** customization
:PROPERTIES:
:ID:       3f0570f0-436b-4a53-92c4-52b06ae26a15
:END:

****** bindings
:PROPERTIES:
:ID:       4ca3fe54-54b1-47ca-90f1-a14b3df1cc59
:END:

Org mode demands its own editing.

******* navigation
:PROPERTIES:
:ID:       25a91495-073d-4557-8407-49ea63f13383
:END:

#+begin_src emacs-lisp
(define-key! 'normal org-mode-map
  "j" #'org/dwim-next-line
  "k" #'org/dwim-previous-line)
#+end_src

******* org mode local bindings
:PROPERTIES:
:ID:       a950d732-b0d2-46b9-82ce-1b9a474e7d76
:END:

#+begin_src emacs-lisp
(define-localleader-key!
  :keymaps 'org-mode-map
  "o" (list :def #'outorg-edit-as-org         :wk "edit as org")
  "w" (list :def #'widen                      :wk "widen")
  "n" (list :def #'org-narrow-to-subtree      :wk "narrow")
  "k" (list :def #'org-cut-subtree            :wk "cut subtree")
  "c" (list :def #'org-copy-subtree           :wk "copy subtree")
  "r" (list :def #'org-refile                 :wk "refile")
  "j" (list :def #'org/avy-goto-headline      :wk "jump to headline")
  "E" (list :def #'org-babel-execute-subtree  :wk "execute subtree")
  "d" (list :def #'org/dwim-edit-description  :wk "edit description")
  "e" (list :def #'org/dwim-edit-source-block :wk "edit source block")
  "," (list :def #'org/dwim-edit-source-block :wk "edit source block"))
#+end_src

******* generic org bindings
:PROPERTIES:
:ID:       583bd7ac-64e0-48ea-bd75-5b6a20f2deae
:END:

Org mode just does not lend itself to typical evil bindings. These bindings are
much more useful considering the specific structure of org mode documents.

#+begin_src emacs-lisp
(general-def 'normal org-mode-map
  "E" #'org/dwim-eval-block
  "e" #'org/dwim-eval-block
  "b" #'org/dwim-insert-elisp-block
  "o" #'org/insert-heading-below
  "O" #'org/insert-heading-above
  "h" #'org-up-heading-safe
  "l" #'org-do-demote
  "H" #'org-promote-subtree
  "S" #'org-demote-subtree
  ">" #'org-shiftmetaright
  "<" #'org-shiftmetaleft
  "t" #'org-set-tags-command
  "r" #'org-capture
  "s" #'org/dwim-edit-source-block
  "R" #'org-refile
  "T" #'org-todo
  "D" #'org-cut-subtree
  "Y" #'org-copy-subtree
  "K" #'org-metaup
  "J" #'org-metadown)
#+end_src

******* bindings
:PROPERTIES:
:ID:       3f4144ee-a780-478e-a1ad-47591f181ff3
:END:

#+begin_src emacs-lisp
(define-key! '(normal) org-mode-map
  ;; Doesn't work for some reason -> "TAB" #'outline-toggle-children
  "D" #'org-cut-subtree
  "P" #'org-paste-subtree)

(define-key! [remap org-cycle] #'outline-toggle-children)
#+end_src

****** custom commands
:PROPERTIES:
:ID:       4dfeccc9-f12e-4449-a5fe-17541070b40e
:END:

******* goto start of heading
:PROPERTIES:
:ID:       0431e49f-ef6b-4edb-854c-6427479e5ee2
:END:

#+begin_src emacs-lisp
(defun org:heading-goto-start ()
  "Go to the end of headline."
  (save-match-data
    (beginning-of-line)
    (when (looking-at (rx (1+ "*")))
      (goto-char (1- (match-end 0))))))
#+end_src

******* do the right thing after jumping to headline
:PROPERTIES:
:ID:       2ca61454-a0ca-47b3-8622-91d7969653da
:END:

When I search for a headline with [[helpfn:void/goto-line][xl/goto-line]] or [[helpfn:void/goto-headline][xl/goto-headline]] or even their
counsel equivalents, the proper headlines aren't automatically revealed.

[[screenshot:][This]] is what headline structure looks after using counsel/ivy's [[helpfn:swiper][swiper]] to find
the word =xl/goto-line= in my emacs. You can see that only the headline that has
the target word is revealed but it's parents are (akwardly) hidden. I never want
headlines to be unfolded like this.

******** show branch
:PROPERTIES:
:ID:       d95fab52-7d8f-439f-9221-188490f4ad5f
:END:

This shows all headlines that make up the branch of the current headine and
their children. This is the typical behavior you would expect in any outlining
program.

#+begin_src emacs-lisp
(defun org:show-branch ()
  "Reveal the current org branch.
Show all of the current headine's parents and their children. This includes this
headline."
  (loopy (before-do (org-back-to-heading t))
         ((while (org-up-heading-safe))
          (collect points (point)))
         (finally-do
          (--each-r points
            (goto-char it)
            (outline-show-children)
            (outline-show-entry)))))
#+end_src

******** show branch after jumping to point
:PROPERTIES:
:ID:       251e5df0-0a7d-4bf9-8fd9-69991d89a074
:END:

Note that I use points to store the heading points and go back to them inreverse
order. This is important because org does not unfold headlines properly if you
start from an invisible subheading.

Notably, I do not try to conserve the return value of =xl/goto-line= or
=xl/jump-to-headline= because these functions are and should only be used for
their side-effects.

#+begin_src emacs-lisp
(defadvice! show-current-branch-in-org-mode (:after xl/goto-line org/goto-headline)
  "Properly unfold nearby headlines and reveal current headline."
  (when (eq major-mode 'org-mode)
    (org:show-branch)))
#+end_src

******* return
:PROPERTIES:
:ID:       8314f2e0-da63-4f2f-ad89-b97987ca5843
:END:

#+begin_src emacs-lisp
(defun org/dwim-return ()
  "Do what I mean."
  (interactive)
  (cond ((org-at-heading-p)
         (org/insert-heading-below))
        (t
         (call-interactively #'org-return))))
#+end_src

******** next-line
:PROPERTIES:
:ID: d8d118a7-78e8-4602-81b3-17fd1d8ab79c
:END:

#+begin_src emacs-lisp
(defun org/dwim-next-line (&optional backward)
  "Go to the start of the next heading.
If DIR is a negative integer, go the opposite direction: the start of the
  previous heading."
  (interactive)
  (outline-next-visible-heading (if backward -1 1))
  (when (org-at-heading-p)
    (org:heading-goto-start)))
#+end_src

******* navigation
:PROPERTIES:
:ID:       3d9ea885-e679-46e5-9541-dea0436d05ec
:END:

******** next-line
:PROPERTIES:
:ID: d8d118a7-78e8-4602-81b3-17fd1d8ab79c
:END:

#+begin_src emacs-lisp
(defun org/dwim-next-line (&optional backward)
  "Go to the start of the next heading.
If DIR is a negative integer, go the opposite direction: the start of the
  previous heading."
  (interactive)
  (outline-next-visible-heading (if backward -1 1))
  (when (org-at-heading-p)
    (org:heading-goto-start)))
#+end_src

******** previous-line
:PROPERTIES:
:ID: e7562921-77ca-4d90-be57-1d586ec26ee5
:END:

#+begin_src emacs-lisp
(defun org/dwim-previous-line (&optional forward)
  (interactive)
  (funcall #'org/dwim-next-line (not forward)))
#+end_src

******* inserting
:PROPERTIES:
:ID: e99abeff-328b-48e4-aebb-00db34fa98e8
:END:

In my eyes, many Org functions are unnecessarily complicated and long. Often they
need to perform a simple task (like inserting a heading) but lose their
fundamental purpose in their inclusion of numerous obscure and opinionated
options. For this reason I wrote my own insert heading functions.

******** newlines between headings
:PROPERTIES:
:ID: e0dcf718-120c-488d-9d37-96243132bf0b
:END:

#+begin_src emacs-lisp
(defvar org:newlines-between-headings "\n\n"
  "Number of newlines between headings.")
#+end_src

******** heading above
:PROPERTIES:
:ID: 6c227dea-e10b-4f86-a01b-5d223d18e3a4
:END:

#+begin_src emacs-lisp
(defun org/insert-heading-above (&optional below)
  "Insert a heading above the current heading."
  (interactive)
  (funcall #'org/insert-heading-below (not below)))
#+end_src

******** heading below
:PROPERTIES:
:ID: b059a431-e29c-4f2c-ab5e-8d2d02636405
:END:

#+begin_src emacs-lisp
(defun org/insert-heading-below (&optional above)
  "Insert heading below."
  (interactive)
  (let* ((on-heading-p (ignore-errors (org-back-to-heading)))
         (newlines org:newlines-between-headings)
         (level (or (org-current-level) 1))
         (heading (concat (make-string level ?*) "\s")))
    (cond ((not on-heading-p)
           (insert heading))
          (above
           (goto-char (line-beginning-position))
           (insert heading)
           (save-excursion (insert newlines)))
          (t ; below
           (org-end-of-subtree)
           (insert (concat newlines heading))))
    (run-hooks 'org-insert-heading-hook)))
#+end_src

******** subheading
:PROPERTIES:
:ID: cf910dcf-6250-4b6a-80d5-63ac457d4a81
:END:

#+begin_src emacs-lisp
(defun org/insert-subheading ()
  "Insert subheading below current heading."
  (interactive)
  (org/insert-heading-below)
  (org-demote))
#+end_src

******** elisp block
:PROPERTIES:
:ID:       e03149e3-500f-45d6-a4c1-b2f69947b4d5
:END:

#+begin_src emacs-lisp
(defun org/dwim-insert-elisp-block ()
  "Insert elisp block."
  (interactive)
  (save-excursion
    (unless (org-at-heading-p)
      (org-back-to-heading))
    (org-end-of-subtree)
    (goto-char (line-end-position))
    (insert (concat "\n\n"
                    "#+begin_src emacs-lisp"
                    "\n"
                    "#+end_src"))
    (forward-line -1)))
#+end_src

******* org choose tags
:PROPERTIES:
:ID:       b8b0c3a2-2cdc-424f-9cd6-ef3ad3d1512c
:END:

#+begin_src emacs-lisp
(defun org/choose-tags ()
  "Select tags to add to headline."
  (interactive)
  (let* ((current (org-get-tags (point)))
         (selected (->> (org-get-buffer-tags)
                        (completing-read-multiple "Select org tag(s): "))))
    (alet (-distinct (append (-difference current selected)
                             (-difference selected current)))
      (org-set-tags it))))
#+end_src

******* eval
:PROPERTIES:
:ID: e804805a-ba96-41d0-aa6f-6756c65e9abf
:END:

#+begin_src emacs-lisp
(defun org/dwim-eval-block ()
  "Eval block contents."
  (interactive)
  (unless (org-at-heading-p)
    (user-error "Not in source block"))
  (save-window-excursion
    (org-babel-execute-subtree)))
#+end_src

***** links
:PROPERTIES:
:ID:       f70f36ae-1ef1-4dce-ad84-e4a8430f40a5
:END:

****** link snippets
:PROPERTIES:
:ID:       fd297eb5-e7b0-4dd5-b9f4-6d76f1426ade
:END:

This headline contains various snippets that help me insert org links quickly
and painlessly.

******* helpvar
:PROPERTIES:
:ID:       cc0ae97d-4cce-42de-bea0-7e195bd6168b
:END:

#+begin_src emacs-lisp
(defsnippet! helpvar ("hvar" org-mode)
  "Help function link."
  `("[[helpvar:" (C var "variable: " ,obarray helpful--variable-p) "][" (s var) "]]"))
#+end_src

******* helpfn
:PROPERTIES:
:ID:       7bd2651e-e3f8-4e76-822c-2208b71af0c3
:END:

#+begin_src emacs-lisp
(defsnippet! helpfn ("hfn" org-mode)
  "Help function link."
  '("[[helpfn:" (C fn "function: " help--symbol-completion-table) "][" (s fn) "]]"))
#+end_src

****** org-super-links
:PROPERTIES:
:ID:       f3eed884-408f-44cb-becc-17c1431060c5
:END:

#+begin_src emacs-lisp
(use-package! org-superlinks
  :xl-ensure
  (:host github :type git :repo "toshism/org-super-links")
  :commands org-super-links-link
  :xl-set
  (org-super-links-backlink-prefix      . nil)
  (org-super-links-related-into-drawer  . "LINKS")
  (org-super-links-backlink-into-drawer . "LINKS"))
#+end_src

****** org-link-minor-mode
:PROPERTIES:
:ID:       25b93a1f-b105-47aa-9647-5015d23a4ac3
:END:

This is a minor mode for displaying links in non-org buffers.

#+begin_src emacs-lisp
(use-package! org-link-minor-mode
  :xl-hook outshine-mode-hook)
#+end_src

***** org-todo-keywords
:PROPERTIES:
:ID:       aaa98680-d9b4-4726-b3ba-a50b3442e8e8
:END:

I like the terms "issue" and "closed" because they are more general than the
corresponding "todo" and "done". "Issue" simply implies a problem that needs to
be fixed. When I use =todo= I feel obligated to write what I have to do and
often I don't know that. Who knows? It could even be that nothing needs to be
done.

#+begin_src emacs-lisp
(set! org-todo-keywords
      '((sequence "ISSUE" "CLOSED")
	(sequence "TODO" "DONE")))
#+end_src

***** org-ml
:PROPERTIES:
:ID:       7f3ec0ad-45f8-4100-970e-773cfb9a625b
:END:

#+begin_src emacs-lisp
(use-package! org-ml)
#+end_src

***** org-journal
:PROPERTIES:
:ID:       c3056303-5fa1-49f9-ae2d-294942e25f54
:END:

=org-journal= is a package that provides functions to maintain a simple
diary/journal using =org-mode=.

#+begin_src emacs-lisp
(use-package! org-journal
  :commands org-journal-new-entry
  :xl-set
  (org-journal-file-type . 'yearly)
  (org-journal-find-file . 'find-file)
  (org-journal-dir       . (concat org-directory "journal/")))
#+end_src

***** org-src
:PROPERTIES:
:ID:       e00378a1-adcf-4e83-8533-b6b442b5f362
:END:

#+begin_src emacs-lisp
(use-feature! org-src
  :xl-idle-require t
  :xl-rule ("bottom" "org source" :newfile "\\*Org Src")
  :xl-set
  (org-src-ask-before-returning-to-edit-buffer . nil)
  (org-edit-src-persistent-message             . nil)
  (org-src-preserve-indentation                . t)
  (org-confirm-babel-evaluate                  . nil)
  (org-src-tab-acts-natively                   . t)
  (org-src-fontify-natively                    . t)
  (org-babel-default-header-args . '((:session . "none")
				     (:results . "silent")
				     (:exports . "code")
				     (:cache   .   "no")
				     (:initeb  .  "no")
				     (:hlines  .  "no")
				     (:tangle  .  "yes"))))
#+end_src

****** bindings in source block
:PROPERTIES:
:ID:       df270638-f6a7-4f0e-abe7-dd0c4e7df7ce
:END:

Note that you should have bindings that are different for entering and exiting
source blocks.

#+begin_src emacs-lisp
(defhook! enable-org-exit-src-bindings (org-src-mode-hook)
  (define-localleader-key!
    "," (list :def #'org-edit-src-exit  :wk "exit source block")
    "a" (list :def #'org-edit-src-abort :wk "abort source block")
    "c" (list :def #'org-edit-src-exit  :wk "exit source block")))
#+end_src

***** org-capture
:PROPERTIES:
:ID:       3225bbc4-9685-4e7b-ae32-41a26780d191
:END:

=org-capture= is a feature that allows you to quickly save a thought that popped
into your head while keeing disctractions to a minimum.

****** init
:PROPERTIES:
:ID:       8fc5d248-ff21-45e4-a48b-57cecd57b7a3
:END:

#+begin_src emacs-lisp
(use-feature! org-capture
  :xl-idle-require t
  :xl-before-call
  (ts     . org-capture)
  (org-ml . org-capture)
  :xl-rule ("bottom" "capture" :newname "\\`CAPTURE-.+")
  :xl-config
  (after! evil (xl-add-hook 'org-capture-mode-hook #'evil-insert-state))
  :init
  (after! org-agenda (push (xl-capture-file) org-agenda-files)))
#+end_src

****** remove capture headerline
:PROPERTIES:
:ID: 7b8a8e1d-3c72-492f-9311-56a2428a1f1d
:END:

By default org capture templates display a header line. This was the answer to [[https://emacs.stackexchange.com/questions/53648/eliminate-org-capture-message][my
question]]. I need to disable =org-capture's= header-line.

#+begin_src emacs-lisp
(defhook! disable-header-line (org-capture-mode-hook)
  "Turn of the header line message."
  (setq-local header-line-format nil))
#+end_src

****** prevent capture templates from deleting windows
:PROPERTIES:
:ID:       a13e330a-33ff-4c1e-add4-00c5db4e6cd1
:END:

=org-capture= deletes all the other windows in the frame.

#+begin_src emacs-lisp
(defadvice! dont-delete-other-windows (:around org-capture-place-template)
  "Don't delete other windows when opening a capture template."
  (cl-letf (((symbol-function #'delete-other-windows) #'ignore))
    (apply <orig-fn> <args>)))
#+end_src

****** make templates follow popup rules
:PROPERTIES:
:ID:       d1fafcb4-dcaf-4ba0-835d-cb12acb8e445
:END:

[[helpfn:org-capture-place-template][org-capture-place-template]] is what's responsible for displaying the org capture
buffer. We need to try to make it use display buffer.

#+begin_src emacs-lisp
(defadvice! use-display-buffer (:around org-switch-to-buffer-other-window)
  ())
#+end_src

****** doct
:PROPERTIES:
:ID:       fa37f618-b58c-449b-a216-9d2f80ed12c6
:END:

[[https://github.com/progfolio/doct][doct]] is a package designed to ease writing and understanding capture templates
by allowing you to write them in a declarative style (see [[helpfn:doct][doct docstring]]).
In org mode, capture templates are [[info:org#Capture templates][represented as plain lists]]. This makes
it easy to forget what a certain element meant or to accidentally omit a capture
template element as you're writing it.

******* init
:PROPERTIES:
:ID:       0118ba87-219b-4611-9743-19228accaa2c
:END:

#+begin_src emacs-lisp
(use-package! doct
  :xl-before-call org-capture)
#+end_src

******* add to capture templates
:PROPERTIES:
:ID:       16c55272-f8c2-4798-9da1-2ab492769f44
:END:

[[helpfn:doct][doct]] returns the new value of capture templates. but it does not actually add
it. For convenience this function declare it and add it in all in one go.
Additionally, it removes any capture templates with the same key so that I can
freely re-evaluate it without cluttering my capture templates with duplicate
entries.

#+begin_src emacs-lisp
(defun doct:add-to-templates (declarations)
  "Set `org-capture-templates' to the result of (doct DECLARATIONS).
Before adding result, remove any members of `org-capture-templates' with the
same key as the one(s) being added."
  (cl-labels ((clean (templates)
                     (when templates
                       (cons (car templates)
                             (--remove (string= (caar templates) (car it))
                                       (clean (cdr templates)))))))
    (setq org-capture-templates
          (clean (-concat (doct declarations) org-capture-templates)))))
#+end_src

****** capture templates
:PROPERTIES:
:ID:       a2a3f682-322a-450f-91bf-169d90f040c0
:END:

******* issue
:PROPERTIES:
:ID:       ef103d28-b746-42ba-ac1a-0462a19f03cd
:END:

******** issue capture template string
:PROPERTIES:
:ID:       a58f1de7-2049-4195-abfb-daad93a6ff2a
:END:

Instead of passing in the string I use =org-ml= to print the string.

#+begin_src emacs-lisp
(defun org-capture:issue-template ()
  "Return capture template for an issue."
  (->> (org-ml-build-headline! :title-text "%?")
       (org-ml-headline-set-node-property "ID" (org-id-new))
       (org-ml-headline-set-node-property "CREATED" (ts-format))
       (org-ml-set-property :todo-keyword "ISSUE")
       (org-ml-to-trimmed-string)))
#+end_src

******** issue
:PROPERTIES:
:ID:       2682910c-9620-4cbf-ab71-371ed29e25a1
:END:

#+begin_src emacs-lisp
(after! org-capture
  (doct:add-to-templates
   (list "issue"
	 :keys "i"
	 :template #'org-capture:issue-template
	 :file (xl-capture-file)
	 :prepend t
	 :empty-lines 1)))
#+end_src

***** org-clock
:PROPERTIES:
:ID:       d378471c-89df-48c9-a755-b79880f27308
:END:

=org-clock= is a built-in package that provides time logging functions for
tracking the time you spend on a particular task.

#+begin_src emacs-lisp
(use-feature! org-clock
  :xl-idle-require t
  :commands org-clock-in org-clock-goto
  :xl-hook (kill-emacs-hook . org-clock-save)
  :xl-set
  (org-clock-persist      . 'history)
  (org-clock-persist-file . (concat XL-DATA-DIR "org-clock-save.el"))
  (org-clock-in-resume    . t)
  :xl-config
  (org-clock-persistence-insinuate))
#+end_src

***** org-agenda
:PROPERTIES:
:ID:       389bcdde-e2fb-401d-b4ec-47c73c8cf545
:END:

For any todo workflow, having a way to get an overview of the essential tasks
for a certain block of time is a must. =org-agenda= is this overview.

****** org-agenda
:PROPERTIES:
:ID:       efa9d237-b055-4bfb-a1f9-86d964b5f007
:END:

#+begin_src emacs-lisp
(use-feature! org-agenda
  :xl-idle-require t
  :xl-rule ("left" "org agenda" :newname "\\*Org Agenda\\*")
  :xl-gc-pause org-agenda-list
  :xl-set
  (org-agenda-text-search-extra-files . '(agenda-archives))
  (org-agenda-skip-unavailable-files  . t)
  (org-agenda-files                   . nil)
  (org-agenda-start-on-weekday        . 0)
  (org-agenda-timegrid-use-ampm       . nil)
  (org-agenda-time-leading-zero       . t)
  (org-agenda-dim-blocked-tasks       . t)
  (org-agenda-inhibit-startup         . t))
#+end_src

****** respect display-buffer
:PROPERTIES:
:ID:       50933d82-1208-481d-8dc7-42630f3f3b41
:END:

=org= functions are known to try to configure buffer displays themselves. This
forces agenda view to rely on [[helpvar:display-buffer-alist][display-buffer-alist]] for it's display.

#+begin_src emacs-lisp
(defadvice! use-display-buffer (:override (abuf filter-alist) org-agenda-prepare-window)
  "Use `display-buffer' to display the agenda buffer.
Unlike `org-agenda-prepare-window', this function does not store the window configuration."
  (display-buffer abuf)
  (setq org-agenda-tag-filter (cdr (assq 'tag filter-alist)))
  (setq org-agenda-category-filter (cdr (assq 'cat filter-alist)))
  (setq org-agenda-effort-filter (cdr (assq 'effort filter-alist)))
  (setq org-agenda-regexp-filter (cdr (assq 're filter-alist)))

  (unless (equal (current-buffer) abuf)
    (pop-to-buffer-same-window abuf)))
#+end_src

****** org-super-agenda
:PROPERTIES:
:ID:       d708a7e8-0c24-4b1d-b57b-7ebd91a3ae05
:END:

=org-super-agenda= provides a powerful and convenient way to organize how the
org agenda buffer is displayed.

******* org-super-agenda
:PROPERTIES:
:ID:       e1fdf658-1fe4-40d5-9dbf-626a39f7d2ae
:END:

#+begin_src emacs-lisp
(use-package! org-super-agenda
  :xl-before-call org-agenda-list
  :xl-config
  (org-super-agenda-mode))
#+end_src

******* top five overdue entries
:PROPERTIES:
:ID:       9c825b83-057e-4373-9256-047e3d09f693
:END:

***** org-refile
:PROPERTIES:
:ID:       6dfc0415-2945-4259-a782-b569fcb397ea
:END:

#+begin_src emacs-lisp
(use-feature! org-refile
  :xl-idle-require t
  :xl-set
  (org-refile-targets                     . nil)
  (org-refile-use-outline-path            . 'file)
  (org-refile-allow-creating-parent-nodes . t)
  (org-reverse-note-order                 . t)
  (org-outline-path-complete-in-steps     . nil))
#+end_src

***** org-id
:PROPERTIES:
:ID:       95f2a096-2cf4-4634-aa32-13f00b31ea19
:END:

=org-id= is a built-in package that creates that provides tools for creating and
storing universally unique IDs. This is primarily used to disguish and
referenance org headlines.

#+begin_src emacs-lisp
(use-feature! org-id
  :xl-idle-require t
  :xl-hook (org-insert-heading-hook . org-id-get-create)
  :xl-set
  (org-id-locations-file-relative . t)
  (org-id-link-to-org-use-id      . 'create-if-interactive-and-no-custom-id)
  (org-id-locations-file          . (xl-data-dir "org-id-locations"))
  (org-id-files                   . (list XL-MAIN-ORG-FILE)))
#+end_src

***** org-superstar
:PROPERTIES:
:ID:       c4428756-a804-47e8-9586-f63b82dd1561
:END:

#+begin_src emacs-lisp
(use-package! org-superstar
  :xl-hook org-mode-hook
  :xl-set
  (org-superstar-leading-bullet     . ?\s)
  (org-superstar-special-todo-items . t))
#+end_src

***** org-fancy-priorities
:PROPERTIES:
:ID:       c4ff4407-774c-4028-bb9d-01412fdfc8d2
:END:

#+begin_src emacs-lisp
(use-package! org-fancy-priorities
  :xl-hook org-mode-hook)
#+end_src

***** org mode snippets
:PROPERTIES:
:ID:       cd25f425-a4db-4a4c-be9e-4b672116048c
:END:

****** helpvar
:PROPERTIES:
:ID:       cc0ae97d-4cce-42de-bea0-7e195bd6168b
:END:

#+begin_src emacs-lisp
(defsnippet! helpvar ("hvar" org-mode)
  "Help function link."
  `("[[helpvar:" (C var "variable: " ,obarray helpful--variable-p) "][" (s var) "]]"))
#+end_src

****** helpfn
:PROPERTIES:
:ID:       7bd2651e-e3f8-4e76-822c-2208b71af0c3
:END:

#+begin_src emacs-lisp
(defsnippet! helpfn ("hfn" org-mode)
  "Help function link."
  '("[[helpfn:" (C fn "function: " help--symbol-completion-table) "][" (s fn) "]]"))
#+end_src

****** ids
:PROPERTIES:
:ID:       532aa739-3a53-4339-8121-fb9dce2dd914
:END:

#+begin_src emacs-lisp
(defsnippet! id-link ("scrot" org-mode)
  "Id link."
  '("[[" (C fn "id: " ()) "][" "hello" "]]"))
#+end_src

****** screenshot
:PROPERTIES:
:ID:       a9efb825-33f4-43d6-8240-ac3f17f10fcf
:END:

This snippet provides me with a convenient way to add links of screenshots I
have taken.

#+begin_src emacs-lisp
(defsnippet! screenshot-link ("scrot" org-mode)
  "Screenshot link."
  '("[[" (C fn "screenshots: " (xl-screenshots)) "][" "hello" "]]"))

(defun xl-screenshots ()
  "Return a list of all screenshots."
  (cddr (directory-files (xl-screenshot-dir))))
#+end_src

***** org-tanglesync
:PROPERTIES:
:ID:       f6282ee4-a4b5-4cec-b275-947655516583
:END:

#+begin_src emacs-lisp
(use-package! org-tanglesync
  :xl-set
  (org-tanglesync-watch-files . (-map #'expand-file-name '("~/README.org"))))
#+end_src

*** Asthetic
:PROPERTIES:
:ID: bd21a69a-794c-4ff1-97d0-9e5911a26ad7
:END:

It's easy to underestimate how much of a difference having an asthetically
pleasing Emacs configuration can have. Ugliness really can take its toll.

**** text scaling
:PROPERTIES:
:ID:       5d242d0e-eeab-46de-bcee-ecfd79b2bffc
:END:

I change the text scale frequently because in some cases, such as viewing my
main org file, I want a birds-eye view where I can see the structure of a
document at a glance. However, when I'm doing something like editing a source
block I want to focus on a very specific thing totally; therefore, I want the
text to take up most of the screen.

***** zoom-frm
:PROPERTIES:
:ID:       15b8577e-3f98-420a-81a5-c7b91292aca3
:END:

This package increases or decreases the font of the current frame. It differs
from [[helpfn:text-scale-increase][text-scale-increase]] and [[helpfn:text-scale-decrease][text-scale-decrease]] in that it applies this
"zooming" to the whole frame instead of the current buffer.

#+begin_src emacs-lisp
(use-package! zoom-frm
  :xl-set
  (frame-zoom-font-difference . 0.5)
  (zoom-frame/buffer          . 'buffer))
#+end_src

**** mini-modeline
:PROPERTIES:
:ID:       51768ba1-170f-497b-9479-541e7c6aadd6
:END:

***** setup
:PROPERTIES:
:ID:       d9acb47b-089f-4b18-8fdd-94ffefb2ef86
:END:

These variables do stuff with displaying lines and separators to make the
modeline more visible. I do that myself with =window-divider= so I don't need
this.

#+begin_src emacs-lisp
(use-package! mini-modeline
  :demand t
  :xl-hook (emacs-startup-hook . mini-modeline-mode)
  :xl-set
  (mini-modeline-enhance-visual . nil)
  (mini-modeline-display-gui-line . nil))
#+end_src

***** default face
:PROPERTIES:
:ID:       1aab03cd-83b2-4d3a-bf3b-71f52dc6158d
:END:

If you don't set this, mini-modeline's background color won't
update with the theme. This is probably what the default value of this
variable should be anyway.

#+begin_src emacs-lisp
(use-package! mini-modeline
  :xl-set
  (mini-modeline-face-attr . '(:inherit default)))
#+end_src

***** left format
:PROPERTIES:
:ID:       a7d11a8b-e792-43e5-9992-10df562e17ea
:END:

#+begin_src emacs-lisp
(setq mini-modeline-l-format
      '("%e" mode-line-buffer-identification))
#+end_src

***** right format
:PROPERTIES:
:ID:       fd79e9cb-40d7-4320-9b1d-248da4330bca
:END:

#+begin_src emacs-lisp
(setq mini-modeline-r-format
      '("%e"
	(:eval (awhen (mini-modeline:display-current-workgroup)
		(concat it " ")))
	(:eval (format-time-string "%a %m/%d %T"))))
#+end_src

***** set the modeline display
:PROPERTIES:
:ID:       37f062a8-b9d9-4533-ba8e-d675a1d5f10a
:END:

#+begin_src emacs-lisp
(defun mini-modeline:display-current-workgroup ()
  "Return the name of the current workgroup."
  (awhen (and (featurep 'workgroups2)
	      (wg-workgroup-name (wg-current-workgroup)))
    it))
#+end_src

***** dont redisplay
:PROPERTIES:
:ID:       b3afd056-7b0a-485f-8691-5cc7e4765ca1
:END:

Enabling =mini-modeline-mode= triggers a call to [[helpfn:redisplay][redisplay]]. During startup, this
takes a long time and makes emacs unresponsive for a few seconds. This redisplay
does not seem to be needed (feebleline doesn't do it and it works fine).

#+begin_src emacs-lisp
(defadvice! dont-redisplay (:around mini-modeline-mode)
  (cl-letf (((symbol-function #'redisplay) #'ignore))
    (apply <orig-fn> <args>)))
#+end_src

**** info
:PROPERTIES:
:ID:       d49f83c4-ba8f-477e-beef-8156ed8b974b
:END:

This headline is for customizing info nodes.

#+begin_src emacs-lisp
(use-feature! info
  :xl-rule ("top" "info" :newname "\\*info"))
#+end_src

**** helpful
:PROPERTIES:
:ID:       5340ddb3-92bc-42e5-bf0e-9f9650c41cd9
:END:

[[github:wilfred/helpful][helpful]] provides a complete replacement for the built-in
Emacs help facility which provides much more contextual information
in a better format.

#+begin_src emacs-lisp
(use-package! helpful
  :xl-rule ("bottom" "help" :newname "\\*help.+")
  :general
  ([remap describe-function] #'helpful-callable
   [remap describe-command]  #'helpful-command
   [remap describe-variable] #'helpful-variable
   [remap describe-key]      #'helpful-key))
#+end_src

**** which-key
:PROPERTIES:
:ID:       2ad092a3-ff63-49cd-91b9-380c91dbe9f5
:END:

Emacs is full of so many keybindings, that it can be difficult to keep track of
them. Especially when you're starting out, but even when you're an Emacs-pro,
it's easy to forget what a particular functionality is bound to. Typically,
you'll remember the first few key strokes but struggle with the rest. To address
this [[github:][which-key]] displays key binding sequences in the minibuffer as your typing
them ([[][]] and [[][]] are screenshots of this in action). By doing this
you can "discover" the commands as you go along.

***** init
:PROPERTIES:
:ID:       c4aedc23-0be3-46fe-b046-32b5f0738c6b
:END:

#+begin_src emacs-lisp
(use-package! which-key
  :xl-hook emacs-startup-hook
  :xl-set
  (which-key-sort-uppercase-first . nil)
  (which-key-max-display-columns  . nil)
  (which-key-add-column-padding   . 1)
  (which-key-min-display-lines    . 6)
  (which-key-side-window-slot     . -10)
  (which-key-sort-order           . #'which-key-prefix-then-key-order)
  (which-key-popup-type           . 'minibuffer)
  (which-key-idle-delay           . 0.8))
#+end_src

***** set line spacing
:PROPERTIES:
:ID:       6abb35f4-c648-4bed-b59a-5a0636857fd8
:END:

#+begin_src emacs-lisp
(defhook! set-line-spacing (which-key-init-buffer-hook)
  (setq line-spacing 3))
#+end_src

***** leader keys
:PROPERTIES:
:ID:       1df41291-32c3-44ca-89a9-f042fb2bbd6c
:END:

#+begin_src emacs-lisp
(use-package! which-key :xl-config
  (which-key-add-key-based-replacements XL-LEADER-KEY "<leader>")
  (which-key-add-key-based-replacements XL-LOCALLEADER-KEY "<localleader>"))
#+end_src

**** dashboard
:PROPERTIES:
:ID: 20926522-b78b-4bca-b70e-9ef4213c4344
:END:

[[https://github.com/emacs-dashboard/emacs-dashboard][dashboard]] is an extensible emacs startup screen. I love the idea of =dashboard=:
having an extensible, fast, nice-looking dashboard when starting emacs is
nice. It's not only nice asthetically, it's also strategic too. First, you can
use it as a launching point to get to your tasks quicker. And second, it doesn't
require any expensive modes. I've often been starting out with the scratch
buffer and I've wanted to have the scratch buffer start off with
=emacs-lisp-mode=, but I don't want it to trigger =company=, =yasnippet=, etc. on
startup. If I start my emacs with =dashboard= I can avoid this.

***** init
:PROPERTIES:
:ID:       de94c9a8-fc05-46ec-ac06-510f1014e02d
:END:

****** random logo
:PROPERTIES:
:ID:       80e5fa17-d18a-4ec0-af8d-728d77843c69
:END:

#+begin_src emacs-lisp
(defun dashboard:random-logo ()
  "Display a random logo."
  (seq-random-elt
   (append '(1 2 3) (if (display-graphic-p) '(official logo)))))
#+end_src

****** require
:PROPERTIES:
:ID:       73d00f99-4b70-44d1-8359-01bd2c94b330
:END:

#+begin_src emacs-lisp
(use-package! dashboard
  :demand t
  :xl-hook (window-setup-hook . dashboard-insert-startupify-lists)
  :xl-set
  (dashboard-items . nil)
  (dashboard-startup-banner . (dashboard:random-logo))
  (dashboard-center-content . t)
  (initial-buffer-choice . #'xl-initial-buffer-choice))
#+end_src

****** open dashboard at startup
:PROPERTIES:
:ID:       1bcc371e-61fa-480e-bdae-4a999d3b10c9
:END:

#+begin_src emacs-lisp
(defadvice! open-dashboard-instead (:around xl-initial-buffer-choice)
  (if xl-debug-p
      (apply <orig-fn> <args>)
    (get-buffer-create "*dashboard*")))
#+end_src

***** dashboard-init-info
:PROPERTIES:
:ID: 92c199ad-5862-4fe3-be04-44c94d4286b6
:END:

[[helpvar:xl-init-time][xl-init-time]] is more accurate than dashboard's init time measure. So I use it
instead.

#+begin_src emacs-lisp
(defadvice! show-package-load-time (:before dashboard-insert-startupify-lists)
  (setq dashboard-init-info
        (format "%d packages loaded in %.2f seconds"
                (cond ((featurep 'straight)
                       (hash-table-size straight--profile-cache))
                      ((featurep 'package) (length package-activated-list))
                      (t 0))
                (string-to-number (emacs-init-time)))))
#+end_src

***** add icons to dashboard
:PROPERTIES:
:ID:       d4714639-919c-4691-9f7f-004cfa627089
:END:

#+begin_src emacs-lisp
#+end_src

**** window divider
:PROPERTIES:
:ID:       2cdd6e24-5153-4585-8f1f-206b33445359
:END:

Emacs can add border to windows using a mode called [[helpfn:window-divider-mode][window-divider-mode]].
Often in emacs you have multiple windows displaying different buffers on the
screen. By default the border between these windows is very thin, so it can be
hard to distinguish windows sometimes. The point of adding borders to windows is
to distinguish them easily from one another.

Window dividers are useful in general so I don't get confused about when one
window ends and another begins (see [[helpfn:window-divider-mode][window-divider-mode]]). When using [[I like emacs][exwm]] it
makes emacs feel like a window manager with gaps.

***** init
:PROPERTIES:
:ID:       c3e2fda8-89c8-4f3b-951a-113e936d6206
:END:

#+begin_src emacs-lisp
(use-feature! window-divider
  :xl-hook (window-setup-hook . window-divider-mode)
  :xl-set
  (window-divider-default-bottom-width . 7)
  (window-divider-default-right-width  . 7)
  (window-divider-default-places       . t))
#+end_src

***** window divider face
:PROPERTIES:
:ID:       61157149-dcce-40a9-8bfa-76a6af24838a
:END:

#+begin_src emacs-lisp
(defhook! set-window-divider-face (load-theme)
  :config window-divider
  (set-face-foreground 'window-divider "black"))
#+end_src

***** update on theme change
:PROPERTIES:
:ID: 342bd557-889b-4dbd-8e76-5cd9da3b0f74
:END:

#+begin_src emacs-lisp
(defhook! update-window-divider (xl-after-load-theme-hook)
  "Ensure window divider persists after theme change."
  :config window-divider
  (unless (bound-and-true-p window-divider-mode)
    (window-divider-mode 1)))
#+end_src

***** adjust window divider gap size
:PROPERTIES:
:ID:       5485c926-fac0-4e87-ae97-f7bf25d0a55c
:END:

****** TODO increase gap size
:PROPERTIES:
:ID:       867fad5c-b4d4-4cba-929e-0dc23f007c5b
:END:

Somtimes I might want to adjust this.

#+begin_src emacs-lisp
(defun +frame-adjust-window-divider-size (amount)
  "Adjust the gap size of window-divider by AMOUNT."
  (general-setq window-divider-default-bottom-width
                (+ amount window-divider-default-bottom-width))
  (general-setq window-divider-default-right-width
                (+ amount window-divider-default-right-width)))
#+end_src

****** increase
:PROPERTIES:
:ID:       ebd6b013-6213-42a1-9e95-fefc7e7da991
:END:

#+begin_src emacs-lisp
(defun frame/increment-window-divider-size ()
  "Increase window divider size."
  (interactive)
  (+frame-adjust-window-divider-size 1))
#+end_src

****** decrease
:PROPERTIES:
:ID:       6b1eb1cd-1cfd-4b82-a413-cb61fa13e0a4
:END:

#+begin_src emacs-lisp
(defun frame/decrement-window-divider-size ()
  "Decrease window divider size."
  (interactive)
  (+frame-adjust-window-divider-size -1))
#+end_src

**** zone
:PROPERTIES:
:ID:       fe176959-3134-4b18-8abb-a962347b8df0
:END:

*** Keybindings
:PROPERTIES:
:ID:       e4605d42-4d57-40d9-8594-15b06f6196a4
:END:

**** execute extended command
:PROPERTIES:
:ID: d8071a32-e58c-41ab-8fd7-7d7732708ee8
:END:

One of the most common--if not the most common--command you use in Emacs is
[[helpfn:execute-extended-command][execute-extended-command]]. This command let's you search any other command and
upon pressing enter, then you execute the command. The fact that this command is
invoked so frequently demands it have one of the shortest, easiest to press
bindings. I chose to give it =SPC SPC= and =;=. =SPC SPC= is short and quick to
type as well as consistent with other =SPC= bindings. While =;= is super fast to
press as well and even faster than =SPC SPC=.

#+begin_src emacs-lisp
(define-leader-key! "SPC"
  (list :def #'execute-extended-command :wk "M-x"))

(general-def 'normal
  ";" #'execute-extended-command)

(general-def
  "A-x" #'execute-extended-command
  "M-x" #'execute-extended-command)
#+end_src

**** bindings that should be available everywhere
:PROPERTIES:
:ID:       cfb08f5e-9e6e-4e9f-ab85-92f9cc26f1bd
:END:

#+begin_src emacs-lisp
(define-localleader-key!
  "a" (list :def #'org-agenda         :wk "agenda")
  "s" (list :def #'xl/open-scratch  :wk "scratch")
  "f" (list :def #'xl/set-font-size :wk "font size")
  "c" (list :def #'org-capture        :wk "capture"))

(define-leader-key!
  :infix "t"
  :keymaps 'org-mode-map
  "l" (list :def #'org-toggle-link-display :wk "link display"))
#+end_src

**** space bindings
:PROPERTIES:
:ID:       8f00f10d-0ace-4531-a3f4-2508a6592e06
:END:

***** eval
:PROPERTIES:
:ID: afa6be08-a38c-45f1-867a-5620fc290aac
:END:

#+begin_src emacs-lisp
(define-leader-key! "e" (list :ignore t :wk "eval"))

(define-leader-key!
  :infix "e"
  "e" (list :def #'eval-expression :wk "expression")
  "r" (list :def #'eval-region          :wk "region")
  "d" (list :def #'eval-defun           :wk "defun")
  "l" (list :def #'eval-print-last-sexp :wk "sexp")
  "B" (list :def #'eval-buffer          :wk "buffer"))

(define-leader-key!
  :infix "e"
  :keymaps 'org-mode-map
  "b" (list :def #'org-babel-execute-src-block :wk "source block")
  "s" (list :def #'org-babel-execute-subtree :wk "subtree"))
#+end_src

***** packages
:PROPERTIES:
:ID: d3286920-ead4-4f7c-bf9d-8a6ed3d7ba46
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "p"
  ""  (list :ignore t                       :wk "package")
  "i" (list :def #'straight-use-package     :wk "install")
  "r" (list :def #'straight-rebuild-package :wk "rebuild")
  "p" (list :def #'straight-pull-package    :wk "pull")
  "s" (list :def #'straight/search-package  :wk "search"))
#+end_src

***** git
:PROPERTIES:
:ID: 87ba6613-6606-423c-84ec-f7c9ae10c9a6
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "g"
  ""  (list :ignore t           :wk "git")
  "c" (list :def #'magit-commit :wk "commit")
  "s" (list :def #'magit-status :wk "status"))
#+end_src

***** toggle
:PROPERTIES:
:ID: 10d6851b-6af6-4185-8976-0ad65b3d1d28
:END:

#+begin_src emacs-lisp
(define-leader-key! "t" (list :ignore t :wk "toggle/set"))

(define-leader-key!
  :infix "t"
  "r" (list :def #'read-only-mode        :wk "read-only")
  "t" (list :def #'load-theme            :wk "load theme")
  "c" (list :def #'caps-lock-mode        :wk "caps lock")
  "d" (list :def #'toggle-debug-on-error :wk "debug")
  "F" (list :def #'xl/set-font-face    :wk "set font")
  "f" (list :def #'xl/set-font-size    :wk "font size"))

(define-leader-key!
  :infix "t"
  :keymaps 'org-mode-map
  "l" (list :def #'org-toggle-link-display :wk "link display"))
#+end_src

***** help
:PROPERTIES:
:ID: c7f3b699-7cf9-480b-a88c-10bdae4c165e
:END:

There's a lot of documentation finding and information searching involved in
Emacs and for that we need all the help we can get.

#+begin_src emacs-lisp
(define-leader-key!
  :infix "h"
  ""  (list :ignore t                :wk "help")
  "i" (list :def #'info              :wk "info")
  "m" (list :def #'describe-mode     :wk "mode")
  "h" (list :def #'describe-function :wk "function")
  "v" (list :def #'describe-variable :wk "variable")
  "c" (list :def #'describe-char     :wk "char")
  "k" (list :def #'describe-key      :wk "key")
  "f" (list :def #'describe-function :wk "function")
  "a" (list :def #'apropos           :wk "apropos"))
#+end_src

***** quit
:PROPERTIES:
:ID:       ae435361-79e7-41c8-b490-8ec0f8d23a59
:END:

There's many ways to quit Emacs. Sometimes I'd like to save all the buffers I
had been working on. Sometimes, when I'm testing something and I mess up
[[helpvar:kill-emacs-hook][kill-emacs-hook]] I want Emacs to just quit even if it means ignoring that hook.
Most of the time, I know what I'm doing when I quit Emacs, so I don't want a
prompt asking me if I'm sure.

#+begin_src emacs-lisp
(define-leader-key!
  :infix "q"
  ""  (list :ignore t                      :wk "quit")
  "q" (list :def #'evil-quit-all           :wk "normally")
  "s" (list :def #'xl/quit-emacs-no-prompt :wk "with no prompt")
  "Q" (list :def #'evil-save-and-quit      :wk "and save")
  "x" (list :def #'xl/kill-emacs-no-hook   :wk "with no hook")
  "e" (list :def #'xl/kill-emacs-processes :wk "emacs processes")
  "b" (list :def #'xl/kill-emacs-brutally  :wk "brutally")
  ;; "r" (list :def #'restart-emacs           :wk "and restart")
  )
#+end_src

***** buffer
:PROPERTIES:
:ID: e3eec4f8-88d8-4010-adb5-2f8e05f14677
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "b"
  ""  (list :def nil                             :wk "buffer")
  "p" (list :def #'previous-buffer               :wk "previous")
  "n" (list :def #'next-buffer                   :wk "next")
  "o" (list :def #'switch-to-buffer-other-window :wk "switch other window")
  "b" (list :def #'switch-to-buffer              :wk "switch")
  "d" (list :def #'display-buffer                :wk "display"))

(define-leader-key!
  :infix "b k"
  ""  (list :ignore t             :wk "kill")
  "c" (list #'kill-current-buffer :wk "current"))

(define-leader-key!
  :infix "b c"
  ""  (list :ignore t                  :wk "common buffers")
  "m" (list :def #'xl/open-messages  :wk "*Messages*")
  "s" (list :def #'xl/open-scratch   :wk "*scratch*")
  "i" (list :def #'xl/open-init-file :wk "init"))
#+end_src

***** code
:PROPERTIES:
:ID: 661f77fb-3435-4e4f-8adb-c4d6390ea6b8
:END:

These bindings are for generally working with code.

#+begin_src emacs-lisp
(define-leader-key! "c" (list :ignore t :wk "code"))

(define-leader-key!
  :infix "c"
  "a" (list :def #'ialign                               :wk "align")
  "l" (list :def #'lispyville-comment-or-uncomment-line :wk "toggle comment")
  "y" (list :def #'lispyvile-comment-and-cone-dwim      :wk "copy comment"))
#+end_src

***** app
:PROPERTIES:
:ID: 3f09a41a-03b8-4d5c-85c5-d7adeb7dd328
:END:

These are keybindings I use most frequently.

#+begin_src emacs-lisp
(define-leader-key! "a" (list :ignore t :wk "app"))

(define-leader-key!
  :infix "a"
  "a" (list :def #'xl/open-org-agenda        :wk "agenda")
  "m" (list :def #'mu4e                        :wk "mu4e")
  "l" (list :def #'org-store-link              :wk "store link")
  "f" (list :def #'elfeed                      :wk "elfeed")
  "d" (list :def #'deer                        :wk "deer")
  "r" (list :def #'ranger                      :wk "ranger")
  "e" (list :def #'xl/open-emacs-instance    :wk "emacs")
  "q" (list :def #'engine/search-duckduckgo    :wk "browse web")
  "j" (list :def #'org/avy-goto-headline       :wk "heading jump")
  "c" (list :def #'org-capture :wk "capture"))
#+end_src

***** search
:PROPERTIES:
:ID: b50ed0da-652d-4d20-8a4e-e0cf053548a6
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "s"
  ""  (list :ignore t                       :wk "search")
  "s" (list :def #'consult-line             :wk "jump to line")
  "w" (list :def #'engine/search-duckduckgo :wk "web")
  "h" (list :def #'consult-outline          :wk "jump to outline heading"))
#+end_src

* email
:PROPERTIES:
:ID:       cff26aaa-5e46-411f-bbca-f4a5545e8e51
:END:

** noweb helpers
:PROPERTIES:
:ID:       80df9191-15ae-4559-a666-88869796e287
:END:

** convert to string
:PROPERTIES:
:ID:       d9014e42-cddf-4547-85c7-c3fa6ce54f36
:END:

#+begin_src emacs-lisp
(defun dotfiles:plist-to-config-string (&rest plist)
  "Return the arguments of dotfiles as a plist."
  ())
#+end_src

** mbsync
:PROPERTIES:
:ID:       532cd56a-45c8-4cd3-819f-cd1f5fca3e5d
:HEADER-ARGS: :tangle ~/.config/isync/mbsyncrc
:END:

The. The setup for mbsync contains many repetative blocks of it's DSL which are
multiplied by the number of.

*** mbsync account setup
:PROPERTIES:
:ID:       1e503ace-8af6-46a1-9ec0-62cef1372adf
:END:

#+begin_src emacs-lisp :tangle no
(defun dotfiles:mbsyncrc-imap-account-setup (mail)
  "Return the account part of the."
  (dotfiles:convert-to-string
   :IMAPAccount $account
   :Host $server
   :User $email
   :PassCmd (dotfiles:string "pass email/%s | head -n 1" $email)
   :SSLType 'IMAPS
   :CertificateFile '/etc/ssl/certs/ca-certificates.crt
   :Port $in-port))
#+end_src

*** set up config
:PROPERTIES:
:ID:       371436cf-420b-45d5-9135-8a766e770f29
:END:

concatenta

#+begin_src emacs-lisp
(defun dotfiles:setup-config ()
  "Return."
  (loopy ((list account accounts)
	  (expr account-block (dotfiles:mbsyncrc-account account))
	  (expr )
	  (expr )
	  (collect config (list account-block this that)))
	 (finally-return)))
#+end_src

*** mbsyncrc
:PROPERTIES:
:ID:       d2c2a9e3-a0a8-4fc2-bf1e-32e33129b1e7
:END:

#+begin_src conf
<<mbsyncrc-setup()>>
#+end_src

** msmtprc
:PROPERTIES:
:ID:       881dfeda-6370-4cbd-b385-f2e49bf042c0
:HEADER-ARGS: :tangle ~/config/msmtp/msmtprc
:END:

*** setup
:PROPERTIES:
:ID:       56f1b4e0-f1fc-4e51-b300-94ae7f4f4606
:END:

